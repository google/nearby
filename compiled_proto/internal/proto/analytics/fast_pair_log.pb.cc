// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: internal/proto/analytics/fast_pair_log.proto

#include "internal/proto/analytics/fast_pair_log.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace nearby {
namespace proto {
namespace fastpair {
constexpr FastPairLog_GattEvent::FastPairLog_GattEvent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_from_os_(0){}
struct FastPairLog_GattEventDefaultTypeInternal {
  constexpr FastPairLog_GattEventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLog_GattEventDefaultTypeInternal() {}
  union {
    FastPairLog_GattEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLog_GattEventDefaultTypeInternal _FastPairLog_GattEvent_default_instance_;
constexpr FastPairLog_BrEdrHandoverEvent::FastPairLog_BrEdrHandoverEvent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_code_(0)
{}
struct FastPairLog_BrEdrHandoverEventDefaultTypeInternal {
  constexpr FastPairLog_BrEdrHandoverEventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLog_BrEdrHandoverEventDefaultTypeInternal() {}
  union {
    FastPairLog_BrEdrHandoverEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLog_BrEdrHandoverEventDefaultTypeInternal _FastPairLog_BrEdrHandoverEvent_default_instance_;
constexpr FastPairLog_CreateBondEvent::FastPairLog_CreateBondEvent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_code_(0)

  , unbond_reason_(0){}
struct FastPairLog_CreateBondEventDefaultTypeInternal {
  constexpr FastPairLog_CreateBondEventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLog_CreateBondEventDefaultTypeInternal() {}
  union {
    FastPairLog_CreateBondEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLog_CreateBondEventDefaultTypeInternal _FastPairLog_CreateBondEvent_default_instance_;
constexpr FastPairLog_ConnectEvent::FastPairLog_ConnectEvent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_code_(0)

  , profile_uuid_(0){}
struct FastPairLog_ConnectEventDefaultTypeInternal {
  constexpr FastPairLog_ConnectEventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLog_ConnectEventDefaultTypeInternal() {}
  union {
    FastPairLog_ConnectEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLog_ConnectEventDefaultTypeInternal _FastPairLog_ConnectEvent_default_instance_;
constexpr FastPairLog_ProviderInfo::FastPairLog_ProviderInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : database_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , number_account_keys_on_provider_(0){}
struct FastPairLog_ProviderInfoDefaultTypeInternal {
  constexpr FastPairLog_ProviderInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLog_ProviderInfoDefaultTypeInternal() {}
  union {
    FastPairLog_ProviderInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLog_ProviderInfoDefaultTypeInternal _FastPairLog_ProviderInfo_default_instance_;
constexpr FastPairLog_FootprintsInfo::FastPairLog_FootprintsInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : number_devices_on_footprints_(0){}
struct FastPairLog_FootprintsInfoDefaultTypeInternal {
  constexpr FastPairLog_FootprintsInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLog_FootprintsInfoDefaultTypeInternal() {}
  union {
    FastPairLog_FootprintsInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLog_FootprintsInfoDefaultTypeInternal _FastPairLog_FootprintsInfo_default_instance_;
constexpr FastPairLog_KeyBasedPairingInfo::FastPairLog_KeyBasedPairingInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_flag_(0u)
  , response_type_(0u)
  , response_flag_(0u)
  , response_device_count_(0u){}
struct FastPairLog_KeyBasedPairingInfoDefaultTypeInternal {
  constexpr FastPairLog_KeyBasedPairingInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLog_KeyBasedPairingInfoDefaultTypeInternal() {}
  union {
    FastPairLog_KeyBasedPairingInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLog_KeyBasedPairingInfoDefaultTypeInternal _FastPairLog_KeyBasedPairingInfo_default_instance_;
constexpr FastPairLog::FastPairLog(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gatt_event_(nullptr)
  , br_edr_handover_event_(nullptr)
  , bond_event_(nullptr)
  , connect_event_(nullptr)
  , provider_info_(nullptr)
  , footprints_info_(nullptr)
  , key_based_pairing_info_(nullptr)
  , model_id_(0)
  , bond_state_(0)

  , error_code_(0)

  , device_type_(0)

  , hashed_salted_device_address_(int64_t{0})
  , duration_(int64_t{0})
  , os_type_(0)

  , active_wifi_frequency_(0)
  , number_connected_peripherals_(0)
  , bonding_transport_(0u)
  , is_scanned_by_offload_scanner_(false)
  , is_first_day_new_user_(false)
  , is_seven_days_new_user_(false)
  , is_pair_triggered_by_settings_(false)
  , bonded_device_count_(0u)
  , nearby_mainline_tethering_version_(int64_t{0})
  , sass_connection_state_(0)
  , is_in_paired_history_(false)
  , nearby_nano_app_version_(int64_t{0}){}
struct FastPairLogDefaultTypeInternal {
  constexpr FastPairLogDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FastPairLogDefaultTypeInternal() {}
  union {
    FastPairLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FastPairLogDefaultTypeInternal _FastPairLog_default_instance_;
}  // namespace fastpair
}  // namespace proto
}  // namespace nearby
namespace nearby {
namespace proto {
namespace fastpair {

// ===================================================================

class FastPairLog_GattEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog_GattEvent>()._has_bits_);
  static void set_has_error_from_os(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FastPairLog_GattEvent::FastPairLog_GattEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog.GattEvent)
}
FastPairLog_GattEvent::FastPairLog_GattEvent(const FastPairLog_GattEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_from_os_ = from.error_from_os_;
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog.GattEvent)
}

inline void FastPairLog_GattEvent::SharedCtor() {
error_from_os_ = 0;
}

FastPairLog_GattEvent::~FastPairLog_GattEvent() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog.GattEvent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog_GattEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastPairLog_GattEvent::ArenaDtor(void* object) {
  FastPairLog_GattEvent* _this = reinterpret_cast< FastPairLog_GattEvent* >(object);
  (void)_this;
}
void FastPairLog_GattEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog_GattEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog_GattEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog.GattEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_from_os_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog_GattEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 error_from_os = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_from_os(&has_bits);
          error_from_os_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog_GattEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog.GattEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 error_from_os = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_from_os(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog.GattEvent)
  return target;
}

size_t FastPairLog_GattEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog.GattEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 error_from_os = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_error_from_os());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog_GattEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog_GattEvent*>(
      &from));
}

void FastPairLog_GattEvent::MergeFrom(const FastPairLog_GattEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog.GattEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error_from_os()) {
    _internal_set_error_from_os(from._internal_error_from_os());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog_GattEvent::CopyFrom(const FastPairLog_GattEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog.GattEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog_GattEvent::IsInitialized() const {
  return true;
}

void FastPairLog_GattEvent::InternalSwap(FastPairLog_GattEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(error_from_os_, other->error_from_os_);
}

std::string FastPairLog_GattEvent::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog.GattEvent";
}


// ===================================================================

class FastPairLog_BrEdrHandoverEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog_BrEdrHandoverEvent>()._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FastPairLog_BrEdrHandoverEvent::FastPairLog_BrEdrHandoverEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
}
FastPairLog_BrEdrHandoverEvent::FastPairLog_BrEdrHandoverEvent(const FastPairLog_BrEdrHandoverEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_code_ = from.error_code_;
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
}

inline void FastPairLog_BrEdrHandoverEvent::SharedCtor() {
error_code_ = 0;
}

FastPairLog_BrEdrHandoverEvent::~FastPairLog_BrEdrHandoverEvent() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog_BrEdrHandoverEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastPairLog_BrEdrHandoverEvent::ArenaDtor(void* object) {
  FastPairLog_BrEdrHandoverEvent* _this = reinterpret_cast< FastPairLog_BrEdrHandoverEvent* >(object);
  (void)_this;
}
void FastPairLog_BrEdrHandoverEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog_BrEdrHandoverEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog_BrEdrHandoverEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_code_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog_BrEdrHandoverEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.proto.fastpair.FastPairEvent.BrEdrHandoverErrorCode error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode_IsValid(val))) {
            _internal_set_error_code(static_cast<::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog_BrEdrHandoverEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .nearby.proto.fastpair.FastPairEvent.BrEdrHandoverErrorCode error_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
  return target;
}

size_t FastPairLog_BrEdrHandoverEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .nearby.proto.fastpair.FastPairEvent.BrEdrHandoverErrorCode error_code = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog_BrEdrHandoverEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog_BrEdrHandoverEvent*>(
      &from));
}

void FastPairLog_BrEdrHandoverEvent::MergeFrom(const FastPairLog_BrEdrHandoverEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error_code()) {
    _internal_set_error_code(from._internal_error_code());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog_BrEdrHandoverEvent::CopyFrom(const FastPairLog_BrEdrHandoverEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog_BrEdrHandoverEvent::IsInitialized() const {
  return true;
}

void FastPairLog_BrEdrHandoverEvent::InternalSwap(FastPairLog_BrEdrHandoverEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(error_code_, other->error_code_);
}

std::string FastPairLog_BrEdrHandoverEvent::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent";
}


// ===================================================================

class FastPairLog_CreateBondEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog_CreateBondEvent>()._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_unbond_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FastPairLog_CreateBondEvent::FastPairLog_CreateBondEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
}
FastPairLog_CreateBondEvent::FastPairLog_CreateBondEvent(const FastPairLog_CreateBondEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&error_code_, &from.error_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&unbond_reason_) -
    reinterpret_cast<char*>(&error_code_)) + sizeof(unbond_reason_));
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
}

inline void FastPairLog_CreateBondEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&error_code_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&unbond_reason_) -
    reinterpret_cast<char*>(&error_code_)) + sizeof(unbond_reason_));
}

FastPairLog_CreateBondEvent::~FastPairLog_CreateBondEvent() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog_CreateBondEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastPairLog_CreateBondEvent::ArenaDtor(void* object) {
  FastPairLog_CreateBondEvent* _this = reinterpret_cast< FastPairLog_CreateBondEvent* >(object);
  (void)_this;
}
void FastPairLog_CreateBondEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog_CreateBondEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog_CreateBondEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&error_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unbond_reason_) -
        reinterpret_cast<char*>(&error_code_)) + sizeof(unbond_reason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog_CreateBondEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.proto.fastpair.FastPairEvent.CreateBondErrorCode error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode_IsValid(val))) {
            _internal_set_error_code(static_cast<::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 unbond_reason = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_unbond_reason(&has_bits);
          unbond_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog_CreateBondEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .nearby.proto.fastpair.FastPairEvent.CreateBondErrorCode error_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error_code(), target);
  }

  // optional int32 unbond_reason = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_unbond_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
  return target;
}

size_t FastPairLog_CreateBondEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .nearby.proto.fastpair.FastPairEvent.CreateBondErrorCode error_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    // optional int32 unbond_reason = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_unbond_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog_CreateBondEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog_CreateBondEvent*>(
      &from));
}

void FastPairLog_CreateBondEvent::MergeFrom(const FastPairLog_CreateBondEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      error_code_ = from.error_code_;
    }
    if (cached_has_bits & 0x00000002u) {
      unbond_reason_ = from.unbond_reason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog_CreateBondEvent::CopyFrom(const FastPairLog_CreateBondEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog_CreateBondEvent::IsInitialized() const {
  return true;
}

void FastPairLog_CreateBondEvent::InternalSwap(FastPairLog_CreateBondEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastPairLog_CreateBondEvent, unbond_reason_)
      + sizeof(FastPairLog_CreateBondEvent::unbond_reason_)
      - PROTOBUF_FIELD_OFFSET(FastPairLog_CreateBondEvent, error_code_)>(
          reinterpret_cast<char*>(&error_code_),
          reinterpret_cast<char*>(&other->error_code_));
}

std::string FastPairLog_CreateBondEvent::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog.CreateBondEvent";
}


// ===================================================================

class FastPairLog_ConnectEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog_ConnectEvent>()._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_profile_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FastPairLog_ConnectEvent::FastPairLog_ConnectEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog.ConnectEvent)
}
FastPairLog_ConnectEvent::FastPairLog_ConnectEvent(const FastPairLog_ConnectEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&error_code_, &from.error_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&profile_uuid_) -
    reinterpret_cast<char*>(&error_code_)) + sizeof(profile_uuid_));
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog.ConnectEvent)
}

inline void FastPairLog_ConnectEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&error_code_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&profile_uuid_) -
    reinterpret_cast<char*>(&error_code_)) + sizeof(profile_uuid_));
}

FastPairLog_ConnectEvent::~FastPairLog_ConnectEvent() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog.ConnectEvent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog_ConnectEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastPairLog_ConnectEvent::ArenaDtor(void* object) {
  FastPairLog_ConnectEvent* _this = reinterpret_cast< FastPairLog_ConnectEvent* >(object);
  (void)_this;
}
void FastPairLog_ConnectEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog_ConnectEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog_ConnectEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog.ConnectEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&error_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&profile_uuid_) -
        reinterpret_cast<char*>(&error_code_)) + sizeof(profile_uuid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog_ConnectEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.proto.fastpair.FastPairEvent.ConnectErrorCode error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode_IsValid(val))) {
            _internal_set_error_code(static_cast<::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 profile_uuid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_profile_uuid(&has_bits);
          profile_uuid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog_ConnectEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog.ConnectEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .nearby.proto.fastpair.FastPairEvent.ConnectErrorCode error_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error_code(), target);
  }

  // optional int32 profile_uuid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_profile_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog.ConnectEvent)
  return target;
}

size_t FastPairLog_ConnectEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog.ConnectEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .nearby.proto.fastpair.FastPairEvent.ConnectErrorCode error_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    // optional int32 profile_uuid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_profile_uuid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog_ConnectEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog_ConnectEvent*>(
      &from));
}

void FastPairLog_ConnectEvent::MergeFrom(const FastPairLog_ConnectEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog.ConnectEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      error_code_ = from.error_code_;
    }
    if (cached_has_bits & 0x00000002u) {
      profile_uuid_ = from.profile_uuid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog_ConnectEvent::CopyFrom(const FastPairLog_ConnectEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog.ConnectEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog_ConnectEvent::IsInitialized() const {
  return true;
}

void FastPairLog_ConnectEvent::InternalSwap(FastPairLog_ConnectEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastPairLog_ConnectEvent, profile_uuid_)
      + sizeof(FastPairLog_ConnectEvent::profile_uuid_)
      - PROTOBUF_FIELD_OFFSET(FastPairLog_ConnectEvent, error_code_)>(
          reinterpret_cast<char*>(&error_code_),
          reinterpret_cast<char*>(&other->error_code_));
}

std::string FastPairLog_ConnectEvent::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog.ConnectEvent";
}


// ===================================================================

class FastPairLog_ProviderInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog_ProviderInfo>()._has_bits_);
  static void set_has_number_account_keys_on_provider(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_database_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FastPairLog_ProviderInfo::FastPairLog_ProviderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog.ProviderInfo)
}
FastPairLog_ProviderInfo::FastPairLog_ProviderInfo(const FastPairLog_ProviderInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  database_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    database_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_database_hash()) {
    database_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_database_hash(), 
      GetArenaForAllocation());
  }
  number_account_keys_on_provider_ = from.number_account_keys_on_provider_;
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog.ProviderInfo)
}

inline void FastPairLog_ProviderInfo::SharedCtor() {
database_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  database_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
number_account_keys_on_provider_ = 0;
}

FastPairLog_ProviderInfo::~FastPairLog_ProviderInfo() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog.ProviderInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog_ProviderInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  database_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FastPairLog_ProviderInfo::ArenaDtor(void* object) {
  FastPairLog_ProviderInfo* _this = reinterpret_cast< FastPairLog_ProviderInfo* >(object);
  (void)_this;
}
void FastPairLog_ProviderInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog_ProviderInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog_ProviderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog.ProviderInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    database_hash_.ClearNonDefaultToEmpty();
  }
  number_account_keys_on_provider_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog_ProviderInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 number_account_keys_on_provider = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_number_account_keys_on_provider(&has_bits);
          number_account_keys_on_provider_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string database_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_database_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog_ProviderInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog.ProviderInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 number_account_keys_on_provider = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_number_account_keys_on_provider(), target);
  }

  // optional string database_hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_database_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog.ProviderInfo)
  return target;
}

size_t FastPairLog_ProviderInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog.ProviderInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string database_hash = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_database_hash());
    }

    // optional int32 number_account_keys_on_provider = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_number_account_keys_on_provider());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog_ProviderInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog_ProviderInfo*>(
      &from));
}

void FastPairLog_ProviderInfo::MergeFrom(const FastPairLog_ProviderInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog.ProviderInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_database_hash(from._internal_database_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      number_account_keys_on_provider_ = from.number_account_keys_on_provider_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog_ProviderInfo::CopyFrom(const FastPairLog_ProviderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog.ProviderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog_ProviderInfo::IsInitialized() const {
  return true;
}

void FastPairLog_ProviderInfo::InternalSwap(FastPairLog_ProviderInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &database_hash_, lhs_arena,
      &other->database_hash_, rhs_arena
  );
  swap(number_account_keys_on_provider_, other->number_account_keys_on_provider_);
}

std::string FastPairLog_ProviderInfo::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog.ProviderInfo";
}


// ===================================================================

class FastPairLog_FootprintsInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog_FootprintsInfo>()._has_bits_);
  static void set_has_number_devices_on_footprints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FastPairLog_FootprintsInfo::FastPairLog_FootprintsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
}
FastPairLog_FootprintsInfo::FastPairLog_FootprintsInfo(const FastPairLog_FootprintsInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  number_devices_on_footprints_ = from.number_devices_on_footprints_;
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
}

inline void FastPairLog_FootprintsInfo::SharedCtor() {
number_devices_on_footprints_ = 0;
}

FastPairLog_FootprintsInfo::~FastPairLog_FootprintsInfo() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog_FootprintsInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastPairLog_FootprintsInfo::ArenaDtor(void* object) {
  FastPairLog_FootprintsInfo* _this = reinterpret_cast< FastPairLog_FootprintsInfo* >(object);
  (void)_this;
}
void FastPairLog_FootprintsInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog_FootprintsInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog_FootprintsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  number_devices_on_footprints_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog_FootprintsInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 number_devices_on_footprints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_number_devices_on_footprints(&has_bits);
          number_devices_on_footprints_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog_FootprintsInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 number_devices_on_footprints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_number_devices_on_footprints(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
  return target;
}

size_t FastPairLog_FootprintsInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 number_devices_on_footprints = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_number_devices_on_footprints());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog_FootprintsInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog_FootprintsInfo*>(
      &from));
}

void FastPairLog_FootprintsInfo::MergeFrom(const FastPairLog_FootprintsInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_number_devices_on_footprints()) {
    _internal_set_number_devices_on_footprints(from._internal_number_devices_on_footprints());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog_FootprintsInfo::CopyFrom(const FastPairLog_FootprintsInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog_FootprintsInfo::IsInitialized() const {
  return true;
}

void FastPairLog_FootprintsInfo::InternalSwap(FastPairLog_FootprintsInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(number_devices_on_footprints_, other->number_devices_on_footprints_);
}

std::string FastPairLog_FootprintsInfo::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog.FootprintsInfo";
}


// ===================================================================

class FastPairLog_KeyBasedPairingInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog_KeyBasedPairingInfo>()._has_bits_);
  static void set_has_request_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_response_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_response_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_response_device_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

FastPairLog_KeyBasedPairingInfo::FastPairLog_KeyBasedPairingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
}
FastPairLog_KeyBasedPairingInfo::FastPairLog_KeyBasedPairingInfo(const FastPairLog_KeyBasedPairingInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_flag_, &from.request_flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&response_device_count_) -
    reinterpret_cast<char*>(&request_flag_)) + sizeof(response_device_count_));
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
}

inline void FastPairLog_KeyBasedPairingInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_flag_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&response_device_count_) -
    reinterpret_cast<char*>(&request_flag_)) + sizeof(response_device_count_));
}

FastPairLog_KeyBasedPairingInfo::~FastPairLog_KeyBasedPairingInfo() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog_KeyBasedPairingInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastPairLog_KeyBasedPairingInfo::ArenaDtor(void* object) {
  FastPairLog_KeyBasedPairingInfo* _this = reinterpret_cast< FastPairLog_KeyBasedPairingInfo* >(object);
  (void)_this;
}
void FastPairLog_KeyBasedPairingInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog_KeyBasedPairingInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog_KeyBasedPairingInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&request_flag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&response_device_count_) -
        reinterpret_cast<char*>(&request_flag_)) + sizeof(response_device_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog_KeyBasedPairingInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 request_flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_flag(&has_bits);
          request_flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 response_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_response_type(&has_bits);
          response_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 response_flag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_response_flag(&has_bits);
          response_flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 response_device_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_response_device_count(&has_bits);
          response_device_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog_KeyBasedPairingInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 request_flag = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_flag(), target);
  }

  // optional uint32 response_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_response_type(), target);
  }

  // optional uint32 response_flag = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_response_flag(), target);
  }

  // optional uint32 response_device_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_response_device_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
  return target;
}

size_t FastPairLog_KeyBasedPairingInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 request_flag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_flag());
    }

    // optional uint32 response_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_response_type());
    }

    // optional uint32 response_flag = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_response_flag());
    }

    // optional uint32 response_device_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_response_device_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog_KeyBasedPairingInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog_KeyBasedPairingInfo*>(
      &from));
}

void FastPairLog_KeyBasedPairingInfo::MergeFrom(const FastPairLog_KeyBasedPairingInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      request_flag_ = from.request_flag_;
    }
    if (cached_has_bits & 0x00000002u) {
      response_type_ = from.response_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      response_flag_ = from.response_flag_;
    }
    if (cached_has_bits & 0x00000008u) {
      response_device_count_ = from.response_device_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog_KeyBasedPairingInfo::CopyFrom(const FastPairLog_KeyBasedPairingInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog_KeyBasedPairingInfo::IsInitialized() const {
  return true;
}

void FastPairLog_KeyBasedPairingInfo::InternalSwap(FastPairLog_KeyBasedPairingInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastPairLog_KeyBasedPairingInfo, response_device_count_)
      + sizeof(FastPairLog_KeyBasedPairingInfo::response_device_count_)
      - PROTOBUF_FIELD_OFFSET(FastPairLog_KeyBasedPairingInfo, request_flag_)>(
          reinterpret_cast<char*>(&request_flag_),
          reinterpret_cast<char*>(&other->request_flag_));
}

std::string FastPairLog_KeyBasedPairingInfo::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo";
}


// ===================================================================

class FastPairLog::_Internal {
 public:
  using HasBits = decltype(std::declval<FastPairLog>()._has_bits_);
  static void set_has_model_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bond_state(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::nearby::proto::fastpair::FastPairLog_GattEvent& gatt_event(const FastPairLog* msg);
  static void set_has_gatt_event(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent& br_edr_handover_event(const FastPairLog* msg);
  static void set_has_br_edr_handover_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent& bond_event(const FastPairLog* msg);
  static void set_has_bond_event(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::nearby::proto::fastpair::FastPairLog_ConnectEvent& connect_event(const FastPairLog* msg);
  static void set_has_connect_event(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hashed_salted_device_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::nearby::proto::fastpair::FastPairLog_ProviderInfo& provider_info(const FastPairLog* msg);
  static void set_has_provider_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo& footprints_info(const FastPairLog* msg);
  static void set_has_footprints_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_active_wifi_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_number_connected_peripherals(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_is_scanned_by_offload_scanner(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo& key_based_pairing_info(const FastPairLog* msg);
  static void set_has_key_based_pairing_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_bonding_transport(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_is_first_day_new_user(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_is_seven_days_new_user(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_bonded_device_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_sass_connection_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_is_pair_triggered_by_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_nearby_mainline_tethering_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_nearby_nano_app_version(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_is_in_paired_history(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
};

const ::nearby::proto::fastpair::FastPairLog_GattEvent&
FastPairLog::_Internal::gatt_event(const FastPairLog* msg) {
  return *msg->gatt_event_;
}
const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent&
FastPairLog::_Internal::br_edr_handover_event(const FastPairLog* msg) {
  return *msg->br_edr_handover_event_;
}
const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent&
FastPairLog::_Internal::bond_event(const FastPairLog* msg) {
  return *msg->bond_event_;
}
const ::nearby::proto::fastpair::FastPairLog_ConnectEvent&
FastPairLog::_Internal::connect_event(const FastPairLog* msg) {
  return *msg->connect_event_;
}
const ::nearby::proto::fastpair::FastPairLog_ProviderInfo&
FastPairLog::_Internal::provider_info(const FastPairLog* msg) {
  return *msg->provider_info_;
}
const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo&
FastPairLog::_Internal::footprints_info(const FastPairLog* msg) {
  return *msg->footprints_info_;
}
const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo&
FastPairLog::_Internal::key_based_pairing_info(const FastPairLog* msg) {
  return *msg->key_based_pairing_info_;
}
FastPairLog::FastPairLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:nearby.proto.fastpair.FastPairLog)
}
FastPairLog::FastPairLog(const FastPairLog& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_gatt_event()) {
    gatt_event_ = new ::nearby::proto::fastpair::FastPairLog_GattEvent(*from.gatt_event_);
  } else {
    gatt_event_ = nullptr;
  }
  if (from._internal_has_br_edr_handover_event()) {
    br_edr_handover_event_ = new ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent(*from.br_edr_handover_event_);
  } else {
    br_edr_handover_event_ = nullptr;
  }
  if (from._internal_has_bond_event()) {
    bond_event_ = new ::nearby::proto::fastpair::FastPairLog_CreateBondEvent(*from.bond_event_);
  } else {
    bond_event_ = nullptr;
  }
  if (from._internal_has_connect_event()) {
    connect_event_ = new ::nearby::proto::fastpair::FastPairLog_ConnectEvent(*from.connect_event_);
  } else {
    connect_event_ = nullptr;
  }
  if (from._internal_has_provider_info()) {
    provider_info_ = new ::nearby::proto::fastpair::FastPairLog_ProviderInfo(*from.provider_info_);
  } else {
    provider_info_ = nullptr;
  }
  if (from._internal_has_footprints_info()) {
    footprints_info_ = new ::nearby::proto::fastpair::FastPairLog_FootprintsInfo(*from.footprints_info_);
  } else {
    footprints_info_ = nullptr;
  }
  if (from._internal_has_key_based_pairing_info()) {
    key_based_pairing_info_ = new ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo(*from.key_based_pairing_info_);
  } else {
    key_based_pairing_info_ = nullptr;
  }
  ::memcpy(&model_id_, &from.model_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&nearby_nano_app_version_) -
    reinterpret_cast<char*>(&model_id_)) + sizeof(nearby_nano_app_version_));
  // @@protoc_insertion_point(copy_constructor:nearby.proto.fastpair.FastPairLog)
}

inline void FastPairLog::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gatt_event_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&nearby_nano_app_version_) -
    reinterpret_cast<char*>(&gatt_event_)) + sizeof(nearby_nano_app_version_));
}

FastPairLog::~FastPairLog() {
  // @@protoc_insertion_point(destructor:nearby.proto.fastpair.FastPairLog)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FastPairLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete gatt_event_;
  if (this != internal_default_instance()) delete br_edr_handover_event_;
  if (this != internal_default_instance()) delete bond_event_;
  if (this != internal_default_instance()) delete connect_event_;
  if (this != internal_default_instance()) delete provider_info_;
  if (this != internal_default_instance()) delete footprints_info_;
  if (this != internal_default_instance()) delete key_based_pairing_info_;
}

void FastPairLog::ArenaDtor(void* object) {
  FastPairLog* _this = reinterpret_cast< FastPairLog* >(object);
  (void)_this;
}
void FastPairLog::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FastPairLog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FastPairLog::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.proto.fastpair.FastPairLog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(gatt_event_ != nullptr);
      gatt_event_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(br_edr_handover_event_ != nullptr);
      br_edr_handover_event_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(bond_event_ != nullptr);
      bond_event_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(connect_event_ != nullptr);
      connect_event_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(provider_info_ != nullptr);
      provider_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(footprints_info_ != nullptr);
      footprints_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(key_based_pairing_info_ != nullptr);
      key_based_pairing_info_->Clear();
    }
  }
  model_id_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&bond_state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_connected_peripherals_) -
        reinterpret_cast<char*>(&bond_state_)) + sizeof(number_connected_peripherals_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&bonding_transport_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sass_connection_state_) -
        reinterpret_cast<char*>(&bonding_transport_)) + sizeof(sass_connection_state_));
  }
  if (cached_has_bits & 0x03000000u) {
    ::memset(&is_in_paired_history_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nearby_nano_app_version_) -
        reinterpret_cast<char*>(&is_in_paired_history_)) + sizeof(nearby_nano_app_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastPairLog::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 model_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_model_id(&has_bits);
          model_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairEvent.BondState bond_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::proto::fastpair::FastPairEvent_BondState_IsValid(val))) {
            _internal_set_bond_state(static_cast<::nearby::proto::fastpair::FastPairEvent_BondState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairEvent.ErrorCode error_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::proto::fastpair::FastPairEvent_ErrorCode_IsValid(val))) {
            _internal_set_error_code(static_cast<::nearby::proto::fastpair::FastPairEvent_ErrorCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairLog.GattEvent gatt_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_gatt_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent br_edr_handover_event = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_br_edr_handover_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairLog.CreateBondEvent bond_event = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_bond_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairLog.ConnectEvent connect_event = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 hashed_salted_device_address = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_hashed_salted_device_address(&has_bits);
          hashed_salted_device_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 duration = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_duration(&has_bits);
          duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairLog.ProviderInfo provider_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_provider_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairLog.FootprintsInfo footprints_info = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_footprints_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.DeviceType device_type = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::proto::fastpair::DeviceType_IsValid(val))) {
            _internal_set_device_type(static_cast<::nearby::proto::fastpair::DeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.OsType os_type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::proto::fastpair::OsType_IsValid(val))) {
            _internal_set_os_type(static_cast<::nearby::proto::fastpair::OsType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 active_wifi_frequency = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_active_wifi_frequency(&has_bits);
          active_wifi_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 number_connected_peripherals = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_number_connected_peripherals(&has_bits);
          number_connected_peripherals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_scanned_by_offload_scanner = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_is_scanned_by_offload_scanner(&has_bits);
          is_scanned_by_offload_scanner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo key_based_pairing_info = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_based_pairing_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bonding_transport = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_bonding_transport(&has_bits);
          bonding_transport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_first_day_new_user = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_is_first_day_new_user(&has_bits);
          is_first_day_new_user_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_seven_days_new_user = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_is_seven_days_new_user(&has_bits);
          is_seven_days_new_user_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bonded_device_count = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_bonded_device_count(&has_bits);
          bonded_device_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sass_connection_state = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_sass_connection_state(&has_bits);
          sass_connection_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_pair_triggered_by_settings = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_is_pair_triggered_by_settings(&has_bits);
          is_pair_triggered_by_settings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nearby_mainline_tethering_version = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_nearby_mainline_tethering_version(&has_bits);
          nearby_mainline_tethering_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nearby_nano_app_version = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_nearby_nano_app_version(&has_bits);
          nearby_nano_app_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_in_paired_history = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_is_in_paired_history(&has_bits);
          is_in_paired_history_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastPairLog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.proto.fastpair.FastPairLog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 model_id = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_model_id(), target);
  }

  // optional .nearby.proto.fastpair.FastPairEvent.BondState bond_state = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_bond_state(), target);
  }

  // optional .nearby.proto.fastpair.FastPairEvent.ErrorCode error_code = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error_code(), target);
  }

  // optional .nearby.proto.fastpair.FastPairLog.GattEvent gatt_event = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::gatt_event(this), target, stream);
  }

  // optional .nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent br_edr_handover_event = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::br_edr_handover_event(this), target, stream);
  }

  // optional .nearby.proto.fastpair.FastPairLog.CreateBondEvent bond_event = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::bond_event(this), target, stream);
  }

  // optional .nearby.proto.fastpair.FastPairLog.ConnectEvent connect_event = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::connect_event(this), target, stream);
  }

  // optional int64 hashed_salted_device_address = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_hashed_salted_device_address(), target);
  }

  // optional int64 duration = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_duration(), target);
  }

  // optional .nearby.proto.fastpair.FastPairLog.ProviderInfo provider_info = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::provider_info(this), target, stream);
  }

  // optional .nearby.proto.fastpair.FastPairLog.FootprintsInfo footprints_info = 11;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::footprints_info(this), target, stream);
  }

  // optional .nearby.proto.fastpair.DeviceType device_type = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_device_type(), target);
  }

  // optional .nearby.proto.fastpair.OsType os_type = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      13, this->_internal_os_type(), target);
  }

  // optional int32 active_wifi_frequency = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->_internal_active_wifi_frequency(), target);
  }

  // optional int32 number_connected_peripherals = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->_internal_number_connected_peripherals(), target);
  }

  // optional bool is_scanned_by_offload_scanner = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_is_scanned_by_offload_scanner(), target);
  }

  // optional .nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo key_based_pairing_info = 17;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::key_based_pairing_info(this), target, stream);
  }

  // optional uint32 bonding_transport = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(18, this->_internal_bonding_transport(), target);
  }

  // optional bool is_first_day_new_user = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_is_first_day_new_user(), target);
  }

  // optional bool is_seven_days_new_user = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_is_seven_days_new_user(), target);
  }

  // optional uint32 bonded_device_count = 21;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(21, this->_internal_bonded_device_count(), target);
  }

  // optional int32 sass_connection_state = 22;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(22, this->_internal_sass_connection_state(), target);
  }

  // optional bool is_pair_triggered_by_settings = 23;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_is_pair_triggered_by_settings(), target);
  }

  // optional int64 nearby_mainline_tethering_version = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(24, this->_internal_nearby_mainline_tethering_version(), target);
  }

  // optional int64 nearby_nano_app_version = 25;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(25, this->_internal_nearby_nano_app_version(), target);
  }

  // optional bool is_in_paired_history = 26;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(26, this->_internal_is_in_paired_history(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.proto.fastpair.FastPairLog)
  return target;
}

size_t FastPairLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.proto.fastpair.FastPairLog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .nearby.proto.fastpair.FastPairLog.GattEvent gatt_event = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gatt_event_);
    }

    // optional .nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent br_edr_handover_event = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *br_edr_handover_event_);
    }

    // optional .nearby.proto.fastpair.FastPairLog.CreateBondEvent bond_event = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bond_event_);
    }

    // optional .nearby.proto.fastpair.FastPairLog.ConnectEvent connect_event = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connect_event_);
    }

    // optional .nearby.proto.fastpair.FastPairLog.ProviderInfo provider_info = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *provider_info_);
    }

    // optional .nearby.proto.fastpair.FastPairLog.FootprintsInfo footprints_info = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *footprints_info_);
    }

    // optional .nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo key_based_pairing_info = 17;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *key_based_pairing_info_);
    }

    // optional int32 model_id = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_model_id());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .nearby.proto.fastpair.FastPairEvent.BondState bond_state = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_bond_state());
    }

    // optional .nearby.proto.fastpair.FastPairEvent.ErrorCode error_code = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    // optional .nearby.proto.fastpair.DeviceType device_type = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_device_type());
    }

    // optional int64 hashed_salted_device_address = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_hashed_salted_device_address());
    }

    // optional int64 duration = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_duration());
    }

    // optional .nearby.proto.fastpair.OsType os_type = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_os_type());
    }

    // optional int32 active_wifi_frequency = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_active_wifi_frequency());
    }

    // optional int32 number_connected_peripherals = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_number_connected_peripherals());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 bonding_transport = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_bonding_transport());
    }

    // optional bool is_scanned_by_offload_scanner = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool is_first_day_new_user = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool is_seven_days_new_user = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool is_pair_triggered_by_settings = 23;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional uint32 bonded_device_count = 21;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_bonded_device_count());
    }

    // optional int64 nearby_mainline_tethering_version = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_nearby_mainline_tethering_version());
    }

    // optional int32 sass_connection_state = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_sass_connection_state());
    }

  }
  if (cached_has_bits & 0x03000000u) {
    // optional bool is_in_paired_history = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional int64 nearby_nano_app_version = 25;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_nearby_nano_app_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastPairLog::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FastPairLog*>(
      &from));
}

void FastPairLog::MergeFrom(const FastPairLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nearby.proto.fastpair.FastPairLog)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_gatt_event()->::nearby::proto::fastpair::FastPairLog_GattEvent::MergeFrom(from._internal_gatt_event());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_br_edr_handover_event()->::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent::MergeFrom(from._internal_br_edr_handover_event());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_bond_event()->::nearby::proto::fastpair::FastPairLog_CreateBondEvent::MergeFrom(from._internal_bond_event());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_connect_event()->::nearby::proto::fastpair::FastPairLog_ConnectEvent::MergeFrom(from._internal_connect_event());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_provider_info()->::nearby::proto::fastpair::FastPairLog_ProviderInfo::MergeFrom(from._internal_provider_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_footprints_info()->::nearby::proto::fastpair::FastPairLog_FootprintsInfo::MergeFrom(from._internal_footprints_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_key_based_pairing_info()->::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo::MergeFrom(from._internal_key_based_pairing_info());
    }
    if (cached_has_bits & 0x00000080u) {
      model_id_ = from.model_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      bond_state_ = from.bond_state_;
    }
    if (cached_has_bits & 0x00000200u) {
      error_code_ = from.error_code_;
    }
    if (cached_has_bits & 0x00000400u) {
      device_type_ = from.device_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      hashed_salted_device_address_ = from.hashed_salted_device_address_;
    }
    if (cached_has_bits & 0x00001000u) {
      duration_ = from.duration_;
    }
    if (cached_has_bits & 0x00002000u) {
      os_type_ = from.os_type_;
    }
    if (cached_has_bits & 0x00004000u) {
      active_wifi_frequency_ = from.active_wifi_frequency_;
    }
    if (cached_has_bits & 0x00008000u) {
      number_connected_peripherals_ = from.number_connected_peripherals_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      bonding_transport_ = from.bonding_transport_;
    }
    if (cached_has_bits & 0x00020000u) {
      is_scanned_by_offload_scanner_ = from.is_scanned_by_offload_scanner_;
    }
    if (cached_has_bits & 0x00040000u) {
      is_first_day_new_user_ = from.is_first_day_new_user_;
    }
    if (cached_has_bits & 0x00080000u) {
      is_seven_days_new_user_ = from.is_seven_days_new_user_;
    }
    if (cached_has_bits & 0x00100000u) {
      is_pair_triggered_by_settings_ = from.is_pair_triggered_by_settings_;
    }
    if (cached_has_bits & 0x00200000u) {
      bonded_device_count_ = from.bonded_device_count_;
    }
    if (cached_has_bits & 0x00400000u) {
      nearby_mainline_tethering_version_ = from.nearby_mainline_tethering_version_;
    }
    if (cached_has_bits & 0x00800000u) {
      sass_connection_state_ = from.sass_connection_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x03000000u) {
    if (cached_has_bits & 0x01000000u) {
      is_in_paired_history_ = from.is_in_paired_history_;
    }
    if (cached_has_bits & 0x02000000u) {
      nearby_nano_app_version_ = from.nearby_nano_app_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastPairLog::CopyFrom(const FastPairLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.proto.fastpair.FastPairLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastPairLog::IsInitialized() const {
  return true;
}

void FastPairLog::InternalSwap(FastPairLog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastPairLog, nearby_nano_app_version_)
      + sizeof(FastPairLog::nearby_nano_app_version_)
      - PROTOBUF_FIELD_OFFSET(FastPairLog, gatt_event_)>(
          reinterpret_cast<char*>(&gatt_event_),
          reinterpret_cast<char*>(&other->gatt_event_));
}

std::string FastPairLog::GetTypeName() const {
  return "nearby.proto.fastpair.FastPairLog";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace fastpair
}  // namespace proto
}  // namespace nearby
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog_GattEvent* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog_GattEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog_GattEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog_CreateBondEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog_CreateBondEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog_ConnectEvent* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog_ConnectEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog_ConnectEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog_ProviderInfo* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog_ProviderInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog_ProviderInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog_FootprintsInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog_FootprintsInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::proto::fastpair::FastPairLog* Arena::CreateMaybeMessage< ::nearby::proto::fastpair::FastPairLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::proto::fastpair::FastPairLog >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
