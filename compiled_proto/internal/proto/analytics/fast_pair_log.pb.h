// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: internal/proto/analytics/fast_pair_log.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "proto/fast_pair_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace nearby {
namespace proto {
namespace fastpair {
class FastPairLog;
struct FastPairLogDefaultTypeInternal;
extern FastPairLogDefaultTypeInternal _FastPairLog_default_instance_;
class FastPairLog_BrEdrHandoverEvent;
struct FastPairLog_BrEdrHandoverEventDefaultTypeInternal;
extern FastPairLog_BrEdrHandoverEventDefaultTypeInternal _FastPairLog_BrEdrHandoverEvent_default_instance_;
class FastPairLog_ConnectEvent;
struct FastPairLog_ConnectEventDefaultTypeInternal;
extern FastPairLog_ConnectEventDefaultTypeInternal _FastPairLog_ConnectEvent_default_instance_;
class FastPairLog_CreateBondEvent;
struct FastPairLog_CreateBondEventDefaultTypeInternal;
extern FastPairLog_CreateBondEventDefaultTypeInternal _FastPairLog_CreateBondEvent_default_instance_;
class FastPairLog_FootprintsInfo;
struct FastPairLog_FootprintsInfoDefaultTypeInternal;
extern FastPairLog_FootprintsInfoDefaultTypeInternal _FastPairLog_FootprintsInfo_default_instance_;
class FastPairLog_GattEvent;
struct FastPairLog_GattEventDefaultTypeInternal;
extern FastPairLog_GattEventDefaultTypeInternal _FastPairLog_GattEvent_default_instance_;
class FastPairLog_KeyBasedPairingInfo;
struct FastPairLog_KeyBasedPairingInfoDefaultTypeInternal;
extern FastPairLog_KeyBasedPairingInfoDefaultTypeInternal _FastPairLog_KeyBasedPairingInfo_default_instance_;
class FastPairLog_ProviderInfo;
struct FastPairLog_ProviderInfoDefaultTypeInternal;
extern FastPairLog_ProviderInfoDefaultTypeInternal _FastPairLog_ProviderInfo_default_instance_;
}  // namespace fastpair
}  // namespace proto
}  // namespace nearby
PROTOBUF_NAMESPACE_OPEN
template<> ::nearby::proto::fastpair::FastPairLog* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog>(Arena*);
template<> ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent>(Arena*);
template<> ::nearby::proto::fastpair::FastPairLog_ConnectEvent* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_ConnectEvent>(Arena*);
template<> ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_CreateBondEvent>(Arena*);
template<> ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_FootprintsInfo>(Arena*);
template<> ::nearby::proto::fastpair::FastPairLog_GattEvent* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_GattEvent>(Arena*);
template<> ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo>(Arena*);
template<> ::nearby::proto::fastpair::FastPairLog_ProviderInfo* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_ProviderInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace nearby {
namespace proto {
namespace fastpair {

// ===================================================================

class FastPairLog_GattEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog.GattEvent) */ {
 public:
  inline FastPairLog_GattEvent() : FastPairLog_GattEvent(nullptr) {}
  ~FastPairLog_GattEvent() override;
  explicit constexpr FastPairLog_GattEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog_GattEvent(const FastPairLog_GattEvent& from);
  FastPairLog_GattEvent(FastPairLog_GattEvent&& from) noexcept
    : FastPairLog_GattEvent() {
    *this = ::std::move(from);
  }

  inline FastPairLog_GattEvent& operator=(const FastPairLog_GattEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog_GattEvent& operator=(FastPairLog_GattEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog_GattEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog_GattEvent* internal_default_instance() {
    return reinterpret_cast<const FastPairLog_GattEvent*>(
               &_FastPairLog_GattEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FastPairLog_GattEvent& a, FastPairLog_GattEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog_GattEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog_GattEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog_GattEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog_GattEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog_GattEvent& from);
  void MergeFrom(const FastPairLog_GattEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog_GattEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog.GattEvent";
  }
  protected:
  explicit FastPairLog_GattEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFromOsFieldNumber = 1,
  };
  // optional int32 error_from_os = 1;
  bool has_error_from_os() const;
  private:
  bool _internal_has_error_from_os() const;
  public:
  void clear_error_from_os();
  int32_t error_from_os() const;
  void set_error_from_os(int32_t value);
  private:
  int32_t _internal_error_from_os() const;
  void _internal_set_error_from_os(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog.GattEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t error_from_os_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// -------------------------------------------------------------------

class FastPairLog_BrEdrHandoverEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent) */ {
 public:
  inline FastPairLog_BrEdrHandoverEvent() : FastPairLog_BrEdrHandoverEvent(nullptr) {}
  ~FastPairLog_BrEdrHandoverEvent() override;
  explicit constexpr FastPairLog_BrEdrHandoverEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog_BrEdrHandoverEvent(const FastPairLog_BrEdrHandoverEvent& from);
  FastPairLog_BrEdrHandoverEvent(FastPairLog_BrEdrHandoverEvent&& from) noexcept
    : FastPairLog_BrEdrHandoverEvent() {
    *this = ::std::move(from);
  }

  inline FastPairLog_BrEdrHandoverEvent& operator=(const FastPairLog_BrEdrHandoverEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog_BrEdrHandoverEvent& operator=(FastPairLog_BrEdrHandoverEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog_BrEdrHandoverEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog_BrEdrHandoverEvent* internal_default_instance() {
    return reinterpret_cast<const FastPairLog_BrEdrHandoverEvent*>(
               &_FastPairLog_BrEdrHandoverEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FastPairLog_BrEdrHandoverEvent& a, FastPairLog_BrEdrHandoverEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog_BrEdrHandoverEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog_BrEdrHandoverEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog_BrEdrHandoverEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog_BrEdrHandoverEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog_BrEdrHandoverEvent& from);
  void MergeFrom(const FastPairLog_BrEdrHandoverEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog_BrEdrHandoverEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent";
  }
  protected:
  explicit FastPairLog_BrEdrHandoverEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
  };
  // optional .nearby.proto.fastpair.FastPairEvent.BrEdrHandoverErrorCode error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode error_code() const;
  void set_error_code(::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode value);
  private:
  ::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode _internal_error_code() const;
  void _internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int error_code_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// -------------------------------------------------------------------

class FastPairLog_CreateBondEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog.CreateBondEvent) */ {
 public:
  inline FastPairLog_CreateBondEvent() : FastPairLog_CreateBondEvent(nullptr) {}
  ~FastPairLog_CreateBondEvent() override;
  explicit constexpr FastPairLog_CreateBondEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog_CreateBondEvent(const FastPairLog_CreateBondEvent& from);
  FastPairLog_CreateBondEvent(FastPairLog_CreateBondEvent&& from) noexcept
    : FastPairLog_CreateBondEvent() {
    *this = ::std::move(from);
  }

  inline FastPairLog_CreateBondEvent& operator=(const FastPairLog_CreateBondEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog_CreateBondEvent& operator=(FastPairLog_CreateBondEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog_CreateBondEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog_CreateBondEvent* internal_default_instance() {
    return reinterpret_cast<const FastPairLog_CreateBondEvent*>(
               &_FastPairLog_CreateBondEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FastPairLog_CreateBondEvent& a, FastPairLog_CreateBondEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog_CreateBondEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog_CreateBondEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog_CreateBondEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog_CreateBondEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog_CreateBondEvent& from);
  void MergeFrom(const FastPairLog_CreateBondEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog_CreateBondEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog.CreateBondEvent";
  }
  protected:
  explicit FastPairLog_CreateBondEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kUnbondReasonFieldNumber = 2,
  };
  // optional .nearby.proto.fastpair.FastPairEvent.CreateBondErrorCode error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode error_code() const;
  void set_error_code(::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode value);
  private:
  ::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode _internal_error_code() const;
  void _internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode value);
  public:

  // optional int32 unbond_reason = 2;
  bool has_unbond_reason() const;
  private:
  bool _internal_has_unbond_reason() const;
  public:
  void clear_unbond_reason();
  int32_t unbond_reason() const;
  void set_unbond_reason(int32_t value);
  private:
  int32_t _internal_unbond_reason() const;
  void _internal_set_unbond_reason(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog.CreateBondEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int error_code_;
  int32_t unbond_reason_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// -------------------------------------------------------------------

class FastPairLog_ConnectEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog.ConnectEvent) */ {
 public:
  inline FastPairLog_ConnectEvent() : FastPairLog_ConnectEvent(nullptr) {}
  ~FastPairLog_ConnectEvent() override;
  explicit constexpr FastPairLog_ConnectEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog_ConnectEvent(const FastPairLog_ConnectEvent& from);
  FastPairLog_ConnectEvent(FastPairLog_ConnectEvent&& from) noexcept
    : FastPairLog_ConnectEvent() {
    *this = ::std::move(from);
  }

  inline FastPairLog_ConnectEvent& operator=(const FastPairLog_ConnectEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog_ConnectEvent& operator=(FastPairLog_ConnectEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog_ConnectEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog_ConnectEvent* internal_default_instance() {
    return reinterpret_cast<const FastPairLog_ConnectEvent*>(
               &_FastPairLog_ConnectEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FastPairLog_ConnectEvent& a, FastPairLog_ConnectEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog_ConnectEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog_ConnectEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog_ConnectEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog_ConnectEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog_ConnectEvent& from);
  void MergeFrom(const FastPairLog_ConnectEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog_ConnectEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog.ConnectEvent";
  }
  protected:
  explicit FastPairLog_ConnectEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kProfileUuidFieldNumber = 2,
  };
  // optional .nearby.proto.fastpair.FastPairEvent.ConnectErrorCode error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode error_code() const;
  void set_error_code(::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode value);
  private:
  ::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode _internal_error_code() const;
  void _internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode value);
  public:

  // optional int32 profile_uuid = 2;
  bool has_profile_uuid() const;
  private:
  bool _internal_has_profile_uuid() const;
  public:
  void clear_profile_uuid();
  int32_t profile_uuid() const;
  void set_profile_uuid(int32_t value);
  private:
  int32_t _internal_profile_uuid() const;
  void _internal_set_profile_uuid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog.ConnectEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int error_code_;
  int32_t profile_uuid_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// -------------------------------------------------------------------

class FastPairLog_ProviderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog.ProviderInfo) */ {
 public:
  inline FastPairLog_ProviderInfo() : FastPairLog_ProviderInfo(nullptr) {}
  ~FastPairLog_ProviderInfo() override;
  explicit constexpr FastPairLog_ProviderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog_ProviderInfo(const FastPairLog_ProviderInfo& from);
  FastPairLog_ProviderInfo(FastPairLog_ProviderInfo&& from) noexcept
    : FastPairLog_ProviderInfo() {
    *this = ::std::move(from);
  }

  inline FastPairLog_ProviderInfo& operator=(const FastPairLog_ProviderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog_ProviderInfo& operator=(FastPairLog_ProviderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog_ProviderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog_ProviderInfo* internal_default_instance() {
    return reinterpret_cast<const FastPairLog_ProviderInfo*>(
               &_FastPairLog_ProviderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FastPairLog_ProviderInfo& a, FastPairLog_ProviderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog_ProviderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog_ProviderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog_ProviderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog_ProviderInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog_ProviderInfo& from);
  void MergeFrom(const FastPairLog_ProviderInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog_ProviderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog.ProviderInfo";
  }
  protected:
  explicit FastPairLog_ProviderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseHashFieldNumber = 2,
    kNumberAccountKeysOnProviderFieldNumber = 1,
  };
  // optional string database_hash = 2;
  bool has_database_hash() const;
  private:
  bool _internal_has_database_hash() const;
  public:
  void clear_database_hash();
  const std::string& database_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_hash();
  PROTOBUF_NODISCARD std::string* release_database_hash();
  void set_allocated_database_hash(std::string* database_hash);
  private:
  const std::string& _internal_database_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_hash(const std::string& value);
  std::string* _internal_mutable_database_hash();
  public:

  // optional int32 number_account_keys_on_provider = 1;
  bool has_number_account_keys_on_provider() const;
  private:
  bool _internal_has_number_account_keys_on_provider() const;
  public:
  void clear_number_account_keys_on_provider();
  int32_t number_account_keys_on_provider() const;
  void set_number_account_keys_on_provider(int32_t value);
  private:
  int32_t _internal_number_account_keys_on_provider() const;
  void _internal_set_number_account_keys_on_provider(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog.ProviderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_hash_;
  int32_t number_account_keys_on_provider_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// -------------------------------------------------------------------

class FastPairLog_FootprintsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog.FootprintsInfo) */ {
 public:
  inline FastPairLog_FootprintsInfo() : FastPairLog_FootprintsInfo(nullptr) {}
  ~FastPairLog_FootprintsInfo() override;
  explicit constexpr FastPairLog_FootprintsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog_FootprintsInfo(const FastPairLog_FootprintsInfo& from);
  FastPairLog_FootprintsInfo(FastPairLog_FootprintsInfo&& from) noexcept
    : FastPairLog_FootprintsInfo() {
    *this = ::std::move(from);
  }

  inline FastPairLog_FootprintsInfo& operator=(const FastPairLog_FootprintsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog_FootprintsInfo& operator=(FastPairLog_FootprintsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog_FootprintsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog_FootprintsInfo* internal_default_instance() {
    return reinterpret_cast<const FastPairLog_FootprintsInfo*>(
               &_FastPairLog_FootprintsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FastPairLog_FootprintsInfo& a, FastPairLog_FootprintsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog_FootprintsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog_FootprintsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog_FootprintsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog_FootprintsInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog_FootprintsInfo& from);
  void MergeFrom(const FastPairLog_FootprintsInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog_FootprintsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog.FootprintsInfo";
  }
  protected:
  explicit FastPairLog_FootprintsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberDevicesOnFootprintsFieldNumber = 1,
  };
  // optional int32 number_devices_on_footprints = 1;
  bool has_number_devices_on_footprints() const;
  private:
  bool _internal_has_number_devices_on_footprints() const;
  public:
  void clear_number_devices_on_footprints();
  int32_t number_devices_on_footprints() const;
  void set_number_devices_on_footprints(int32_t value);
  private:
  int32_t _internal_number_devices_on_footprints() const;
  void _internal_set_number_devices_on_footprints(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog.FootprintsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t number_devices_on_footprints_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// -------------------------------------------------------------------

class FastPairLog_KeyBasedPairingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo) */ {
 public:
  inline FastPairLog_KeyBasedPairingInfo() : FastPairLog_KeyBasedPairingInfo(nullptr) {}
  ~FastPairLog_KeyBasedPairingInfo() override;
  explicit constexpr FastPairLog_KeyBasedPairingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog_KeyBasedPairingInfo(const FastPairLog_KeyBasedPairingInfo& from);
  FastPairLog_KeyBasedPairingInfo(FastPairLog_KeyBasedPairingInfo&& from) noexcept
    : FastPairLog_KeyBasedPairingInfo() {
    *this = ::std::move(from);
  }

  inline FastPairLog_KeyBasedPairingInfo& operator=(const FastPairLog_KeyBasedPairingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog_KeyBasedPairingInfo& operator=(FastPairLog_KeyBasedPairingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog_KeyBasedPairingInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog_KeyBasedPairingInfo* internal_default_instance() {
    return reinterpret_cast<const FastPairLog_KeyBasedPairingInfo*>(
               &_FastPairLog_KeyBasedPairingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FastPairLog_KeyBasedPairingInfo& a, FastPairLog_KeyBasedPairingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog_KeyBasedPairingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog_KeyBasedPairingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog_KeyBasedPairingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog_KeyBasedPairingInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog_KeyBasedPairingInfo& from);
  void MergeFrom(const FastPairLog_KeyBasedPairingInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog_KeyBasedPairingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo";
  }
  protected:
  explicit FastPairLog_KeyBasedPairingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFlagFieldNumber = 1,
    kResponseTypeFieldNumber = 2,
    kResponseFlagFieldNumber = 3,
    kResponseDeviceCountFieldNumber = 4,
  };
  // optional uint32 request_flag = 1;
  bool has_request_flag() const;
  private:
  bool _internal_has_request_flag() const;
  public:
  void clear_request_flag();
  uint32_t request_flag() const;
  void set_request_flag(uint32_t value);
  private:
  uint32_t _internal_request_flag() const;
  void _internal_set_request_flag(uint32_t value);
  public:

  // optional uint32 response_type = 2;
  bool has_response_type() const;
  private:
  bool _internal_has_response_type() const;
  public:
  void clear_response_type();
  uint32_t response_type() const;
  void set_response_type(uint32_t value);
  private:
  uint32_t _internal_response_type() const;
  void _internal_set_response_type(uint32_t value);
  public:

  // optional uint32 response_flag = 3;
  bool has_response_flag() const;
  private:
  bool _internal_has_response_flag() const;
  public:
  void clear_response_flag();
  uint32_t response_flag() const;
  void set_response_flag(uint32_t value);
  private:
  uint32_t _internal_response_flag() const;
  void _internal_set_response_flag(uint32_t value);
  public:

  // optional uint32 response_device_count = 4;
  bool has_response_device_count() const;
  private:
  bool _internal_has_response_device_count() const;
  public:
  void clear_response_device_count();
  uint32_t response_device_count() const;
  void set_response_device_count(uint32_t value);
  private:
  uint32_t _internal_response_device_count() const;
  void _internal_set_response_device_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t request_flag_;
  uint32_t response_type_;
  uint32_t response_flag_;
  uint32_t response_device_count_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// -------------------------------------------------------------------

class FastPairLog final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairLog) */ {
 public:
  inline FastPairLog() : FastPairLog(nullptr) {}
  ~FastPairLog() override;
  explicit constexpr FastPairLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairLog(const FastPairLog& from);
  FastPairLog(FastPairLog&& from) noexcept
    : FastPairLog() {
    *this = ::std::move(from);
  }

  inline FastPairLog& operator=(const FastPairLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairLog& operator=(FastPairLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairLog* internal_default_instance() {
    return reinterpret_cast<const FastPairLog*>(
               &_FastPairLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FastPairLog& a, FastPairLog& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairLog>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairLog& from);
  void MergeFrom(const FastPairLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairLog";
  }
  protected:
  explicit FastPairLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FastPairLog_GattEvent GattEvent;
  typedef FastPairLog_BrEdrHandoverEvent BrEdrHandoverEvent;
  typedef FastPairLog_CreateBondEvent CreateBondEvent;
  typedef FastPairLog_ConnectEvent ConnectEvent;
  typedef FastPairLog_ProviderInfo ProviderInfo;
  typedef FastPairLog_FootprintsInfo FootprintsInfo;
  typedef FastPairLog_KeyBasedPairingInfo KeyBasedPairingInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kGattEventFieldNumber = 4,
    kBrEdrHandoverEventFieldNumber = 5,
    kBondEventFieldNumber = 6,
    kConnectEventFieldNumber = 7,
    kProviderInfoFieldNumber = 10,
    kFootprintsInfoFieldNumber = 11,
    kKeyBasedPairingInfoFieldNumber = 17,
    kModelIdFieldNumber = 1,
    kBondStateFieldNumber = 2,
    kErrorCodeFieldNumber = 3,
    kDeviceTypeFieldNumber = 12,
    kHashedSaltedDeviceAddressFieldNumber = 8,
    kDurationFieldNumber = 9,
    kOsTypeFieldNumber = 13,
    kActiveWifiFrequencyFieldNumber = 14,
    kNumberConnectedPeripheralsFieldNumber = 15,
    kBondingTransportFieldNumber = 18,
    kIsScannedByOffloadScannerFieldNumber = 16,
    kIsFirstDayNewUserFieldNumber = 19,
    kIsSevenDaysNewUserFieldNumber = 20,
    kIsPairTriggeredBySettingsFieldNumber = 23,
    kBondedDeviceCountFieldNumber = 21,
    kNearbyMainlineTetheringVersionFieldNumber = 24,
    kSassConnectionStateFieldNumber = 22,
    kIsInPairedHistoryFieldNumber = 26,
    kNearbyNanoAppVersionFieldNumber = 25,
  };
  // optional .nearby.proto.fastpair.FastPairLog.GattEvent gatt_event = 4;
  bool has_gatt_event() const;
  private:
  bool _internal_has_gatt_event() const;
  public:
  void clear_gatt_event();
  const ::nearby::proto::fastpair::FastPairLog_GattEvent& gatt_event() const;
  PROTOBUF_NODISCARD ::nearby::proto::fastpair::FastPairLog_GattEvent* release_gatt_event();
  ::nearby::proto::fastpair::FastPairLog_GattEvent* mutable_gatt_event();
  void set_allocated_gatt_event(::nearby::proto::fastpair::FastPairLog_GattEvent* gatt_event);
  private:
  const ::nearby::proto::fastpair::FastPairLog_GattEvent& _internal_gatt_event() const;
  ::nearby::proto::fastpair::FastPairLog_GattEvent* _internal_mutable_gatt_event();
  public:
  void unsafe_arena_set_allocated_gatt_event(
      ::nearby::proto::fastpair::FastPairLog_GattEvent* gatt_event);
  ::nearby::proto::fastpair::FastPairLog_GattEvent* unsafe_arena_release_gatt_event();

  // optional .nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent br_edr_handover_event = 5;
  bool has_br_edr_handover_event() const;
  private:
  bool _internal_has_br_edr_handover_event() const;
  public:
  void clear_br_edr_handover_event();
  const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent& br_edr_handover_event() const;
  PROTOBUF_NODISCARD ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* release_br_edr_handover_event();
  ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* mutable_br_edr_handover_event();
  void set_allocated_br_edr_handover_event(::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* br_edr_handover_event);
  private:
  const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent& _internal_br_edr_handover_event() const;
  ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* _internal_mutable_br_edr_handover_event();
  public:
  void unsafe_arena_set_allocated_br_edr_handover_event(
      ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* br_edr_handover_event);
  ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* unsafe_arena_release_br_edr_handover_event();

  // optional .nearby.proto.fastpair.FastPairLog.CreateBondEvent bond_event = 6;
  bool has_bond_event() const;
  private:
  bool _internal_has_bond_event() const;
  public:
  void clear_bond_event();
  const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent& bond_event() const;
  PROTOBUF_NODISCARD ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* release_bond_event();
  ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* mutable_bond_event();
  void set_allocated_bond_event(::nearby::proto::fastpair::FastPairLog_CreateBondEvent* bond_event);
  private:
  const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent& _internal_bond_event() const;
  ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* _internal_mutable_bond_event();
  public:
  void unsafe_arena_set_allocated_bond_event(
      ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* bond_event);
  ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* unsafe_arena_release_bond_event();

  // optional .nearby.proto.fastpair.FastPairLog.ConnectEvent connect_event = 7;
  bool has_connect_event() const;
  private:
  bool _internal_has_connect_event() const;
  public:
  void clear_connect_event();
  const ::nearby::proto::fastpair::FastPairLog_ConnectEvent& connect_event() const;
  PROTOBUF_NODISCARD ::nearby::proto::fastpair::FastPairLog_ConnectEvent* release_connect_event();
  ::nearby::proto::fastpair::FastPairLog_ConnectEvent* mutable_connect_event();
  void set_allocated_connect_event(::nearby::proto::fastpair::FastPairLog_ConnectEvent* connect_event);
  private:
  const ::nearby::proto::fastpair::FastPairLog_ConnectEvent& _internal_connect_event() const;
  ::nearby::proto::fastpair::FastPairLog_ConnectEvent* _internal_mutable_connect_event();
  public:
  void unsafe_arena_set_allocated_connect_event(
      ::nearby::proto::fastpair::FastPairLog_ConnectEvent* connect_event);
  ::nearby::proto::fastpair::FastPairLog_ConnectEvent* unsafe_arena_release_connect_event();

  // optional .nearby.proto.fastpair.FastPairLog.ProviderInfo provider_info = 10;
  bool has_provider_info() const;
  private:
  bool _internal_has_provider_info() const;
  public:
  void clear_provider_info();
  const ::nearby::proto::fastpair::FastPairLog_ProviderInfo& provider_info() const;
  PROTOBUF_NODISCARD ::nearby::proto::fastpair::FastPairLog_ProviderInfo* release_provider_info();
  ::nearby::proto::fastpair::FastPairLog_ProviderInfo* mutable_provider_info();
  void set_allocated_provider_info(::nearby::proto::fastpair::FastPairLog_ProviderInfo* provider_info);
  private:
  const ::nearby::proto::fastpair::FastPairLog_ProviderInfo& _internal_provider_info() const;
  ::nearby::proto::fastpair::FastPairLog_ProviderInfo* _internal_mutable_provider_info();
  public:
  void unsafe_arena_set_allocated_provider_info(
      ::nearby::proto::fastpair::FastPairLog_ProviderInfo* provider_info);
  ::nearby::proto::fastpair::FastPairLog_ProviderInfo* unsafe_arena_release_provider_info();

  // optional .nearby.proto.fastpair.FastPairLog.FootprintsInfo footprints_info = 11;
  bool has_footprints_info() const;
  private:
  bool _internal_has_footprints_info() const;
  public:
  void clear_footprints_info();
  const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo& footprints_info() const;
  PROTOBUF_NODISCARD ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* release_footprints_info();
  ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* mutable_footprints_info();
  void set_allocated_footprints_info(::nearby::proto::fastpair::FastPairLog_FootprintsInfo* footprints_info);
  private:
  const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo& _internal_footprints_info() const;
  ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* _internal_mutable_footprints_info();
  public:
  void unsafe_arena_set_allocated_footprints_info(
      ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* footprints_info);
  ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* unsafe_arena_release_footprints_info();

  // optional .nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo key_based_pairing_info = 17;
  bool has_key_based_pairing_info() const;
  private:
  bool _internal_has_key_based_pairing_info() const;
  public:
  void clear_key_based_pairing_info();
  const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo& key_based_pairing_info() const;
  PROTOBUF_NODISCARD ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* release_key_based_pairing_info();
  ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* mutable_key_based_pairing_info();
  void set_allocated_key_based_pairing_info(::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* key_based_pairing_info);
  private:
  const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo& _internal_key_based_pairing_info() const;
  ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* _internal_mutable_key_based_pairing_info();
  public:
  void unsafe_arena_set_allocated_key_based_pairing_info(
      ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* key_based_pairing_info);
  ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* unsafe_arena_release_key_based_pairing_info();

  // optional int32 model_id = 1;
  bool has_model_id() const;
  private:
  bool _internal_has_model_id() const;
  public:
  void clear_model_id();
  int32_t model_id() const;
  void set_model_id(int32_t value);
  private:
  int32_t _internal_model_id() const;
  void _internal_set_model_id(int32_t value);
  public:

  // optional .nearby.proto.fastpair.FastPairEvent.BondState bond_state = 2;
  bool has_bond_state() const;
  private:
  bool _internal_has_bond_state() const;
  public:
  void clear_bond_state();
  ::nearby::proto::fastpair::FastPairEvent_BondState bond_state() const;
  void set_bond_state(::nearby::proto::fastpair::FastPairEvent_BondState value);
  private:
  ::nearby::proto::fastpair::FastPairEvent_BondState _internal_bond_state() const;
  void _internal_set_bond_state(::nearby::proto::fastpair::FastPairEvent_BondState value);
  public:

  // optional .nearby.proto.fastpair.FastPairEvent.ErrorCode error_code = 3;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::nearby::proto::fastpair::FastPairEvent_ErrorCode error_code() const;
  void set_error_code(::nearby::proto::fastpair::FastPairEvent_ErrorCode value);
  private:
  ::nearby::proto::fastpair::FastPairEvent_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_ErrorCode value);
  public:

  // optional .nearby.proto.fastpair.DeviceType device_type = 12;
  bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  void clear_device_type();
  ::nearby::proto::fastpair::DeviceType device_type() const;
  void set_device_type(::nearby::proto::fastpair::DeviceType value);
  private:
  ::nearby::proto::fastpair::DeviceType _internal_device_type() const;
  void _internal_set_device_type(::nearby::proto::fastpair::DeviceType value);
  public:

  // optional int64 hashed_salted_device_address = 8;
  bool has_hashed_salted_device_address() const;
  private:
  bool _internal_has_hashed_salted_device_address() const;
  public:
  void clear_hashed_salted_device_address();
  int64_t hashed_salted_device_address() const;
  void set_hashed_salted_device_address(int64_t value);
  private:
  int64_t _internal_hashed_salted_device_address() const;
  void _internal_set_hashed_salted_device_address(int64_t value);
  public:

  // optional int64 duration = 9;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  int64_t duration() const;
  void set_duration(int64_t value);
  private:
  int64_t _internal_duration() const;
  void _internal_set_duration(int64_t value);
  public:

  // optional .nearby.proto.fastpair.OsType os_type = 13;
  bool has_os_type() const;
  private:
  bool _internal_has_os_type() const;
  public:
  void clear_os_type();
  ::nearby::proto::fastpair::OsType os_type() const;
  void set_os_type(::nearby::proto::fastpair::OsType value);
  private:
  ::nearby::proto::fastpair::OsType _internal_os_type() const;
  void _internal_set_os_type(::nearby::proto::fastpair::OsType value);
  public:

  // optional int32 active_wifi_frequency = 14;
  bool has_active_wifi_frequency() const;
  private:
  bool _internal_has_active_wifi_frequency() const;
  public:
  void clear_active_wifi_frequency();
  int32_t active_wifi_frequency() const;
  void set_active_wifi_frequency(int32_t value);
  private:
  int32_t _internal_active_wifi_frequency() const;
  void _internal_set_active_wifi_frequency(int32_t value);
  public:

  // optional int32 number_connected_peripherals = 15;
  bool has_number_connected_peripherals() const;
  private:
  bool _internal_has_number_connected_peripherals() const;
  public:
  void clear_number_connected_peripherals();
  int32_t number_connected_peripherals() const;
  void set_number_connected_peripherals(int32_t value);
  private:
  int32_t _internal_number_connected_peripherals() const;
  void _internal_set_number_connected_peripherals(int32_t value);
  public:

  // optional uint32 bonding_transport = 18;
  bool has_bonding_transport() const;
  private:
  bool _internal_has_bonding_transport() const;
  public:
  void clear_bonding_transport();
  uint32_t bonding_transport() const;
  void set_bonding_transport(uint32_t value);
  private:
  uint32_t _internal_bonding_transport() const;
  void _internal_set_bonding_transport(uint32_t value);
  public:

  // optional bool is_scanned_by_offload_scanner = 16;
  bool has_is_scanned_by_offload_scanner() const;
  private:
  bool _internal_has_is_scanned_by_offload_scanner() const;
  public:
  void clear_is_scanned_by_offload_scanner();
  bool is_scanned_by_offload_scanner() const;
  void set_is_scanned_by_offload_scanner(bool value);
  private:
  bool _internal_is_scanned_by_offload_scanner() const;
  void _internal_set_is_scanned_by_offload_scanner(bool value);
  public:

  // optional bool is_first_day_new_user = 19;
  bool has_is_first_day_new_user() const;
  private:
  bool _internal_has_is_first_day_new_user() const;
  public:
  void clear_is_first_day_new_user();
  bool is_first_day_new_user() const;
  void set_is_first_day_new_user(bool value);
  private:
  bool _internal_is_first_day_new_user() const;
  void _internal_set_is_first_day_new_user(bool value);
  public:

  // optional bool is_seven_days_new_user = 20;
  bool has_is_seven_days_new_user() const;
  private:
  bool _internal_has_is_seven_days_new_user() const;
  public:
  void clear_is_seven_days_new_user();
  bool is_seven_days_new_user() const;
  void set_is_seven_days_new_user(bool value);
  private:
  bool _internal_is_seven_days_new_user() const;
  void _internal_set_is_seven_days_new_user(bool value);
  public:

  // optional bool is_pair_triggered_by_settings = 23;
  bool has_is_pair_triggered_by_settings() const;
  private:
  bool _internal_has_is_pair_triggered_by_settings() const;
  public:
  void clear_is_pair_triggered_by_settings();
  bool is_pair_triggered_by_settings() const;
  void set_is_pair_triggered_by_settings(bool value);
  private:
  bool _internal_is_pair_triggered_by_settings() const;
  void _internal_set_is_pair_triggered_by_settings(bool value);
  public:

  // optional uint32 bonded_device_count = 21;
  bool has_bonded_device_count() const;
  private:
  bool _internal_has_bonded_device_count() const;
  public:
  void clear_bonded_device_count();
  uint32_t bonded_device_count() const;
  void set_bonded_device_count(uint32_t value);
  private:
  uint32_t _internal_bonded_device_count() const;
  void _internal_set_bonded_device_count(uint32_t value);
  public:

  // optional int64 nearby_mainline_tethering_version = 24;
  bool has_nearby_mainline_tethering_version() const;
  private:
  bool _internal_has_nearby_mainline_tethering_version() const;
  public:
  void clear_nearby_mainline_tethering_version();
  int64_t nearby_mainline_tethering_version() const;
  void set_nearby_mainline_tethering_version(int64_t value);
  private:
  int64_t _internal_nearby_mainline_tethering_version() const;
  void _internal_set_nearby_mainline_tethering_version(int64_t value);
  public:

  // optional int32 sass_connection_state = 22;
  bool has_sass_connection_state() const;
  private:
  bool _internal_has_sass_connection_state() const;
  public:
  void clear_sass_connection_state();
  int32_t sass_connection_state() const;
  void set_sass_connection_state(int32_t value);
  private:
  int32_t _internal_sass_connection_state() const;
  void _internal_set_sass_connection_state(int32_t value);
  public:

  // optional bool is_in_paired_history = 26;
  bool has_is_in_paired_history() const;
  private:
  bool _internal_has_is_in_paired_history() const;
  public:
  void clear_is_in_paired_history();
  bool is_in_paired_history() const;
  void set_is_in_paired_history(bool value);
  private:
  bool _internal_is_in_paired_history() const;
  void _internal_set_is_in_paired_history(bool value);
  public:

  // optional int64 nearby_nano_app_version = 25;
  bool has_nearby_nano_app_version() const;
  private:
  bool _internal_has_nearby_nano_app_version() const;
  public:
  void clear_nearby_nano_app_version();
  int64_t nearby_nano_app_version() const;
  void set_nearby_nano_app_version(int64_t value);
  private:
  int64_t _internal_nearby_nano_app_version() const;
  void _internal_set_nearby_nano_app_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::nearby::proto::fastpair::FastPairLog_GattEvent* gatt_event_;
  ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* br_edr_handover_event_;
  ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* bond_event_;
  ::nearby::proto::fastpair::FastPairLog_ConnectEvent* connect_event_;
  ::nearby::proto::fastpair::FastPairLog_ProviderInfo* provider_info_;
  ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* footprints_info_;
  ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* key_based_pairing_info_;
  int32_t model_id_;
  int bond_state_;
  int error_code_;
  int device_type_;
  int64_t hashed_salted_device_address_;
  int64_t duration_;
  int os_type_;
  int32_t active_wifi_frequency_;
  int32_t number_connected_peripherals_;
  uint32_t bonding_transport_;
  bool is_scanned_by_offload_scanner_;
  bool is_first_day_new_user_;
  bool is_seven_days_new_user_;
  bool is_pair_triggered_by_settings_;
  uint32_t bonded_device_count_;
  int64_t nearby_mainline_tethering_version_;
  int32_t sass_connection_state_;
  bool is_in_paired_history_;
  int64_t nearby_nano_app_version_;
  friend struct ::TableStruct_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FastPairLog_GattEvent

// optional int32 error_from_os = 1;
inline bool FastPairLog_GattEvent::_internal_has_error_from_os() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FastPairLog_GattEvent::has_error_from_os() const {
  return _internal_has_error_from_os();
}
inline void FastPairLog_GattEvent::clear_error_from_os() {
  error_from_os_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t FastPairLog_GattEvent::_internal_error_from_os() const {
  return error_from_os_;
}
inline int32_t FastPairLog_GattEvent::error_from_os() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.GattEvent.error_from_os)
  return _internal_error_from_os();
}
inline void FastPairLog_GattEvent::_internal_set_error_from_os(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  error_from_os_ = value;
}
inline void FastPairLog_GattEvent::set_error_from_os(int32_t value) {
  _internal_set_error_from_os(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.GattEvent.error_from_os)
}

// -------------------------------------------------------------------

// FastPairLog_BrEdrHandoverEvent

// optional .nearby.proto.fastpair.FastPairEvent.BrEdrHandoverErrorCode error_code = 1;
inline bool FastPairLog_BrEdrHandoverEvent::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FastPairLog_BrEdrHandoverEvent::has_error_code() const {
  return _internal_has_error_code();
}
inline void FastPairLog_BrEdrHandoverEvent::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode FastPairLog_BrEdrHandoverEvent::_internal_error_code() const {
  return static_cast< ::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode >(error_code_);
}
inline ::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode FastPairLog_BrEdrHandoverEvent::error_code() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent.error_code)
  return _internal_error_code();
}
inline void FastPairLog_BrEdrHandoverEvent::_internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode value) {
  assert(::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  error_code_ = value;
}
inline void FastPairLog_BrEdrHandoverEvent::set_error_code(::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent.error_code)
}

// -------------------------------------------------------------------

// FastPairLog_CreateBondEvent

// optional .nearby.proto.fastpair.FastPairEvent.CreateBondErrorCode error_code = 1;
inline bool FastPairLog_CreateBondEvent::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FastPairLog_CreateBondEvent::has_error_code() const {
  return _internal_has_error_code();
}
inline void FastPairLog_CreateBondEvent::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode FastPairLog_CreateBondEvent::_internal_error_code() const {
  return static_cast< ::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode >(error_code_);
}
inline ::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode FastPairLog_CreateBondEvent::error_code() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.CreateBondEvent.error_code)
  return _internal_error_code();
}
inline void FastPairLog_CreateBondEvent::_internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode value) {
  assert(::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  error_code_ = value;
}
inline void FastPairLog_CreateBondEvent::set_error_code(::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.CreateBondEvent.error_code)
}

// optional int32 unbond_reason = 2;
inline bool FastPairLog_CreateBondEvent::_internal_has_unbond_reason() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FastPairLog_CreateBondEvent::has_unbond_reason() const {
  return _internal_has_unbond_reason();
}
inline void FastPairLog_CreateBondEvent::clear_unbond_reason() {
  unbond_reason_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t FastPairLog_CreateBondEvent::_internal_unbond_reason() const {
  return unbond_reason_;
}
inline int32_t FastPairLog_CreateBondEvent::unbond_reason() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.CreateBondEvent.unbond_reason)
  return _internal_unbond_reason();
}
inline void FastPairLog_CreateBondEvent::_internal_set_unbond_reason(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  unbond_reason_ = value;
}
inline void FastPairLog_CreateBondEvent::set_unbond_reason(int32_t value) {
  _internal_set_unbond_reason(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.CreateBondEvent.unbond_reason)
}

// -------------------------------------------------------------------

// FastPairLog_ConnectEvent

// optional .nearby.proto.fastpair.FastPairEvent.ConnectErrorCode error_code = 1;
inline bool FastPairLog_ConnectEvent::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FastPairLog_ConnectEvent::has_error_code() const {
  return _internal_has_error_code();
}
inline void FastPairLog_ConnectEvent::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode FastPairLog_ConnectEvent::_internal_error_code() const {
  return static_cast< ::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode >(error_code_);
}
inline ::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode FastPairLog_ConnectEvent::error_code() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.ConnectEvent.error_code)
  return _internal_error_code();
}
inline void FastPairLog_ConnectEvent::_internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode value) {
  assert(::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  error_code_ = value;
}
inline void FastPairLog_ConnectEvent::set_error_code(::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.ConnectEvent.error_code)
}

// optional int32 profile_uuid = 2;
inline bool FastPairLog_ConnectEvent::_internal_has_profile_uuid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FastPairLog_ConnectEvent::has_profile_uuid() const {
  return _internal_has_profile_uuid();
}
inline void FastPairLog_ConnectEvent::clear_profile_uuid() {
  profile_uuid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t FastPairLog_ConnectEvent::_internal_profile_uuid() const {
  return profile_uuid_;
}
inline int32_t FastPairLog_ConnectEvent::profile_uuid() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.ConnectEvent.profile_uuid)
  return _internal_profile_uuid();
}
inline void FastPairLog_ConnectEvent::_internal_set_profile_uuid(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  profile_uuid_ = value;
}
inline void FastPairLog_ConnectEvent::set_profile_uuid(int32_t value) {
  _internal_set_profile_uuid(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.ConnectEvent.profile_uuid)
}

// -------------------------------------------------------------------

// FastPairLog_ProviderInfo

// optional int32 number_account_keys_on_provider = 1;
inline bool FastPairLog_ProviderInfo::_internal_has_number_account_keys_on_provider() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FastPairLog_ProviderInfo::has_number_account_keys_on_provider() const {
  return _internal_has_number_account_keys_on_provider();
}
inline void FastPairLog_ProviderInfo::clear_number_account_keys_on_provider() {
  number_account_keys_on_provider_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t FastPairLog_ProviderInfo::_internal_number_account_keys_on_provider() const {
  return number_account_keys_on_provider_;
}
inline int32_t FastPairLog_ProviderInfo::number_account_keys_on_provider() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.ProviderInfo.number_account_keys_on_provider)
  return _internal_number_account_keys_on_provider();
}
inline void FastPairLog_ProviderInfo::_internal_set_number_account_keys_on_provider(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  number_account_keys_on_provider_ = value;
}
inline void FastPairLog_ProviderInfo::set_number_account_keys_on_provider(int32_t value) {
  _internal_set_number_account_keys_on_provider(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.ProviderInfo.number_account_keys_on_provider)
}

// optional string database_hash = 2;
inline bool FastPairLog_ProviderInfo::_internal_has_database_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FastPairLog_ProviderInfo::has_database_hash() const {
  return _internal_has_database_hash();
}
inline void FastPairLog_ProviderInfo::clear_database_hash() {
  database_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FastPairLog_ProviderInfo::database_hash() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.ProviderInfo.database_hash)
  return _internal_database_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FastPairLog_ProviderInfo::set_database_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.ProviderInfo.database_hash)
}
inline std::string* FastPairLog_ProviderInfo::mutable_database_hash() {
  std::string* _s = _internal_mutable_database_hash();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.ProviderInfo.database_hash)
  return _s;
}
inline const std::string& FastPairLog_ProviderInfo::_internal_database_hash() const {
  return database_hash_.Get();
}
inline void FastPairLog_ProviderInfo::_internal_set_database_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FastPairLog_ProviderInfo::_internal_mutable_database_hash() {
  _has_bits_[0] |= 0x00000001u;
  return database_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FastPairLog_ProviderInfo::release_database_hash() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.ProviderInfo.database_hash)
  if (!_internal_has_database_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = database_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FastPairLog_ProviderInfo::set_allocated_database_hash(std::string* database_hash) {
  if (database_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.ProviderInfo.database_hash)
}

// -------------------------------------------------------------------

// FastPairLog_FootprintsInfo

// optional int32 number_devices_on_footprints = 1;
inline bool FastPairLog_FootprintsInfo::_internal_has_number_devices_on_footprints() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FastPairLog_FootprintsInfo::has_number_devices_on_footprints() const {
  return _internal_has_number_devices_on_footprints();
}
inline void FastPairLog_FootprintsInfo::clear_number_devices_on_footprints() {
  number_devices_on_footprints_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t FastPairLog_FootprintsInfo::_internal_number_devices_on_footprints() const {
  return number_devices_on_footprints_;
}
inline int32_t FastPairLog_FootprintsInfo::number_devices_on_footprints() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.FootprintsInfo.number_devices_on_footprints)
  return _internal_number_devices_on_footprints();
}
inline void FastPairLog_FootprintsInfo::_internal_set_number_devices_on_footprints(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  number_devices_on_footprints_ = value;
}
inline void FastPairLog_FootprintsInfo::set_number_devices_on_footprints(int32_t value) {
  _internal_set_number_devices_on_footprints(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.FootprintsInfo.number_devices_on_footprints)
}

// -------------------------------------------------------------------

// FastPairLog_KeyBasedPairingInfo

// optional uint32 request_flag = 1;
inline bool FastPairLog_KeyBasedPairingInfo::_internal_has_request_flag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FastPairLog_KeyBasedPairingInfo::has_request_flag() const {
  return _internal_has_request_flag();
}
inline void FastPairLog_KeyBasedPairingInfo::clear_request_flag() {
  request_flag_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::_internal_request_flag() const {
  return request_flag_;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::request_flag() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.request_flag)
  return _internal_request_flag();
}
inline void FastPairLog_KeyBasedPairingInfo::_internal_set_request_flag(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  request_flag_ = value;
}
inline void FastPairLog_KeyBasedPairingInfo::set_request_flag(uint32_t value) {
  _internal_set_request_flag(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.request_flag)
}

// optional uint32 response_type = 2;
inline bool FastPairLog_KeyBasedPairingInfo::_internal_has_response_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FastPairLog_KeyBasedPairingInfo::has_response_type() const {
  return _internal_has_response_type();
}
inline void FastPairLog_KeyBasedPairingInfo::clear_response_type() {
  response_type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::_internal_response_type() const {
  return response_type_;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::response_type() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.response_type)
  return _internal_response_type();
}
inline void FastPairLog_KeyBasedPairingInfo::_internal_set_response_type(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  response_type_ = value;
}
inline void FastPairLog_KeyBasedPairingInfo::set_response_type(uint32_t value) {
  _internal_set_response_type(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.response_type)
}

// optional uint32 response_flag = 3;
inline bool FastPairLog_KeyBasedPairingInfo::_internal_has_response_flag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FastPairLog_KeyBasedPairingInfo::has_response_flag() const {
  return _internal_has_response_flag();
}
inline void FastPairLog_KeyBasedPairingInfo::clear_response_flag() {
  response_flag_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::_internal_response_flag() const {
  return response_flag_;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::response_flag() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.response_flag)
  return _internal_response_flag();
}
inline void FastPairLog_KeyBasedPairingInfo::_internal_set_response_flag(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  response_flag_ = value;
}
inline void FastPairLog_KeyBasedPairingInfo::set_response_flag(uint32_t value) {
  _internal_set_response_flag(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.response_flag)
}

// optional uint32 response_device_count = 4;
inline bool FastPairLog_KeyBasedPairingInfo::_internal_has_response_device_count() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FastPairLog_KeyBasedPairingInfo::has_response_device_count() const {
  return _internal_has_response_device_count();
}
inline void FastPairLog_KeyBasedPairingInfo::clear_response_device_count() {
  response_device_count_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::_internal_response_device_count() const {
  return response_device_count_;
}
inline uint32_t FastPairLog_KeyBasedPairingInfo::response_device_count() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.response_device_count)
  return _internal_response_device_count();
}
inline void FastPairLog_KeyBasedPairingInfo::_internal_set_response_device_count(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  response_device_count_ = value;
}
inline void FastPairLog_KeyBasedPairingInfo::set_response_device_count(uint32_t value) {
  _internal_set_response_device_count(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo.response_device_count)
}

// -------------------------------------------------------------------

// FastPairLog

// optional int32 model_id = 1;
inline bool FastPairLog::_internal_has_model_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FastPairLog::has_model_id() const {
  return _internal_has_model_id();
}
inline void FastPairLog::clear_model_id() {
  model_id_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t FastPairLog::_internal_model_id() const {
  return model_id_;
}
inline int32_t FastPairLog::model_id() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.model_id)
  return _internal_model_id();
}
inline void FastPairLog::_internal_set_model_id(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  model_id_ = value;
}
inline void FastPairLog::set_model_id(int32_t value) {
  _internal_set_model_id(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.model_id)
}

// optional .nearby.proto.fastpair.FastPairEvent.BondState bond_state = 2;
inline bool FastPairLog::_internal_has_bond_state() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FastPairLog::has_bond_state() const {
  return _internal_has_bond_state();
}
inline void FastPairLog::clear_bond_state() {
  bond_state_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::nearby::proto::fastpair::FastPairEvent_BondState FastPairLog::_internal_bond_state() const {
  return static_cast< ::nearby::proto::fastpair::FastPairEvent_BondState >(bond_state_);
}
inline ::nearby::proto::fastpair::FastPairEvent_BondState FastPairLog::bond_state() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.bond_state)
  return _internal_bond_state();
}
inline void FastPairLog::_internal_set_bond_state(::nearby::proto::fastpair::FastPairEvent_BondState value) {
  assert(::nearby::proto::fastpair::FastPairEvent_BondState_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  bond_state_ = value;
}
inline void FastPairLog::set_bond_state(::nearby::proto::fastpair::FastPairEvent_BondState value) {
  _internal_set_bond_state(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.bond_state)
}

// optional .nearby.proto.fastpair.FastPairEvent.ErrorCode error_code = 3;
inline bool FastPairLog::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FastPairLog::has_error_code() const {
  return _internal_has_error_code();
}
inline void FastPairLog::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::nearby::proto::fastpair::FastPairEvent_ErrorCode FastPairLog::_internal_error_code() const {
  return static_cast< ::nearby::proto::fastpair::FastPairEvent_ErrorCode >(error_code_);
}
inline ::nearby::proto::fastpair::FastPairEvent_ErrorCode FastPairLog::error_code() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.error_code)
  return _internal_error_code();
}
inline void FastPairLog::_internal_set_error_code(::nearby::proto::fastpair::FastPairEvent_ErrorCode value) {
  assert(::nearby::proto::fastpair::FastPairEvent_ErrorCode_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  error_code_ = value;
}
inline void FastPairLog::set_error_code(::nearby::proto::fastpair::FastPairEvent_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.error_code)
}

// optional .nearby.proto.fastpair.FastPairLog.GattEvent gatt_event = 4;
inline bool FastPairLog::_internal_has_gatt_event() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gatt_event_ != nullptr);
  return value;
}
inline bool FastPairLog::has_gatt_event() const {
  return _internal_has_gatt_event();
}
inline void FastPairLog::clear_gatt_event() {
  if (gatt_event_ != nullptr) gatt_event_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::nearby::proto::fastpair::FastPairLog_GattEvent& FastPairLog::_internal_gatt_event() const {
  const ::nearby::proto::fastpair::FastPairLog_GattEvent* p = gatt_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::proto::fastpair::FastPairLog_GattEvent&>(
      ::nearby::proto::fastpair::_FastPairLog_GattEvent_default_instance_);
}
inline const ::nearby::proto::fastpair::FastPairLog_GattEvent& FastPairLog::gatt_event() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.gatt_event)
  return _internal_gatt_event();
}
inline void FastPairLog::unsafe_arena_set_allocated_gatt_event(
    ::nearby::proto::fastpair::FastPairLog_GattEvent* gatt_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gatt_event_);
  }
  gatt_event_ = gatt_event;
  if (gatt_event) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.proto.fastpair.FastPairLog.gatt_event)
}
inline ::nearby::proto::fastpair::FastPairLog_GattEvent* FastPairLog::release_gatt_event() {
  _has_bits_[0] &= ~0x00000001u;
  ::nearby::proto::fastpair::FastPairLog_GattEvent* temp = gatt_event_;
  gatt_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_GattEvent* FastPairLog::unsafe_arena_release_gatt_event() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.gatt_event)
  _has_bits_[0] &= ~0x00000001u;
  ::nearby::proto::fastpair::FastPairLog_GattEvent* temp = gatt_event_;
  gatt_event_ = nullptr;
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_GattEvent* FastPairLog::_internal_mutable_gatt_event() {
  _has_bits_[0] |= 0x00000001u;
  if (gatt_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_GattEvent>(GetArenaForAllocation());
    gatt_event_ = p;
  }
  return gatt_event_;
}
inline ::nearby::proto::fastpair::FastPairLog_GattEvent* FastPairLog::mutable_gatt_event() {
  ::nearby::proto::fastpair::FastPairLog_GattEvent* _msg = _internal_mutable_gatt_event();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.gatt_event)
  return _msg;
}
inline void FastPairLog::set_allocated_gatt_event(::nearby::proto::fastpair::FastPairLog_GattEvent* gatt_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gatt_event_;
  }
  if (gatt_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nearby::proto::fastpair::FastPairLog_GattEvent>::GetOwningArena(gatt_event);
    if (message_arena != submessage_arena) {
      gatt_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gatt_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gatt_event_ = gatt_event;
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.gatt_event)
}

// optional .nearby.proto.fastpair.FastPairLog.BrEdrHandoverEvent br_edr_handover_event = 5;
inline bool FastPairLog::_internal_has_br_edr_handover_event() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || br_edr_handover_event_ != nullptr);
  return value;
}
inline bool FastPairLog::has_br_edr_handover_event() const {
  return _internal_has_br_edr_handover_event();
}
inline void FastPairLog::clear_br_edr_handover_event() {
  if (br_edr_handover_event_ != nullptr) br_edr_handover_event_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent& FastPairLog::_internal_br_edr_handover_event() const {
  const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* p = br_edr_handover_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent&>(
      ::nearby::proto::fastpair::_FastPairLog_BrEdrHandoverEvent_default_instance_);
}
inline const ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent& FastPairLog::br_edr_handover_event() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.br_edr_handover_event)
  return _internal_br_edr_handover_event();
}
inline void FastPairLog::unsafe_arena_set_allocated_br_edr_handover_event(
    ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* br_edr_handover_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(br_edr_handover_event_);
  }
  br_edr_handover_event_ = br_edr_handover_event;
  if (br_edr_handover_event) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.proto.fastpair.FastPairLog.br_edr_handover_event)
}
inline ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* FastPairLog::release_br_edr_handover_event() {
  _has_bits_[0] &= ~0x00000002u;
  ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* temp = br_edr_handover_event_;
  br_edr_handover_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* FastPairLog::unsafe_arena_release_br_edr_handover_event() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.br_edr_handover_event)
  _has_bits_[0] &= ~0x00000002u;
  ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* temp = br_edr_handover_event_;
  br_edr_handover_event_ = nullptr;
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* FastPairLog::_internal_mutable_br_edr_handover_event() {
  _has_bits_[0] |= 0x00000002u;
  if (br_edr_handover_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent>(GetArenaForAllocation());
    br_edr_handover_event_ = p;
  }
  return br_edr_handover_event_;
}
inline ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* FastPairLog::mutable_br_edr_handover_event() {
  ::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* _msg = _internal_mutable_br_edr_handover_event();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.br_edr_handover_event)
  return _msg;
}
inline void FastPairLog::set_allocated_br_edr_handover_event(::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent* br_edr_handover_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete br_edr_handover_event_;
  }
  if (br_edr_handover_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nearby::proto::fastpair::FastPairLog_BrEdrHandoverEvent>::GetOwningArena(br_edr_handover_event);
    if (message_arena != submessage_arena) {
      br_edr_handover_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, br_edr_handover_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  br_edr_handover_event_ = br_edr_handover_event;
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.br_edr_handover_event)
}

// optional .nearby.proto.fastpair.FastPairLog.CreateBondEvent bond_event = 6;
inline bool FastPairLog::_internal_has_bond_event() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || bond_event_ != nullptr);
  return value;
}
inline bool FastPairLog::has_bond_event() const {
  return _internal_has_bond_event();
}
inline void FastPairLog::clear_bond_event() {
  if (bond_event_ != nullptr) bond_event_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent& FastPairLog::_internal_bond_event() const {
  const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* p = bond_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent&>(
      ::nearby::proto::fastpair::_FastPairLog_CreateBondEvent_default_instance_);
}
inline const ::nearby::proto::fastpair::FastPairLog_CreateBondEvent& FastPairLog::bond_event() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.bond_event)
  return _internal_bond_event();
}
inline void FastPairLog::unsafe_arena_set_allocated_bond_event(
    ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* bond_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bond_event_);
  }
  bond_event_ = bond_event;
  if (bond_event) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.proto.fastpair.FastPairLog.bond_event)
}
inline ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* FastPairLog::release_bond_event() {
  _has_bits_[0] &= ~0x00000004u;
  ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* temp = bond_event_;
  bond_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* FastPairLog::unsafe_arena_release_bond_event() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.bond_event)
  _has_bits_[0] &= ~0x00000004u;
  ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* temp = bond_event_;
  bond_event_ = nullptr;
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* FastPairLog::_internal_mutable_bond_event() {
  _has_bits_[0] |= 0x00000004u;
  if (bond_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_CreateBondEvent>(GetArenaForAllocation());
    bond_event_ = p;
  }
  return bond_event_;
}
inline ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* FastPairLog::mutable_bond_event() {
  ::nearby::proto::fastpair::FastPairLog_CreateBondEvent* _msg = _internal_mutable_bond_event();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.bond_event)
  return _msg;
}
inline void FastPairLog::set_allocated_bond_event(::nearby::proto::fastpair::FastPairLog_CreateBondEvent* bond_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bond_event_;
  }
  if (bond_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nearby::proto::fastpair::FastPairLog_CreateBondEvent>::GetOwningArena(bond_event);
    if (message_arena != submessage_arena) {
      bond_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bond_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  bond_event_ = bond_event;
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.bond_event)
}

// optional .nearby.proto.fastpair.FastPairLog.ConnectEvent connect_event = 7;
inline bool FastPairLog::_internal_has_connect_event() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || connect_event_ != nullptr);
  return value;
}
inline bool FastPairLog::has_connect_event() const {
  return _internal_has_connect_event();
}
inline void FastPairLog::clear_connect_event() {
  if (connect_event_ != nullptr) connect_event_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::nearby::proto::fastpair::FastPairLog_ConnectEvent& FastPairLog::_internal_connect_event() const {
  const ::nearby::proto::fastpair::FastPairLog_ConnectEvent* p = connect_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::proto::fastpair::FastPairLog_ConnectEvent&>(
      ::nearby::proto::fastpair::_FastPairLog_ConnectEvent_default_instance_);
}
inline const ::nearby::proto::fastpair::FastPairLog_ConnectEvent& FastPairLog::connect_event() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.connect_event)
  return _internal_connect_event();
}
inline void FastPairLog::unsafe_arena_set_allocated_connect_event(
    ::nearby::proto::fastpair::FastPairLog_ConnectEvent* connect_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connect_event_);
  }
  connect_event_ = connect_event;
  if (connect_event) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.proto.fastpair.FastPairLog.connect_event)
}
inline ::nearby::proto::fastpair::FastPairLog_ConnectEvent* FastPairLog::release_connect_event() {
  _has_bits_[0] &= ~0x00000008u;
  ::nearby::proto::fastpair::FastPairLog_ConnectEvent* temp = connect_event_;
  connect_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_ConnectEvent* FastPairLog::unsafe_arena_release_connect_event() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.connect_event)
  _has_bits_[0] &= ~0x00000008u;
  ::nearby::proto::fastpair::FastPairLog_ConnectEvent* temp = connect_event_;
  connect_event_ = nullptr;
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_ConnectEvent* FastPairLog::_internal_mutable_connect_event() {
  _has_bits_[0] |= 0x00000008u;
  if (connect_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_ConnectEvent>(GetArenaForAllocation());
    connect_event_ = p;
  }
  return connect_event_;
}
inline ::nearby::proto::fastpair::FastPairLog_ConnectEvent* FastPairLog::mutable_connect_event() {
  ::nearby::proto::fastpair::FastPairLog_ConnectEvent* _msg = _internal_mutable_connect_event();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.connect_event)
  return _msg;
}
inline void FastPairLog::set_allocated_connect_event(::nearby::proto::fastpair::FastPairLog_ConnectEvent* connect_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connect_event_;
  }
  if (connect_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nearby::proto::fastpair::FastPairLog_ConnectEvent>::GetOwningArena(connect_event);
    if (message_arena != submessage_arena) {
      connect_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connect_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  connect_event_ = connect_event;
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.connect_event)
}

// optional int64 hashed_salted_device_address = 8;
inline bool FastPairLog::_internal_has_hashed_salted_device_address() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool FastPairLog::has_hashed_salted_device_address() const {
  return _internal_has_hashed_salted_device_address();
}
inline void FastPairLog::clear_hashed_salted_device_address() {
  hashed_salted_device_address_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline int64_t FastPairLog::_internal_hashed_salted_device_address() const {
  return hashed_salted_device_address_;
}
inline int64_t FastPairLog::hashed_salted_device_address() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.hashed_salted_device_address)
  return _internal_hashed_salted_device_address();
}
inline void FastPairLog::_internal_set_hashed_salted_device_address(int64_t value) {
  _has_bits_[0] |= 0x00000800u;
  hashed_salted_device_address_ = value;
}
inline void FastPairLog::set_hashed_salted_device_address(int64_t value) {
  _internal_set_hashed_salted_device_address(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.hashed_salted_device_address)
}

// optional int64 duration = 9;
inline bool FastPairLog::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool FastPairLog::has_duration() const {
  return _internal_has_duration();
}
inline void FastPairLog::clear_duration() {
  duration_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline int64_t FastPairLog::_internal_duration() const {
  return duration_;
}
inline int64_t FastPairLog::duration() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.duration)
  return _internal_duration();
}
inline void FastPairLog::_internal_set_duration(int64_t value) {
  _has_bits_[0] |= 0x00001000u;
  duration_ = value;
}
inline void FastPairLog::set_duration(int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.duration)
}

// optional .nearby.proto.fastpair.FastPairLog.ProviderInfo provider_info = 10;
inline bool FastPairLog::_internal_has_provider_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || provider_info_ != nullptr);
  return value;
}
inline bool FastPairLog::has_provider_info() const {
  return _internal_has_provider_info();
}
inline void FastPairLog::clear_provider_info() {
  if (provider_info_ != nullptr) provider_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::nearby::proto::fastpair::FastPairLog_ProviderInfo& FastPairLog::_internal_provider_info() const {
  const ::nearby::proto::fastpair::FastPairLog_ProviderInfo* p = provider_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::proto::fastpair::FastPairLog_ProviderInfo&>(
      ::nearby::proto::fastpair::_FastPairLog_ProviderInfo_default_instance_);
}
inline const ::nearby::proto::fastpair::FastPairLog_ProviderInfo& FastPairLog::provider_info() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.provider_info)
  return _internal_provider_info();
}
inline void FastPairLog::unsafe_arena_set_allocated_provider_info(
    ::nearby::proto::fastpair::FastPairLog_ProviderInfo* provider_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_info_);
  }
  provider_info_ = provider_info;
  if (provider_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.proto.fastpair.FastPairLog.provider_info)
}
inline ::nearby::proto::fastpair::FastPairLog_ProviderInfo* FastPairLog::release_provider_info() {
  _has_bits_[0] &= ~0x00000010u;
  ::nearby::proto::fastpair::FastPairLog_ProviderInfo* temp = provider_info_;
  provider_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_ProviderInfo* FastPairLog::unsafe_arena_release_provider_info() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.provider_info)
  _has_bits_[0] &= ~0x00000010u;
  ::nearby::proto::fastpair::FastPairLog_ProviderInfo* temp = provider_info_;
  provider_info_ = nullptr;
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_ProviderInfo* FastPairLog::_internal_mutable_provider_info() {
  _has_bits_[0] |= 0x00000010u;
  if (provider_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_ProviderInfo>(GetArenaForAllocation());
    provider_info_ = p;
  }
  return provider_info_;
}
inline ::nearby::proto::fastpair::FastPairLog_ProviderInfo* FastPairLog::mutable_provider_info() {
  ::nearby::proto::fastpair::FastPairLog_ProviderInfo* _msg = _internal_mutable_provider_info();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.provider_info)
  return _msg;
}
inline void FastPairLog::set_allocated_provider_info(::nearby::proto::fastpair::FastPairLog_ProviderInfo* provider_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete provider_info_;
  }
  if (provider_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nearby::proto::fastpair::FastPairLog_ProviderInfo>::GetOwningArena(provider_info);
    if (message_arena != submessage_arena) {
      provider_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  provider_info_ = provider_info;
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.provider_info)
}

// optional .nearby.proto.fastpair.FastPairLog.FootprintsInfo footprints_info = 11;
inline bool FastPairLog::_internal_has_footprints_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || footprints_info_ != nullptr);
  return value;
}
inline bool FastPairLog::has_footprints_info() const {
  return _internal_has_footprints_info();
}
inline void FastPairLog::clear_footprints_info() {
  if (footprints_info_ != nullptr) footprints_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo& FastPairLog::_internal_footprints_info() const {
  const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* p = footprints_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo&>(
      ::nearby::proto::fastpair::_FastPairLog_FootprintsInfo_default_instance_);
}
inline const ::nearby::proto::fastpair::FastPairLog_FootprintsInfo& FastPairLog::footprints_info() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.footprints_info)
  return _internal_footprints_info();
}
inline void FastPairLog::unsafe_arena_set_allocated_footprints_info(
    ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* footprints_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(footprints_info_);
  }
  footprints_info_ = footprints_info;
  if (footprints_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.proto.fastpair.FastPairLog.footprints_info)
}
inline ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* FastPairLog::release_footprints_info() {
  _has_bits_[0] &= ~0x00000020u;
  ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* temp = footprints_info_;
  footprints_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* FastPairLog::unsafe_arena_release_footprints_info() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.footprints_info)
  _has_bits_[0] &= ~0x00000020u;
  ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* temp = footprints_info_;
  footprints_info_ = nullptr;
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* FastPairLog::_internal_mutable_footprints_info() {
  _has_bits_[0] |= 0x00000020u;
  if (footprints_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_FootprintsInfo>(GetArenaForAllocation());
    footprints_info_ = p;
  }
  return footprints_info_;
}
inline ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* FastPairLog::mutable_footprints_info() {
  ::nearby::proto::fastpair::FastPairLog_FootprintsInfo* _msg = _internal_mutable_footprints_info();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.footprints_info)
  return _msg;
}
inline void FastPairLog::set_allocated_footprints_info(::nearby::proto::fastpair::FastPairLog_FootprintsInfo* footprints_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete footprints_info_;
  }
  if (footprints_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nearby::proto::fastpair::FastPairLog_FootprintsInfo>::GetOwningArena(footprints_info);
    if (message_arena != submessage_arena) {
      footprints_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footprints_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  footprints_info_ = footprints_info;
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.footprints_info)
}

// optional .nearby.proto.fastpair.DeviceType device_type = 12;
inline bool FastPairLog::_internal_has_device_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool FastPairLog::has_device_type() const {
  return _internal_has_device_type();
}
inline void FastPairLog::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::nearby::proto::fastpair::DeviceType FastPairLog::_internal_device_type() const {
  return static_cast< ::nearby::proto::fastpair::DeviceType >(device_type_);
}
inline ::nearby::proto::fastpair::DeviceType FastPairLog::device_type() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.device_type)
  return _internal_device_type();
}
inline void FastPairLog::_internal_set_device_type(::nearby::proto::fastpair::DeviceType value) {
  assert(::nearby::proto::fastpair::DeviceType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  device_type_ = value;
}
inline void FastPairLog::set_device_type(::nearby::proto::fastpair::DeviceType value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.device_type)
}

// optional .nearby.proto.fastpair.OsType os_type = 13;
inline bool FastPairLog::_internal_has_os_type() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool FastPairLog::has_os_type() const {
  return _internal_has_os_type();
}
inline void FastPairLog::clear_os_type() {
  os_type_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::nearby::proto::fastpair::OsType FastPairLog::_internal_os_type() const {
  return static_cast< ::nearby::proto::fastpair::OsType >(os_type_);
}
inline ::nearby::proto::fastpair::OsType FastPairLog::os_type() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.os_type)
  return _internal_os_type();
}
inline void FastPairLog::_internal_set_os_type(::nearby::proto::fastpair::OsType value) {
  assert(::nearby::proto::fastpair::OsType_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  os_type_ = value;
}
inline void FastPairLog::set_os_type(::nearby::proto::fastpair::OsType value) {
  _internal_set_os_type(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.os_type)
}

// optional int32 active_wifi_frequency = 14;
inline bool FastPairLog::_internal_has_active_wifi_frequency() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool FastPairLog::has_active_wifi_frequency() const {
  return _internal_has_active_wifi_frequency();
}
inline void FastPairLog::clear_active_wifi_frequency() {
  active_wifi_frequency_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline int32_t FastPairLog::_internal_active_wifi_frequency() const {
  return active_wifi_frequency_;
}
inline int32_t FastPairLog::active_wifi_frequency() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.active_wifi_frequency)
  return _internal_active_wifi_frequency();
}
inline void FastPairLog::_internal_set_active_wifi_frequency(int32_t value) {
  _has_bits_[0] |= 0x00004000u;
  active_wifi_frequency_ = value;
}
inline void FastPairLog::set_active_wifi_frequency(int32_t value) {
  _internal_set_active_wifi_frequency(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.active_wifi_frequency)
}

// optional int32 number_connected_peripherals = 15;
inline bool FastPairLog::_internal_has_number_connected_peripherals() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool FastPairLog::has_number_connected_peripherals() const {
  return _internal_has_number_connected_peripherals();
}
inline void FastPairLog::clear_number_connected_peripherals() {
  number_connected_peripherals_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline int32_t FastPairLog::_internal_number_connected_peripherals() const {
  return number_connected_peripherals_;
}
inline int32_t FastPairLog::number_connected_peripherals() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.number_connected_peripherals)
  return _internal_number_connected_peripherals();
}
inline void FastPairLog::_internal_set_number_connected_peripherals(int32_t value) {
  _has_bits_[0] |= 0x00008000u;
  number_connected_peripherals_ = value;
}
inline void FastPairLog::set_number_connected_peripherals(int32_t value) {
  _internal_set_number_connected_peripherals(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.number_connected_peripherals)
}

// optional bool is_scanned_by_offload_scanner = 16;
inline bool FastPairLog::_internal_has_is_scanned_by_offload_scanner() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool FastPairLog::has_is_scanned_by_offload_scanner() const {
  return _internal_has_is_scanned_by_offload_scanner();
}
inline void FastPairLog::clear_is_scanned_by_offload_scanner() {
  is_scanned_by_offload_scanner_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool FastPairLog::_internal_is_scanned_by_offload_scanner() const {
  return is_scanned_by_offload_scanner_;
}
inline bool FastPairLog::is_scanned_by_offload_scanner() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.is_scanned_by_offload_scanner)
  return _internal_is_scanned_by_offload_scanner();
}
inline void FastPairLog::_internal_set_is_scanned_by_offload_scanner(bool value) {
  _has_bits_[0] |= 0x00020000u;
  is_scanned_by_offload_scanner_ = value;
}
inline void FastPairLog::set_is_scanned_by_offload_scanner(bool value) {
  _internal_set_is_scanned_by_offload_scanner(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.is_scanned_by_offload_scanner)
}

// optional .nearby.proto.fastpair.FastPairLog.KeyBasedPairingInfo key_based_pairing_info = 17;
inline bool FastPairLog::_internal_has_key_based_pairing_info() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || key_based_pairing_info_ != nullptr);
  return value;
}
inline bool FastPairLog::has_key_based_pairing_info() const {
  return _internal_has_key_based_pairing_info();
}
inline void FastPairLog::clear_key_based_pairing_info() {
  if (key_based_pairing_info_ != nullptr) key_based_pairing_info_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo& FastPairLog::_internal_key_based_pairing_info() const {
  const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* p = key_based_pairing_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo&>(
      ::nearby::proto::fastpair::_FastPairLog_KeyBasedPairingInfo_default_instance_);
}
inline const ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo& FastPairLog::key_based_pairing_info() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.key_based_pairing_info)
  return _internal_key_based_pairing_info();
}
inline void FastPairLog::unsafe_arena_set_allocated_key_based_pairing_info(
    ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* key_based_pairing_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_based_pairing_info_);
  }
  key_based_pairing_info_ = key_based_pairing_info;
  if (key_based_pairing_info) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.proto.fastpair.FastPairLog.key_based_pairing_info)
}
inline ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* FastPairLog::release_key_based_pairing_info() {
  _has_bits_[0] &= ~0x00000040u;
  ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* temp = key_based_pairing_info_;
  key_based_pairing_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* FastPairLog::unsafe_arena_release_key_based_pairing_info() {
  // @@protoc_insertion_point(field_release:nearby.proto.fastpair.FastPairLog.key_based_pairing_info)
  _has_bits_[0] &= ~0x00000040u;
  ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* temp = key_based_pairing_info_;
  key_based_pairing_info_ = nullptr;
  return temp;
}
inline ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* FastPairLog::_internal_mutable_key_based_pairing_info() {
  _has_bits_[0] |= 0x00000040u;
  if (key_based_pairing_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo>(GetArenaForAllocation());
    key_based_pairing_info_ = p;
  }
  return key_based_pairing_info_;
}
inline ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* FastPairLog::mutable_key_based_pairing_info() {
  ::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* _msg = _internal_mutable_key_based_pairing_info();
  // @@protoc_insertion_point(field_mutable:nearby.proto.fastpair.FastPairLog.key_based_pairing_info)
  return _msg;
}
inline void FastPairLog::set_allocated_key_based_pairing_info(::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo* key_based_pairing_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_based_pairing_info_;
  }
  if (key_based_pairing_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nearby::proto::fastpair::FastPairLog_KeyBasedPairingInfo>::GetOwningArena(key_based_pairing_info);
    if (message_arena != submessage_arena) {
      key_based_pairing_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_based_pairing_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  key_based_pairing_info_ = key_based_pairing_info;
  // @@protoc_insertion_point(field_set_allocated:nearby.proto.fastpair.FastPairLog.key_based_pairing_info)
}

// optional uint32 bonding_transport = 18;
inline bool FastPairLog::_internal_has_bonding_transport() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool FastPairLog::has_bonding_transport() const {
  return _internal_has_bonding_transport();
}
inline void FastPairLog::clear_bonding_transport() {
  bonding_transport_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline uint32_t FastPairLog::_internal_bonding_transport() const {
  return bonding_transport_;
}
inline uint32_t FastPairLog::bonding_transport() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.bonding_transport)
  return _internal_bonding_transport();
}
inline void FastPairLog::_internal_set_bonding_transport(uint32_t value) {
  _has_bits_[0] |= 0x00010000u;
  bonding_transport_ = value;
}
inline void FastPairLog::set_bonding_transport(uint32_t value) {
  _internal_set_bonding_transport(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.bonding_transport)
}

// optional bool is_first_day_new_user = 19;
inline bool FastPairLog::_internal_has_is_first_day_new_user() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool FastPairLog::has_is_first_day_new_user() const {
  return _internal_has_is_first_day_new_user();
}
inline void FastPairLog::clear_is_first_day_new_user() {
  is_first_day_new_user_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool FastPairLog::_internal_is_first_day_new_user() const {
  return is_first_day_new_user_;
}
inline bool FastPairLog::is_first_day_new_user() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.is_first_day_new_user)
  return _internal_is_first_day_new_user();
}
inline void FastPairLog::_internal_set_is_first_day_new_user(bool value) {
  _has_bits_[0] |= 0x00040000u;
  is_first_day_new_user_ = value;
}
inline void FastPairLog::set_is_first_day_new_user(bool value) {
  _internal_set_is_first_day_new_user(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.is_first_day_new_user)
}

// optional bool is_seven_days_new_user = 20;
inline bool FastPairLog::_internal_has_is_seven_days_new_user() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool FastPairLog::has_is_seven_days_new_user() const {
  return _internal_has_is_seven_days_new_user();
}
inline void FastPairLog::clear_is_seven_days_new_user() {
  is_seven_days_new_user_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool FastPairLog::_internal_is_seven_days_new_user() const {
  return is_seven_days_new_user_;
}
inline bool FastPairLog::is_seven_days_new_user() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.is_seven_days_new_user)
  return _internal_is_seven_days_new_user();
}
inline void FastPairLog::_internal_set_is_seven_days_new_user(bool value) {
  _has_bits_[0] |= 0x00080000u;
  is_seven_days_new_user_ = value;
}
inline void FastPairLog::set_is_seven_days_new_user(bool value) {
  _internal_set_is_seven_days_new_user(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.is_seven_days_new_user)
}

// optional uint32 bonded_device_count = 21;
inline bool FastPairLog::_internal_has_bonded_device_count() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool FastPairLog::has_bonded_device_count() const {
  return _internal_has_bonded_device_count();
}
inline void FastPairLog::clear_bonded_device_count() {
  bonded_device_count_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline uint32_t FastPairLog::_internal_bonded_device_count() const {
  return bonded_device_count_;
}
inline uint32_t FastPairLog::bonded_device_count() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.bonded_device_count)
  return _internal_bonded_device_count();
}
inline void FastPairLog::_internal_set_bonded_device_count(uint32_t value) {
  _has_bits_[0] |= 0x00200000u;
  bonded_device_count_ = value;
}
inline void FastPairLog::set_bonded_device_count(uint32_t value) {
  _internal_set_bonded_device_count(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.bonded_device_count)
}

// optional int32 sass_connection_state = 22;
inline bool FastPairLog::_internal_has_sass_connection_state() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool FastPairLog::has_sass_connection_state() const {
  return _internal_has_sass_connection_state();
}
inline void FastPairLog::clear_sass_connection_state() {
  sass_connection_state_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline int32_t FastPairLog::_internal_sass_connection_state() const {
  return sass_connection_state_;
}
inline int32_t FastPairLog::sass_connection_state() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.sass_connection_state)
  return _internal_sass_connection_state();
}
inline void FastPairLog::_internal_set_sass_connection_state(int32_t value) {
  _has_bits_[0] |= 0x00800000u;
  sass_connection_state_ = value;
}
inline void FastPairLog::set_sass_connection_state(int32_t value) {
  _internal_set_sass_connection_state(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.sass_connection_state)
}

// optional bool is_pair_triggered_by_settings = 23;
inline bool FastPairLog::_internal_has_is_pair_triggered_by_settings() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool FastPairLog::has_is_pair_triggered_by_settings() const {
  return _internal_has_is_pair_triggered_by_settings();
}
inline void FastPairLog::clear_is_pair_triggered_by_settings() {
  is_pair_triggered_by_settings_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool FastPairLog::_internal_is_pair_triggered_by_settings() const {
  return is_pair_triggered_by_settings_;
}
inline bool FastPairLog::is_pair_triggered_by_settings() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.is_pair_triggered_by_settings)
  return _internal_is_pair_triggered_by_settings();
}
inline void FastPairLog::_internal_set_is_pair_triggered_by_settings(bool value) {
  _has_bits_[0] |= 0x00100000u;
  is_pair_triggered_by_settings_ = value;
}
inline void FastPairLog::set_is_pair_triggered_by_settings(bool value) {
  _internal_set_is_pair_triggered_by_settings(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.is_pair_triggered_by_settings)
}

// optional int64 nearby_mainline_tethering_version = 24;
inline bool FastPairLog::_internal_has_nearby_mainline_tethering_version() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool FastPairLog::has_nearby_mainline_tethering_version() const {
  return _internal_has_nearby_mainline_tethering_version();
}
inline void FastPairLog::clear_nearby_mainline_tethering_version() {
  nearby_mainline_tethering_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00400000u;
}
inline int64_t FastPairLog::_internal_nearby_mainline_tethering_version() const {
  return nearby_mainline_tethering_version_;
}
inline int64_t FastPairLog::nearby_mainline_tethering_version() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.nearby_mainline_tethering_version)
  return _internal_nearby_mainline_tethering_version();
}
inline void FastPairLog::_internal_set_nearby_mainline_tethering_version(int64_t value) {
  _has_bits_[0] |= 0x00400000u;
  nearby_mainline_tethering_version_ = value;
}
inline void FastPairLog::set_nearby_mainline_tethering_version(int64_t value) {
  _internal_set_nearby_mainline_tethering_version(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.nearby_mainline_tethering_version)
}

// optional int64 nearby_nano_app_version = 25;
inline bool FastPairLog::_internal_has_nearby_nano_app_version() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool FastPairLog::has_nearby_nano_app_version() const {
  return _internal_has_nearby_nano_app_version();
}
inline void FastPairLog::clear_nearby_nano_app_version() {
  nearby_nano_app_version_ = int64_t{0};
  _has_bits_[0] &= ~0x02000000u;
}
inline int64_t FastPairLog::_internal_nearby_nano_app_version() const {
  return nearby_nano_app_version_;
}
inline int64_t FastPairLog::nearby_nano_app_version() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.nearby_nano_app_version)
  return _internal_nearby_nano_app_version();
}
inline void FastPairLog::_internal_set_nearby_nano_app_version(int64_t value) {
  _has_bits_[0] |= 0x02000000u;
  nearby_nano_app_version_ = value;
}
inline void FastPairLog::set_nearby_nano_app_version(int64_t value) {
  _internal_set_nearby_nano_app_version(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.nearby_nano_app_version)
}

// optional bool is_in_paired_history = 26;
inline bool FastPairLog::_internal_has_is_in_paired_history() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool FastPairLog::has_is_in_paired_history() const {
  return _internal_has_is_in_paired_history();
}
inline void FastPairLog::clear_is_in_paired_history() {
  is_in_paired_history_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool FastPairLog::_internal_is_in_paired_history() const {
  return is_in_paired_history_;
}
inline bool FastPairLog::is_in_paired_history() const {
  // @@protoc_insertion_point(field_get:nearby.proto.fastpair.FastPairLog.is_in_paired_history)
  return _internal_is_in_paired_history();
}
inline void FastPairLog::_internal_set_is_in_paired_history(bool value) {
  _has_bits_[0] |= 0x01000000u;
  is_in_paired_history_ = value;
}
inline void FastPairLog::set_is_in_paired_history(bool value) {
  _internal_set_is_in_paired_history(value);
  // @@protoc_insertion_point(field_set:nearby.proto.fastpair.FastPairLog.is_in_paired_history)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fastpair
}  // namespace proto
}  // namespace nearby

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_internal_2fproto_2fanalytics_2ffast_5fpair_5flog_2eproto
