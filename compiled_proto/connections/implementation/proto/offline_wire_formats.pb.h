// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connections/implementation/proto/offline_wire_formats.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace location {
namespace nearby {
namespace connections {
class AuthenticationMessageFrame;
struct AuthenticationMessageFrameDefaultTypeInternal;
extern AuthenticationMessageFrameDefaultTypeInternal _AuthenticationMessageFrame_default_instance_;
class AuthenticationResultFrame;
struct AuthenticationResultFrameDefaultTypeInternal;
extern AuthenticationResultFrameDefaultTypeInternal _AuthenticationResultFrame_default_instance_;
class AutoReconnectFrame;
struct AutoReconnectFrameDefaultTypeInternal;
extern AutoReconnectFrameDefaultTypeInternal _AutoReconnectFrame_default_instance_;
class AutoResumeFrame;
struct AutoResumeFrameDefaultTypeInternal;
extern AutoResumeFrameDefaultTypeInternal _AutoResumeFrame_default_instance_;
class AvailableChannels;
struct AvailableChannelsDefaultTypeInternal;
extern AvailableChannelsDefaultTypeInternal _AvailableChannels_default_instance_;
class BandwidthUpgradeNegotiationFrame;
struct BandwidthUpgradeNegotiationFrameDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrameDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_default_instance_;
class BandwidthUpgradeNegotiationFrame_ClientIntroduction;
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_;
class BandwidthUpgradeNegotiationFrame_ClientIntroductionAck;
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_;
class ConnectionRequestFrame;
struct ConnectionRequestFrameDefaultTypeInternal;
extern ConnectionRequestFrameDefaultTypeInternal _ConnectionRequestFrame_default_instance_;
class ConnectionResponseFrame;
struct ConnectionResponseFrameDefaultTypeInternal;
extern ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
class ConnectionsDevice;
struct ConnectionsDeviceDefaultTypeInternal;
extern ConnectionsDeviceDefaultTypeInternal _ConnectionsDevice_default_instance_;
class DisconnectionFrame;
struct DisconnectionFrameDefaultTypeInternal;
extern DisconnectionFrameDefaultTypeInternal _DisconnectionFrame_default_instance_;
class KeepAliveFrame;
struct KeepAliveFrameDefaultTypeInternal;
extern KeepAliveFrameDefaultTypeInternal _KeepAliveFrame_default_instance_;
class LocationHint;
struct LocationHintDefaultTypeInternal;
extern LocationHintDefaultTypeInternal _LocationHint_default_instance_;
class LocationStandard;
struct LocationStandardDefaultTypeInternal;
extern LocationStandardDefaultTypeInternal _LocationStandard_default_instance_;
class MediumMetadata;
struct MediumMetadataDefaultTypeInternal;
extern MediumMetadataDefaultTypeInternal _MediumMetadata_default_instance_;
class OfflineFrame;
struct OfflineFrameDefaultTypeInternal;
extern OfflineFrameDefaultTypeInternal _OfflineFrame_default_instance_;
class OsInfo;
struct OsInfoDefaultTypeInternal;
extern OsInfoDefaultTypeInternal _OsInfo_default_instance_;
class PairedKeyEncryptionFrame;
struct PairedKeyEncryptionFrameDefaultTypeInternal;
extern PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;
class PayloadTransferFrame;
struct PayloadTransferFrameDefaultTypeInternal;
extern PayloadTransferFrameDefaultTypeInternal _PayloadTransferFrame_default_instance_;
class PayloadTransferFrame_ControlMessage;
struct PayloadTransferFrame_ControlMessageDefaultTypeInternal;
extern PayloadTransferFrame_ControlMessageDefaultTypeInternal _PayloadTransferFrame_ControlMessage_default_instance_;
class PayloadTransferFrame_PayloadChunk;
struct PayloadTransferFrame_PayloadChunkDefaultTypeInternal;
extern PayloadTransferFrame_PayloadChunkDefaultTypeInternal _PayloadTransferFrame_PayloadChunk_default_instance_;
class PayloadTransferFrame_PayloadHeader;
struct PayloadTransferFrame_PayloadHeaderDefaultTypeInternal;
extern PayloadTransferFrame_PayloadHeaderDefaultTypeInternal _PayloadTransferFrame_PayloadHeader_default_instance_;
class PresenceDevice;
struct PresenceDeviceDefaultTypeInternal;
extern PresenceDeviceDefaultTypeInternal _PresenceDevice_default_instance_;
class V1Frame;
struct V1FrameDefaultTypeInternal;
extern V1FrameDefaultTypeInternal _V1Frame_default_instance_;
class WifiAwareUsableChannels;
struct WifiAwareUsableChannelsDefaultTypeInternal;
extern WifiAwareUsableChannelsDefaultTypeInternal _WifiAwareUsableChannels_default_instance_;
class WifiDirectCliUsableChannels;
struct WifiDirectCliUsableChannelsDefaultTypeInternal;
extern WifiDirectCliUsableChannelsDefaultTypeInternal _WifiDirectCliUsableChannels_default_instance_;
class WifiHotspotStaUsableChannels;
struct WifiHotspotStaUsableChannelsDefaultTypeInternal;
extern WifiHotspotStaUsableChannelsDefaultTypeInternal _WifiHotspotStaUsableChannels_default_instance_;
class WifiLanUsableChannels;
struct WifiLanUsableChannelsDefaultTypeInternal;
extern WifiLanUsableChannelsDefaultTypeInternal _WifiLanUsableChannels_default_instance_;
}  // namespace connections
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template<> ::location::nearby::connections::AuthenticationMessageFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AuthenticationMessageFrame>(Arena*);
template<> ::location::nearby::connections::AuthenticationResultFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AuthenticationResultFrame>(Arena*);
template<> ::location::nearby::connections::AutoReconnectFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AutoReconnectFrame>(Arena*);
template<> ::location::nearby::connections::AutoResumeFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AutoResumeFrame>(Arena*);
template<> ::location::nearby::connections::AvailableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::AvailableChannels>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(Arena*);
template<> ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(Arena*);
template<> ::location::nearby::connections::ConnectionRequestFrame* Arena::CreateMaybeMessage<::location::nearby::connections::ConnectionRequestFrame>(Arena*);
template<> ::location::nearby::connections::ConnectionResponseFrame* Arena::CreateMaybeMessage<::location::nearby::connections::ConnectionResponseFrame>(Arena*);
template<> ::location::nearby::connections::ConnectionsDevice* Arena::CreateMaybeMessage<::location::nearby::connections::ConnectionsDevice>(Arena*);
template<> ::location::nearby::connections::DisconnectionFrame* Arena::CreateMaybeMessage<::location::nearby::connections::DisconnectionFrame>(Arena*);
template<> ::location::nearby::connections::KeepAliveFrame* Arena::CreateMaybeMessage<::location::nearby::connections::KeepAliveFrame>(Arena*);
template<> ::location::nearby::connections::LocationHint* Arena::CreateMaybeMessage<::location::nearby::connections::LocationHint>(Arena*);
template<> ::location::nearby::connections::LocationStandard* Arena::CreateMaybeMessage<::location::nearby::connections::LocationStandard>(Arena*);
template<> ::location::nearby::connections::MediumMetadata* Arena::CreateMaybeMessage<::location::nearby::connections::MediumMetadata>(Arena*);
template<> ::location::nearby::connections::OfflineFrame* Arena::CreateMaybeMessage<::location::nearby::connections::OfflineFrame>(Arena*);
template<> ::location::nearby::connections::OsInfo* Arena::CreateMaybeMessage<::location::nearby::connections::OsInfo>(Arena*);
template<> ::location::nearby::connections::PairedKeyEncryptionFrame* Arena::CreateMaybeMessage<::location::nearby::connections::PairedKeyEncryptionFrame>(Arena*);
template<> ::location::nearby::connections::PayloadTransferFrame* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame>(Arena*);
template<> ::location::nearby::connections::PayloadTransferFrame_ControlMessage* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_ControlMessage>(Arena*);
template<> ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadChunk>(Arena*);
template<> ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadHeader>(Arena*);
template<> ::location::nearby::connections::PresenceDevice* Arena::CreateMaybeMessage<::location::nearby::connections::PresenceDevice>(Arena*);
template<> ::location::nearby::connections::V1Frame* Arena::CreateMaybeMessage<::location::nearby::connections::V1Frame>(Arena*);
template<> ::location::nearby::connections::WifiAwareUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiAwareUsableChannels>(Arena*);
template<> ::location::nearby::connections::WifiDirectCliUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiDirectCliUsableChannels>(Arena*);
template<> ::location::nearby::connections::WifiHotspotStaUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiHotspotStaUsableChannels>(Arena*);
template<> ::location::nearby::connections::WifiLanUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiLanUsableChannels>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace location {
namespace nearby {
namespace connections {

enum OfflineFrame_Version : int {
  OfflineFrame_Version_UNKNOWN_VERSION = 0,
  OfflineFrame_Version_V1 = 1
};
bool OfflineFrame_Version_IsValid(int value);
constexpr OfflineFrame_Version OfflineFrame_Version_Version_MIN = OfflineFrame_Version_UNKNOWN_VERSION;
constexpr OfflineFrame_Version OfflineFrame_Version_Version_MAX = OfflineFrame_Version_V1;
constexpr int OfflineFrame_Version_Version_ARRAYSIZE = OfflineFrame_Version_Version_MAX + 1;

const std::string& OfflineFrame_Version_Name(OfflineFrame_Version value);
template<typename T>
inline const std::string& OfflineFrame_Version_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfflineFrame_Version>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfflineFrame_Version_Name.");
  return OfflineFrame_Version_Name(static_cast<OfflineFrame_Version>(enum_t_value));
}
bool OfflineFrame_Version_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfflineFrame_Version* value);
enum V1Frame_FrameType : int {
  V1Frame_FrameType_UNKNOWN_FRAME_TYPE = 0,
  V1Frame_FrameType_CONNECTION_REQUEST = 1,
  V1Frame_FrameType_CONNECTION_RESPONSE = 2,
  V1Frame_FrameType_PAYLOAD_TRANSFER = 3,
  V1Frame_FrameType_BANDWIDTH_UPGRADE_NEGOTIATION = 4,
  V1Frame_FrameType_KEEP_ALIVE = 5,
  V1Frame_FrameType_DISCONNECTION = 6,
  V1Frame_FrameType_PAIRED_KEY_ENCRYPTION = 7,
  V1Frame_FrameType_AUTHENTICATION_MESSAGE = 8,
  V1Frame_FrameType_AUTHENTICATION_RESULT = 9,
  V1Frame_FrameType_AUTO_RESUME = 10,
  V1Frame_FrameType_AUTO_RECONNECT = 11
};
bool V1Frame_FrameType_IsValid(int value);
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MIN = V1Frame_FrameType_UNKNOWN_FRAME_TYPE;
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MAX = V1Frame_FrameType_AUTO_RECONNECT;
constexpr int V1Frame_FrameType_FrameType_ARRAYSIZE = V1Frame_FrameType_FrameType_MAX + 1;

const std::string& V1Frame_FrameType_Name(V1Frame_FrameType value);
template<typename T>
inline const std::string& V1Frame_FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, V1Frame_FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function V1Frame_FrameType_Name.");
  return V1Frame_FrameType_Name(static_cast<V1Frame_FrameType>(enum_t_value));
}
bool V1Frame_FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V1Frame_FrameType* value);
enum ConnectionRequestFrame_Medium : int {
  ConnectionRequestFrame_Medium_UNKNOWN_MEDIUM = 0,
  ConnectionRequestFrame_Medium_MDNS PROTOBUF_DEPRECATED_ENUM = 1,
  ConnectionRequestFrame_Medium_BLUETOOTH = 2,
  ConnectionRequestFrame_Medium_WIFI_HOTSPOT = 3,
  ConnectionRequestFrame_Medium_BLE = 4,
  ConnectionRequestFrame_Medium_WIFI_LAN = 5,
  ConnectionRequestFrame_Medium_WIFI_AWARE = 6,
  ConnectionRequestFrame_Medium_NFC = 7,
  ConnectionRequestFrame_Medium_WIFI_DIRECT = 8,
  ConnectionRequestFrame_Medium_WEB_RTC = 9,
  ConnectionRequestFrame_Medium_BLE_L2CAP = 10,
  ConnectionRequestFrame_Medium_USB = 11
};
bool ConnectionRequestFrame_Medium_IsValid(int value);
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame_Medium_Medium_MIN = ConnectionRequestFrame_Medium_UNKNOWN_MEDIUM;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame_Medium_Medium_MAX = ConnectionRequestFrame_Medium_USB;
constexpr int ConnectionRequestFrame_Medium_Medium_ARRAYSIZE = ConnectionRequestFrame_Medium_Medium_MAX + 1;

const std::string& ConnectionRequestFrame_Medium_Name(ConnectionRequestFrame_Medium value);
template<typename T>
inline const std::string& ConnectionRequestFrame_Medium_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionRequestFrame_Medium>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionRequestFrame_Medium_Name.");
  return ConnectionRequestFrame_Medium_Name(static_cast<ConnectionRequestFrame_Medium>(enum_t_value));
}
bool ConnectionRequestFrame_Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionRequestFrame_Medium* value);
enum ConnectionResponseFrame_ResponseStatus : int {
  ConnectionResponseFrame_ResponseStatus_UNKNOWN_RESPONSE_STATUS = 0,
  ConnectionResponseFrame_ResponseStatus_ACCEPT = 1,
  ConnectionResponseFrame_ResponseStatus_REJECT = 2
};
bool ConnectionResponseFrame_ResponseStatus_IsValid(int value);
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame_ResponseStatus_ResponseStatus_MIN = ConnectionResponseFrame_ResponseStatus_UNKNOWN_RESPONSE_STATUS;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame_ResponseStatus_ResponseStatus_MAX = ConnectionResponseFrame_ResponseStatus_REJECT;
constexpr int ConnectionResponseFrame_ResponseStatus_ResponseStatus_ARRAYSIZE = ConnectionResponseFrame_ResponseStatus_ResponseStatus_MAX + 1;

const std::string& ConnectionResponseFrame_ResponseStatus_Name(ConnectionResponseFrame_ResponseStatus value);
template<typename T>
inline const std::string& ConnectionResponseFrame_ResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionResponseFrame_ResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionResponseFrame_ResponseStatus_Name.");
  return ConnectionResponseFrame_ResponseStatus_Name(static_cast<ConnectionResponseFrame_ResponseStatus>(enum_t_value));
}
bool ConnectionResponseFrame_ResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionResponseFrame_ResponseStatus* value);
enum PayloadTransferFrame_PayloadHeader_PayloadType : int {
  PayloadTransferFrame_PayloadHeader_PayloadType_UNKNOWN_PAYLOAD_TYPE = 0,
  PayloadTransferFrame_PayloadHeader_PayloadType_BYTES = 1,
  PayloadTransferFrame_PayloadHeader_PayloadType_FILE = 2,
  PayloadTransferFrame_PayloadHeader_PayloadType_STREAM = 3
};
bool PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(int value);
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MIN = PayloadTransferFrame_PayloadHeader_PayloadType_UNKNOWN_PAYLOAD_TYPE;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MAX = PayloadTransferFrame_PayloadHeader_PayloadType_STREAM;
constexpr int PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_ARRAYSIZE = PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MAX + 1;

const std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(PayloadTransferFrame_PayloadHeader_PayloadType value);
template<typename T>
inline const std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadTransferFrame_PayloadHeader_PayloadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadTransferFrame_PayloadHeader_PayloadType_Name.");
  return PayloadTransferFrame_PayloadHeader_PayloadType_Name(static_cast<PayloadTransferFrame_PayloadHeader_PayloadType>(enum_t_value));
}
bool PayloadTransferFrame_PayloadHeader_PayloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PayloadHeader_PayloadType* value);
enum PayloadTransferFrame_PayloadChunk_Flags : int {
  PayloadTransferFrame_PayloadChunk_Flags_LAST_CHUNK = 1
};
bool PayloadTransferFrame_PayloadChunk_Flags_IsValid(int value);
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk_Flags_Flags_MIN = PayloadTransferFrame_PayloadChunk_Flags_LAST_CHUNK;
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk_Flags_Flags_MAX = PayloadTransferFrame_PayloadChunk_Flags_LAST_CHUNK;
constexpr int PayloadTransferFrame_PayloadChunk_Flags_Flags_ARRAYSIZE = PayloadTransferFrame_PayloadChunk_Flags_Flags_MAX + 1;

const std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(PayloadTransferFrame_PayloadChunk_Flags value);
template<typename T>
inline const std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadTransferFrame_PayloadChunk_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadTransferFrame_PayloadChunk_Flags_Name.");
  return PayloadTransferFrame_PayloadChunk_Flags_Name(static_cast<PayloadTransferFrame_PayloadChunk_Flags>(enum_t_value));
}
bool PayloadTransferFrame_PayloadChunk_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PayloadChunk_Flags* value);
enum PayloadTransferFrame_ControlMessage_EventType : int {
  PayloadTransferFrame_ControlMessage_EventType_UNKNOWN_EVENT_TYPE = 0,
  PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_ERROR = 1,
  PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_CANCELED = 2,
  PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_RECEIVED_ACK = 3
};
bool PayloadTransferFrame_ControlMessage_EventType_IsValid(int value);
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage_EventType_EventType_MIN = PayloadTransferFrame_ControlMessage_EventType_UNKNOWN_EVENT_TYPE;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage_EventType_EventType_MAX = PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_RECEIVED_ACK;
constexpr int PayloadTransferFrame_ControlMessage_EventType_EventType_ARRAYSIZE = PayloadTransferFrame_ControlMessage_EventType_EventType_MAX + 1;

const std::string& PayloadTransferFrame_ControlMessage_EventType_Name(PayloadTransferFrame_ControlMessage_EventType value);
template<typename T>
inline const std::string& PayloadTransferFrame_ControlMessage_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadTransferFrame_ControlMessage_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadTransferFrame_ControlMessage_EventType_Name.");
  return PayloadTransferFrame_ControlMessage_EventType_Name(static_cast<PayloadTransferFrame_ControlMessage_EventType>(enum_t_value));
}
bool PayloadTransferFrame_ControlMessage_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_ControlMessage_EventType* value);
enum PayloadTransferFrame_PacketType : int {
  PayloadTransferFrame_PacketType_UNKNOWN_PACKET_TYPE = 0,
  PayloadTransferFrame_PacketType_DATA = 1,
  PayloadTransferFrame_PacketType_CONTROL = 2
};
bool PayloadTransferFrame_PacketType_IsValid(int value);
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame_PacketType_PacketType_MIN = PayloadTransferFrame_PacketType_UNKNOWN_PACKET_TYPE;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame_PacketType_PacketType_MAX = PayloadTransferFrame_PacketType_CONTROL;
constexpr int PayloadTransferFrame_PacketType_PacketType_ARRAYSIZE = PayloadTransferFrame_PacketType_PacketType_MAX + 1;

const std::string& PayloadTransferFrame_PacketType_Name(PayloadTransferFrame_PacketType value);
template<typename T>
inline const std::string& PayloadTransferFrame_PacketType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadTransferFrame_PacketType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadTransferFrame_PacketType_Name.");
  return PayloadTransferFrame_PacketType_Name(static_cast<PayloadTransferFrame_PacketType>(enum_t_value));
}
bool PayloadTransferFrame_PacketType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PacketType* value);
enum BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium : int {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_UNKNOWN_MEDIUM = 0,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_MDNS PROTOBUF_DEPRECATED_ENUM = 1,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLUETOOTH = 2,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_HOTSPOT = 3,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLE = 4,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_LAN = 5,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_AWARE = 6,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_NFC = 7,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_DIRECT = 8,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WEB_RTC = 9,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_USB = 11
};
bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(int value);
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MIN = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_UNKNOWN_MEDIUM;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MAX = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_USB;
constexpr int BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_ARRAYSIZE = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MAX + 1;

const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value);
template<typename T>
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name.");
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(enum_t_value));
}
bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium* value);
enum BandwidthUpgradeNegotiationFrame_EventType : int {
  BandwidthUpgradeNegotiationFrame_EventType_UNKNOWN_EVENT_TYPE = 0,
  BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_PATH_AVAILABLE = 1,
  BandwidthUpgradeNegotiationFrame_EventType_LAST_WRITE_TO_PRIOR_CHANNEL = 2,
  BandwidthUpgradeNegotiationFrame_EventType_SAFE_TO_CLOSE_PRIOR_CHANNEL = 3,
  BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION = 4,
  BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_FAILURE = 5,
  BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION_ACK = 6
};
bool BandwidthUpgradeNegotiationFrame_EventType_IsValid(int value);
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame_EventType_EventType_MIN = BandwidthUpgradeNegotiationFrame_EventType_UNKNOWN_EVENT_TYPE;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame_EventType_EventType_MAX = BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION_ACK;
constexpr int BandwidthUpgradeNegotiationFrame_EventType_EventType_ARRAYSIZE = BandwidthUpgradeNegotiationFrame_EventType_EventType_MAX + 1;

const std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(BandwidthUpgradeNegotiationFrame_EventType value);
template<typename T>
inline const std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BandwidthUpgradeNegotiationFrame_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BandwidthUpgradeNegotiationFrame_EventType_Name.");
  return BandwidthUpgradeNegotiationFrame_EventType_Name(static_cast<BandwidthUpgradeNegotiationFrame_EventType>(enum_t_value));
}
bool BandwidthUpgradeNegotiationFrame_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeNegotiationFrame_EventType* value);
enum AutoResumeFrame_EventType : int {
  AutoResumeFrame_EventType_UNKNOWN_AUTO_RESUME_EVENT_TYPE = 0,
  AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_START = 1,
  AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_ACK = 2
};
bool AutoResumeFrame_EventType_IsValid(int value);
constexpr AutoResumeFrame_EventType AutoResumeFrame_EventType_EventType_MIN = AutoResumeFrame_EventType_UNKNOWN_AUTO_RESUME_EVENT_TYPE;
constexpr AutoResumeFrame_EventType AutoResumeFrame_EventType_EventType_MAX = AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_ACK;
constexpr int AutoResumeFrame_EventType_EventType_ARRAYSIZE = AutoResumeFrame_EventType_EventType_MAX + 1;

const std::string& AutoResumeFrame_EventType_Name(AutoResumeFrame_EventType value);
template<typename T>
inline const std::string& AutoResumeFrame_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutoResumeFrame_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutoResumeFrame_EventType_Name.");
  return AutoResumeFrame_EventType_Name(static_cast<AutoResumeFrame_EventType>(enum_t_value));
}
bool AutoResumeFrame_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoResumeFrame_EventType* value);
enum AutoReconnectFrame_EventType : int {
  AutoReconnectFrame_EventType_UNKNOWN_EVENT_TYPE = 0,
  AutoReconnectFrame_EventType_CLIENT_INTRODUCTION = 1,
  AutoReconnectFrame_EventType_CLIENT_INTRODUCTION_ACK = 2
};
bool AutoReconnectFrame_EventType_IsValid(int value);
constexpr AutoReconnectFrame_EventType AutoReconnectFrame_EventType_EventType_MIN = AutoReconnectFrame_EventType_UNKNOWN_EVENT_TYPE;
constexpr AutoReconnectFrame_EventType AutoReconnectFrame_EventType_EventType_MAX = AutoReconnectFrame_EventType_CLIENT_INTRODUCTION_ACK;
constexpr int AutoReconnectFrame_EventType_EventType_ARRAYSIZE = AutoReconnectFrame_EventType_EventType_MAX + 1;

const std::string& AutoReconnectFrame_EventType_Name(AutoReconnectFrame_EventType value);
template<typename T>
inline const std::string& AutoReconnectFrame_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutoReconnectFrame_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutoReconnectFrame_EventType_Name.");
  return AutoReconnectFrame_EventType_Name(static_cast<AutoReconnectFrame_EventType>(enum_t_value));
}
bool AutoReconnectFrame_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoReconnectFrame_EventType* value);
enum LocationStandard_Format : int {
  LocationStandard_Format_UNKNOWN = 0,
  LocationStandard_Format_E164_CALLING = 1,
  LocationStandard_Format_ISO_3166_1_ALPHA_2 = 2
};
bool LocationStandard_Format_IsValid(int value);
constexpr LocationStandard_Format LocationStandard_Format_Format_MIN = LocationStandard_Format_UNKNOWN;
constexpr LocationStandard_Format LocationStandard_Format_Format_MAX = LocationStandard_Format_ISO_3166_1_ALPHA_2;
constexpr int LocationStandard_Format_Format_ARRAYSIZE = LocationStandard_Format_Format_MAX + 1;

const std::string& LocationStandard_Format_Name(LocationStandard_Format value);
template<typename T>
inline const std::string& LocationStandard_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocationStandard_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocationStandard_Format_Name.");
  return LocationStandard_Format_Name(static_cast<LocationStandard_Format>(enum_t_value));
}
bool LocationStandard_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocationStandard_Format* value);
enum OsInfo_OsType : int {
  OsInfo_OsType_UNKNOWN_OS_TYPE = 0,
  OsInfo_OsType_ANDROID = 1,
  OsInfo_OsType_CHROME_OS = 2,
  OsInfo_OsType_WINDOWS = 3,
  OsInfo_OsType_APPLE = 4,
  OsInfo_OsType_LINUX = 100
};
bool OsInfo_OsType_IsValid(int value);
constexpr OsInfo_OsType OsInfo_OsType_OsType_MIN = OsInfo_OsType_UNKNOWN_OS_TYPE;
constexpr OsInfo_OsType OsInfo_OsType_OsType_MAX = OsInfo_OsType_LINUX;
constexpr int OsInfo_OsType_OsType_ARRAYSIZE = OsInfo_OsType_OsType_MAX + 1;

const std::string& OsInfo_OsType_Name(OsInfo_OsType value);
template<typename T>
inline const std::string& OsInfo_OsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OsInfo_OsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OsInfo_OsType_Name.");
  return OsInfo_OsType_Name(static_cast<OsInfo_OsType>(enum_t_value));
}
bool OsInfo_OsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OsInfo_OsType* value);
enum PresenceDevice_DeviceType : int {
  PresenceDevice_DeviceType_UNKNOWN = 0,
  PresenceDevice_DeviceType_PHONE = 1,
  PresenceDevice_DeviceType_TABLET = 2,
  PresenceDevice_DeviceType_DISPLAY = 3,
  PresenceDevice_DeviceType_LAPTOP = 4,
  PresenceDevice_DeviceType_TV = 5,
  PresenceDevice_DeviceType_WATCH = 6
};
bool PresenceDevice_DeviceType_IsValid(int value);
constexpr PresenceDevice_DeviceType PresenceDevice_DeviceType_DeviceType_MIN = PresenceDevice_DeviceType_UNKNOWN;
constexpr PresenceDevice_DeviceType PresenceDevice_DeviceType_DeviceType_MAX = PresenceDevice_DeviceType_WATCH;
constexpr int PresenceDevice_DeviceType_DeviceType_ARRAYSIZE = PresenceDevice_DeviceType_DeviceType_MAX + 1;

const std::string& PresenceDevice_DeviceType_Name(PresenceDevice_DeviceType value);
template<typename T>
inline const std::string& PresenceDevice_DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PresenceDevice_DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PresenceDevice_DeviceType_Name.");
  return PresenceDevice_DeviceType_Name(static_cast<PresenceDevice_DeviceType>(enum_t_value));
}
bool PresenceDevice_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PresenceDevice_DeviceType* value);
enum EndpointType : int {
  UNKNOWN_ENDPOINT = 0,
  CONNECTIONS_ENDPOINT = 1,
  PRESENCE_ENDPOINT = 2
};
bool EndpointType_IsValid(int value);
constexpr EndpointType EndpointType_MIN = UNKNOWN_ENDPOINT;
constexpr EndpointType EndpointType_MAX = PRESENCE_ENDPOINT;
constexpr int EndpointType_ARRAYSIZE = EndpointType_MAX + 1;

const std::string& EndpointType_Name(EndpointType value);
template<typename T>
inline const std::string& EndpointType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EndpointType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EndpointType_Name.");
  return EndpointType_Name(static_cast<EndpointType>(enum_t_value));
}
bool EndpointType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EndpointType* value);
// ===================================================================

class OfflineFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.OfflineFrame) */ {
 public:
  inline OfflineFrame() : OfflineFrame(nullptr) {}
  ~OfflineFrame() override;
  explicit constexpr OfflineFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfflineFrame(const OfflineFrame& from);
  OfflineFrame(OfflineFrame&& from) noexcept
    : OfflineFrame() {
    *this = ::std::move(from);
  }

  inline OfflineFrame& operator=(const OfflineFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineFrame& operator=(OfflineFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OfflineFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineFrame* internal_default_instance() {
    return reinterpret_cast<const OfflineFrame*>(
               &_OfflineFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OfflineFrame& a, OfflineFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(OfflineFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfflineFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfflineFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OfflineFrame& from);
  void MergeFrom(const OfflineFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OfflineFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.OfflineFrame";
  }
  protected:
  explicit OfflineFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef OfflineFrame_Version Version;
  static constexpr Version UNKNOWN_VERSION =
    OfflineFrame_Version_UNKNOWN_VERSION;
  static constexpr Version V1 =
    OfflineFrame_Version_V1;
  static inline bool Version_IsValid(int value) {
    return OfflineFrame_Version_IsValid(value);
  }
  static constexpr Version Version_MIN =
    OfflineFrame_Version_Version_MIN;
  static constexpr Version Version_MAX =
    OfflineFrame_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE =
    OfflineFrame_Version_Version_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Version_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Version>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Version_Name.");
    return OfflineFrame_Version_Name(enum_t_value);
  }
  static inline bool Version_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Version* value) {
    return OfflineFrame_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // optional .location.nearby.connections.V1Frame v1 = 2;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::location::nearby::connections::V1Frame& v1() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::V1Frame* release_v1();
  ::location::nearby::connections::V1Frame* mutable_v1();
  void set_allocated_v1(::location::nearby::connections::V1Frame* v1);
  private:
  const ::location::nearby::connections::V1Frame& _internal_v1() const;
  ::location::nearby::connections::V1Frame* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::location::nearby::connections::V1Frame* v1);
  ::location::nearby::connections::V1Frame* unsafe_arena_release_v1();

  // optional .location.nearby.connections.OfflineFrame.Version version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::location::nearby::connections::OfflineFrame_Version version() const;
  void set_version(::location::nearby::connections::OfflineFrame_Version value);
  private:
  ::location::nearby::connections::OfflineFrame_Version _internal_version() const;
  void _internal_set_version(::location::nearby::connections::OfflineFrame_Version value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.OfflineFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::connections::V1Frame* v1_;
  int version_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class V1Frame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.V1Frame) */ {
 public:
  inline V1Frame() : V1Frame(nullptr) {}
  ~V1Frame() override;
  explicit constexpr V1Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V1Frame(const V1Frame& from);
  V1Frame(V1Frame&& from) noexcept
    : V1Frame() {
    *this = ::std::move(from);
  }

  inline V1Frame& operator=(const V1Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline V1Frame& operator=(V1Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V1Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const V1Frame* internal_default_instance() {
    return reinterpret_cast<const V1Frame*>(
               &_V1Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(V1Frame& a, V1Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(V1Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V1Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V1Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V1Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V1Frame& from);
  void MergeFrom(const V1Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V1Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.V1Frame";
  }
  protected:
  explicit V1Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef V1Frame_FrameType FrameType;
  static constexpr FrameType UNKNOWN_FRAME_TYPE =
    V1Frame_FrameType_UNKNOWN_FRAME_TYPE;
  static constexpr FrameType CONNECTION_REQUEST =
    V1Frame_FrameType_CONNECTION_REQUEST;
  static constexpr FrameType CONNECTION_RESPONSE =
    V1Frame_FrameType_CONNECTION_RESPONSE;
  static constexpr FrameType PAYLOAD_TRANSFER =
    V1Frame_FrameType_PAYLOAD_TRANSFER;
  static constexpr FrameType BANDWIDTH_UPGRADE_NEGOTIATION =
    V1Frame_FrameType_BANDWIDTH_UPGRADE_NEGOTIATION;
  static constexpr FrameType KEEP_ALIVE =
    V1Frame_FrameType_KEEP_ALIVE;
  static constexpr FrameType DISCONNECTION =
    V1Frame_FrameType_DISCONNECTION;
  static constexpr FrameType PAIRED_KEY_ENCRYPTION =
    V1Frame_FrameType_PAIRED_KEY_ENCRYPTION;
  static constexpr FrameType AUTHENTICATION_MESSAGE =
    V1Frame_FrameType_AUTHENTICATION_MESSAGE;
  static constexpr FrameType AUTHENTICATION_RESULT =
    V1Frame_FrameType_AUTHENTICATION_RESULT;
  static constexpr FrameType AUTO_RESUME =
    V1Frame_FrameType_AUTO_RESUME;
  static constexpr FrameType AUTO_RECONNECT =
    V1Frame_FrameType_AUTO_RECONNECT;
  static inline bool FrameType_IsValid(int value) {
    return V1Frame_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN =
    V1Frame_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX =
    V1Frame_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE =
    V1Frame_FrameType_FrameType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameType_Name.");
    return V1Frame_FrameType_Name(enum_t_value);
  }
  static inline bool FrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FrameType* value) {
    return V1Frame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionRequestFieldNumber = 2,
    kConnectionResponseFieldNumber = 3,
    kPayloadTransferFieldNumber = 4,
    kBandwidthUpgradeNegotiationFieldNumber = 5,
    kKeepAliveFieldNumber = 6,
    kDisconnectionFieldNumber = 7,
    kPairedKeyEncryptionFieldNumber = 8,
    kAuthenticationMessageFieldNumber = 9,
    kAuthenticationResultFieldNumber = 10,
    kAutoResumeFieldNumber = 11,
    kAutoReconnectFieldNumber = 12,
    kTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
  bool has_connection_request() const;
  private:
  bool _internal_has_connection_request() const;
  public:
  void clear_connection_request();
  const ::location::nearby::connections::ConnectionRequestFrame& connection_request() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::ConnectionRequestFrame* release_connection_request();
  ::location::nearby::connections::ConnectionRequestFrame* mutable_connection_request();
  void set_allocated_connection_request(::location::nearby::connections::ConnectionRequestFrame* connection_request);
  private:
  const ::location::nearby::connections::ConnectionRequestFrame& _internal_connection_request() const;
  ::location::nearby::connections::ConnectionRequestFrame* _internal_mutable_connection_request();
  public:
  void unsafe_arena_set_allocated_connection_request(
      ::location::nearby::connections::ConnectionRequestFrame* connection_request);
  ::location::nearby::connections::ConnectionRequestFrame* unsafe_arena_release_connection_request();

  // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
  bool has_connection_response() const;
  private:
  bool _internal_has_connection_response() const;
  public:
  void clear_connection_response();
  const ::location::nearby::connections::ConnectionResponseFrame& connection_response() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::ConnectionResponseFrame* release_connection_response();
  ::location::nearby::connections::ConnectionResponseFrame* mutable_connection_response();
  void set_allocated_connection_response(::location::nearby::connections::ConnectionResponseFrame* connection_response);
  private:
  const ::location::nearby::connections::ConnectionResponseFrame& _internal_connection_response() const;
  ::location::nearby::connections::ConnectionResponseFrame* _internal_mutable_connection_response();
  public:
  void unsafe_arena_set_allocated_connection_response(
      ::location::nearby::connections::ConnectionResponseFrame* connection_response);
  ::location::nearby::connections::ConnectionResponseFrame* unsafe_arena_release_connection_response();

  // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
  bool has_payload_transfer() const;
  private:
  bool _internal_has_payload_transfer() const;
  public:
  void clear_payload_transfer();
  const ::location::nearby::connections::PayloadTransferFrame& payload_transfer() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame* release_payload_transfer();
  ::location::nearby::connections::PayloadTransferFrame* mutable_payload_transfer();
  void set_allocated_payload_transfer(::location::nearby::connections::PayloadTransferFrame* payload_transfer);
  private:
  const ::location::nearby::connections::PayloadTransferFrame& _internal_payload_transfer() const;
  ::location::nearby::connections::PayloadTransferFrame* _internal_mutable_payload_transfer();
  public:
  void unsafe_arena_set_allocated_payload_transfer(
      ::location::nearby::connections::PayloadTransferFrame* payload_transfer);
  ::location::nearby::connections::PayloadTransferFrame* unsafe_arena_release_payload_transfer();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
  bool has_bandwidth_upgrade_negotiation() const;
  private:
  bool _internal_has_bandwidth_upgrade_negotiation() const;
  public:
  void clear_bandwidth_upgrade_negotiation();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& bandwidth_upgrade_negotiation() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* release_bandwidth_upgrade_negotiation();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* mutable_bandwidth_upgrade_negotiation();
  void set_allocated_bandwidth_upgrade_negotiation(::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& _internal_bandwidth_upgrade_negotiation() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* _internal_mutable_bandwidth_upgrade_negotiation();
  public:
  void unsafe_arena_set_allocated_bandwidth_upgrade_negotiation(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* unsafe_arena_release_bandwidth_upgrade_negotiation();

  // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
  bool has_keep_alive() const;
  private:
  bool _internal_has_keep_alive() const;
  public:
  void clear_keep_alive();
  const ::location::nearby::connections::KeepAliveFrame& keep_alive() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::KeepAliveFrame* release_keep_alive();
  ::location::nearby::connections::KeepAliveFrame* mutable_keep_alive();
  void set_allocated_keep_alive(::location::nearby::connections::KeepAliveFrame* keep_alive);
  private:
  const ::location::nearby::connections::KeepAliveFrame& _internal_keep_alive() const;
  ::location::nearby::connections::KeepAliveFrame* _internal_mutable_keep_alive();
  public:
  void unsafe_arena_set_allocated_keep_alive(
      ::location::nearby::connections::KeepAliveFrame* keep_alive);
  ::location::nearby::connections::KeepAliveFrame* unsafe_arena_release_keep_alive();

  // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
  bool has_disconnection() const;
  private:
  bool _internal_has_disconnection() const;
  public:
  void clear_disconnection();
  const ::location::nearby::connections::DisconnectionFrame& disconnection() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::DisconnectionFrame* release_disconnection();
  ::location::nearby::connections::DisconnectionFrame* mutable_disconnection();
  void set_allocated_disconnection(::location::nearby::connections::DisconnectionFrame* disconnection);
  private:
  const ::location::nearby::connections::DisconnectionFrame& _internal_disconnection() const;
  ::location::nearby::connections::DisconnectionFrame* _internal_mutable_disconnection();
  public:
  void unsafe_arena_set_allocated_disconnection(
      ::location::nearby::connections::DisconnectionFrame* disconnection);
  ::location::nearby::connections::DisconnectionFrame* unsafe_arena_release_disconnection();

  // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
  bool has_paired_key_encryption() const;
  private:
  bool _internal_has_paired_key_encryption() const;
  public:
  void clear_paired_key_encryption();
  const ::location::nearby::connections::PairedKeyEncryptionFrame& paired_key_encryption() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PairedKeyEncryptionFrame* release_paired_key_encryption();
  ::location::nearby::connections::PairedKeyEncryptionFrame* mutable_paired_key_encryption();
  void set_allocated_paired_key_encryption(::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption);
  private:
  const ::location::nearby::connections::PairedKeyEncryptionFrame& _internal_paired_key_encryption() const;
  ::location::nearby::connections::PairedKeyEncryptionFrame* _internal_mutable_paired_key_encryption();
  public:
  void unsafe_arena_set_allocated_paired_key_encryption(
      ::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption);
  ::location::nearby::connections::PairedKeyEncryptionFrame* unsafe_arena_release_paired_key_encryption();

  // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
  bool has_authentication_message() const;
  private:
  bool _internal_has_authentication_message() const;
  public:
  void clear_authentication_message();
  const ::location::nearby::connections::AuthenticationMessageFrame& authentication_message() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AuthenticationMessageFrame* release_authentication_message();
  ::location::nearby::connections::AuthenticationMessageFrame* mutable_authentication_message();
  void set_allocated_authentication_message(::location::nearby::connections::AuthenticationMessageFrame* authentication_message);
  private:
  const ::location::nearby::connections::AuthenticationMessageFrame& _internal_authentication_message() const;
  ::location::nearby::connections::AuthenticationMessageFrame* _internal_mutable_authentication_message();
  public:
  void unsafe_arena_set_allocated_authentication_message(
      ::location::nearby::connections::AuthenticationMessageFrame* authentication_message);
  ::location::nearby::connections::AuthenticationMessageFrame* unsafe_arena_release_authentication_message();

  // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
  bool has_authentication_result() const;
  private:
  bool _internal_has_authentication_result() const;
  public:
  void clear_authentication_result();
  const ::location::nearby::connections::AuthenticationResultFrame& authentication_result() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AuthenticationResultFrame* release_authentication_result();
  ::location::nearby::connections::AuthenticationResultFrame* mutable_authentication_result();
  void set_allocated_authentication_result(::location::nearby::connections::AuthenticationResultFrame* authentication_result);
  private:
  const ::location::nearby::connections::AuthenticationResultFrame& _internal_authentication_result() const;
  ::location::nearby::connections::AuthenticationResultFrame* _internal_mutable_authentication_result();
  public:
  void unsafe_arena_set_allocated_authentication_result(
      ::location::nearby::connections::AuthenticationResultFrame* authentication_result);
  ::location::nearby::connections::AuthenticationResultFrame* unsafe_arena_release_authentication_result();

  // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
  bool has_auto_resume() const;
  private:
  bool _internal_has_auto_resume() const;
  public:
  void clear_auto_resume();
  const ::location::nearby::connections::AutoResumeFrame& auto_resume() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AutoResumeFrame* release_auto_resume();
  ::location::nearby::connections::AutoResumeFrame* mutable_auto_resume();
  void set_allocated_auto_resume(::location::nearby::connections::AutoResumeFrame* auto_resume);
  private:
  const ::location::nearby::connections::AutoResumeFrame& _internal_auto_resume() const;
  ::location::nearby::connections::AutoResumeFrame* _internal_mutable_auto_resume();
  public:
  void unsafe_arena_set_allocated_auto_resume(
      ::location::nearby::connections::AutoResumeFrame* auto_resume);
  ::location::nearby::connections::AutoResumeFrame* unsafe_arena_release_auto_resume();

  // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
  bool has_auto_reconnect() const;
  private:
  bool _internal_has_auto_reconnect() const;
  public:
  void clear_auto_reconnect();
  const ::location::nearby::connections::AutoReconnectFrame& auto_reconnect() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AutoReconnectFrame* release_auto_reconnect();
  ::location::nearby::connections::AutoReconnectFrame* mutable_auto_reconnect();
  void set_allocated_auto_reconnect(::location::nearby::connections::AutoReconnectFrame* auto_reconnect);
  private:
  const ::location::nearby::connections::AutoReconnectFrame& _internal_auto_reconnect() const;
  ::location::nearby::connections::AutoReconnectFrame* _internal_mutable_auto_reconnect();
  public:
  void unsafe_arena_set_allocated_auto_reconnect(
      ::location::nearby::connections::AutoReconnectFrame* auto_reconnect);
  ::location::nearby::connections::AutoReconnectFrame* unsafe_arena_release_auto_reconnect();

  // optional .location.nearby.connections.V1Frame.FrameType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::location::nearby::connections::V1Frame_FrameType type() const;
  void set_type(::location::nearby::connections::V1Frame_FrameType value);
  private:
  ::location::nearby::connections::V1Frame_FrameType _internal_type() const;
  void _internal_set_type(::location::nearby::connections::V1Frame_FrameType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.V1Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::connections::ConnectionRequestFrame* connection_request_;
  ::location::nearby::connections::ConnectionResponseFrame* connection_response_;
  ::location::nearby::connections::PayloadTransferFrame* payload_transfer_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation_;
  ::location::nearby::connections::KeepAliveFrame* keep_alive_;
  ::location::nearby::connections::DisconnectionFrame* disconnection_;
  ::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption_;
  ::location::nearby::connections::AuthenticationMessageFrame* authentication_message_;
  ::location::nearby::connections::AuthenticationResultFrame* authentication_result_;
  ::location::nearby::connections::AutoResumeFrame* auto_resume_;
  ::location::nearby::connections::AutoReconnectFrame* auto_reconnect_;
  int type_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class ConnectionRequestFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.ConnectionRequestFrame) */ {
 public:
  inline ConnectionRequestFrame() : ConnectionRequestFrame(nullptr) {}
  ~ConnectionRequestFrame() override;
  explicit constexpr ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionRequestFrame(const ConnectionRequestFrame& from);
  ConnectionRequestFrame(ConnectionRequestFrame&& from) noexcept
    : ConnectionRequestFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionRequestFrame& operator=(const ConnectionRequestFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionRequestFrame& operator=(ConnectionRequestFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionRequestFrame& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceCase {
    kConnectionsDevice = 12,
    kPresenceDevice = 13,
    DEVICE_NOT_SET = 0,
  };

  static inline const ConnectionRequestFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionRequestFrame*>(
               &_ConnectionRequestFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConnectionRequestFrame& a, ConnectionRequestFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionRequestFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionRequestFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionRequestFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionRequestFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionRequestFrame& from);
  void MergeFrom(const ConnectionRequestFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionRequestFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.ConnectionRequestFrame";
  }
  protected:
  explicit ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionRequestFrame_Medium Medium;
  static constexpr Medium UNKNOWN_MEDIUM =
    ConnectionRequestFrame_Medium_UNKNOWN_MEDIUM;
  PROTOBUF_DEPRECATED_ENUM static constexpr Medium MDNS =
    ConnectionRequestFrame_Medium_MDNS;
  static constexpr Medium BLUETOOTH =
    ConnectionRequestFrame_Medium_BLUETOOTH;
  static constexpr Medium WIFI_HOTSPOT =
    ConnectionRequestFrame_Medium_WIFI_HOTSPOT;
  static constexpr Medium BLE =
    ConnectionRequestFrame_Medium_BLE;
  static constexpr Medium WIFI_LAN =
    ConnectionRequestFrame_Medium_WIFI_LAN;
  static constexpr Medium WIFI_AWARE =
    ConnectionRequestFrame_Medium_WIFI_AWARE;
  static constexpr Medium NFC =
    ConnectionRequestFrame_Medium_NFC;
  static constexpr Medium WIFI_DIRECT =
    ConnectionRequestFrame_Medium_WIFI_DIRECT;
  static constexpr Medium WEB_RTC =
    ConnectionRequestFrame_Medium_WEB_RTC;
  static constexpr Medium BLE_L2CAP =
    ConnectionRequestFrame_Medium_BLE_L2CAP;
  static constexpr Medium USB =
    ConnectionRequestFrame_Medium_USB;
  static inline bool Medium_IsValid(int value) {
    return ConnectionRequestFrame_Medium_IsValid(value);
  }
  static constexpr Medium Medium_MIN =
    ConnectionRequestFrame_Medium_Medium_MIN;
  static constexpr Medium Medium_MAX =
    ConnectionRequestFrame_Medium_Medium_MAX;
  static constexpr int Medium_ARRAYSIZE =
    ConnectionRequestFrame_Medium_Medium_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Medium_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Medium>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Medium_Name.");
    return ConnectionRequestFrame_Medium_Name(enum_t_value);
  }
  static inline bool Medium_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Medium* value) {
    return ConnectionRequestFrame_Medium_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMediumsFieldNumber = 5,
    kEndpointIdFieldNumber = 1,
    kEndpointNameFieldNumber = 2,
    kHandshakeDataFieldNumber = 3,
    kEndpointInfoFieldNumber = 6,
    kDeviceInfoFieldNumber = 11,
    kMediumMetadataFieldNumber = 7,
    kNonceFieldNumber = 4,
    kKeepAliveIntervalMillisFieldNumber = 8,
    kKeepAliveTimeoutMillisFieldNumber = 9,
    kDeviceTypeFieldNumber = 10,
    kConnectionsDeviceFieldNumber = 12,
    kPresenceDeviceFieldNumber = 13,
  };
  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
  int mediums_size() const;
  private:
  int _internal_mediums_size() const;
  public:
  void clear_mediums();
  private:
  ::location::nearby::connections::ConnectionRequestFrame_Medium _internal_mediums(int index) const;
  void _internal_add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_mediums();
  public:
  ::location::nearby::connections::ConnectionRequestFrame_Medium mediums(int index) const;
  void set_mediums(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value);
  void add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& mediums() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_mediums();

  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  private:
  bool _internal_has_endpoint_id() const;
  public:
  void clear_endpoint_id();
  const std::string& endpoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* endpoint_id);
  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(const std::string& value);
  std::string* _internal_mutable_endpoint_id();
  public:

  // optional string endpoint_name = 2;
  bool has_endpoint_name() const;
  private:
  bool _internal_has_endpoint_name() const;
  public:
  void clear_endpoint_name();
  const std::string& endpoint_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_name();
  PROTOBUF_NODISCARD std::string* release_endpoint_name();
  void set_allocated_endpoint_name(std::string* endpoint_name);
  private:
  const std::string& _internal_endpoint_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_name(const std::string& value);
  std::string* _internal_mutable_endpoint_name();
  public:

  // optional bytes handshake_data = 3;
  bool has_handshake_data() const;
  private:
  bool _internal_has_handshake_data() const;
  public:
  void clear_handshake_data();
  const std::string& handshake_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handshake_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handshake_data();
  PROTOBUF_NODISCARD std::string* release_handshake_data();
  void set_allocated_handshake_data(std::string* handshake_data);
  private:
  const std::string& _internal_handshake_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handshake_data(const std::string& value);
  std::string* _internal_mutable_handshake_data();
  public:

  // optional bytes endpoint_info = 6;
  bool has_endpoint_info() const;
  private:
  bool _internal_has_endpoint_info() const;
  public:
  void clear_endpoint_info();
  const std::string& endpoint_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_info();
  PROTOBUF_NODISCARD std::string* release_endpoint_info();
  void set_allocated_endpoint_info(std::string* endpoint_info);
  private:
  const std::string& _internal_endpoint_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_info(const std::string& value);
  std::string* _internal_mutable_endpoint_info();
  public:

  // optional bytes device_info = 11 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_device_info() const;
  private:
  bool _internal_has_device_info() const;
  public:
  PROTOBUF_DEPRECATED void clear_device_info();
  PROTOBUF_DEPRECATED const std::string& device_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_device_info(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_device_info();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_device_info();
  PROTOBUF_DEPRECATED void set_allocated_device_info(std::string* device_info);
  private:
  const std::string& _internal_device_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_info(const std::string& value);
  std::string* _internal_mutable_device_info();
  public:

  // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
  bool has_medium_metadata() const;
  private:
  bool _internal_has_medium_metadata() const;
  public:
  void clear_medium_metadata();
  const ::location::nearby::connections::MediumMetadata& medium_metadata() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::MediumMetadata* release_medium_metadata();
  ::location::nearby::connections::MediumMetadata* mutable_medium_metadata();
  void set_allocated_medium_metadata(::location::nearby::connections::MediumMetadata* medium_metadata);
  private:
  const ::location::nearby::connections::MediumMetadata& _internal_medium_metadata() const;
  ::location::nearby::connections::MediumMetadata* _internal_mutable_medium_metadata();
  public:
  void unsafe_arena_set_allocated_medium_metadata(
      ::location::nearby::connections::MediumMetadata* medium_metadata);
  ::location::nearby::connections::MediumMetadata* unsafe_arena_release_medium_metadata();

  // optional int32 nonce = 4;
  bool has_nonce() const;
  private:
  bool _internal_has_nonce() const;
  public:
  void clear_nonce();
  int32_t nonce() const;
  void set_nonce(int32_t value);
  private:
  int32_t _internal_nonce() const;
  void _internal_set_nonce(int32_t value);
  public:

  // optional int32 keep_alive_interval_millis = 8;
  bool has_keep_alive_interval_millis() const;
  private:
  bool _internal_has_keep_alive_interval_millis() const;
  public:
  void clear_keep_alive_interval_millis();
  int32_t keep_alive_interval_millis() const;
  void set_keep_alive_interval_millis(int32_t value);
  private:
  int32_t _internal_keep_alive_interval_millis() const;
  void _internal_set_keep_alive_interval_millis(int32_t value);
  public:

  // optional int32 keep_alive_timeout_millis = 9;
  bool has_keep_alive_timeout_millis() const;
  private:
  bool _internal_has_keep_alive_timeout_millis() const;
  public:
  void clear_keep_alive_timeout_millis();
  int32_t keep_alive_timeout_millis() const;
  void set_keep_alive_timeout_millis(int32_t value);
  private:
  int32_t _internal_keep_alive_timeout_millis() const;
  void _internal_set_keep_alive_timeout_millis(int32_t value);
  public:

  // optional int32 device_type = 10 [default = 0, deprecated = true];
  PROTOBUF_DEPRECATED bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  PROTOBUF_DEPRECATED void clear_device_type();
  PROTOBUF_DEPRECATED int32_t device_type() const;
  PROTOBUF_DEPRECATED void set_device_type(int32_t value);
  private:
  int32_t _internal_device_type() const;
  void _internal_set_device_type(int32_t value);
  public:

  // .location.nearby.connections.ConnectionsDevice connections_device = 12;
  bool has_connections_device() const;
  private:
  bool _internal_has_connections_device() const;
  public:
  void clear_connections_device();
  const ::location::nearby::connections::ConnectionsDevice& connections_device() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::ConnectionsDevice* release_connections_device();
  ::location::nearby::connections::ConnectionsDevice* mutable_connections_device();
  void set_allocated_connections_device(::location::nearby::connections::ConnectionsDevice* connections_device);
  private:
  const ::location::nearby::connections::ConnectionsDevice& _internal_connections_device() const;
  ::location::nearby::connections::ConnectionsDevice* _internal_mutable_connections_device();
  public:
  void unsafe_arena_set_allocated_connections_device(
      ::location::nearby::connections::ConnectionsDevice* connections_device);
  ::location::nearby::connections::ConnectionsDevice* unsafe_arena_release_connections_device();

  // .location.nearby.connections.PresenceDevice presence_device = 13;
  bool has_presence_device() const;
  private:
  bool _internal_has_presence_device() const;
  public:
  void clear_presence_device();
  const ::location::nearby::connections::PresenceDevice& presence_device() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PresenceDevice* release_presence_device();
  ::location::nearby::connections::PresenceDevice* mutable_presence_device();
  void set_allocated_presence_device(::location::nearby::connections::PresenceDevice* presence_device);
  private:
  const ::location::nearby::connections::PresenceDevice& _internal_presence_device() const;
  ::location::nearby::connections::PresenceDevice* _internal_mutable_presence_device();
  public:
  void unsafe_arena_set_allocated_presence_device(
      ::location::nearby::connections::PresenceDevice* presence_device);
  ::location::nearby::connections::PresenceDevice* unsafe_arena_release_presence_device();

  void clear_Device();
  DeviceCase Device_case() const;
  // @@protoc_insertion_point(class_scope:location.nearby.connections.ConnectionRequestFrame)
 private:
  class _Internal;
  void set_has_connections_device();
  void set_has_presence_device();

  inline bool has_Device() const;
  inline void clear_has_Device();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> mediums_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handshake_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_info_;
  ::location::nearby::connections::MediumMetadata* medium_metadata_;
  int32_t nonce_;
  int32_t keep_alive_interval_millis_;
  int32_t keep_alive_timeout_millis_;
  int32_t device_type_;
  union DeviceUnion {
    constexpr DeviceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::location::nearby::connections::ConnectionsDevice* connections_device_;
    ::location::nearby::connections::PresenceDevice* presence_device_;
  } Device_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class ConnectionResponseFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.ConnectionResponseFrame) */ {
 public:
  inline ConnectionResponseFrame() : ConnectionResponseFrame(nullptr) {}
  ~ConnectionResponseFrame() override;
  explicit constexpr ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionResponseFrame(const ConnectionResponseFrame& from);
  ConnectionResponseFrame(ConnectionResponseFrame&& from) noexcept
    : ConnectionResponseFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionResponseFrame& operator=(const ConnectionResponseFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionResponseFrame& operator=(ConnectionResponseFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionResponseFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionResponseFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionResponseFrame*>(
               &_ConnectionResponseFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConnectionResponseFrame& a, ConnectionResponseFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionResponseFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionResponseFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionResponseFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionResponseFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionResponseFrame& from);
  void MergeFrom(const ConnectionResponseFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionResponseFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.ConnectionResponseFrame";
  }
  protected:
  explicit ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionResponseFrame_ResponseStatus ResponseStatus;
  static constexpr ResponseStatus UNKNOWN_RESPONSE_STATUS =
    ConnectionResponseFrame_ResponseStatus_UNKNOWN_RESPONSE_STATUS;
  static constexpr ResponseStatus ACCEPT =
    ConnectionResponseFrame_ResponseStatus_ACCEPT;
  static constexpr ResponseStatus REJECT =
    ConnectionResponseFrame_ResponseStatus_REJECT;
  static inline bool ResponseStatus_IsValid(int value) {
    return ConnectionResponseFrame_ResponseStatus_IsValid(value);
  }
  static constexpr ResponseStatus ResponseStatus_MIN =
    ConnectionResponseFrame_ResponseStatus_ResponseStatus_MIN;
  static constexpr ResponseStatus ResponseStatus_MAX =
    ConnectionResponseFrame_ResponseStatus_ResponseStatus_MAX;
  static constexpr int ResponseStatus_ARRAYSIZE =
    ConnectionResponseFrame_ResponseStatus_ResponseStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResponseStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseStatus_Name.");
    return ConnectionResponseFrame_ResponseStatus_Name(enum_t_value);
  }
  static inline bool ResponseStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResponseStatus* value) {
    return ConnectionResponseFrame_ResponseStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHandshakeDataFieldNumber = 2,
    kOsInfoFieldNumber = 4,
    kStatusFieldNumber = 1,
    kResponseFieldNumber = 3,
    kMultiplexSocketBitmaskFieldNumber = 5,
    kNearbyConnectionsVersionFieldNumber = 6,
    kSafeToDisconnectVersionFieldNumber = 7,
  };
  // optional bytes handshake_data = 2;
  bool has_handshake_data() const;
  private:
  bool _internal_has_handshake_data() const;
  public:
  void clear_handshake_data();
  const std::string& handshake_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handshake_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handshake_data();
  PROTOBUF_NODISCARD std::string* release_handshake_data();
  void set_allocated_handshake_data(std::string* handshake_data);
  private:
  const std::string& _internal_handshake_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handshake_data(const std::string& value);
  std::string* _internal_mutable_handshake_data();
  public:

  // optional .location.nearby.connections.OsInfo os_info = 4;
  bool has_os_info() const;
  private:
  bool _internal_has_os_info() const;
  public:
  void clear_os_info();
  const ::location::nearby::connections::OsInfo& os_info() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::OsInfo* release_os_info();
  ::location::nearby::connections::OsInfo* mutable_os_info();
  void set_allocated_os_info(::location::nearby::connections::OsInfo* os_info);
  private:
  const ::location::nearby::connections::OsInfo& _internal_os_info() const;
  ::location::nearby::connections::OsInfo* _internal_mutable_os_info();
  public:
  void unsafe_arena_set_allocated_os_info(
      ::location::nearby::connections::OsInfo* os_info);
  ::location::nearby::connections::OsInfo* unsafe_arena_release_os_info();

  // optional int32 status = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  PROTOBUF_DEPRECATED void clear_status();
  PROTOBUF_DEPRECATED int32_t status() const;
  PROTOBUF_DEPRECATED void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus response() const;
  void set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value);
  private:
  ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus _internal_response() const;
  void _internal_set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value);
  public:

  // optional int32 multiplex_socket_bitmask = 5;
  bool has_multiplex_socket_bitmask() const;
  private:
  bool _internal_has_multiplex_socket_bitmask() const;
  public:
  void clear_multiplex_socket_bitmask();
  int32_t multiplex_socket_bitmask() const;
  void set_multiplex_socket_bitmask(int32_t value);
  private:
  int32_t _internal_multiplex_socket_bitmask() const;
  void _internal_set_multiplex_socket_bitmask(int32_t value);
  public:

  // optional int32 nearby_connections_version = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_nearby_connections_version() const;
  private:
  bool _internal_has_nearby_connections_version() const;
  public:
  PROTOBUF_DEPRECATED void clear_nearby_connections_version();
  PROTOBUF_DEPRECATED int32_t nearby_connections_version() const;
  PROTOBUF_DEPRECATED void set_nearby_connections_version(int32_t value);
  private:
  int32_t _internal_nearby_connections_version() const;
  void _internal_set_nearby_connections_version(int32_t value);
  public:

  // optional int32 safe_to_disconnect_version = 7;
  bool has_safe_to_disconnect_version() const;
  private:
  bool _internal_has_safe_to_disconnect_version() const;
  public:
  void clear_safe_to_disconnect_version();
  int32_t safe_to_disconnect_version() const;
  void set_safe_to_disconnect_version(int32_t value);
  private:
  int32_t _internal_safe_to_disconnect_version() const;
  void _internal_set_safe_to_disconnect_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.ConnectionResponseFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handshake_data_;
  ::location::nearby::connections::OsInfo* os_info_;
  int32_t status_;
  int response_;
  int32_t multiplex_socket_bitmask_;
  int32_t nearby_connections_version_;
  int32_t safe_to_disconnect_version_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class PayloadTransferFrame_PayloadHeader final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame.PayloadHeader) */ {
 public:
  inline PayloadTransferFrame_PayloadHeader() : PayloadTransferFrame_PayloadHeader(nullptr) {}
  ~PayloadTransferFrame_PayloadHeader() override;
  explicit constexpr PayloadTransferFrame_PayloadHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame_PayloadHeader(const PayloadTransferFrame_PayloadHeader& from);
  PayloadTransferFrame_PayloadHeader(PayloadTransferFrame_PayloadHeader&& from) noexcept
    : PayloadTransferFrame_PayloadHeader() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame_PayloadHeader& operator=(const PayloadTransferFrame_PayloadHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame_PayloadHeader& operator=(PayloadTransferFrame_PayloadHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame_PayloadHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame_PayloadHeader* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame_PayloadHeader*>(
               &_PayloadTransferFrame_PayloadHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PayloadTransferFrame_PayloadHeader& a, PayloadTransferFrame_PayloadHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame_PayloadHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame_PayloadHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame_PayloadHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame_PayloadHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame_PayloadHeader& from);
  void MergeFrom(const PayloadTransferFrame_PayloadHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame_PayloadHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame.PayloadHeader";
  }
  protected:
  explicit PayloadTransferFrame_PayloadHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PayloadTransferFrame_PayloadHeader_PayloadType PayloadType;
  static constexpr PayloadType UNKNOWN_PAYLOAD_TYPE =
    PayloadTransferFrame_PayloadHeader_PayloadType_UNKNOWN_PAYLOAD_TYPE;
  static constexpr PayloadType BYTES =
    PayloadTransferFrame_PayloadHeader_PayloadType_BYTES;
  static constexpr PayloadType FILE =
    PayloadTransferFrame_PayloadHeader_PayloadType_FILE;
  static constexpr PayloadType STREAM =
    PayloadTransferFrame_PayloadHeader_PayloadType_STREAM;
  static inline bool PayloadType_IsValid(int value) {
    return PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(value);
  }
  static constexpr PayloadType PayloadType_MIN =
    PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MIN;
  static constexpr PayloadType PayloadType_MAX =
    PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MAX;
  static constexpr int PayloadType_ARRAYSIZE =
    PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PayloadType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PayloadType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PayloadType_Name.");
    return PayloadTransferFrame_PayloadHeader_PayloadType_Name(enum_t_value);
  }
  static inline bool PayloadType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PayloadType* value) {
    return PayloadTransferFrame_PayloadHeader_PayloadType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 5,
    kParentFolderFieldNumber = 6,
    kIdFieldNumber = 1,
    kTotalSizeFieldNumber = 3,
    kTypeFieldNumber = 2,
    kIsSensitiveFieldNumber = 4,
  };
  // optional string file_name = 5;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // optional string parent_folder = 6;
  bool has_parent_folder() const;
  private:
  bool _internal_has_parent_folder() const;
  public:
  void clear_parent_folder();
  const std::string& parent_folder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_folder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_folder();
  PROTOBUF_NODISCARD std::string* release_parent_folder();
  void set_allocated_parent_folder(std::string* parent_folder);
  private:
  const std::string& _internal_parent_folder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_folder(const std::string& value);
  std::string* _internal_mutable_parent_folder();
  public:

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // optional int64 total_size = 3;
  bool has_total_size() const;
  private:
  bool _internal_has_total_size() const;
  public:
  void clear_total_size();
  int64_t total_size() const;
  void set_total_size(int64_t value);
  private:
  int64_t _internal_total_size() const;
  void _internal_set_total_size(int64_t value);
  public:

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType type() const;
  void set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value);
  private:
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType _internal_type() const;
  void _internal_set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value);
  public:

  // optional bool is_sensitive = 4;
  bool has_is_sensitive() const;
  private:
  bool _internal_has_is_sensitive() const;
  public:
  void clear_is_sensitive();
  bool is_sensitive() const;
  void set_is_sensitive(bool value);
  private:
  bool _internal_is_sensitive() const;
  void _internal_set_is_sensitive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_folder_;
  int64_t id_;
  int64_t total_size_;
  int type_;
  bool is_sensitive_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class PayloadTransferFrame_PayloadChunk final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame.PayloadChunk) */ {
 public:
  inline PayloadTransferFrame_PayloadChunk() : PayloadTransferFrame_PayloadChunk(nullptr) {}
  ~PayloadTransferFrame_PayloadChunk() override;
  explicit constexpr PayloadTransferFrame_PayloadChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame_PayloadChunk(const PayloadTransferFrame_PayloadChunk& from);
  PayloadTransferFrame_PayloadChunk(PayloadTransferFrame_PayloadChunk&& from) noexcept
    : PayloadTransferFrame_PayloadChunk() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame_PayloadChunk& operator=(const PayloadTransferFrame_PayloadChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame_PayloadChunk& operator=(PayloadTransferFrame_PayloadChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame_PayloadChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame_PayloadChunk* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame_PayloadChunk*>(
               &_PayloadTransferFrame_PayloadChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PayloadTransferFrame_PayloadChunk& a, PayloadTransferFrame_PayloadChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame_PayloadChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame_PayloadChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame_PayloadChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame_PayloadChunk>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame_PayloadChunk& from);
  void MergeFrom(const PayloadTransferFrame_PayloadChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame_PayloadChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame.PayloadChunk";
  }
  protected:
  explicit PayloadTransferFrame_PayloadChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PayloadTransferFrame_PayloadChunk_Flags Flags;
  static constexpr Flags LAST_CHUNK =
    PayloadTransferFrame_PayloadChunk_Flags_LAST_CHUNK;
  static inline bool Flags_IsValid(int value) {
    return PayloadTransferFrame_PayloadChunk_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    PayloadTransferFrame_PayloadChunk_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    PayloadTransferFrame_PayloadChunk_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    PayloadTransferFrame_PayloadChunk_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return PayloadTransferFrame_PayloadChunk_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return PayloadTransferFrame_PayloadChunk_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 3,
    kOffsetFieldNumber = 2,
    kFlagsFieldNumber = 1,
    kIndexFieldNumber = 4,
  };
  // optional bytes body = 3;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // optional int64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // optional int32 flags = 1;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // optional int32 index = 4;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  int64_t offset_;
  int32_t flags_;
  int32_t index_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class PayloadTransferFrame_ControlMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame.ControlMessage) */ {
 public:
  inline PayloadTransferFrame_ControlMessage() : PayloadTransferFrame_ControlMessage(nullptr) {}
  ~PayloadTransferFrame_ControlMessage() override;
  explicit constexpr PayloadTransferFrame_ControlMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame_ControlMessage(const PayloadTransferFrame_ControlMessage& from);
  PayloadTransferFrame_ControlMessage(PayloadTransferFrame_ControlMessage&& from) noexcept
    : PayloadTransferFrame_ControlMessage() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame_ControlMessage& operator=(const PayloadTransferFrame_ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame_ControlMessage& operator=(PayloadTransferFrame_ControlMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame_ControlMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame_ControlMessage* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame_ControlMessage*>(
               &_PayloadTransferFrame_ControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PayloadTransferFrame_ControlMessage& a, PayloadTransferFrame_ControlMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame_ControlMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame_ControlMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame_ControlMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame_ControlMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame_ControlMessage& from);
  void MergeFrom(const PayloadTransferFrame_ControlMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame_ControlMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame.ControlMessage";
  }
  protected:
  explicit PayloadTransferFrame_ControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PayloadTransferFrame_ControlMessage_EventType EventType;
  static constexpr EventType UNKNOWN_EVENT_TYPE =
    PayloadTransferFrame_ControlMessage_EventType_UNKNOWN_EVENT_TYPE;
  static constexpr EventType PAYLOAD_ERROR =
    PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_ERROR;
  static constexpr EventType PAYLOAD_CANCELED =
    PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_CANCELED;
  static constexpr EventType PAYLOAD_RECEIVED_ACK =
    PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_RECEIVED_ACK;
  static inline bool EventType_IsValid(int value) {
    return PayloadTransferFrame_ControlMessage_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    PayloadTransferFrame_ControlMessage_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    PayloadTransferFrame_ControlMessage_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    PayloadTransferFrame_ControlMessage_EventType_EventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return PayloadTransferFrame_ControlMessage_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return PayloadTransferFrame_ControlMessage_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 2,
    kEventFieldNumber = 1,
  };
  // optional int64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType event() const;
  void set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value);
  private:
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType _internal_event() const;
  void _internal_set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame.ControlMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t offset_;
  int event_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class PayloadTransferFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame) */ {
 public:
  inline PayloadTransferFrame() : PayloadTransferFrame(nullptr) {}
  ~PayloadTransferFrame() override;
  explicit constexpr PayloadTransferFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame(const PayloadTransferFrame& from);
  PayloadTransferFrame(PayloadTransferFrame&& from) noexcept
    : PayloadTransferFrame() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame& operator=(const PayloadTransferFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame& operator=(PayloadTransferFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame*>(
               &_PayloadTransferFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PayloadTransferFrame& a, PayloadTransferFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame& from);
  void MergeFrom(const PayloadTransferFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame";
  }
  protected:
  explicit PayloadTransferFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PayloadTransferFrame_PayloadHeader PayloadHeader;
  typedef PayloadTransferFrame_PayloadChunk PayloadChunk;
  typedef PayloadTransferFrame_ControlMessage ControlMessage;

  typedef PayloadTransferFrame_PacketType PacketType;
  static constexpr PacketType UNKNOWN_PACKET_TYPE =
    PayloadTransferFrame_PacketType_UNKNOWN_PACKET_TYPE;
  static constexpr PacketType DATA =
    PayloadTransferFrame_PacketType_DATA;
  static constexpr PacketType CONTROL =
    PayloadTransferFrame_PacketType_CONTROL;
  static inline bool PacketType_IsValid(int value) {
    return PayloadTransferFrame_PacketType_IsValid(value);
  }
  static constexpr PacketType PacketType_MIN =
    PayloadTransferFrame_PacketType_PacketType_MIN;
  static constexpr PacketType PacketType_MAX =
    PayloadTransferFrame_PacketType_PacketType_MAX;
  static constexpr int PacketType_ARRAYSIZE =
    PayloadTransferFrame_PacketType_PacketType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PacketType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PacketType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PacketType_Name.");
    return PayloadTransferFrame_PacketType_Name(enum_t_value);
  }
  static inline bool PacketType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PacketType* value) {
    return PayloadTransferFrame_PacketType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadHeaderFieldNumber = 2,
    kPayloadChunkFieldNumber = 3,
    kControlMessageFieldNumber = 4,
    kPacketTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
  bool has_payload_header() const;
  private:
  bool _internal_has_payload_header() const;
  public:
  void clear_payload_header();
  const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& payload_header() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* release_payload_header();
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* mutable_payload_header();
  void set_allocated_payload_header(::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header);
  private:
  const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& _internal_payload_header() const;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* _internal_mutable_payload_header();
  public:
  void unsafe_arena_set_allocated_payload_header(
      ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header);
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* unsafe_arena_release_payload_header();

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
  bool has_payload_chunk() const;
  private:
  bool _internal_has_payload_chunk() const;
  public:
  void clear_payload_chunk();
  const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& payload_chunk() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* release_payload_chunk();
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* mutable_payload_chunk();
  void set_allocated_payload_chunk(::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk);
  private:
  const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& _internal_payload_chunk() const;
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* _internal_mutable_payload_chunk();
  public:
  void unsafe_arena_set_allocated_payload_chunk(
      ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk);
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* unsafe_arena_release_payload_chunk();

  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
  bool has_control_message() const;
  private:
  bool _internal_has_control_message() const;
  public:
  void clear_control_message();
  const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& control_message() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame_ControlMessage* release_control_message();
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* mutable_control_message();
  void set_allocated_control_message(::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message);
  private:
  const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& _internal_control_message() const;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* _internal_mutable_control_message();
  public:
  void unsafe_arena_set_allocated_control_message(
      ::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message);
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* unsafe_arena_release_control_message();

  // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
  bool has_packet_type() const;
  private:
  bool _internal_has_packet_type() const;
  public:
  void clear_packet_type();
  ::location::nearby::connections::PayloadTransferFrame_PacketType packet_type() const;
  void set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value);
  private:
  ::location::nearby::connections::PayloadTransferFrame_PacketType _internal_packet_type() const;
  void _internal_set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header_;
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk_;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message_;
  int packet_type_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kGatewayFieldNumber = 4,
    kPortFieldNumber = 3,
    kFrequencyFieldNumber = 5,
  };
  // optional string ssid = 1;
  bool has_ssid() const;
  private:
  bool _internal_has_ssid() const;
  public:
  void clear_ssid();
  const std::string& ssid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ssid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ssid();
  PROTOBUF_NODISCARD std::string* release_ssid();
  void set_allocated_ssid(std::string* ssid);
  private:
  const std::string& _internal_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssid(const std::string& value);
  std::string* _internal_mutable_ssid();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string gateway = 4 [default = "0.0.0.0"];
  bool has_gateway() const;
  private:
  bool _internal_has_gateway() const;
  public:
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // optional int32 port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // optional int32 frequency = 5 [default = -1];
  bool has_frequency() const;
  private:
  bool _internal_has_frequency() const;
  public:
  void clear_frequency();
  int32_t frequency() const;
  void set_frequency(int32_t value);
  private:
  int32_t _internal_frequency() const;
  void _internal_set_frequency(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_gateway_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
  int32_t port_;
  int32_t frequency_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 1,
    kWifiPortFieldNumber = 2,
  };
  // optional bytes ip_address = 1;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // optional int32 wifi_port = 2;
  bool has_wifi_port() const;
  private:
  bool _internal_has_wifi_port() const;
  public:
  void clear_wifi_port();
  int32_t wifi_port() const;
  void set_wifi_port(int32_t value);
  private:
  int32_t _internal_wifi_port() const;
  void _internal_set_wifi_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  int32_t wifi_port_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kMacAddressFieldNumber = 2,
  };
  // optional string service_name = 1;
  bool has_service_name() const;
  private:
  bool _internal_has_service_name() const;
  public:
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // optional string mac_address = 2;
  bool has_mac_address() const;
  private:
  bool _internal_has_mac_address() const;
  public:
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdFieldNumber = 1,
    kServiceInfoFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // optional string service_id = 1;
  bool has_service_id() const;
  private:
  bool _internal_has_service_id() const;
  public:
  void clear_service_id();
  const std::string& service_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_id();
  PROTOBUF_NODISCARD std::string* release_service_id();
  void set_allocated_service_id(std::string* service_id);
  private:
  const std::string& _internal_service_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_id(const std::string& value);
  std::string* _internal_mutable_service_id();
  public:

  // optional bytes service_info = 2;
  bool has_service_info() const;
  private:
  bool _internal_has_service_info() const;
  public:
  void clear_service_info();
  const std::string& service_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_info();
  PROTOBUF_NODISCARD std::string* release_service_info();
  void set_allocated_service_info(std::string* service_info);
  private:
  const std::string& _internal_service_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_info(const std::string& value);
  std::string* _internal_mutable_service_info();
  public:

  // optional string password = 3;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kGatewayFieldNumber = 5,
    kIpV6AddressFieldNumber = 6,
    kPortFieldNumber = 3,
    kFrequencyFieldNumber = 4,
  };
  // optional string ssid = 1;
  bool has_ssid() const;
  private:
  bool _internal_has_ssid() const;
  public:
  void clear_ssid();
  const std::string& ssid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ssid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ssid();
  PROTOBUF_NODISCARD std::string* release_ssid();
  void set_allocated_ssid(std::string* ssid);
  private:
  const std::string& _internal_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssid(const std::string& value);
  std::string* _internal_mutable_ssid();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string gateway = 5 [default = "0.0.0.0"];
  bool has_gateway() const;
  private:
  bool _internal_has_gateway() const;
  public:
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // optional bytes ip_v6_address = 6;
  bool has_ip_v6_address() const;
  private:
  bool _internal_has_ip_v6_address() const;
  public:
  void clear_ip_v6_address();
  const std::string& ip_v6_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_v6_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_v6_address();
  PROTOBUF_NODISCARD std::string* release_ip_v6_address();
  void set_allocated_ip_v6_address(std::string* ip_v6_address);
  private:
  const std::string& _internal_ip_v6_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_v6_address(const std::string& value);
  std::string* _internal_mutable_ip_v6_address();
  public:

  // optional int32 port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // optional int32 frequency = 4;
  bool has_frequency() const;
  private:
  bool _internal_has_frequency() const;
  public:
  void clear_frequency();
  int32_t frequency() const;
  void set_frequency(int32_t value);
  private:
  int32_t _internal_frequency() const;
  void _internal_set_frequency(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_gateway_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_v6_address_;
  int32_t port_;
  int32_t frequency_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kLocationHintFieldNumber = 2,
  };
  // optional string peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const std::string& peer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_id();
  PROTOBUF_NODISCARD std::string* release_peer_id();
  void set_allocated_peer_id(std::string* peer_id);
  private:
  const std::string& _internal_peer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_id(const std::string& value);
  std::string* _internal_mutable_peer_id();
  public:

  // optional .location.nearby.connections.LocationHint location_hint = 2;
  bool has_location_hint() const;
  private:
  bool _internal_has_location_hint() const;
  public:
  void clear_location_hint();
  const ::location::nearby::connections::LocationHint& location_hint() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::LocationHint* release_location_hint();
  ::location::nearby::connections::LocationHint* mutable_location_hint();
  void set_allocated_location_hint(::location::nearby::connections::LocationHint* location_hint);
  private:
  const ::location::nearby::connections::LocationHint& _internal_location_hint() const;
  ::location::nearby::connections::LocationHint* _internal_mutable_location_hint();
  public:
  void unsafe_arena_set_allocated_location_hint(
      ::location::nearby::connections::LocationHint* location_hint);
  ::location::nearby::connections::LocationHint* unsafe_arena_release_location_hint();

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_id_;
  ::location::nearby::connections::LocationHint* location_hint_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo(BandwidthUpgradeNegotiationFrame_UpgradePathInfo&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials WifiHotspotCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket WifiLanSocket;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials BluetoothCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials WifiAwareCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials WifiDirectCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials WebRtcCredentials;

  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium Medium;
  static constexpr Medium UNKNOWN_MEDIUM =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_UNKNOWN_MEDIUM;
  PROTOBUF_DEPRECATED_ENUM static constexpr Medium MDNS =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_MDNS;
  static constexpr Medium BLUETOOTH =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLUETOOTH;
  static constexpr Medium WIFI_HOTSPOT =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_HOTSPOT;
  static constexpr Medium BLE =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLE;
  static constexpr Medium WIFI_LAN =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_LAN;
  static constexpr Medium WIFI_AWARE =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_AWARE;
  static constexpr Medium NFC =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_NFC;
  static constexpr Medium WIFI_DIRECT =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_DIRECT;
  static constexpr Medium WEB_RTC =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WEB_RTC;
  static constexpr Medium USB =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_USB;
  static inline bool Medium_IsValid(int value) {
    return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(value);
  }
  static constexpr Medium Medium_MIN =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MIN;
  static constexpr Medium Medium_MAX =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MAX;
  static constexpr int Medium_ARRAYSIZE =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Medium_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Medium>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Medium_Name.");
    return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(enum_t_value);
  }
  static inline bool Medium_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Medium* value) {
    return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWifiHotspotCredentialsFieldNumber = 2,
    kWifiLanSocketFieldNumber = 3,
    kBluetoothCredentialsFieldNumber = 4,
    kWifiAwareCredentialsFieldNumber = 5,
    kWifiDirectCredentialsFieldNumber = 6,
    kWebRtcCredentialsFieldNumber = 8,
    kMediumFieldNumber = 1,
    kSupportsDisablingEncryptionFieldNumber = 7,
    kSupportsClientIntroductionAckFieldNumber = 9,
  };
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
  bool has_wifi_hotspot_credentials() const;
  private:
  bool _internal_has_wifi_hotspot_credentials() const;
  public:
  void clear_wifi_hotspot_credentials();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& wifi_hotspot_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* release_wifi_hotspot_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* mutable_wifi_hotspot_credentials();
  void set_allocated_wifi_hotspot_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& _internal_wifi_hotspot_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* _internal_mutable_wifi_hotspot_credentials();
  public:
  void unsafe_arena_set_allocated_wifi_hotspot_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* unsafe_arena_release_wifi_hotspot_credentials();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
  bool has_wifi_lan_socket() const;
  private:
  bool _internal_has_wifi_lan_socket() const;
  public:
  void clear_wifi_lan_socket();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& wifi_lan_socket() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* release_wifi_lan_socket();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* mutable_wifi_lan_socket();
  void set_allocated_wifi_lan_socket(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& _internal_wifi_lan_socket() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* _internal_mutable_wifi_lan_socket();
  public:
  void unsafe_arena_set_allocated_wifi_lan_socket(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* unsafe_arena_release_wifi_lan_socket();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
  bool has_bluetooth_credentials() const;
  private:
  bool _internal_has_bluetooth_credentials() const;
  public:
  void clear_bluetooth_credentials();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& bluetooth_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* release_bluetooth_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* mutable_bluetooth_credentials();
  void set_allocated_bluetooth_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& _internal_bluetooth_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* _internal_mutable_bluetooth_credentials();
  public:
  void unsafe_arena_set_allocated_bluetooth_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* unsafe_arena_release_bluetooth_credentials();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
  bool has_wifi_aware_credentials() const;
  private:
  bool _internal_has_wifi_aware_credentials() const;
  public:
  void clear_wifi_aware_credentials();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& wifi_aware_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* release_wifi_aware_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* mutable_wifi_aware_credentials();
  void set_allocated_wifi_aware_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& _internal_wifi_aware_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* _internal_mutable_wifi_aware_credentials();
  public:
  void unsafe_arena_set_allocated_wifi_aware_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* unsafe_arena_release_wifi_aware_credentials();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
  bool has_wifi_direct_credentials() const;
  private:
  bool _internal_has_wifi_direct_credentials() const;
  public:
  void clear_wifi_direct_credentials();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& wifi_direct_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* release_wifi_direct_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* mutable_wifi_direct_credentials();
  void set_allocated_wifi_direct_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& _internal_wifi_direct_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* _internal_mutable_wifi_direct_credentials();
  public:
  void unsafe_arena_set_allocated_wifi_direct_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* unsafe_arena_release_wifi_direct_credentials();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
  bool has_web_rtc_credentials() const;
  private:
  bool _internal_has_web_rtc_credentials() const;
  public:
  void clear_web_rtc_credentials();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& web_rtc_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* release_web_rtc_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* mutable_web_rtc_credentials();
  void set_allocated_web_rtc_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& _internal_web_rtc_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* _internal_mutable_web_rtc_credentials();
  public:
  void unsafe_arena_set_allocated_web_rtc_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* unsafe_arena_release_web_rtc_credentials();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
  bool has_medium() const;
  private:
  bool _internal_has_medium() const;
  public:
  void clear_medium();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium medium() const;
  void set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value);
  private:
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium _internal_medium() const;
  void _internal_set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value);
  public:

  // optional bool supports_disabling_encryption = 7;
  bool has_supports_disabling_encryption() const;
  private:
  bool _internal_has_supports_disabling_encryption() const;
  public:
  void clear_supports_disabling_encryption();
  bool supports_disabling_encryption() const;
  void set_supports_disabling_encryption(bool value);
  private:
  bool _internal_supports_disabling_encryption() const;
  void _internal_set_supports_disabling_encryption(bool value);
  public:

  // optional bool supports_client_introduction_ack = 9;
  bool has_supports_client_introduction_ack() const;
  private:
  bool _internal_has_supports_client_introduction_ack() const;
  public:
  void clear_supports_client_introduction_ack();
  bool supports_client_introduction_ack() const;
  void set_supports_client_introduction_ack(bool value);
  private:
  bool _internal_supports_client_introduction_ack() const;
  void _internal_set_supports_client_introduction_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials_;
  int medium_;
  bool supports_disabling_encryption_;
  bool supports_client_introduction_ack_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_ClientIntroduction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_ClientIntroduction() : BandwidthUpgradeNegotiationFrame_ClientIntroduction(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroduction() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_ClientIntroduction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_ClientIntroduction(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from);
  BandwidthUpgradeNegotiationFrame_ClientIntroduction(BandwidthUpgradeNegotiationFrame_ClientIntroduction&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_ClientIntroduction() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_ClientIntroduction& operator=(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_ClientIntroduction& operator=(BandwidthUpgradeNegotiationFrame_ClientIntroduction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_ClientIntroduction& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_ClientIntroduction* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroduction*>(
               &_BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BandwidthUpgradeNegotiationFrame_ClientIntroduction& a, BandwidthUpgradeNegotiationFrame_ClientIntroduction& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_ClientIntroduction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_ClientIntroduction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_ClientIntroduction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointIdFieldNumber = 1,
    kSupportsDisablingEncryptionFieldNumber = 2,
  };
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  private:
  bool _internal_has_endpoint_id() const;
  public:
  void clear_endpoint_id();
  const std::string& endpoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* endpoint_id);
  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(const std::string& value);
  std::string* _internal_mutable_endpoint_id();
  public:

  // optional bool supports_disabling_encryption = 2;
  bool has_supports_disabling_encryption() const;
  private:
  bool _internal_has_supports_disabling_encryption() const;
  public:
  void clear_supports_disabling_encryption();
  bool supports_disabling_encryption() const;
  void set_supports_disabling_encryption(bool value);
  private:
  bool _internal_supports_disabling_encryption() const;
  void _internal_set_supports_disabling_encryption(bool value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
  bool supports_disabling_encryption_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_ClientIntroductionAck final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() : BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from);
  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& operator=(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& operator=(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck*>(
               &_BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& a, BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame() : BandwidthUpgradeNegotiationFrame(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame() override;
  explicit constexpr BandwidthUpgradeNegotiationFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame(const BandwidthUpgradeNegotiationFrame& from);
  BandwidthUpgradeNegotiationFrame(BandwidthUpgradeNegotiationFrame&& from) noexcept
    : BandwidthUpgradeNegotiationFrame() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame& operator=(const BandwidthUpgradeNegotiationFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame& operator=(BandwidthUpgradeNegotiationFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame*>(
               &_BandwidthUpgradeNegotiationFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BandwidthUpgradeNegotiationFrame& a, BandwidthUpgradeNegotiationFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo UpgradePathInfo;
  typedef BandwidthUpgradeNegotiationFrame_ClientIntroduction ClientIntroduction;
  typedef BandwidthUpgradeNegotiationFrame_ClientIntroductionAck ClientIntroductionAck;

  typedef BandwidthUpgradeNegotiationFrame_EventType EventType;
  static constexpr EventType UNKNOWN_EVENT_TYPE =
    BandwidthUpgradeNegotiationFrame_EventType_UNKNOWN_EVENT_TYPE;
  static constexpr EventType UPGRADE_PATH_AVAILABLE =
    BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_PATH_AVAILABLE;
  static constexpr EventType LAST_WRITE_TO_PRIOR_CHANNEL =
    BandwidthUpgradeNegotiationFrame_EventType_LAST_WRITE_TO_PRIOR_CHANNEL;
  static constexpr EventType SAFE_TO_CLOSE_PRIOR_CHANNEL =
    BandwidthUpgradeNegotiationFrame_EventType_SAFE_TO_CLOSE_PRIOR_CHANNEL;
  static constexpr EventType CLIENT_INTRODUCTION =
    BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION;
  static constexpr EventType UPGRADE_FAILURE =
    BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_FAILURE;
  static constexpr EventType CLIENT_INTRODUCTION_ACK =
    BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION_ACK;
  static inline bool EventType_IsValid(int value) {
    return BandwidthUpgradeNegotiationFrame_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    BandwidthUpgradeNegotiationFrame_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    BandwidthUpgradeNegotiationFrame_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    BandwidthUpgradeNegotiationFrame_EventType_EventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return BandwidthUpgradeNegotiationFrame_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return BandwidthUpgradeNegotiationFrame_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUpgradePathInfoFieldNumber = 2,
    kClientIntroductionFieldNumber = 3,
    kClientIntroductionAckFieldNumber = 4,
    kEventTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
  bool has_upgrade_path_info() const;
  private:
  bool _internal_has_upgrade_path_info() const;
  public:
  void clear_upgrade_path_info();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& upgrade_path_info() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* release_upgrade_path_info();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* mutable_upgrade_path_info();
  void set_allocated_upgrade_path_info(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& _internal_upgrade_path_info() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* _internal_mutable_upgrade_path_info();
  public:
  void unsafe_arena_set_allocated_upgrade_path_info(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* unsafe_arena_release_upgrade_path_info();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
  bool has_client_introduction() const;
  private:
  bool _internal_has_client_introduction() const;
  public:
  void clear_client_introduction();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& client_introduction() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* release_client_introduction();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* mutable_client_introduction();
  void set_allocated_client_introduction(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& _internal_client_introduction() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* _internal_mutable_client_introduction();
  public:
  void unsafe_arena_set_allocated_client_introduction(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* unsafe_arena_release_client_introduction();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
  bool has_client_introduction_ack() const;
  private:
  bool _internal_has_client_introduction_ack() const;
  public:
  void clear_client_introduction_ack();
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& client_introduction_ack() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* release_client_introduction_ack();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* mutable_client_introduction_ack();
  void set_allocated_client_introduction_ack(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& _internal_client_introduction_ack() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* _internal_mutable_client_introduction_ack();
  public:
  void unsafe_arena_set_allocated_client_introduction_ack(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* unsafe_arena_release_client_introduction_ack();

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType event_type() const;
  void set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value);
  private:
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType _internal_event_type() const;
  void _internal_set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction_;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack_;
  int event_type_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class KeepAliveFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.KeepAliveFrame) */ {
 public:
  inline KeepAliveFrame() : KeepAliveFrame(nullptr) {}
  ~KeepAliveFrame() override;
  explicit constexpr KeepAliveFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeepAliveFrame(const KeepAliveFrame& from);
  KeepAliveFrame(KeepAliveFrame&& from) noexcept
    : KeepAliveFrame() {
    *this = ::std::move(from);
  }

  inline KeepAliveFrame& operator=(const KeepAliveFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAliveFrame& operator=(KeepAliveFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeepAliveFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeepAliveFrame* internal_default_instance() {
    return reinterpret_cast<const KeepAliveFrame*>(
               &_KeepAliveFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(KeepAliveFrame& a, KeepAliveFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepAliveFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepAliveFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeepAliveFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeepAliveFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeepAliveFrame& from);
  void MergeFrom(const KeepAliveFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeepAliveFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.KeepAliveFrame";
  }
  protected:
  explicit KeepAliveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
    kSeqNumFieldNumber = 2,
  };
  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // optional uint32 seq_num = 2;
  bool has_seq_num() const;
  private:
  bool _internal_has_seq_num() const;
  public:
  void clear_seq_num();
  uint32_t seq_num() const;
  void set_seq_num(uint32_t value);
  private:
  uint32_t _internal_seq_num() const;
  void _internal_set_seq_num(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.KeepAliveFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool ack_;
  uint32_t seq_num_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class DisconnectionFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.DisconnectionFrame) */ {
 public:
  inline DisconnectionFrame() : DisconnectionFrame(nullptr) {}
  ~DisconnectionFrame() override;
  explicit constexpr DisconnectionFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectionFrame(const DisconnectionFrame& from);
  DisconnectionFrame(DisconnectionFrame&& from) noexcept
    : DisconnectionFrame() {
    *this = ::std::move(from);
  }

  inline DisconnectionFrame& operator=(const DisconnectionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectionFrame& operator=(DisconnectionFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisconnectionFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectionFrame* internal_default_instance() {
    return reinterpret_cast<const DisconnectionFrame*>(
               &_DisconnectionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DisconnectionFrame& a, DisconnectionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectionFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectionFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisconnectionFrame& from);
  void MergeFrom(const DisconnectionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisconnectionFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.DisconnectionFrame";
  }
  protected:
  explicit DisconnectionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestSafeToDisconnectFieldNumber = 1,
    kAckSafeToDisconnectFieldNumber = 2,
  };
  // optional bool request_safe_to_disconnect = 1;
  bool has_request_safe_to_disconnect() const;
  private:
  bool _internal_has_request_safe_to_disconnect() const;
  public:
  void clear_request_safe_to_disconnect();
  bool request_safe_to_disconnect() const;
  void set_request_safe_to_disconnect(bool value);
  private:
  bool _internal_request_safe_to_disconnect() const;
  void _internal_set_request_safe_to_disconnect(bool value);
  public:

  // optional bool ack_safe_to_disconnect = 2;
  bool has_ack_safe_to_disconnect() const;
  private:
  bool _internal_has_ack_safe_to_disconnect() const;
  public:
  void clear_ack_safe_to_disconnect();
  bool ack_safe_to_disconnect() const;
  void set_ack_safe_to_disconnect(bool value);
  private:
  bool _internal_ack_safe_to_disconnect() const;
  void _internal_set_ack_safe_to_disconnect(bool value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.DisconnectionFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool request_safe_to_disconnect_;
  bool ack_safe_to_disconnect_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class PairedKeyEncryptionFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PairedKeyEncryptionFrame) */ {
 public:
  inline PairedKeyEncryptionFrame() : PairedKeyEncryptionFrame(nullptr) {}
  ~PairedKeyEncryptionFrame() override;
  explicit constexpr PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from);
  PairedKeyEncryptionFrame(PairedKeyEncryptionFrame&& from) noexcept
    : PairedKeyEncryptionFrame() {
    *this = ::std::move(from);
  }

  inline PairedKeyEncryptionFrame& operator=(const PairedKeyEncryptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairedKeyEncryptionFrame& operator=(PairedKeyEncryptionFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PairedKeyEncryptionFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const PairedKeyEncryptionFrame* internal_default_instance() {
    return reinterpret_cast<const PairedKeyEncryptionFrame*>(
               &_PairedKeyEncryptionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PairedKeyEncryptionFrame& a, PairedKeyEncryptionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PairedKeyEncryptionFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PairedKeyEncryptionFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PairedKeyEncryptionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PairedKeyEncryptionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PairedKeyEncryptionFrame& from);
  void MergeFrom(const PairedKeyEncryptionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairedKeyEncryptionFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.PairedKeyEncryptionFrame";
  }
  protected:
  explicit PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedDataFieldNumber = 1,
  };
  // optional bytes signed_data = 1;
  bool has_signed_data() const;
  private:
  bool _internal_has_signed_data() const;
  public:
  void clear_signed_data();
  const std::string& signed_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signed_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signed_data();
  PROTOBUF_NODISCARD std::string* release_signed_data();
  void set_allocated_signed_data(std::string* signed_data);
  private:
  const std::string& _internal_signed_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signed_data(const std::string& value);
  std::string* _internal_mutable_signed_data();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.PairedKeyEncryptionFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_data_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class AuthenticationMessageFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AuthenticationMessageFrame) */ {
 public:
  inline AuthenticationMessageFrame() : AuthenticationMessageFrame(nullptr) {}
  ~AuthenticationMessageFrame() override;
  explicit constexpr AuthenticationMessageFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationMessageFrame(const AuthenticationMessageFrame& from);
  AuthenticationMessageFrame(AuthenticationMessageFrame&& from) noexcept
    : AuthenticationMessageFrame() {
    *this = ::std::move(from);
  }

  inline AuthenticationMessageFrame& operator=(const AuthenticationMessageFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationMessageFrame& operator=(AuthenticationMessageFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthenticationMessageFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationMessageFrame* internal_default_instance() {
    return reinterpret_cast<const AuthenticationMessageFrame*>(
               &_AuthenticationMessageFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AuthenticationMessageFrame& a, AuthenticationMessageFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationMessageFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationMessageFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticationMessageFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticationMessageFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthenticationMessageFrame& from);
  void MergeFrom(const AuthenticationMessageFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticationMessageFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.AuthenticationMessageFrame";
  }
  protected:
  explicit AuthenticationMessageFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthMessageFieldNumber = 1,
  };
  // optional bytes auth_message = 1;
  bool has_auth_message() const;
  private:
  bool _internal_has_auth_message() const;
  public:
  void clear_auth_message();
  const std::string& auth_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_message();
  PROTOBUF_NODISCARD std::string* release_auth_message();
  void set_allocated_auth_message(std::string* auth_message);
  private:
  const std::string& _internal_auth_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_message(const std::string& value);
  std::string* _internal_mutable_auth_message();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.AuthenticationMessageFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_message_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class AuthenticationResultFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AuthenticationResultFrame) */ {
 public:
  inline AuthenticationResultFrame() : AuthenticationResultFrame(nullptr) {}
  ~AuthenticationResultFrame() override;
  explicit constexpr AuthenticationResultFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationResultFrame(const AuthenticationResultFrame& from);
  AuthenticationResultFrame(AuthenticationResultFrame&& from) noexcept
    : AuthenticationResultFrame() {
    *this = ::std::move(from);
  }

  inline AuthenticationResultFrame& operator=(const AuthenticationResultFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationResultFrame& operator=(AuthenticationResultFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthenticationResultFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationResultFrame* internal_default_instance() {
    return reinterpret_cast<const AuthenticationResultFrame*>(
               &_AuthenticationResultFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AuthenticationResultFrame& a, AuthenticationResultFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationResultFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationResultFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticationResultFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticationResultFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthenticationResultFrame& from);
  void MergeFrom(const AuthenticationResultFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticationResultFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.AuthenticationResultFrame";
  }
  protected:
  explicit AuthenticationResultFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.AuthenticationResultFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t result_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class AutoResumeFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AutoResumeFrame) */ {
 public:
  inline AutoResumeFrame() : AutoResumeFrame(nullptr) {}
  ~AutoResumeFrame() override;
  explicit constexpr AutoResumeFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoResumeFrame(const AutoResumeFrame& from);
  AutoResumeFrame(AutoResumeFrame&& from) noexcept
    : AutoResumeFrame() {
    *this = ::std::move(from);
  }

  inline AutoResumeFrame& operator=(const AutoResumeFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoResumeFrame& operator=(AutoResumeFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutoResumeFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoResumeFrame* internal_default_instance() {
    return reinterpret_cast<const AutoResumeFrame*>(
               &_AutoResumeFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AutoResumeFrame& a, AutoResumeFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoResumeFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoResumeFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoResumeFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoResumeFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutoResumeFrame& from);
  void MergeFrom(const AutoResumeFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutoResumeFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.AutoResumeFrame";
  }
  protected:
  explicit AutoResumeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutoResumeFrame_EventType EventType;
  static constexpr EventType UNKNOWN_AUTO_RESUME_EVENT_TYPE =
    AutoResumeFrame_EventType_UNKNOWN_AUTO_RESUME_EVENT_TYPE;
  static constexpr EventType PAYLOAD_RESUME_TRANSFER_START =
    AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_START;
  static constexpr EventType PAYLOAD_RESUME_TRANSFER_ACK =
    AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_ACK;
  static inline bool EventType_IsValid(int value) {
    return AutoResumeFrame_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    AutoResumeFrame_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    AutoResumeFrame_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    AutoResumeFrame_EventType_EventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return AutoResumeFrame_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return AutoResumeFrame_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPendingPayloadIdFieldNumber = 2,
    kEventTypeFieldNumber = 1,
    kNextPayloadChunkIndexFieldNumber = 3,
  };
  // optional int64 pending_payload_id = 2;
  bool has_pending_payload_id() const;
  private:
  bool _internal_has_pending_payload_id() const;
  public:
  void clear_pending_payload_id();
  int64_t pending_payload_id() const;
  void set_pending_payload_id(int64_t value);
  private:
  int64_t _internal_pending_payload_id() const;
  void _internal_set_pending_payload_id(int64_t value);
  public:

  // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  ::location::nearby::connections::AutoResumeFrame_EventType event_type() const;
  void set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value);
  private:
  ::location::nearby::connections::AutoResumeFrame_EventType _internal_event_type() const;
  void _internal_set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value);
  public:

  // optional int32 next_payload_chunk_index = 3;
  bool has_next_payload_chunk_index() const;
  private:
  bool _internal_has_next_payload_chunk_index() const;
  public:
  void clear_next_payload_chunk_index();
  int32_t next_payload_chunk_index() const;
  void set_next_payload_chunk_index(int32_t value);
  private:
  int32_t _internal_next_payload_chunk_index() const;
  void _internal_set_next_payload_chunk_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.AutoResumeFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t pending_payload_id_;
  int event_type_;
  int32_t next_payload_chunk_index_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class AutoReconnectFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AutoReconnectFrame) */ {
 public:
  inline AutoReconnectFrame() : AutoReconnectFrame(nullptr) {}
  ~AutoReconnectFrame() override;
  explicit constexpr AutoReconnectFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoReconnectFrame(const AutoReconnectFrame& from);
  AutoReconnectFrame(AutoReconnectFrame&& from) noexcept
    : AutoReconnectFrame() {
    *this = ::std::move(from);
  }

  inline AutoReconnectFrame& operator=(const AutoReconnectFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoReconnectFrame& operator=(AutoReconnectFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutoReconnectFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoReconnectFrame* internal_default_instance() {
    return reinterpret_cast<const AutoReconnectFrame*>(
               &_AutoReconnectFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AutoReconnectFrame& a, AutoReconnectFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoReconnectFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoReconnectFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoReconnectFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoReconnectFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutoReconnectFrame& from);
  void MergeFrom(const AutoReconnectFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutoReconnectFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.AutoReconnectFrame";
  }
  protected:
  explicit AutoReconnectFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutoReconnectFrame_EventType EventType;
  static constexpr EventType UNKNOWN_EVENT_TYPE =
    AutoReconnectFrame_EventType_UNKNOWN_EVENT_TYPE;
  static constexpr EventType CLIENT_INTRODUCTION =
    AutoReconnectFrame_EventType_CLIENT_INTRODUCTION;
  static constexpr EventType CLIENT_INTRODUCTION_ACK =
    AutoReconnectFrame_EventType_CLIENT_INTRODUCTION_ACK;
  static inline bool EventType_IsValid(int value) {
    return AutoReconnectFrame_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    AutoReconnectFrame_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    AutoReconnectFrame_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    AutoReconnectFrame_EventType_EventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return AutoReconnectFrame_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return AutoReconnectFrame_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
  };
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  private:
  bool _internal_has_endpoint_id() const;
  public:
  void clear_endpoint_id();
  const std::string& endpoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* endpoint_id);
  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(const std::string& value);
  std::string* _internal_mutable_endpoint_id();
  public:

  // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  ::location::nearby::connections::AutoReconnectFrame_EventType event_type() const;
  void set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value);
  private:
  ::location::nearby::connections::AutoReconnectFrame_EventType _internal_event_type() const;
  void _internal_set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.AutoReconnectFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
  int event_type_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class MediumMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.MediumMetadata) */ {
 public:
  inline MediumMetadata() : MediumMetadata(nullptr) {}
  ~MediumMetadata() override;
  explicit constexpr MediumMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediumMetadata(const MediumMetadata& from);
  MediumMetadata(MediumMetadata&& from) noexcept
    : MediumMetadata() {
    *this = ::std::move(from);
  }

  inline MediumMetadata& operator=(const MediumMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediumMetadata& operator=(MediumMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MediumMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediumMetadata* internal_default_instance() {
    return reinterpret_cast<const MediumMetadata*>(
               &_MediumMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MediumMetadata& a, MediumMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MediumMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediumMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediumMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediumMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MediumMetadata& from);
  void MergeFrom(const MediumMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MediumMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.MediumMetadata";
  }
  protected:
  explicit MediumMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBssidFieldNumber = 2,
    kIpAddressFieldNumber = 3,
    kAvailableChannelsFieldNumber = 7,
    kWifiDirectCliUsableChannelsFieldNumber = 8,
    kWifiLanUsableChannelsFieldNumber = 9,
    kWifiAwareUsableChannelsFieldNumber = 10,
    kWifiHotspotStaUsableChannelsFieldNumber = 11,
    kSupports5GhzFieldNumber = 1,
    kSupports6GhzFieldNumber = 4,
    kMobileRadioFieldNumber = 5,
    kApFrequencyFieldNumber = 6,
  };
  // optional string bssid = 2;
  bool has_bssid() const;
  private:
  bool _internal_has_bssid() const;
  public:
  void clear_bssid();
  const std::string& bssid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bssid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bssid();
  PROTOBUF_NODISCARD std::string* release_bssid();
  void set_allocated_bssid(std::string* bssid);
  private:
  const std::string& _internal_bssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bssid(const std::string& value);
  std::string* _internal_mutable_bssid();
  public:

  // optional bytes ip_address = 3;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // optional .location.nearby.connections.AvailableChannels available_channels = 7;
  bool has_available_channels() const;
  private:
  bool _internal_has_available_channels() const;
  public:
  void clear_available_channels();
  const ::location::nearby::connections::AvailableChannels& available_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AvailableChannels* release_available_channels();
  ::location::nearby::connections::AvailableChannels* mutable_available_channels();
  void set_allocated_available_channels(::location::nearby::connections::AvailableChannels* available_channels);
  private:
  const ::location::nearby::connections::AvailableChannels& _internal_available_channels() const;
  ::location::nearby::connections::AvailableChannels* _internal_mutable_available_channels();
  public:
  void unsafe_arena_set_allocated_available_channels(
      ::location::nearby::connections::AvailableChannels* available_channels);
  ::location::nearby::connections::AvailableChannels* unsafe_arena_release_available_channels();

  // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
  bool has_wifi_direct_cli_usable_channels() const;
  private:
  bool _internal_has_wifi_direct_cli_usable_channels() const;
  public:
  void clear_wifi_direct_cli_usable_channels();
  const ::location::nearby::connections::WifiDirectCliUsableChannels& wifi_direct_cli_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiDirectCliUsableChannels* release_wifi_direct_cli_usable_channels();
  ::location::nearby::connections::WifiDirectCliUsableChannels* mutable_wifi_direct_cli_usable_channels();
  void set_allocated_wifi_direct_cli_usable_channels(::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels);
  private:
  const ::location::nearby::connections::WifiDirectCliUsableChannels& _internal_wifi_direct_cli_usable_channels() const;
  ::location::nearby::connections::WifiDirectCliUsableChannels* _internal_mutable_wifi_direct_cli_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_direct_cli_usable_channels(
      ::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels);
  ::location::nearby::connections::WifiDirectCliUsableChannels* unsafe_arena_release_wifi_direct_cli_usable_channels();

  // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
  bool has_wifi_lan_usable_channels() const;
  private:
  bool _internal_has_wifi_lan_usable_channels() const;
  public:
  void clear_wifi_lan_usable_channels();
  const ::location::nearby::connections::WifiLanUsableChannels& wifi_lan_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiLanUsableChannels* release_wifi_lan_usable_channels();
  ::location::nearby::connections::WifiLanUsableChannels* mutable_wifi_lan_usable_channels();
  void set_allocated_wifi_lan_usable_channels(::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels);
  private:
  const ::location::nearby::connections::WifiLanUsableChannels& _internal_wifi_lan_usable_channels() const;
  ::location::nearby::connections::WifiLanUsableChannels* _internal_mutable_wifi_lan_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_lan_usable_channels(
      ::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels);
  ::location::nearby::connections::WifiLanUsableChannels* unsafe_arena_release_wifi_lan_usable_channels();

  // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
  bool has_wifi_aware_usable_channels() const;
  private:
  bool _internal_has_wifi_aware_usable_channels() const;
  public:
  void clear_wifi_aware_usable_channels();
  const ::location::nearby::connections::WifiAwareUsableChannels& wifi_aware_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiAwareUsableChannels* release_wifi_aware_usable_channels();
  ::location::nearby::connections::WifiAwareUsableChannels* mutable_wifi_aware_usable_channels();
  void set_allocated_wifi_aware_usable_channels(::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels);
  private:
  const ::location::nearby::connections::WifiAwareUsableChannels& _internal_wifi_aware_usable_channels() const;
  ::location::nearby::connections::WifiAwareUsableChannels* _internal_mutable_wifi_aware_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_aware_usable_channels(
      ::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels);
  ::location::nearby::connections::WifiAwareUsableChannels* unsafe_arena_release_wifi_aware_usable_channels();

  // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
  bool has_wifi_hotspot_sta_usable_channels() const;
  private:
  bool _internal_has_wifi_hotspot_sta_usable_channels() const;
  public:
  void clear_wifi_hotspot_sta_usable_channels();
  const ::location::nearby::connections::WifiHotspotStaUsableChannels& wifi_hotspot_sta_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiHotspotStaUsableChannels* release_wifi_hotspot_sta_usable_channels();
  ::location::nearby::connections::WifiHotspotStaUsableChannels* mutable_wifi_hotspot_sta_usable_channels();
  void set_allocated_wifi_hotspot_sta_usable_channels(::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels);
  private:
  const ::location::nearby::connections::WifiHotspotStaUsableChannels& _internal_wifi_hotspot_sta_usable_channels() const;
  ::location::nearby::connections::WifiHotspotStaUsableChannels* _internal_mutable_wifi_hotspot_sta_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_hotspot_sta_usable_channels(
      ::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels);
  ::location::nearby::connections::WifiHotspotStaUsableChannels* unsafe_arena_release_wifi_hotspot_sta_usable_channels();

  // optional bool supports_5_ghz = 1;
  bool has_supports_5_ghz() const;
  private:
  bool _internal_has_supports_5_ghz() const;
  public:
  void clear_supports_5_ghz();
  bool supports_5_ghz() const;
  void set_supports_5_ghz(bool value);
  private:
  bool _internal_supports_5_ghz() const;
  void _internal_set_supports_5_ghz(bool value);
  public:

  // optional bool supports_6_ghz = 4;
  bool has_supports_6_ghz() const;
  private:
  bool _internal_has_supports_6_ghz() const;
  public:
  void clear_supports_6_ghz();
  bool supports_6_ghz() const;
  void set_supports_6_ghz(bool value);
  private:
  bool _internal_supports_6_ghz() const;
  void _internal_set_supports_6_ghz(bool value);
  public:

  // optional bool mobile_radio = 5;
  bool has_mobile_radio() const;
  private:
  bool _internal_has_mobile_radio() const;
  public:
  void clear_mobile_radio();
  bool mobile_radio() const;
  void set_mobile_radio(bool value);
  private:
  bool _internal_mobile_radio() const;
  void _internal_set_mobile_radio(bool value);
  public:

  // optional int32 ap_frequency = 6 [default = -1];
  bool has_ap_frequency() const;
  private:
  bool _internal_has_ap_frequency() const;
  public:
  void clear_ap_frequency();
  int32_t ap_frequency() const;
  void set_ap_frequency(int32_t value);
  private:
  int32_t _internal_ap_frequency() const;
  void _internal_set_ap_frequency(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.MediumMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bssid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  ::location::nearby::connections::AvailableChannels* available_channels_;
  ::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels_;
  ::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels_;
  ::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels_;
  ::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels_;
  bool supports_5_ghz_;
  bool supports_6_ghz_;
  bool mobile_radio_;
  int32_t ap_frequency_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class AvailableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AvailableChannels) */ {
 public:
  inline AvailableChannels() : AvailableChannels(nullptr) {}
  ~AvailableChannels() override;
  explicit constexpr AvailableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailableChannels(const AvailableChannels& from);
  AvailableChannels(AvailableChannels&& from) noexcept
    : AvailableChannels() {
    *this = ::std::move(from);
  }

  inline AvailableChannels& operator=(const AvailableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailableChannels& operator=(AvailableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvailableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailableChannels* internal_default_instance() {
    return reinterpret_cast<const AvailableChannels*>(
               &_AvailableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AvailableChannels& a, AvailableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailableChannels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvailableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvailableChannels& from);
  void MergeFrom(const AvailableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvailableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.AvailableChannels";
  }
  protected:
  explicit AvailableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  private:
  int32_t _internal_channels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_channels() const;
  void _internal_add_channels(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_channels();
  public:
  int32_t channels(int index) const;
  void set_channels(int index, int32_t value);
  void add_channels(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:location.nearby.connections.AvailableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > channels_;
  mutable std::atomic<int> _channels_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class WifiDirectCliUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiDirectCliUsableChannels) */ {
 public:
  inline WifiDirectCliUsableChannels() : WifiDirectCliUsableChannels(nullptr) {}
  ~WifiDirectCliUsableChannels() override;
  explicit constexpr WifiDirectCliUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiDirectCliUsableChannels(const WifiDirectCliUsableChannels& from);
  WifiDirectCliUsableChannels(WifiDirectCliUsableChannels&& from) noexcept
    : WifiDirectCliUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiDirectCliUsableChannels& operator=(const WifiDirectCliUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiDirectCliUsableChannels& operator=(WifiDirectCliUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiDirectCliUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiDirectCliUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiDirectCliUsableChannels*>(
               &_WifiDirectCliUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(WifiDirectCliUsableChannels& a, WifiDirectCliUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiDirectCliUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiDirectCliUsableChannels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiDirectCliUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiDirectCliUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiDirectCliUsableChannels& from);
  void MergeFrom(const WifiDirectCliUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiDirectCliUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.WifiDirectCliUsableChannels";
  }
  protected:
  explicit WifiDirectCliUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  private:
  int32_t _internal_channels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_channels() const;
  void _internal_add_channels(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_channels();
  public:
  int32_t channels(int index) const;
  void set_channels(int index, int32_t value);
  void add_channels(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiDirectCliUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > channels_;
  mutable std::atomic<int> _channels_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class WifiLanUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiLanUsableChannels) */ {
 public:
  inline WifiLanUsableChannels() : WifiLanUsableChannels(nullptr) {}
  ~WifiLanUsableChannels() override;
  explicit constexpr WifiLanUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiLanUsableChannels(const WifiLanUsableChannels& from);
  WifiLanUsableChannels(WifiLanUsableChannels&& from) noexcept
    : WifiLanUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiLanUsableChannels& operator=(const WifiLanUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiLanUsableChannels& operator=(WifiLanUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiLanUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiLanUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiLanUsableChannels*>(
               &_WifiLanUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(WifiLanUsableChannels& a, WifiLanUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiLanUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiLanUsableChannels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiLanUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiLanUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiLanUsableChannels& from);
  void MergeFrom(const WifiLanUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiLanUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.WifiLanUsableChannels";
  }
  protected:
  explicit WifiLanUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  private:
  int32_t _internal_channels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_channels() const;
  void _internal_add_channels(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_channels();
  public:
  int32_t channels(int index) const;
  void set_channels(int index, int32_t value);
  void add_channels(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiLanUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > channels_;
  mutable std::atomic<int> _channels_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class WifiAwareUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiAwareUsableChannels) */ {
 public:
  inline WifiAwareUsableChannels() : WifiAwareUsableChannels(nullptr) {}
  ~WifiAwareUsableChannels() override;
  explicit constexpr WifiAwareUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiAwareUsableChannels(const WifiAwareUsableChannels& from);
  WifiAwareUsableChannels(WifiAwareUsableChannels&& from) noexcept
    : WifiAwareUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiAwareUsableChannels& operator=(const WifiAwareUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiAwareUsableChannels& operator=(WifiAwareUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiAwareUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiAwareUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiAwareUsableChannels*>(
               &_WifiAwareUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(WifiAwareUsableChannels& a, WifiAwareUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiAwareUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiAwareUsableChannels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiAwareUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiAwareUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiAwareUsableChannels& from);
  void MergeFrom(const WifiAwareUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiAwareUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.WifiAwareUsableChannels";
  }
  protected:
  explicit WifiAwareUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  private:
  int32_t _internal_channels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_channels() const;
  void _internal_add_channels(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_channels();
  public:
  int32_t channels(int index) const;
  void set_channels(int index, int32_t value);
  void add_channels(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiAwareUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > channels_;
  mutable std::atomic<int> _channels_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class WifiHotspotStaUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiHotspotStaUsableChannels) */ {
 public:
  inline WifiHotspotStaUsableChannels() : WifiHotspotStaUsableChannels(nullptr) {}
  ~WifiHotspotStaUsableChannels() override;
  explicit constexpr WifiHotspotStaUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiHotspotStaUsableChannels(const WifiHotspotStaUsableChannels& from);
  WifiHotspotStaUsableChannels(WifiHotspotStaUsableChannels&& from) noexcept
    : WifiHotspotStaUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiHotspotStaUsableChannels& operator=(const WifiHotspotStaUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiHotspotStaUsableChannels& operator=(WifiHotspotStaUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiHotspotStaUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiHotspotStaUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiHotspotStaUsableChannels*>(
               &_WifiHotspotStaUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(WifiHotspotStaUsableChannels& a, WifiHotspotStaUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiHotspotStaUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiHotspotStaUsableChannels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiHotspotStaUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiHotspotStaUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiHotspotStaUsableChannels& from);
  void MergeFrom(const WifiHotspotStaUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiHotspotStaUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.WifiHotspotStaUsableChannels";
  }
  protected:
  explicit WifiHotspotStaUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  private:
  int32_t _internal_channels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_channels() const;
  void _internal_add_channels(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_channels();
  public:
  int32_t channels(int index) const;
  void set_channels(int index, int32_t value);
  void add_channels(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiHotspotStaUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > channels_;
  mutable std::atomic<int> _channels_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class LocationHint final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.LocationHint) */ {
 public:
  inline LocationHint() : LocationHint(nullptr) {}
  ~LocationHint() override;
  explicit constexpr LocationHint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationHint(const LocationHint& from);
  LocationHint(LocationHint&& from) noexcept
    : LocationHint() {
    *this = ::std::move(from);
  }

  inline LocationHint& operator=(const LocationHint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationHint& operator=(LocationHint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LocationHint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationHint* internal_default_instance() {
    return reinterpret_cast<const LocationHint*>(
               &_LocationHint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LocationHint& a, LocationHint& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationHint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationHint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationHint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationHint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocationHint& from);
  void MergeFrom(const LocationHint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocationHint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.LocationHint";
  }
  protected:
  explicit LocationHint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  // optional string location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // optional .location.nearby.connections.LocationStandard.Format format = 2;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::location::nearby::connections::LocationStandard_Format format() const;
  void set_format(::location::nearby::connections::LocationStandard_Format value);
  private:
  ::location::nearby::connections::LocationStandard_Format _internal_format() const;
  void _internal_set_format(::location::nearby::connections::LocationStandard_Format value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.LocationHint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  int format_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class LocationStandard final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.LocationStandard) */ {
 public:
  inline LocationStandard() : LocationStandard(nullptr) {}
  ~LocationStandard() override;
  explicit constexpr LocationStandard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationStandard(const LocationStandard& from);
  LocationStandard(LocationStandard&& from) noexcept
    : LocationStandard() {
    *this = ::std::move(from);
  }

  inline LocationStandard& operator=(const LocationStandard& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationStandard& operator=(LocationStandard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LocationStandard& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationStandard* internal_default_instance() {
    return reinterpret_cast<const LocationStandard*>(
               &_LocationStandard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LocationStandard& a, LocationStandard& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationStandard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationStandard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationStandard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationStandard>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocationStandard& from);
  void MergeFrom(const LocationStandard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocationStandard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.LocationStandard";
  }
  protected:
  explicit LocationStandard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LocationStandard_Format Format;
  static constexpr Format UNKNOWN =
    LocationStandard_Format_UNKNOWN;
  static constexpr Format E164_CALLING =
    LocationStandard_Format_E164_CALLING;
  static constexpr Format ISO_3166_1_ALPHA_2 =
    LocationStandard_Format_ISO_3166_1_ALPHA_2;
  static inline bool Format_IsValid(int value) {
    return LocationStandard_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    LocationStandard_Format_Format_MIN;
  static constexpr Format Format_MAX =
    LocationStandard_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    LocationStandard_Format_Format_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return LocationStandard_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return LocationStandard_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:location.nearby.connections.LocationStandard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class OsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.OsInfo) */ {
 public:
  inline OsInfo() : OsInfo(nullptr) {}
  ~OsInfo() override;
  explicit constexpr OsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OsInfo(const OsInfo& from);
  OsInfo(OsInfo&& from) noexcept
    : OsInfo() {
    *this = ::std::move(from);
  }

  inline OsInfo& operator=(const OsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OsInfo& operator=(OsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OsInfo* internal_default_instance() {
    return reinterpret_cast<const OsInfo*>(
               &_OsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(OsInfo& a, OsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OsInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OsInfo& from);
  void MergeFrom(const OsInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.OsInfo";
  }
  protected:
  explicit OsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef OsInfo_OsType OsType;
  static constexpr OsType UNKNOWN_OS_TYPE =
    OsInfo_OsType_UNKNOWN_OS_TYPE;
  static constexpr OsType ANDROID =
    OsInfo_OsType_ANDROID;
  static constexpr OsType CHROME_OS =
    OsInfo_OsType_CHROME_OS;
  static constexpr OsType WINDOWS =
    OsInfo_OsType_WINDOWS;
  static constexpr OsType APPLE =
    OsInfo_OsType_APPLE;
  static constexpr OsType LINUX =
    OsInfo_OsType_LINUX;
  static inline bool OsType_IsValid(int value) {
    return OsInfo_OsType_IsValid(value);
  }
  static constexpr OsType OsType_MIN =
    OsInfo_OsType_OsType_MIN;
  static constexpr OsType OsType_MAX =
    OsInfo_OsType_OsType_MAX;
  static constexpr int OsType_ARRAYSIZE =
    OsInfo_OsType_OsType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& OsType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OsType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OsType_Name.");
    return OsInfo_OsType_Name(enum_t_value);
  }
  static inline bool OsType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OsType* value) {
    return OsInfo_OsType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.OsInfo.OsType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::location::nearby::connections::OsInfo_OsType type() const;
  void set_type(::location::nearby::connections::OsInfo_OsType value);
  private:
  ::location::nearby::connections::OsInfo_OsType _internal_type() const;
  void _internal_set_type(::location::nearby::connections::OsInfo_OsType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.OsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class ConnectionsDevice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.ConnectionsDevice) */ {
 public:
  inline ConnectionsDevice() : ConnectionsDevice(nullptr) {}
  ~ConnectionsDevice() override;
  explicit constexpr ConnectionsDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionsDevice(const ConnectionsDevice& from);
  ConnectionsDevice(ConnectionsDevice&& from) noexcept
    : ConnectionsDevice() {
    *this = ::std::move(from);
  }

  inline ConnectionsDevice& operator=(const ConnectionsDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionsDevice& operator=(ConnectionsDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionsDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionsDevice* internal_default_instance() {
    return reinterpret_cast<const ConnectionsDevice*>(
               &_ConnectionsDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ConnectionsDevice& a, ConnectionsDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionsDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionsDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionsDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionsDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionsDevice& from);
  void MergeFrom(const ConnectionsDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionsDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.ConnectionsDevice";
  }
  protected:
  explicit ConnectionsDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointIdFieldNumber = 1,
    kConnectivityInfoListFieldNumber = 3,
    kEndpointInfoFieldNumber = 4,
    kEndpointTypeFieldNumber = 2,
  };
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  private:
  bool _internal_has_endpoint_id() const;
  public:
  void clear_endpoint_id();
  const std::string& endpoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* endpoint_id);
  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(const std::string& value);
  std::string* _internal_mutable_endpoint_id();
  public:

  // optional bytes connectivity_info_list = 3;
  bool has_connectivity_info_list() const;
  private:
  bool _internal_has_connectivity_info_list() const;
  public:
  void clear_connectivity_info_list();
  const std::string& connectivity_info_list() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectivity_info_list(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectivity_info_list();
  PROTOBUF_NODISCARD std::string* release_connectivity_info_list();
  void set_allocated_connectivity_info_list(std::string* connectivity_info_list);
  private:
  const std::string& _internal_connectivity_info_list() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectivity_info_list(const std::string& value);
  std::string* _internal_mutable_connectivity_info_list();
  public:

  // optional bytes endpoint_info = 4;
  bool has_endpoint_info() const;
  private:
  bool _internal_has_endpoint_info() const;
  public:
  void clear_endpoint_info();
  const std::string& endpoint_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_info();
  PROTOBUF_NODISCARD std::string* release_endpoint_info();
  void set_allocated_endpoint_info(std::string* endpoint_info);
  private:
  const std::string& _internal_endpoint_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_info(const std::string& value);
  std::string* _internal_mutable_endpoint_info();
  public:

  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  bool has_endpoint_type() const;
  private:
  bool _internal_has_endpoint_type() const;
  public:
  void clear_endpoint_type();
  ::location::nearby::connections::EndpointType endpoint_type() const;
  void set_endpoint_type(::location::nearby::connections::EndpointType value);
  private:
  ::location::nearby::connections::EndpointType _internal_endpoint_type() const;
  void _internal_set_endpoint_type(::location::nearby::connections::EndpointType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.ConnectionsDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectivity_info_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_info_;
  int endpoint_type_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// -------------------------------------------------------------------

class PresenceDevice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PresenceDevice) */ {
 public:
  inline PresenceDevice() : PresenceDevice(nullptr) {}
  ~PresenceDevice() override;
  explicit constexpr PresenceDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PresenceDevice(const PresenceDevice& from);
  PresenceDevice(PresenceDevice&& from) noexcept
    : PresenceDevice() {
    *this = ::std::move(from);
  }

  inline PresenceDevice& operator=(const PresenceDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresenceDevice& operator=(PresenceDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PresenceDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresenceDevice* internal_default_instance() {
    return reinterpret_cast<const PresenceDevice*>(
               &_PresenceDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(PresenceDevice& a, PresenceDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(PresenceDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresenceDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PresenceDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PresenceDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PresenceDevice& from);
  void MergeFrom(const PresenceDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PresenceDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.connections.PresenceDevice";
  }
  protected:
  explicit PresenceDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PresenceDevice_DeviceType DeviceType;
  static constexpr DeviceType UNKNOWN =
    PresenceDevice_DeviceType_UNKNOWN;
  static constexpr DeviceType PHONE =
    PresenceDevice_DeviceType_PHONE;
  static constexpr DeviceType TABLET =
    PresenceDevice_DeviceType_TABLET;
  static constexpr DeviceType DISPLAY =
    PresenceDevice_DeviceType_DISPLAY;
  static constexpr DeviceType LAPTOP =
    PresenceDevice_DeviceType_LAPTOP;
  static constexpr DeviceType TV =
    PresenceDevice_DeviceType_TV;
  static constexpr DeviceType WATCH =
    PresenceDevice_DeviceType_WATCH;
  static inline bool DeviceType_IsValid(int value) {
    return PresenceDevice_DeviceType_IsValid(value);
  }
  static constexpr DeviceType DeviceType_MIN =
    PresenceDevice_DeviceType_DeviceType_MIN;
  static constexpr DeviceType DeviceType_MAX =
    PresenceDevice_DeviceType_DeviceType_MAX;
  static constexpr int DeviceType_ARRAYSIZE =
    PresenceDevice_DeviceType_DeviceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceType_Name.");
    return PresenceDevice_DeviceType_Name(enum_t_value);
  }
  static inline bool DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeviceType* value) {
    return PresenceDevice_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDiscoveryMediumFieldNumber = 8,
    kActionsFieldNumber = 9,
    kIdentityTypeFieldNumber = 10,
    kEndpointIdFieldNumber = 1,
    kConnectivityInfoListFieldNumber = 3,
    kDeviceNameFieldNumber = 5,
    kDeviceImageUrlFieldNumber = 7,
    kDeviceIdFieldNumber = 4,
    kEndpointTypeFieldNumber = 2,
    kDeviceTypeFieldNumber = 6,
  };
  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
  int discovery_medium_size() const;
  private:
  int _internal_discovery_medium_size() const;
  public:
  void clear_discovery_medium();
  private:
  ::location::nearby::connections::ConnectionRequestFrame_Medium _internal_discovery_medium(int index) const;
  void _internal_add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_discovery_medium();
  public:
  ::location::nearby::connections::ConnectionRequestFrame_Medium discovery_medium(int index) const;
  void set_discovery_medium(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value);
  void add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& discovery_medium() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_discovery_medium();

  // repeated int32 actions = 9 [packed = true];
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  private:
  int32_t _internal_actions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_actions() const;
  void _internal_add_actions(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_actions();
  public:
  int32_t actions(int index) const;
  void set_actions(int index, int32_t value);
  void add_actions(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_actions();

  // repeated int64 identity_type = 10 [packed = true];
  int identity_type_size() const;
  private:
  int _internal_identity_type_size() const;
  public:
  void clear_identity_type();
  private:
  int64_t _internal_identity_type(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_identity_type() const;
  void _internal_add_identity_type(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_identity_type();
  public:
  int64_t identity_type(int index) const;
  void set_identity_type(int index, int64_t value);
  void add_identity_type(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      identity_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_identity_type();

  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  private:
  bool _internal_has_endpoint_id() const;
  public:
  void clear_endpoint_id();
  const std::string& endpoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* endpoint_id);
  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(const std::string& value);
  std::string* _internal_mutable_endpoint_id();
  public:

  // optional bytes connectivity_info_list = 3;
  bool has_connectivity_info_list() const;
  private:
  bool _internal_has_connectivity_info_list() const;
  public:
  void clear_connectivity_info_list();
  const std::string& connectivity_info_list() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectivity_info_list(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectivity_info_list();
  PROTOBUF_NODISCARD std::string* release_connectivity_info_list();
  void set_allocated_connectivity_info_list(std::string* connectivity_info_list);
  private:
  const std::string& _internal_connectivity_info_list() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectivity_info_list(const std::string& value);
  std::string* _internal_mutable_connectivity_info_list();
  public:

  // optional string device_name = 5;
  bool has_device_name() const;
  private:
  bool _internal_has_device_name() const;
  public:
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // optional string device_image_url = 7;
  bool has_device_image_url() const;
  private:
  bool _internal_has_device_image_url() const;
  public:
  void clear_device_image_url();
  const std::string& device_image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_image_url();
  PROTOBUF_NODISCARD std::string* release_device_image_url();
  void set_allocated_device_image_url(std::string* device_image_url);
  private:
  const std::string& _internal_device_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_image_url(const std::string& value);
  std::string* _internal_mutable_device_image_url();
  public:

  // optional int64 device_id = 4;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  int64_t device_id() const;
  void set_device_id(int64_t value);
  private:
  int64_t _internal_device_id() const;
  void _internal_set_device_id(int64_t value);
  public:

  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  bool has_endpoint_type() const;
  private:
  bool _internal_has_endpoint_type() const;
  public:
  void clear_endpoint_type();
  ::location::nearby::connections::EndpointType endpoint_type() const;
  void set_endpoint_type(::location::nearby::connections::EndpointType value);
  private:
  ::location::nearby::connections::EndpointType _internal_endpoint_type() const;
  void _internal_set_endpoint_type(::location::nearby::connections::EndpointType value);
  public:

  // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
  bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  void clear_device_type();
  ::location::nearby::connections::PresenceDevice_DeviceType device_type() const;
  void set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value);
  private:
  ::location::nearby::connections::PresenceDevice_DeviceType _internal_device_type() const;
  void _internal_set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.connections.PresenceDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> discovery_medium_;
  mutable std::atomic<int> _discovery_medium_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > actions_;
  mutable std::atomic<int> _actions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > identity_type_;
  mutable std::atomic<int> _identity_type_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectivity_info_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_image_url_;
  int64_t device_id_;
  int endpoint_type_;
  int device_type_;
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OfflineFrame

// optional .location.nearby.connections.OfflineFrame.Version version = 1;
inline bool OfflineFrame::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OfflineFrame::has_version() const {
  return _internal_has_version();
}
inline void OfflineFrame::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::OfflineFrame_Version OfflineFrame::_internal_version() const {
  return static_cast< ::location::nearby::connections::OfflineFrame_Version >(version_);
}
inline ::location::nearby::connections::OfflineFrame_Version OfflineFrame::version() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.OfflineFrame.version)
  return _internal_version();
}
inline void OfflineFrame::_internal_set_version(::location::nearby::connections::OfflineFrame_Version value) {
  assert(::location::nearby::connections::OfflineFrame_Version_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void OfflineFrame::set_version(::location::nearby::connections::OfflineFrame_Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.OfflineFrame.version)
}

// optional .location.nearby.connections.V1Frame v1 = 2;
inline bool OfflineFrame::_internal_has_v1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || v1_ != nullptr);
  return value;
}
inline bool OfflineFrame::has_v1() const {
  return _internal_has_v1();
}
inline void OfflineFrame::clear_v1() {
  if (v1_ != nullptr) v1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::V1Frame& OfflineFrame::_internal_v1() const {
  const ::location::nearby::connections::V1Frame* p = v1_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::V1Frame&>(
      ::location::nearby::connections::_V1Frame_default_instance_);
}
inline const ::location::nearby::connections::V1Frame& OfflineFrame::v1() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.OfflineFrame.v1)
  return _internal_v1();
}
inline void OfflineFrame::unsafe_arena_set_allocated_v1(
    ::location::nearby::connections::V1Frame* v1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(v1_);
  }
  v1_ = v1;
  if (v1) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.OfflineFrame.v1)
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::release_v1() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::V1Frame* temp = v1_;
  v1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.OfflineFrame.v1)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::V1Frame* temp = v1_;
  v1_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::_internal_mutable_v1() {
  _has_bits_[0] |= 0x00000001u;
  if (v1_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::V1Frame>(GetArenaForAllocation());
    v1_ = p;
  }
  return v1_;
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::mutable_v1() {
  ::location::nearby::connections::V1Frame* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.OfflineFrame.v1)
  return _msg;
}
inline void OfflineFrame::set_allocated_v1(::location::nearby::connections::V1Frame* v1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete v1_;
  }
  if (v1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::V1Frame>::GetOwningArena(v1);
    if (message_arena != submessage_arena) {
      v1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  v1_ = v1;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.OfflineFrame.v1)
}

// -------------------------------------------------------------------

// V1Frame

// optional .location.nearby.connections.V1Frame.FrameType type = 1;
inline bool V1Frame::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool V1Frame::has_type() const {
  return _internal_has_type();
}
inline void V1Frame::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::location::nearby::connections::V1Frame_FrameType V1Frame::_internal_type() const {
  return static_cast< ::location::nearby::connections::V1Frame_FrameType >(type_);
}
inline ::location::nearby::connections::V1Frame_FrameType V1Frame::type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.type)
  return _internal_type();
}
inline void V1Frame::_internal_set_type(::location::nearby::connections::V1Frame_FrameType value) {
  assert(::location::nearby::connections::V1Frame_FrameType_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  type_ = value;
}
inline void V1Frame::set_type(::location::nearby::connections::V1Frame_FrameType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.V1Frame.type)
}

// optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
inline bool V1Frame::_internal_has_connection_request() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || connection_request_ != nullptr);
  return value;
}
inline bool V1Frame::has_connection_request() const {
  return _internal_has_connection_request();
}
inline void V1Frame::clear_connection_request() {
  if (connection_request_ != nullptr) connection_request_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::ConnectionRequestFrame& V1Frame::_internal_connection_request() const {
  const ::location::nearby::connections::ConnectionRequestFrame* p = connection_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::ConnectionRequestFrame&>(
      ::location::nearby::connections::_ConnectionRequestFrame_default_instance_);
}
inline const ::location::nearby::connections::ConnectionRequestFrame& V1Frame::connection_request() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.connection_request)
  return _internal_connection_request();
}
inline void V1Frame::unsafe_arena_set_allocated_connection_request(
    ::location::nearby::connections::ConnectionRequestFrame* connection_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_request_);
  }
  connection_request_ = connection_request;
  if (connection_request) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.connection_request)
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::release_connection_request() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::ConnectionRequestFrame* temp = connection_request_;
  connection_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::unsafe_arena_release_connection_request() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.connection_request)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::ConnectionRequestFrame* temp = connection_request_;
  connection_request_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::_internal_mutable_connection_request() {
  _has_bits_[0] |= 0x00000001u;
  if (connection_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::ConnectionRequestFrame>(GetArenaForAllocation());
    connection_request_ = p;
  }
  return connection_request_;
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::mutable_connection_request() {
  ::location::nearby::connections::ConnectionRequestFrame* _msg = _internal_mutable_connection_request();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.connection_request)
  return _msg;
}
inline void V1Frame::set_allocated_connection_request(::location::nearby::connections::ConnectionRequestFrame* connection_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connection_request_;
  }
  if (connection_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::ConnectionRequestFrame>::GetOwningArena(connection_request);
    if (message_arena != submessage_arena) {
      connection_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  connection_request_ = connection_request;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.connection_request)
}

// optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
inline bool V1Frame::_internal_has_connection_response() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || connection_response_ != nullptr);
  return value;
}
inline bool V1Frame::has_connection_response() const {
  return _internal_has_connection_response();
}
inline void V1Frame::clear_connection_response() {
  if (connection_response_ != nullptr) connection_response_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::ConnectionResponseFrame& V1Frame::_internal_connection_response() const {
  const ::location::nearby::connections::ConnectionResponseFrame* p = connection_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::ConnectionResponseFrame&>(
      ::location::nearby::connections::_ConnectionResponseFrame_default_instance_);
}
inline const ::location::nearby::connections::ConnectionResponseFrame& V1Frame::connection_response() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.connection_response)
  return _internal_connection_response();
}
inline void V1Frame::unsafe_arena_set_allocated_connection_response(
    ::location::nearby::connections::ConnectionResponseFrame* connection_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_response_);
  }
  connection_response_ = connection_response;
  if (connection_response) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.connection_response)
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::release_connection_response() {
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::ConnectionResponseFrame* temp = connection_response_;
  connection_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::unsafe_arena_release_connection_response() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.connection_response)
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::ConnectionResponseFrame* temp = connection_response_;
  connection_response_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::_internal_mutable_connection_response() {
  _has_bits_[0] |= 0x00000002u;
  if (connection_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::ConnectionResponseFrame>(GetArenaForAllocation());
    connection_response_ = p;
  }
  return connection_response_;
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::mutable_connection_response() {
  ::location::nearby::connections::ConnectionResponseFrame* _msg = _internal_mutable_connection_response();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.connection_response)
  return _msg;
}
inline void V1Frame::set_allocated_connection_response(::location::nearby::connections::ConnectionResponseFrame* connection_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connection_response_;
  }
  if (connection_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::ConnectionResponseFrame>::GetOwningArena(connection_response);
    if (message_arena != submessage_arena) {
      connection_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connection_response_ = connection_response;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.connection_response)
}

// optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
inline bool V1Frame::_internal_has_payload_transfer() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || payload_transfer_ != nullptr);
  return value;
}
inline bool V1Frame::has_payload_transfer() const {
  return _internal_has_payload_transfer();
}
inline void V1Frame::clear_payload_transfer() {
  if (payload_transfer_ != nullptr) payload_transfer_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::PayloadTransferFrame& V1Frame::_internal_payload_transfer() const {
  const ::location::nearby::connections::PayloadTransferFrame* p = payload_transfer_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame&>(
      ::location::nearby::connections::_PayloadTransferFrame_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame& V1Frame::payload_transfer() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.payload_transfer)
  return _internal_payload_transfer();
}
inline void V1Frame::unsafe_arena_set_allocated_payload_transfer(
    ::location::nearby::connections::PayloadTransferFrame* payload_transfer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_transfer_);
  }
  payload_transfer_ = payload_transfer;
  if (payload_transfer) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.payload_transfer)
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::release_payload_transfer() {
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame* temp = payload_transfer_;
  payload_transfer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::unsafe_arena_release_payload_transfer() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.payload_transfer)
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame* temp = payload_transfer_;
  payload_transfer_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::_internal_mutable_payload_transfer() {
  _has_bits_[0] |= 0x00000004u;
  if (payload_transfer_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame>(GetArenaForAllocation());
    payload_transfer_ = p;
  }
  return payload_transfer_;
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::mutable_payload_transfer() {
  ::location::nearby::connections::PayloadTransferFrame* _msg = _internal_mutable_payload_transfer();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.payload_transfer)
  return _msg;
}
inline void V1Frame::set_allocated_payload_transfer(::location::nearby::connections::PayloadTransferFrame* payload_transfer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payload_transfer_;
  }
  if (payload_transfer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::PayloadTransferFrame>::GetOwningArena(payload_transfer);
    if (message_arena != submessage_arena) {
      payload_transfer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_transfer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  payload_transfer_ = payload_transfer;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.payload_transfer)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
inline bool V1Frame::_internal_has_bandwidth_upgrade_negotiation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || bandwidth_upgrade_negotiation_ != nullptr);
  return value;
}
inline bool V1Frame::has_bandwidth_upgrade_negotiation() const {
  return _internal_has_bandwidth_upgrade_negotiation();
}
inline void V1Frame::clear_bandwidth_upgrade_negotiation() {
  if (bandwidth_upgrade_negotiation_ != nullptr) bandwidth_upgrade_negotiation_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& V1Frame::_internal_bandwidth_upgrade_negotiation() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* p = bandwidth_upgrade_negotiation_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& V1Frame::bandwidth_upgrade_negotiation() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
  return _internal_bandwidth_upgrade_negotiation();
}
inline void V1Frame::unsafe_arena_set_allocated_bandwidth_upgrade_negotiation(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bandwidth_upgrade_negotiation_);
  }
  bandwidth_upgrade_negotiation_ = bandwidth_upgrade_negotiation;
  if (bandwidth_upgrade_negotiation) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::release_bandwidth_upgrade_negotiation() {
  _has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* temp = bandwidth_upgrade_negotiation_;
  bandwidth_upgrade_negotiation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::unsafe_arena_release_bandwidth_upgrade_negotiation() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
  _has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* temp = bandwidth_upgrade_negotiation_;
  bandwidth_upgrade_negotiation_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::_internal_mutable_bandwidth_upgrade_negotiation() {
  _has_bits_[0] |= 0x00000008u;
  if (bandwidth_upgrade_negotiation_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame>(GetArenaForAllocation());
    bandwidth_upgrade_negotiation_ = p;
  }
  return bandwidth_upgrade_negotiation_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::mutable_bandwidth_upgrade_negotiation() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* _msg = _internal_mutable_bandwidth_upgrade_negotiation();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
  return _msg;
}
inline void V1Frame::set_allocated_bandwidth_upgrade_negotiation(::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bandwidth_upgrade_negotiation_;
  }
  if (bandwidth_upgrade_negotiation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame>::GetOwningArena(bandwidth_upgrade_negotiation);
    if (message_arena != submessage_arena) {
      bandwidth_upgrade_negotiation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bandwidth_upgrade_negotiation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  bandwidth_upgrade_negotiation_ = bandwidth_upgrade_negotiation;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
}

// optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
inline bool V1Frame::_internal_has_keep_alive() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || keep_alive_ != nullptr);
  return value;
}
inline bool V1Frame::has_keep_alive() const {
  return _internal_has_keep_alive();
}
inline void V1Frame::clear_keep_alive() {
  if (keep_alive_ != nullptr) keep_alive_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::location::nearby::connections::KeepAliveFrame& V1Frame::_internal_keep_alive() const {
  const ::location::nearby::connections::KeepAliveFrame* p = keep_alive_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::KeepAliveFrame&>(
      ::location::nearby::connections::_KeepAliveFrame_default_instance_);
}
inline const ::location::nearby::connections::KeepAliveFrame& V1Frame::keep_alive() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.keep_alive)
  return _internal_keep_alive();
}
inline void V1Frame::unsafe_arena_set_allocated_keep_alive(
    ::location::nearby::connections::KeepAliveFrame* keep_alive) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keep_alive_);
  }
  keep_alive_ = keep_alive;
  if (keep_alive) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.keep_alive)
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::release_keep_alive() {
  _has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::KeepAliveFrame* temp = keep_alive_;
  keep_alive_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::unsafe_arena_release_keep_alive() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.keep_alive)
  _has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::KeepAliveFrame* temp = keep_alive_;
  keep_alive_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::_internal_mutable_keep_alive() {
  _has_bits_[0] |= 0x00000010u;
  if (keep_alive_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::KeepAliveFrame>(GetArenaForAllocation());
    keep_alive_ = p;
  }
  return keep_alive_;
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::mutable_keep_alive() {
  ::location::nearby::connections::KeepAliveFrame* _msg = _internal_mutable_keep_alive();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.keep_alive)
  return _msg;
}
inline void V1Frame::set_allocated_keep_alive(::location::nearby::connections::KeepAliveFrame* keep_alive) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete keep_alive_;
  }
  if (keep_alive) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::KeepAliveFrame>::GetOwningArena(keep_alive);
    if (message_arena != submessage_arena) {
      keep_alive = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keep_alive, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  keep_alive_ = keep_alive;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.keep_alive)
}

// optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
inline bool V1Frame::_internal_has_disconnection() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || disconnection_ != nullptr);
  return value;
}
inline bool V1Frame::has_disconnection() const {
  return _internal_has_disconnection();
}
inline void V1Frame::clear_disconnection() {
  if (disconnection_ != nullptr) disconnection_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::DisconnectionFrame& V1Frame::_internal_disconnection() const {
  const ::location::nearby::connections::DisconnectionFrame* p = disconnection_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::DisconnectionFrame&>(
      ::location::nearby::connections::_DisconnectionFrame_default_instance_);
}
inline const ::location::nearby::connections::DisconnectionFrame& V1Frame::disconnection() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.disconnection)
  return _internal_disconnection();
}
inline void V1Frame::unsafe_arena_set_allocated_disconnection(
    ::location::nearby::connections::DisconnectionFrame* disconnection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disconnection_);
  }
  disconnection_ = disconnection;
  if (disconnection) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.disconnection)
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::release_disconnection() {
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::DisconnectionFrame* temp = disconnection_;
  disconnection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::unsafe_arena_release_disconnection() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.disconnection)
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::DisconnectionFrame* temp = disconnection_;
  disconnection_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::_internal_mutable_disconnection() {
  _has_bits_[0] |= 0x00000020u;
  if (disconnection_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::DisconnectionFrame>(GetArenaForAllocation());
    disconnection_ = p;
  }
  return disconnection_;
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::mutable_disconnection() {
  ::location::nearby::connections::DisconnectionFrame* _msg = _internal_mutable_disconnection();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.disconnection)
  return _msg;
}
inline void V1Frame::set_allocated_disconnection(::location::nearby::connections::DisconnectionFrame* disconnection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete disconnection_;
  }
  if (disconnection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::DisconnectionFrame>::GetOwningArena(disconnection);
    if (message_arena != submessage_arena) {
      disconnection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disconnection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  disconnection_ = disconnection;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.disconnection)
}

// optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
inline bool V1Frame::_internal_has_paired_key_encryption() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || paired_key_encryption_ != nullptr);
  return value;
}
inline bool V1Frame::has_paired_key_encryption() const {
  return _internal_has_paired_key_encryption();
}
inline void V1Frame::clear_paired_key_encryption() {
  if (paired_key_encryption_ != nullptr) paired_key_encryption_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::location::nearby::connections::PairedKeyEncryptionFrame& V1Frame::_internal_paired_key_encryption() const {
  const ::location::nearby::connections::PairedKeyEncryptionFrame* p = paired_key_encryption_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PairedKeyEncryptionFrame&>(
      ::location::nearby::connections::_PairedKeyEncryptionFrame_default_instance_);
}
inline const ::location::nearby::connections::PairedKeyEncryptionFrame& V1Frame::paired_key_encryption() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.paired_key_encryption)
  return _internal_paired_key_encryption();
}
inline void V1Frame::unsafe_arena_set_allocated_paired_key_encryption(
    ::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(paired_key_encryption_);
  }
  paired_key_encryption_ = paired_key_encryption;
  if (paired_key_encryption) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.paired_key_encryption)
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::release_paired_key_encryption() {
  _has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::PairedKeyEncryptionFrame* temp = paired_key_encryption_;
  paired_key_encryption_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::unsafe_arena_release_paired_key_encryption() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.paired_key_encryption)
  _has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::PairedKeyEncryptionFrame* temp = paired_key_encryption_;
  paired_key_encryption_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::_internal_mutable_paired_key_encryption() {
  _has_bits_[0] |= 0x00000040u;
  if (paired_key_encryption_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PairedKeyEncryptionFrame>(GetArenaForAllocation());
    paired_key_encryption_ = p;
  }
  return paired_key_encryption_;
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::mutable_paired_key_encryption() {
  ::location::nearby::connections::PairedKeyEncryptionFrame* _msg = _internal_mutable_paired_key_encryption();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.paired_key_encryption)
  return _msg;
}
inline void V1Frame::set_allocated_paired_key_encryption(::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete paired_key_encryption_;
  }
  if (paired_key_encryption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::PairedKeyEncryptionFrame>::GetOwningArena(paired_key_encryption);
    if (message_arena != submessage_arena) {
      paired_key_encryption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paired_key_encryption, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  paired_key_encryption_ = paired_key_encryption;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.paired_key_encryption)
}

// optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
inline bool V1Frame::_internal_has_authentication_message() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || authentication_message_ != nullptr);
  return value;
}
inline bool V1Frame::has_authentication_message() const {
  return _internal_has_authentication_message();
}
inline void V1Frame::clear_authentication_message() {
  if (authentication_message_ != nullptr) authentication_message_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::location::nearby::connections::AuthenticationMessageFrame& V1Frame::_internal_authentication_message() const {
  const ::location::nearby::connections::AuthenticationMessageFrame* p = authentication_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AuthenticationMessageFrame&>(
      ::location::nearby::connections::_AuthenticationMessageFrame_default_instance_);
}
inline const ::location::nearby::connections::AuthenticationMessageFrame& V1Frame::authentication_message() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.authentication_message)
  return _internal_authentication_message();
}
inline void V1Frame::unsafe_arena_set_allocated_authentication_message(
    ::location::nearby::connections::AuthenticationMessageFrame* authentication_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authentication_message_);
  }
  authentication_message_ = authentication_message;
  if (authentication_message) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.authentication_message)
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::release_authentication_message() {
  _has_bits_[0] &= ~0x00000080u;
  ::location::nearby::connections::AuthenticationMessageFrame* temp = authentication_message_;
  authentication_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::unsafe_arena_release_authentication_message() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.authentication_message)
  _has_bits_[0] &= ~0x00000080u;
  ::location::nearby::connections::AuthenticationMessageFrame* temp = authentication_message_;
  authentication_message_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::_internal_mutable_authentication_message() {
  _has_bits_[0] |= 0x00000080u;
  if (authentication_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AuthenticationMessageFrame>(GetArenaForAllocation());
    authentication_message_ = p;
  }
  return authentication_message_;
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::mutable_authentication_message() {
  ::location::nearby::connections::AuthenticationMessageFrame* _msg = _internal_mutable_authentication_message();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.authentication_message)
  return _msg;
}
inline void V1Frame::set_allocated_authentication_message(::location::nearby::connections::AuthenticationMessageFrame* authentication_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authentication_message_;
  }
  if (authentication_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::AuthenticationMessageFrame>::GetOwningArena(authentication_message);
    if (message_arena != submessage_arena) {
      authentication_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authentication_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  authentication_message_ = authentication_message;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.authentication_message)
}

// optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
inline bool V1Frame::_internal_has_authentication_result() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || authentication_result_ != nullptr);
  return value;
}
inline bool V1Frame::has_authentication_result() const {
  return _internal_has_authentication_result();
}
inline void V1Frame::clear_authentication_result() {
  if (authentication_result_ != nullptr) authentication_result_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::location::nearby::connections::AuthenticationResultFrame& V1Frame::_internal_authentication_result() const {
  const ::location::nearby::connections::AuthenticationResultFrame* p = authentication_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AuthenticationResultFrame&>(
      ::location::nearby::connections::_AuthenticationResultFrame_default_instance_);
}
inline const ::location::nearby::connections::AuthenticationResultFrame& V1Frame::authentication_result() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.authentication_result)
  return _internal_authentication_result();
}
inline void V1Frame::unsafe_arena_set_allocated_authentication_result(
    ::location::nearby::connections::AuthenticationResultFrame* authentication_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authentication_result_);
  }
  authentication_result_ = authentication_result;
  if (authentication_result) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.authentication_result)
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::release_authentication_result() {
  _has_bits_[0] &= ~0x00000100u;
  ::location::nearby::connections::AuthenticationResultFrame* temp = authentication_result_;
  authentication_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::unsafe_arena_release_authentication_result() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.authentication_result)
  _has_bits_[0] &= ~0x00000100u;
  ::location::nearby::connections::AuthenticationResultFrame* temp = authentication_result_;
  authentication_result_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::_internal_mutable_authentication_result() {
  _has_bits_[0] |= 0x00000100u;
  if (authentication_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AuthenticationResultFrame>(GetArenaForAllocation());
    authentication_result_ = p;
  }
  return authentication_result_;
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::mutable_authentication_result() {
  ::location::nearby::connections::AuthenticationResultFrame* _msg = _internal_mutable_authentication_result();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.authentication_result)
  return _msg;
}
inline void V1Frame::set_allocated_authentication_result(::location::nearby::connections::AuthenticationResultFrame* authentication_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authentication_result_;
  }
  if (authentication_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::AuthenticationResultFrame>::GetOwningArena(authentication_result);
    if (message_arena != submessage_arena) {
      authentication_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authentication_result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  authentication_result_ = authentication_result;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.authentication_result)
}

// optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
inline bool V1Frame::_internal_has_auto_resume() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || auto_resume_ != nullptr);
  return value;
}
inline bool V1Frame::has_auto_resume() const {
  return _internal_has_auto_resume();
}
inline void V1Frame::clear_auto_resume() {
  if (auto_resume_ != nullptr) auto_resume_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::location::nearby::connections::AutoResumeFrame& V1Frame::_internal_auto_resume() const {
  const ::location::nearby::connections::AutoResumeFrame* p = auto_resume_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AutoResumeFrame&>(
      ::location::nearby::connections::_AutoResumeFrame_default_instance_);
}
inline const ::location::nearby::connections::AutoResumeFrame& V1Frame::auto_resume() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.auto_resume)
  return _internal_auto_resume();
}
inline void V1Frame::unsafe_arena_set_allocated_auto_resume(
    ::location::nearby::connections::AutoResumeFrame* auto_resume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auto_resume_);
  }
  auto_resume_ = auto_resume;
  if (auto_resume) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.auto_resume)
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::release_auto_resume() {
  _has_bits_[0] &= ~0x00000200u;
  ::location::nearby::connections::AutoResumeFrame* temp = auto_resume_;
  auto_resume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::unsafe_arena_release_auto_resume() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.auto_resume)
  _has_bits_[0] &= ~0x00000200u;
  ::location::nearby::connections::AutoResumeFrame* temp = auto_resume_;
  auto_resume_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::_internal_mutable_auto_resume() {
  _has_bits_[0] |= 0x00000200u;
  if (auto_resume_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AutoResumeFrame>(GetArenaForAllocation());
    auto_resume_ = p;
  }
  return auto_resume_;
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::mutable_auto_resume() {
  ::location::nearby::connections::AutoResumeFrame* _msg = _internal_mutable_auto_resume();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.auto_resume)
  return _msg;
}
inline void V1Frame::set_allocated_auto_resume(::location::nearby::connections::AutoResumeFrame* auto_resume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auto_resume_;
  }
  if (auto_resume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::AutoResumeFrame>::GetOwningArena(auto_resume);
    if (message_arena != submessage_arena) {
      auto_resume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_resume, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  auto_resume_ = auto_resume;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.auto_resume)
}

// optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
inline bool V1Frame::_internal_has_auto_reconnect() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || auto_reconnect_ != nullptr);
  return value;
}
inline bool V1Frame::has_auto_reconnect() const {
  return _internal_has_auto_reconnect();
}
inline void V1Frame::clear_auto_reconnect() {
  if (auto_reconnect_ != nullptr) auto_reconnect_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::location::nearby::connections::AutoReconnectFrame& V1Frame::_internal_auto_reconnect() const {
  const ::location::nearby::connections::AutoReconnectFrame* p = auto_reconnect_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AutoReconnectFrame&>(
      ::location::nearby::connections::_AutoReconnectFrame_default_instance_);
}
inline const ::location::nearby::connections::AutoReconnectFrame& V1Frame::auto_reconnect() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.auto_reconnect)
  return _internal_auto_reconnect();
}
inline void V1Frame::unsafe_arena_set_allocated_auto_reconnect(
    ::location::nearby::connections::AutoReconnectFrame* auto_reconnect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auto_reconnect_);
  }
  auto_reconnect_ = auto_reconnect;
  if (auto_reconnect) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.auto_reconnect)
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::release_auto_reconnect() {
  _has_bits_[0] &= ~0x00000400u;
  ::location::nearby::connections::AutoReconnectFrame* temp = auto_reconnect_;
  auto_reconnect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::unsafe_arena_release_auto_reconnect() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.auto_reconnect)
  _has_bits_[0] &= ~0x00000400u;
  ::location::nearby::connections::AutoReconnectFrame* temp = auto_reconnect_;
  auto_reconnect_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::_internal_mutable_auto_reconnect() {
  _has_bits_[0] |= 0x00000400u;
  if (auto_reconnect_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AutoReconnectFrame>(GetArenaForAllocation());
    auto_reconnect_ = p;
  }
  return auto_reconnect_;
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::mutable_auto_reconnect() {
  ::location::nearby::connections::AutoReconnectFrame* _msg = _internal_mutable_auto_reconnect();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.auto_reconnect)
  return _msg;
}
inline void V1Frame::set_allocated_auto_reconnect(::location::nearby::connections::AutoReconnectFrame* auto_reconnect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auto_reconnect_;
  }
  if (auto_reconnect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::AutoReconnectFrame>::GetOwningArena(auto_reconnect);
    if (message_arena != submessage_arena) {
      auto_reconnect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_reconnect, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  auto_reconnect_ = auto_reconnect;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.auto_reconnect)
}

// -------------------------------------------------------------------

// ConnectionRequestFrame

// optional string endpoint_id = 1;
inline bool ConnectionRequestFrame::_internal_has_endpoint_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_endpoint_id() const {
  return _internal_has_endpoint_id();
}
inline void ConnectionRequestFrame::clear_endpoint_id() {
  endpoint_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionRequestFrame::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
  return _internal_endpoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionRequestFrame::set_endpoint_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
}
inline std::string* ConnectionRequestFrame::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_endpoint_id() const {
  return endpoint_id_.Get();
}
inline void ConnectionRequestFrame::_internal_set_endpoint_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_endpoint_id() {
  _has_bits_[0] |= 0x00000001u;
  return endpoint_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
  if (!_internal_has_endpoint_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = endpoint_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionRequestFrame::set_allocated_endpoint_id(std::string* endpoint_id) {
  if (endpoint_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
}

// optional string endpoint_name = 2;
inline bool ConnectionRequestFrame::_internal_has_endpoint_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_endpoint_name() const {
  return _internal_has_endpoint_name();
}
inline void ConnectionRequestFrame::clear_endpoint_name() {
  endpoint_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectionRequestFrame::endpoint_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
  return _internal_endpoint_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionRequestFrame::set_endpoint_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 endpoint_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
}
inline std::string* ConnectionRequestFrame::mutable_endpoint_name() {
  std::string* _s = _internal_mutable_endpoint_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_endpoint_name() const {
  return endpoint_name_.Get();
}
inline void ConnectionRequestFrame::_internal_set_endpoint_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  endpoint_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_endpoint_name() {
  _has_bits_[0] |= 0x00000002u;
  return endpoint_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_endpoint_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
  if (!_internal_has_endpoint_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = endpoint_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionRequestFrame::set_allocated_endpoint_name(std::string* endpoint_name) {
  if (endpoint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  endpoint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
}

// optional bytes handshake_data = 3;
inline bool ConnectionRequestFrame::_internal_has_handshake_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_handshake_data() const {
  return _internal_has_handshake_data();
}
inline void ConnectionRequestFrame::clear_handshake_data() {
  handshake_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConnectionRequestFrame::handshake_data() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.handshake_data)
  return _internal_handshake_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionRequestFrame::set_handshake_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 handshake_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.handshake_data)
}
inline std::string* ConnectionRequestFrame::mutable_handshake_data() {
  std::string* _s = _internal_mutable_handshake_data();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.handshake_data)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_handshake_data() const {
  return handshake_data_.Get();
}
inline void ConnectionRequestFrame::_internal_set_handshake_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  handshake_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_handshake_data() {
  _has_bits_[0] |= 0x00000004u;
  return handshake_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_handshake_data() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.handshake_data)
  if (!_internal_has_handshake_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = handshake_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (handshake_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionRequestFrame::set_allocated_handshake_data(std::string* handshake_data) {
  if (handshake_data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  handshake_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), handshake_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (handshake_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.handshake_data)
}

// optional int32 nonce = 4;
inline bool ConnectionRequestFrame::_internal_has_nonce() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_nonce() const {
  return _internal_has_nonce();
}
inline void ConnectionRequestFrame::clear_nonce() {
  nonce_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ConnectionRequestFrame::_internal_nonce() const {
  return nonce_;
}
inline int32_t ConnectionRequestFrame::nonce() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.nonce)
  return _internal_nonce();
}
inline void ConnectionRequestFrame::_internal_set_nonce(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  nonce_ = value;
}
inline void ConnectionRequestFrame::set_nonce(int32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.nonce)
}

// repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
inline int ConnectionRequestFrame::_internal_mediums_size() const {
  return mediums_.size();
}
inline int ConnectionRequestFrame::mediums_size() const {
  return _internal_mediums_size();
}
inline void ConnectionRequestFrame::clear_mediums() {
  mediums_.Clear();
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium ConnectionRequestFrame::_internal_mediums(int index) const {
  return static_cast< ::location::nearby::connections::ConnectionRequestFrame_Medium >(mediums_.Get(index));
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium ConnectionRequestFrame::mediums(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.mediums)
  return _internal_mediums(index);
}
inline void ConnectionRequestFrame::set_mediums(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  mediums_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.mediums)
}
inline void ConnectionRequestFrame::_internal_add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  mediums_.Add(value);
}
inline void ConnectionRequestFrame::add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  _internal_add_mediums(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.ConnectionRequestFrame.mediums)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ConnectionRequestFrame::mediums() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.ConnectionRequestFrame.mediums)
  return mediums_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ConnectionRequestFrame::_internal_mutable_mediums() {
  return &mediums_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ConnectionRequestFrame::mutable_mediums() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.ConnectionRequestFrame.mediums)
  return _internal_mutable_mediums();
}

// optional bytes endpoint_info = 6;
inline bool ConnectionRequestFrame::_internal_has_endpoint_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_endpoint_info() const {
  return _internal_has_endpoint_info();
}
inline void ConnectionRequestFrame::clear_endpoint_info() {
  endpoint_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConnectionRequestFrame::endpoint_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
  return _internal_endpoint_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionRequestFrame::set_endpoint_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 endpoint_info_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
}
inline std::string* ConnectionRequestFrame::mutable_endpoint_info() {
  std::string* _s = _internal_mutable_endpoint_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_endpoint_info() const {
  return endpoint_info_.Get();
}
inline void ConnectionRequestFrame::_internal_set_endpoint_info(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  endpoint_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_endpoint_info() {
  _has_bits_[0] |= 0x00000008u;
  return endpoint_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_endpoint_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
  if (!_internal_has_endpoint_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = endpoint_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionRequestFrame::set_allocated_endpoint_info(std::string* endpoint_info) {
  if (endpoint_info != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  endpoint_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
}

// optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
inline bool ConnectionRequestFrame::_internal_has_medium_metadata() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || medium_metadata_ != nullptr);
  return value;
}
inline bool ConnectionRequestFrame::has_medium_metadata() const {
  return _internal_has_medium_metadata();
}
inline void ConnectionRequestFrame::clear_medium_metadata() {
  if (medium_metadata_ != nullptr) medium_metadata_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::MediumMetadata& ConnectionRequestFrame::_internal_medium_metadata() const {
  const ::location::nearby::connections::MediumMetadata* p = medium_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::MediumMetadata&>(
      ::location::nearby::connections::_MediumMetadata_default_instance_);
}
inline const ::location::nearby::connections::MediumMetadata& ConnectionRequestFrame::medium_metadata() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
  return _internal_medium_metadata();
}
inline void ConnectionRequestFrame::unsafe_arena_set_allocated_medium_metadata(
    ::location::nearby::connections::MediumMetadata* medium_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(medium_metadata_);
  }
  medium_metadata_ = medium_metadata;
  if (medium_metadata) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::release_medium_metadata() {
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::MediumMetadata* temp = medium_metadata_;
  medium_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::unsafe_arena_release_medium_metadata() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::MediumMetadata* temp = medium_metadata_;
  medium_metadata_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::_internal_mutable_medium_metadata() {
  _has_bits_[0] |= 0x00000020u;
  if (medium_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::MediumMetadata>(GetArenaForAllocation());
    medium_metadata_ = p;
  }
  return medium_metadata_;
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::mutable_medium_metadata() {
  ::location::nearby::connections::MediumMetadata* _msg = _internal_mutable_medium_metadata();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
  return _msg;
}
inline void ConnectionRequestFrame::set_allocated_medium_metadata(::location::nearby::connections::MediumMetadata* medium_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete medium_metadata_;
  }
  if (medium_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::MediumMetadata>::GetOwningArena(medium_metadata);
    if (message_arena != submessage_arena) {
      medium_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, medium_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  medium_metadata_ = medium_metadata;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
}

// optional int32 keep_alive_interval_millis = 8;
inline bool ConnectionRequestFrame::_internal_has_keep_alive_interval_millis() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_keep_alive_interval_millis() const {
  return _internal_has_keep_alive_interval_millis();
}
inline void ConnectionRequestFrame::clear_keep_alive_interval_millis() {
  keep_alive_interval_millis_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ConnectionRequestFrame::_internal_keep_alive_interval_millis() const {
  return keep_alive_interval_millis_;
}
inline int32_t ConnectionRequestFrame::keep_alive_interval_millis() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.keep_alive_interval_millis)
  return _internal_keep_alive_interval_millis();
}
inline void ConnectionRequestFrame::_internal_set_keep_alive_interval_millis(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  keep_alive_interval_millis_ = value;
}
inline void ConnectionRequestFrame::set_keep_alive_interval_millis(int32_t value) {
  _internal_set_keep_alive_interval_millis(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.keep_alive_interval_millis)
}

// optional int32 keep_alive_timeout_millis = 9;
inline bool ConnectionRequestFrame::_internal_has_keep_alive_timeout_millis() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_keep_alive_timeout_millis() const {
  return _internal_has_keep_alive_timeout_millis();
}
inline void ConnectionRequestFrame::clear_keep_alive_timeout_millis() {
  keep_alive_timeout_millis_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ConnectionRequestFrame::_internal_keep_alive_timeout_millis() const {
  return keep_alive_timeout_millis_;
}
inline int32_t ConnectionRequestFrame::keep_alive_timeout_millis() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.keep_alive_timeout_millis)
  return _internal_keep_alive_timeout_millis();
}
inline void ConnectionRequestFrame::_internal_set_keep_alive_timeout_millis(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  keep_alive_timeout_millis_ = value;
}
inline void ConnectionRequestFrame::set_keep_alive_timeout_millis(int32_t value) {
  _internal_set_keep_alive_timeout_millis(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.keep_alive_timeout_millis)
}

// optional int32 device_type = 10 [default = 0, deprecated = true];
inline bool ConnectionRequestFrame::_internal_has_device_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_device_type() const {
  return _internal_has_device_type();
}
inline void ConnectionRequestFrame::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ConnectionRequestFrame::_internal_device_type() const {
  return device_type_;
}
inline int32_t ConnectionRequestFrame::device_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.device_type)
  return _internal_device_type();
}
inline void ConnectionRequestFrame::_internal_set_device_type(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  device_type_ = value;
}
inline void ConnectionRequestFrame::set_device_type(int32_t value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.device_type)
}

// optional bytes device_info = 11 [deprecated = true];
inline bool ConnectionRequestFrame::_internal_has_device_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConnectionRequestFrame::has_device_info() const {
  return _internal_has_device_info();
}
inline void ConnectionRequestFrame::clear_device_info() {
  device_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConnectionRequestFrame::device_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.device_info)
  return _internal_device_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionRequestFrame::set_device_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 device_info_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.device_info)
}
inline std::string* ConnectionRequestFrame::mutable_device_info() {
  std::string* _s = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.device_info)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_device_info() const {
  return device_info_.Get();
}
inline void ConnectionRequestFrame::_internal_set_device_info(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  device_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_device_info() {
  _has_bits_[0] |= 0x00000010u;
  return device_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_device_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.device_info)
  if (!_internal_has_device_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = device_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionRequestFrame::set_allocated_device_info(std::string* device_info) {
  if (device_info != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  device_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.device_info)
}

// .location.nearby.connections.ConnectionsDevice connections_device = 12;
inline bool ConnectionRequestFrame::_internal_has_connections_device() const {
  return Device_case() == kConnectionsDevice;
}
inline bool ConnectionRequestFrame::has_connections_device() const {
  return _internal_has_connections_device();
}
inline void ConnectionRequestFrame::set_has_connections_device() {
  _oneof_case_[0] = kConnectionsDevice;
}
inline void ConnectionRequestFrame::clear_connections_device() {
  if (_internal_has_connections_device()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Device_.connections_device_;
    }
    clear_has_Device();
  }
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::release_connections_device() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.connections_device)
  if (_internal_has_connections_device()) {
    clear_has_Device();
      ::location::nearby::connections::ConnectionsDevice* temp = Device_.connections_device_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Device_.connections_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::connections::ConnectionsDevice& ConnectionRequestFrame::_internal_connections_device() const {
  return _internal_has_connections_device()
      ? *Device_.connections_device_
      : reinterpret_cast< ::location::nearby::connections::ConnectionsDevice&>(::location::nearby::connections::_ConnectionsDevice_default_instance_);
}
inline const ::location::nearby::connections::ConnectionsDevice& ConnectionRequestFrame::connections_device() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.connections_device)
  return _internal_connections_device();
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::unsafe_arena_release_connections_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.connections.ConnectionRequestFrame.connections_device)
  if (_internal_has_connections_device()) {
    clear_has_Device();
    ::location::nearby::connections::ConnectionsDevice* temp = Device_.connections_device_;
    Device_.connections_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionRequestFrame::unsafe_arena_set_allocated_connections_device(::location::nearby::connections::ConnectionsDevice* connections_device) {
  clear_Device();
  if (connections_device) {
    set_has_connections_device();
    Device_.connections_device_ = connections_device;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionRequestFrame.connections_device)
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::_internal_mutable_connections_device() {
  if (!_internal_has_connections_device()) {
    clear_Device();
    set_has_connections_device();
    Device_.connections_device_ = CreateMaybeMessage< ::location::nearby::connections::ConnectionsDevice >(GetArenaForAllocation());
  }
  return Device_.connections_device_;
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::mutable_connections_device() {
  ::location::nearby::connections::ConnectionsDevice* _msg = _internal_mutable_connections_device();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.connections_device)
  return _msg;
}

// .location.nearby.connections.PresenceDevice presence_device = 13;
inline bool ConnectionRequestFrame::_internal_has_presence_device() const {
  return Device_case() == kPresenceDevice;
}
inline bool ConnectionRequestFrame::has_presence_device() const {
  return _internal_has_presence_device();
}
inline void ConnectionRequestFrame::set_has_presence_device() {
  _oneof_case_[0] = kPresenceDevice;
}
inline void ConnectionRequestFrame::clear_presence_device() {
  if (_internal_has_presence_device()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Device_.presence_device_;
    }
    clear_has_Device();
  }
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::release_presence_device() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.presence_device)
  if (_internal_has_presence_device()) {
    clear_has_Device();
      ::location::nearby::connections::PresenceDevice* temp = Device_.presence_device_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Device_.presence_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::connections::PresenceDevice& ConnectionRequestFrame::_internal_presence_device() const {
  return _internal_has_presence_device()
      ? *Device_.presence_device_
      : reinterpret_cast< ::location::nearby::connections::PresenceDevice&>(::location::nearby::connections::_PresenceDevice_default_instance_);
}
inline const ::location::nearby::connections::PresenceDevice& ConnectionRequestFrame::presence_device() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.presence_device)
  return _internal_presence_device();
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::unsafe_arena_release_presence_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.connections.ConnectionRequestFrame.presence_device)
  if (_internal_has_presence_device()) {
    clear_has_Device();
    ::location::nearby::connections::PresenceDevice* temp = Device_.presence_device_;
    Device_.presence_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionRequestFrame::unsafe_arena_set_allocated_presence_device(::location::nearby::connections::PresenceDevice* presence_device) {
  clear_Device();
  if (presence_device) {
    set_has_presence_device();
    Device_.presence_device_ = presence_device;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionRequestFrame.presence_device)
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::_internal_mutable_presence_device() {
  if (!_internal_has_presence_device()) {
    clear_Device();
    set_has_presence_device();
    Device_.presence_device_ = CreateMaybeMessage< ::location::nearby::connections::PresenceDevice >(GetArenaForAllocation());
  }
  return Device_.presence_device_;
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::mutable_presence_device() {
  ::location::nearby::connections::PresenceDevice* _msg = _internal_mutable_presence_device();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.presence_device)
  return _msg;
}

inline bool ConnectionRequestFrame::has_Device() const {
  return Device_case() != DEVICE_NOT_SET;
}
inline void ConnectionRequestFrame::clear_has_Device() {
  _oneof_case_[0] = DEVICE_NOT_SET;
}
inline ConnectionRequestFrame::DeviceCase ConnectionRequestFrame::Device_case() const {
  return ConnectionRequestFrame::DeviceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConnectionResponseFrame

// optional int32 status = 1 [deprecated = true];
inline bool ConnectionResponseFrame::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnectionResponseFrame::has_status() const {
  return _internal_has_status();
}
inline void ConnectionResponseFrame::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ConnectionResponseFrame::_internal_status() const {
  return status_;
}
inline int32_t ConnectionResponseFrame::status() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.status)
  return _internal_status();
}
inline void ConnectionResponseFrame::_internal_set_status(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void ConnectionResponseFrame::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.status)
}

// optional bytes handshake_data = 2;
inline bool ConnectionResponseFrame::_internal_has_handshake_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectionResponseFrame::has_handshake_data() const {
  return _internal_has_handshake_data();
}
inline void ConnectionResponseFrame::clear_handshake_data() {
  handshake_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionResponseFrame::handshake_data() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.handshake_data)
  return _internal_handshake_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionResponseFrame::set_handshake_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 handshake_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.handshake_data)
}
inline std::string* ConnectionResponseFrame::mutable_handshake_data() {
  std::string* _s = _internal_mutable_handshake_data();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionResponseFrame.handshake_data)
  return _s;
}
inline const std::string& ConnectionResponseFrame::_internal_handshake_data() const {
  return handshake_data_.Get();
}
inline void ConnectionResponseFrame::_internal_set_handshake_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  handshake_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionResponseFrame::_internal_mutable_handshake_data() {
  _has_bits_[0] |= 0x00000001u;
  return handshake_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionResponseFrame::release_handshake_data() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionResponseFrame.handshake_data)
  if (!_internal_has_handshake_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = handshake_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (handshake_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionResponseFrame::set_allocated_handshake_data(std::string* handshake_data) {
  if (handshake_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  handshake_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), handshake_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (handshake_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionResponseFrame.handshake_data)
}

// optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
inline bool ConnectionResponseFrame::_internal_has_response() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnectionResponseFrame::has_response() const {
  return _internal_has_response();
}
inline void ConnectionResponseFrame::clear_response() {
  response_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::_internal_response() const {
  return static_cast< ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus >(response_);
}
inline ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::response() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.response)
  return _internal_response();
}
inline void ConnectionResponseFrame::_internal_set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value) {
  assert(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  response_ = value;
}
inline void ConnectionResponseFrame::set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.response)
}

// optional .location.nearby.connections.OsInfo os_info = 4;
inline bool ConnectionResponseFrame::_internal_has_os_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || os_info_ != nullptr);
  return value;
}
inline bool ConnectionResponseFrame::has_os_info() const {
  return _internal_has_os_info();
}
inline void ConnectionResponseFrame::clear_os_info() {
  if (os_info_ != nullptr) os_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::OsInfo& ConnectionResponseFrame::_internal_os_info() const {
  const ::location::nearby::connections::OsInfo* p = os_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::OsInfo&>(
      ::location::nearby::connections::_OsInfo_default_instance_);
}
inline const ::location::nearby::connections::OsInfo& ConnectionResponseFrame::os_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.os_info)
  return _internal_os_info();
}
inline void ConnectionResponseFrame::unsafe_arena_set_allocated_os_info(
    ::location::nearby::connections::OsInfo* os_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(os_info_);
  }
  os_info_ = os_info;
  if (os_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionResponseFrame.os_info)
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::release_os_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::OsInfo* temp = os_info_;
  os_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::unsafe_arena_release_os_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionResponseFrame.os_info)
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::OsInfo* temp = os_info_;
  os_info_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::_internal_mutable_os_info() {
  _has_bits_[0] |= 0x00000002u;
  if (os_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::OsInfo>(GetArenaForAllocation());
    os_info_ = p;
  }
  return os_info_;
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::mutable_os_info() {
  ::location::nearby::connections::OsInfo* _msg = _internal_mutable_os_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionResponseFrame.os_info)
  return _msg;
}
inline void ConnectionResponseFrame::set_allocated_os_info(::location::nearby::connections::OsInfo* os_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete os_info_;
  }
  if (os_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::OsInfo>::GetOwningArena(os_info);
    if (message_arena != submessage_arena) {
      os_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, os_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  os_info_ = os_info;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionResponseFrame.os_info)
}

// optional int32 multiplex_socket_bitmask = 5;
inline bool ConnectionResponseFrame::_internal_has_multiplex_socket_bitmask() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConnectionResponseFrame::has_multiplex_socket_bitmask() const {
  return _internal_has_multiplex_socket_bitmask();
}
inline void ConnectionResponseFrame::clear_multiplex_socket_bitmask() {
  multiplex_socket_bitmask_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ConnectionResponseFrame::_internal_multiplex_socket_bitmask() const {
  return multiplex_socket_bitmask_;
}
inline int32_t ConnectionResponseFrame::multiplex_socket_bitmask() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.multiplex_socket_bitmask)
  return _internal_multiplex_socket_bitmask();
}
inline void ConnectionResponseFrame::_internal_set_multiplex_socket_bitmask(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  multiplex_socket_bitmask_ = value;
}
inline void ConnectionResponseFrame::set_multiplex_socket_bitmask(int32_t value) {
  _internal_set_multiplex_socket_bitmask(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.multiplex_socket_bitmask)
}

// optional int32 nearby_connections_version = 6 [deprecated = true];
inline bool ConnectionResponseFrame::_internal_has_nearby_connections_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConnectionResponseFrame::has_nearby_connections_version() const {
  return _internal_has_nearby_connections_version();
}
inline void ConnectionResponseFrame::clear_nearby_connections_version() {
  nearby_connections_version_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ConnectionResponseFrame::_internal_nearby_connections_version() const {
  return nearby_connections_version_;
}
inline int32_t ConnectionResponseFrame::nearby_connections_version() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.nearby_connections_version)
  return _internal_nearby_connections_version();
}
inline void ConnectionResponseFrame::_internal_set_nearby_connections_version(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  nearby_connections_version_ = value;
}
inline void ConnectionResponseFrame::set_nearby_connections_version(int32_t value) {
  _internal_set_nearby_connections_version(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.nearby_connections_version)
}

// optional int32 safe_to_disconnect_version = 7;
inline bool ConnectionResponseFrame::_internal_has_safe_to_disconnect_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConnectionResponseFrame::has_safe_to_disconnect_version() const {
  return _internal_has_safe_to_disconnect_version();
}
inline void ConnectionResponseFrame::clear_safe_to_disconnect_version() {
  safe_to_disconnect_version_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ConnectionResponseFrame::_internal_safe_to_disconnect_version() const {
  return safe_to_disconnect_version_;
}
inline int32_t ConnectionResponseFrame::safe_to_disconnect_version() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.safe_to_disconnect_version)
  return _internal_safe_to_disconnect_version();
}
inline void ConnectionResponseFrame::_internal_set_safe_to_disconnect_version(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  safe_to_disconnect_version_ = value;
}
inline void ConnectionResponseFrame::set_safe_to_disconnect_version(int32_t value) {
  _internal_set_safe_to_disconnect_version(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.safe_to_disconnect_version)
}

// -------------------------------------------------------------------

// PayloadTransferFrame_PayloadHeader

// optional int64 id = 1;
inline bool PayloadTransferFrame_PayloadHeader::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadHeader::has_id() const {
  return _internal_has_id();
}
inline void PayloadTransferFrame_PayloadHeader::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t PayloadTransferFrame_PayloadHeader::_internal_id() const {
  return id_;
}
inline int64_t PayloadTransferFrame_PayloadHeader::id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.id)
  return _internal_id();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_id(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void PayloadTransferFrame_PayloadHeader::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.id)
}

// optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
inline bool PayloadTransferFrame_PayloadHeader::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadHeader::has_type() const {
  return _internal_has_type();
}
inline void PayloadTransferFrame_PayloadHeader::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::_internal_type() const {
  return static_cast< ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType >(type_);
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.type)
  return _internal_type();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value) {
  assert(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void PayloadTransferFrame_PayloadHeader::set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.type)
}

// optional int64 total_size = 3;
inline bool PayloadTransferFrame_PayloadHeader::_internal_has_total_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadHeader::has_total_size() const {
  return _internal_has_total_size();
}
inline void PayloadTransferFrame_PayloadHeader::clear_total_size() {
  total_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t PayloadTransferFrame_PayloadHeader::_internal_total_size() const {
  return total_size_;
}
inline int64_t PayloadTransferFrame_PayloadHeader::total_size() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.total_size)
  return _internal_total_size();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_total_size(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  total_size_ = value;
}
inline void PayloadTransferFrame_PayloadHeader::set_total_size(int64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.total_size)
}

// optional bool is_sensitive = 4;
inline bool PayloadTransferFrame_PayloadHeader::_internal_has_is_sensitive() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadHeader::has_is_sensitive() const {
  return _internal_has_is_sensitive();
}
inline void PayloadTransferFrame_PayloadHeader::clear_is_sensitive() {
  is_sensitive_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool PayloadTransferFrame_PayloadHeader::_internal_is_sensitive() const {
  return is_sensitive_;
}
inline bool PayloadTransferFrame_PayloadHeader::is_sensitive() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.is_sensitive)
  return _internal_is_sensitive();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_is_sensitive(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_sensitive_ = value;
}
inline void PayloadTransferFrame_PayloadHeader::set_is_sensitive(bool value) {
  _internal_set_is_sensitive(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.is_sensitive)
}

// optional string file_name = 5;
inline bool PayloadTransferFrame_PayloadHeader::_internal_has_file_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadHeader::has_file_name() const {
  return _internal_has_file_name();
}
inline void PayloadTransferFrame_PayloadHeader::clear_file_name() {
  file_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::file_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PayloadTransferFrame_PayloadHeader::set_file_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
}
inline std::string* PayloadTransferFrame_PayloadHeader::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
  return _s;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::_internal_file_name() const {
  return file_name_.Get();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_file_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::_internal_mutable_file_name() {
  _has_bits_[0] |= 0x00000001u;
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::release_file_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
  if (!_internal_has_file_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = file_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PayloadTransferFrame_PayloadHeader::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
}

// optional string parent_folder = 6;
inline bool PayloadTransferFrame_PayloadHeader::_internal_has_parent_folder() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadHeader::has_parent_folder() const {
  return _internal_has_parent_folder();
}
inline void PayloadTransferFrame_PayloadHeader::clear_parent_folder() {
  parent_folder_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::parent_folder() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
  return _internal_parent_folder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PayloadTransferFrame_PayloadHeader::set_parent_folder(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 parent_folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
}
inline std::string* PayloadTransferFrame_PayloadHeader::mutable_parent_folder() {
  std::string* _s = _internal_mutable_parent_folder();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
  return _s;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::_internal_parent_folder() const {
  return parent_folder_.Get();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_parent_folder(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  parent_folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::_internal_mutable_parent_folder() {
  _has_bits_[0] |= 0x00000002u;
  return parent_folder_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::release_parent_folder() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
  if (!_internal_has_parent_folder()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = parent_folder_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_folder_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_folder_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PayloadTransferFrame_PayloadHeader::set_allocated_parent_folder(std::string* parent_folder) {
  if (parent_folder != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_folder_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_folder,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_folder_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_folder_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
}

// -------------------------------------------------------------------

// PayloadTransferFrame_PayloadChunk

// optional int32 flags = 1;
inline bool PayloadTransferFrame_PayloadChunk::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadChunk::has_flags() const {
  return _internal_has_flags();
}
inline void PayloadTransferFrame_PayloadChunk::clear_flags() {
  flags_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t PayloadTransferFrame_PayloadChunk::_internal_flags() const {
  return flags_;
}
inline int32_t PayloadTransferFrame_PayloadChunk::flags() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.flags)
  return _internal_flags();
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_flags(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
}
inline void PayloadTransferFrame_PayloadChunk::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.flags)
}

// optional int64 offset = 2;
inline bool PayloadTransferFrame_PayloadChunk::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadChunk::has_offset() const {
  return _internal_has_offset();
}
inline void PayloadTransferFrame_PayloadChunk::clear_offset() {
  offset_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t PayloadTransferFrame_PayloadChunk::_internal_offset() const {
  return offset_;
}
inline int64_t PayloadTransferFrame_PayloadChunk::offset() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.offset)
  return _internal_offset();
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_offset(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
}
inline void PayloadTransferFrame_PayloadChunk::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.offset)
}

// optional bytes body = 3;
inline bool PayloadTransferFrame_PayloadChunk::_internal_has_body() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadChunk::has_body() const {
  return _internal_has_body();
}
inline void PayloadTransferFrame_PayloadChunk::clear_body() {
  body_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PayloadTransferFrame_PayloadChunk::body() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PayloadTransferFrame_PayloadChunk::set_body(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 body_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
}
inline std::string* PayloadTransferFrame_PayloadChunk::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
  return _s;
}
inline const std::string& PayloadTransferFrame_PayloadChunk::_internal_body() const {
  return body_.Get();
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_body(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadChunk::_internal_mutable_body() {
  _has_bits_[0] |= 0x00000001u;
  return body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadChunk::release_body() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
  if (!_internal_has_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = body_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PayloadTransferFrame_PayloadChunk::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
}

// optional int32 index = 4;
inline bool PayloadTransferFrame_PayloadChunk::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PayloadTransferFrame_PayloadChunk::has_index() const {
  return _internal_has_index();
}
inline void PayloadTransferFrame_PayloadChunk::clear_index() {
  index_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t PayloadTransferFrame_PayloadChunk::_internal_index() const {
  return index_;
}
inline int32_t PayloadTransferFrame_PayloadChunk::index() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.index)
  return _internal_index();
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_index(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  index_ = value;
}
inline void PayloadTransferFrame_PayloadChunk::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.index)
}

// -------------------------------------------------------------------

// PayloadTransferFrame_ControlMessage

// optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
inline bool PayloadTransferFrame_ControlMessage::_internal_has_event() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PayloadTransferFrame_ControlMessage::has_event() const {
  return _internal_has_event();
}
inline void PayloadTransferFrame_ControlMessage::clear_event() {
  event_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::_internal_event() const {
  return static_cast< ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType >(event_);
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::event() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.ControlMessage.event)
  return _internal_event();
}
inline void PayloadTransferFrame_ControlMessage::_internal_set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value) {
  assert(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  event_ = value;
}
inline void PayloadTransferFrame_ControlMessage::set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.ControlMessage.event)
}

// optional int64 offset = 2;
inline bool PayloadTransferFrame_ControlMessage::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PayloadTransferFrame_ControlMessage::has_offset() const {
  return _internal_has_offset();
}
inline void PayloadTransferFrame_ControlMessage::clear_offset() {
  offset_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t PayloadTransferFrame_ControlMessage::_internal_offset() const {
  return offset_;
}
inline int64_t PayloadTransferFrame_ControlMessage::offset() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.ControlMessage.offset)
  return _internal_offset();
}
inline void PayloadTransferFrame_ControlMessage::_internal_set_offset(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  offset_ = value;
}
inline void PayloadTransferFrame_ControlMessage::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.ControlMessage.offset)
}

// -------------------------------------------------------------------

// PayloadTransferFrame

// optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
inline bool PayloadTransferFrame::_internal_has_packet_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PayloadTransferFrame::has_packet_type() const {
  return _internal_has_packet_type();
}
inline void PayloadTransferFrame::clear_packet_type() {
  packet_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::PayloadTransferFrame_PacketType PayloadTransferFrame::_internal_packet_type() const {
  return static_cast< ::location::nearby::connections::PayloadTransferFrame_PacketType >(packet_type_);
}
inline ::location::nearby::connections::PayloadTransferFrame_PacketType PayloadTransferFrame::packet_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.packet_type)
  return _internal_packet_type();
}
inline void PayloadTransferFrame::_internal_set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value) {
  assert(::location::nearby::connections::PayloadTransferFrame_PacketType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  packet_type_ = value;
}
inline void PayloadTransferFrame::set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value) {
  _internal_set_packet_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.packet_type)
}

// optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
inline bool PayloadTransferFrame::_internal_has_payload_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || payload_header_ != nullptr);
  return value;
}
inline bool PayloadTransferFrame::has_payload_header() const {
  return _internal_has_payload_header();
}
inline void PayloadTransferFrame::clear_payload_header() {
  if (payload_header_ != nullptr) payload_header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& PayloadTransferFrame::_internal_payload_header() const {
  const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* p = payload_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader&>(
      ::location::nearby::connections::_PayloadTransferFrame_PayloadHeader_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& PayloadTransferFrame::payload_header() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.payload_header)
  return _internal_payload_header();
}
inline void PayloadTransferFrame::unsafe_arena_set_allocated_payload_header(
    ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_header_);
  }
  payload_header_ = payload_header;
  if (payload_header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_header)
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::release_payload_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* temp = payload_header_;
  payload_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::unsafe_arena_release_payload_header() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.payload_header)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* temp = payload_header_;
  payload_header_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::_internal_mutable_payload_header() {
  _has_bits_[0] |= 0x00000001u;
  if (payload_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadHeader>(GetArenaForAllocation());
    payload_header_ = p;
  }
  return payload_header_;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::mutable_payload_header() {
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* _msg = _internal_mutable_payload_header();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.payload_header)
  return _msg;
}
inline void PayloadTransferFrame::set_allocated_payload_header(::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payload_header_;
  }
  if (payload_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::PayloadTransferFrame_PayloadHeader>::GetOwningArena(payload_header);
    if (message_arena != submessage_arena) {
      payload_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_header_ = payload_header;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_header)
}

// optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
inline bool PayloadTransferFrame::_internal_has_payload_chunk() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || payload_chunk_ != nullptr);
  return value;
}
inline bool PayloadTransferFrame::has_payload_chunk() const {
  return _internal_has_payload_chunk();
}
inline void PayloadTransferFrame::clear_payload_chunk() {
  if (payload_chunk_ != nullptr) payload_chunk_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& PayloadTransferFrame::_internal_payload_chunk() const {
  const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* p = payload_chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk&>(
      ::location::nearby::connections::_PayloadTransferFrame_PayloadChunk_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& PayloadTransferFrame::payload_chunk() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.payload_chunk)
  return _internal_payload_chunk();
}
inline void PayloadTransferFrame::unsafe_arena_set_allocated_payload_chunk(
    ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_chunk_);
  }
  payload_chunk_ = payload_chunk;
  if (payload_chunk) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_chunk)
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::release_payload_chunk() {
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* temp = payload_chunk_;
  payload_chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::unsafe_arena_release_payload_chunk() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.payload_chunk)
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* temp = payload_chunk_;
  payload_chunk_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::_internal_mutable_payload_chunk() {
  _has_bits_[0] |= 0x00000002u;
  if (payload_chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadChunk>(GetArenaForAllocation());
    payload_chunk_ = p;
  }
  return payload_chunk_;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::mutable_payload_chunk() {
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* _msg = _internal_mutable_payload_chunk();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.payload_chunk)
  return _msg;
}
inline void PayloadTransferFrame::set_allocated_payload_chunk(::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payload_chunk_;
  }
  if (payload_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::PayloadTransferFrame_PayloadChunk>::GetOwningArena(payload_chunk);
    if (message_arena != submessage_arena) {
      payload_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_chunk, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  payload_chunk_ = payload_chunk;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_chunk)
}

// optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
inline bool PayloadTransferFrame::_internal_has_control_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || control_message_ != nullptr);
  return value;
}
inline bool PayloadTransferFrame::has_control_message() const {
  return _internal_has_control_message();
}
inline void PayloadTransferFrame::clear_control_message() {
  if (control_message_ != nullptr) control_message_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& PayloadTransferFrame::_internal_control_message() const {
  const ::location::nearby::connections::PayloadTransferFrame_ControlMessage* p = control_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame_ControlMessage&>(
      ::location::nearby::connections::_PayloadTransferFrame_ControlMessage_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& PayloadTransferFrame::control_message() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.control_message)
  return _internal_control_message();
}
inline void PayloadTransferFrame::unsafe_arena_set_allocated_control_message(
    ::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_message_);
  }
  control_message_ = control_message;
  if (control_message) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.PayloadTransferFrame.control_message)
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::release_control_message() {
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* temp = control_message_;
  control_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::unsafe_arena_release_control_message() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.control_message)
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* temp = control_message_;
  control_message_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::_internal_mutable_control_message() {
  _has_bits_[0] |= 0x00000004u;
  if (control_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_ControlMessage>(GetArenaForAllocation());
    control_message_ = p;
  }
  return control_message_;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::mutable_control_message() {
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* _msg = _internal_mutable_control_message();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.control_message)
  return _msg;
}
inline void PayloadTransferFrame::set_allocated_control_message(::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete control_message_;
  }
  if (control_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::PayloadTransferFrame_ControlMessage>::GetOwningArena(control_message);
    if (message_arena != submessage_arena) {
      control_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  control_message_ = control_message;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.control_message)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials

// optional string ssid = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_has_ssid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_ssid() const {
  return _internal_has_ssid();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_ssid() {
  ssid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ssid() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
  return _internal_ssid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_ssid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::mutable_ssid() {
  std::string* _s = _internal_mutable_ssid();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_ssid() const {
  return ssid_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_ssid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_mutable_ssid() {
  _has_bits_[0] |= 0x00000001u;
  return ssid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::release_ssid() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
  if (!_internal_has_ssid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ssid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ssid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_allocated_ssid(std::string* ssid) {
  if (ssid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ssid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ssid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ssid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
}

// optional string password = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_password() const {
  return _internal_has_password();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::password() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_password() const {
  return password_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::release_password() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
}

// optional int32 port = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_port() const {
  return _internal_has_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_port() const {
  return port_;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::port() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.port)
  return _internal_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_port(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  port_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.port)
}

// optional string gateway = 4 [default = "0.0.0.0"];
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_has_gateway() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_gateway() const {
  return _internal_has_gateway();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_gateway() {
  gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::gateway() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
  if (gateway_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_gateway_.get();
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_gateway(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_gateway() const {
  return gateway_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_gateway(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_mutable_gateway() {
  _has_bits_[0] |= 0x00000004u;
  return gateway_.Mutable(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::release_gateway() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
  if (!_internal_has_gateway()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = gateway_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gateway_.SetAllocated(nullptr, gateway,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
}

// optional int32 frequency = 5 [default = -1];
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_has_frequency() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_frequency() const {
  return _internal_has_frequency();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_frequency() {
  frequency_ = -1;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_frequency() const {
  return frequency_;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::frequency() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.frequency)
  return _internal_frequency();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_frequency(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  frequency_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_frequency(int32_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.frequency)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket

// optional bytes ip_address = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_has_ip_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::clear_ip_address() {
  ip_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ip_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::set_ip_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ip_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_set_ip_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_mutable_ip_address() {
  _has_bits_[0] |= 0x00000001u;
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::release_ip_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
  if (!_internal_has_ip_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ip_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
}

// optional int32 wifi_port = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_has_wifi_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::has_wifi_port() const {
  return _internal_has_wifi_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::clear_wifi_port() {
  wifi_port_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_wifi_port() const {
  return wifi_port_;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::wifi_port() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.wifi_port)
  return _internal_wifi_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_set_wifi_port(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  wifi_port_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::set_wifi_port(int32_t value) {
  _internal_set_wifi_port(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.wifi_port)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials

// optional string service_name = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_has_service_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::has_service_name() const {
  return _internal_has_service_name();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::clear_service_name() {
  service_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::service_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_service_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_service_name() const {
  return service_name_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_set_service_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_mutable_service_name() {
  _has_bits_[0] |= 0x00000001u;
  return service_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::release_service_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
  if (!_internal_has_service_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = service_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
}

// optional string mac_address = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_has_mac_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::has_mac_address() const {
  return _internal_has_mac_address();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::clear_mac_address() {
  mac_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::mac_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_mac_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_set_mac_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_mutable_mac_address() {
  _has_bits_[0] |= 0x00000002u;
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::release_mac_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
  if (!_internal_has_mac_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = mac_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials

// optional string service_id = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_has_service_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::has_service_id() const {
  return _internal_has_service_id();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::clear_service_id() {
  service_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::service_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
  return _internal_service_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_service_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 service_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::mutable_service_id() {
  std::string* _s = _internal_mutable_service_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_service_id() const {
  return service_id_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_set_service_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  service_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_mutable_service_id() {
  _has_bits_[0] |= 0x00000001u;
  return service_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::release_service_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
  if (!_internal_has_service_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = service_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_allocated_service_id(std::string* service_id) {
  if (service_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  service_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
}

// optional bytes service_info = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_has_service_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::has_service_info() const {
  return _internal_has_service_info();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::clear_service_info() {
  service_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::service_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
  return _internal_service_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_service_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 service_info_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::mutable_service_info() {
  std::string* _s = _internal_mutable_service_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_service_info() const {
  return service_info_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_set_service_info(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  service_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_mutable_service_info() {
  _has_bits_[0] |= 0x00000002u;
  return service_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::release_service_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
  if (!_internal_has_service_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = service_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_allocated_service_info(std::string* service_info) {
  if (service_info != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  service_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
}

// optional string password = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::has_password() const {
  return _internal_has_password();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::password() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_password() const {
  return password_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000004u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::release_password() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials

// optional string ssid = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_has_ssid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_ssid() const {
  return _internal_has_ssid();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_ssid() {
  ssid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ssid() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
  return _internal_ssid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_ssid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_ssid() {
  std::string* _s = _internal_mutable_ssid();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_ssid() const {
  return ssid_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_ssid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_ssid() {
  _has_bits_[0] |= 0x00000001u;
  return ssid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_ssid() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
  if (!_internal_has_ssid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ssid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ssid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_ssid(std::string* ssid) {
  if (ssid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ssid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ssid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ssid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
}

// optional string password = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_password() const {
  return _internal_has_password();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::password() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_password() const {
  return password_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_password() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
}

// optional int32 port = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_port() const {
  return _internal_has_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_port() const {
  return port_;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::port() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.port)
  return _internal_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_port(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  port_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.port)
}

// optional int32 frequency = 4;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_has_frequency() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_frequency() const {
  return _internal_has_frequency();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_frequency() {
  frequency_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_frequency() const {
  return frequency_;
}
inline int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::frequency() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.frequency)
  return _internal_frequency();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_frequency(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  frequency_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_frequency(int32_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.frequency)
}

// optional string gateway = 5 [default = "0.0.0.0"];
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_has_gateway() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_gateway() const {
  return _internal_has_gateway();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_gateway() {
  gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::gateway() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
  if (gateway_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_gateway_.get();
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_gateway(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_gateway() const {
  return gateway_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_gateway(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_gateway() {
  _has_bits_[0] |= 0x00000004u;
  return gateway_.Mutable(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_gateway() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
  if (!_internal_has_gateway()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = gateway_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gateway_.SetAllocated(nullptr, gateway,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
}

// optional bytes ip_v6_address = 6;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_has_ip_v6_address() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_ip_v6_address() const {
  return _internal_has_ip_v6_address();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_ip_v6_address() {
  ip_v6_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ip_v6_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
  return _internal_ip_v6_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_ip_v6_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 ip_v6_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_ip_v6_address() {
  std::string* _s = _internal_mutable_ip_v6_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_ip_v6_address() const {
  return ip_v6_address_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_ip_v6_address(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  ip_v6_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_ip_v6_address() {
  _has_bits_[0] |= 0x00000008u;
  return ip_v6_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_ip_v6_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
  if (!_internal_has_ip_v6_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = ip_v6_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_v6_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_v6_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_ip_v6_address(std::string* ip_v6_address) {
  if (ip_v6_address != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ip_v6_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_v6_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_v6_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_v6_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials

// optional string peer_id = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_has_peer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::has_peer_id() const {
  return _internal_has_peer_id();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::clear_peer_id() {
  peer_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::peer_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
  return _internal_peer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::set_peer_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::mutable_peer_id() {
  std::string* _s = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_peer_id() const {
  return peer_id_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_set_peer_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_mutable_peer_id() {
  _has_bits_[0] |= 0x00000001u;
  return peer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::release_peer_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
  if (!_internal_has_peer_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = peer_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::set_allocated_peer_id(std::string* peer_id) {
  if (peer_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
}

// optional .location.nearby.connections.LocationHint location_hint = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_has_location_hint() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || location_hint_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::has_location_hint() const {
  return _internal_has_location_hint();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::clear_location_hint() {
  if (location_hint_ != nullptr) location_hint_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::LocationHint& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_location_hint() const {
  const ::location::nearby::connections::LocationHint* p = location_hint_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::LocationHint&>(
      ::location::nearby::connections::_LocationHint_default_instance_);
}
inline const ::location::nearby::connections::LocationHint& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::location_hint() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
  return _internal_location_hint();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::unsafe_arena_set_allocated_location_hint(
    ::location::nearby::connections::LocationHint* location_hint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_hint_);
  }
  location_hint_ = location_hint;
  if (location_hint) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::release_location_hint() {
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::LocationHint* temp = location_hint_;
  location_hint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::unsafe_arena_release_location_hint() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::LocationHint* temp = location_hint_;
  location_hint_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_mutable_location_hint() {
  _has_bits_[0] |= 0x00000002u;
  if (location_hint_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::LocationHint>(GetArenaForAllocation());
    location_hint_ = p;
  }
  return location_hint_;
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::mutable_location_hint() {
  ::location::nearby::connections::LocationHint* _msg = _internal_mutable_location_hint();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::set_allocated_location_hint(::location::nearby::connections::LocationHint* location_hint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_hint_;
  }
  if (location_hint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::LocationHint>::GetOwningArena(location_hint);
    if (message_arena != submessage_arena) {
      location_hint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location_hint, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  location_hint_ = location_hint;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_medium() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_medium() const {
  return _internal_has_medium();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_medium() {
  medium_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_medium() const {
  return static_cast< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium >(medium_);
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::medium() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.medium)
  return _internal_medium();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value) {
  assert(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  medium_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value) {
  _internal_set_medium(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.medium)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_wifi_hotspot_credentials() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || wifi_hotspot_credentials_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_hotspot_credentials() const {
  return _internal_has_wifi_hotspot_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_hotspot_credentials() {
  if (wifi_hotspot_credentials_ != nullptr) wifi_hotspot_credentials_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_hotspot_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* p = wifi_hotspot_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_hotspot_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
  return _internal_wifi_hotspot_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_hotspot_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_hotspot_credentials_);
  }
  wifi_hotspot_credentials_ = wifi_hotspot_credentials;
  if (wifi_hotspot_credentials) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_hotspot_credentials() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* temp = wifi_hotspot_credentials_;
  wifi_hotspot_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_hotspot_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* temp = wifi_hotspot_credentials_;
  wifi_hotspot_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_hotspot_credentials() {
  _has_bits_[0] |= 0x00000001u;
  if (wifi_hotspot_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(GetArenaForAllocation());
    wifi_hotspot_credentials_ = p;
  }
  return wifi_hotspot_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_hotspot_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* _msg = _internal_mutable_wifi_hotspot_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_hotspot_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_hotspot_credentials_;
  }
  if (wifi_hotspot_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>::GetOwningArena(wifi_hotspot_credentials);
    if (message_arena != submessage_arena) {
      wifi_hotspot_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_hotspot_credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  wifi_hotspot_credentials_ = wifi_hotspot_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_wifi_lan_socket() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || wifi_lan_socket_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_lan_socket() const {
  return _internal_has_wifi_lan_socket();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_lan_socket() {
  if (wifi_lan_socket_ != nullptr) wifi_lan_socket_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_lan_socket() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* p = wifi_lan_socket_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_lan_socket() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
  return _internal_wifi_lan_socket();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_lan_socket(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_lan_socket_);
  }
  wifi_lan_socket_ = wifi_lan_socket;
  if (wifi_lan_socket) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_lan_socket() {
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* temp = wifi_lan_socket_;
  wifi_lan_socket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_lan_socket() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* temp = wifi_lan_socket_;
  wifi_lan_socket_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_lan_socket() {
  _has_bits_[0] |= 0x00000002u;
  if (wifi_lan_socket_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(GetArenaForAllocation());
    wifi_lan_socket_ = p;
  }
  return wifi_lan_socket_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_lan_socket() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* _msg = _internal_mutable_wifi_lan_socket();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_lan_socket(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_lan_socket_;
  }
  if (wifi_lan_socket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>::GetOwningArena(wifi_lan_socket);
    if (message_arena != submessage_arena) {
      wifi_lan_socket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_lan_socket, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  wifi_lan_socket_ = wifi_lan_socket;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_bluetooth_credentials() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || bluetooth_credentials_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_bluetooth_credentials() const {
  return _internal_has_bluetooth_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_bluetooth_credentials() {
  if (bluetooth_credentials_ != nullptr) bluetooth_credentials_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_bluetooth_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* p = bluetooth_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::bluetooth_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
  return _internal_bluetooth_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_bluetooth_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bluetooth_credentials_);
  }
  bluetooth_credentials_ = bluetooth_credentials;
  if (bluetooth_credentials) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_bluetooth_credentials() {
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* temp = bluetooth_credentials_;
  bluetooth_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_bluetooth_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* temp = bluetooth_credentials_;
  bluetooth_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_bluetooth_credentials() {
  _has_bits_[0] |= 0x00000004u;
  if (bluetooth_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(GetArenaForAllocation());
    bluetooth_credentials_ = p;
  }
  return bluetooth_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_bluetooth_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* _msg = _internal_mutable_bluetooth_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_bluetooth_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bluetooth_credentials_;
  }
  if (bluetooth_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>::GetOwningArena(bluetooth_credentials);
    if (message_arena != submessage_arena) {
      bluetooth_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bluetooth_credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  bluetooth_credentials_ = bluetooth_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_wifi_aware_credentials() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || wifi_aware_credentials_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_aware_credentials() const {
  return _internal_has_wifi_aware_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_aware_credentials() {
  if (wifi_aware_credentials_ != nullptr) wifi_aware_credentials_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_aware_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* p = wifi_aware_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_aware_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
  return _internal_wifi_aware_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_aware_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_aware_credentials_);
  }
  wifi_aware_credentials_ = wifi_aware_credentials;
  if (wifi_aware_credentials) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_aware_credentials() {
  _has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* temp = wifi_aware_credentials_;
  wifi_aware_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_aware_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
  _has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* temp = wifi_aware_credentials_;
  wifi_aware_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_aware_credentials() {
  _has_bits_[0] |= 0x00000008u;
  if (wifi_aware_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(GetArenaForAllocation());
    wifi_aware_credentials_ = p;
  }
  return wifi_aware_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_aware_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* _msg = _internal_mutable_wifi_aware_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_aware_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_aware_credentials_;
  }
  if (wifi_aware_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>::GetOwningArena(wifi_aware_credentials);
    if (message_arena != submessage_arena) {
      wifi_aware_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_aware_credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  wifi_aware_credentials_ = wifi_aware_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_wifi_direct_credentials() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || wifi_direct_credentials_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_direct_credentials() const {
  return _internal_has_wifi_direct_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_direct_credentials() {
  if (wifi_direct_credentials_ != nullptr) wifi_direct_credentials_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_direct_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* p = wifi_direct_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_direct_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
  return _internal_wifi_direct_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_direct_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_direct_credentials_);
  }
  wifi_direct_credentials_ = wifi_direct_credentials;
  if (wifi_direct_credentials) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_direct_credentials() {
  _has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* temp = wifi_direct_credentials_;
  wifi_direct_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_direct_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
  _has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* temp = wifi_direct_credentials_;
  wifi_direct_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_direct_credentials() {
  _has_bits_[0] |= 0x00000010u;
  if (wifi_direct_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(GetArenaForAllocation());
    wifi_direct_credentials_ = p;
  }
  return wifi_direct_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_direct_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* _msg = _internal_mutable_wifi_direct_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_direct_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_direct_credentials_;
  }
  if (wifi_direct_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>::GetOwningArena(wifi_direct_credentials);
    if (message_arena != submessage_arena) {
      wifi_direct_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_direct_credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  wifi_direct_credentials_ = wifi_direct_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_web_rtc_credentials() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || web_rtc_credentials_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_web_rtc_credentials() const {
  return _internal_has_web_rtc_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_web_rtc_credentials() {
  if (web_rtc_credentials_ != nullptr) web_rtc_credentials_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_web_rtc_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* p = web_rtc_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::web_rtc_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
  return _internal_web_rtc_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_web_rtc_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_rtc_credentials_);
  }
  web_rtc_credentials_ = web_rtc_credentials;
  if (web_rtc_credentials) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_web_rtc_credentials() {
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* temp = web_rtc_credentials_;
  web_rtc_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_web_rtc_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* temp = web_rtc_credentials_;
  web_rtc_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_web_rtc_credentials() {
  _has_bits_[0] |= 0x00000020u;
  if (web_rtc_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(GetArenaForAllocation());
    web_rtc_credentials_ = p;
  }
  return web_rtc_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_web_rtc_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* _msg = _internal_mutable_web_rtc_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_web_rtc_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete web_rtc_credentials_;
  }
  if (web_rtc_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>::GetOwningArena(web_rtc_credentials);
    if (message_arena != submessage_arena) {
      web_rtc_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, web_rtc_credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  web_rtc_credentials_ = web_rtc_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
}

// optional bool supports_disabling_encryption = 7;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_supports_disabling_encryption() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_supports_disabling_encryption() const {
  return _internal_has_supports_disabling_encryption();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_supports_disabling_encryption() {
  supports_disabling_encryption_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_supports_disabling_encryption() const {
  return supports_disabling_encryption_;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::supports_disabling_encryption() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_disabling_encryption)
  return _internal_supports_disabling_encryption();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_set_supports_disabling_encryption(bool value) {
  _has_bits_[0] |= 0x00000080u;
  supports_disabling_encryption_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_supports_disabling_encryption(bool value) {
  _internal_set_supports_disabling_encryption(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_disabling_encryption)
}

// optional bool supports_client_introduction_ack = 9;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_has_supports_client_introduction_ack() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_supports_client_introduction_ack() const {
  return _internal_has_supports_client_introduction_ack();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_supports_client_introduction_ack() {
  supports_client_introduction_ack_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_supports_client_introduction_ack() const {
  return supports_client_introduction_ack_;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::supports_client_introduction_ack() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_client_introduction_ack)
  return _internal_supports_client_introduction_ack();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_set_supports_client_introduction_ack(bool value) {
  _has_bits_[0] |= 0x00000100u;
  supports_client_introduction_ack_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_supports_client_introduction_ack(bool value) {
  _internal_set_supports_client_introduction_ack(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_client_introduction_ack)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_ClientIntroduction

// optional string endpoint_id = 1;
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_has_endpoint_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::has_endpoint_id() const {
  return _internal_has_endpoint_id();
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::clear_endpoint_id() {
  endpoint_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_ClientIntroduction::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
  return _internal_endpoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BandwidthUpgradeNegotiationFrame_ClientIntroduction::set_endpoint_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
}
inline std::string* BandwidthUpgradeNegotiationFrame_ClientIntroduction::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_endpoint_id() const {
  return endpoint_id_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_set_endpoint_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_mutable_endpoint_id() {
  _has_bits_[0] |= 0x00000001u;
  return endpoint_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_ClientIntroduction::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
  if (!_internal_has_endpoint_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = endpoint_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::set_allocated_endpoint_id(std::string* endpoint_id) {
  if (endpoint_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
}

// optional bool supports_disabling_encryption = 2;
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_has_supports_disabling_encryption() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::has_supports_disabling_encryption() const {
  return _internal_has_supports_disabling_encryption();
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::clear_supports_disabling_encryption() {
  supports_disabling_encryption_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_supports_disabling_encryption() const {
  return supports_disabling_encryption_;
}
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::supports_disabling_encryption() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.supports_disabling_encryption)
  return _internal_supports_disabling_encryption();
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_set_supports_disabling_encryption(bool value) {
  _has_bits_[0] |= 0x00000002u;
  supports_disabling_encryption_ = value;
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::set_supports_disabling_encryption(bool value) {
  _internal_set_supports_disabling_encryption(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.supports_disabling_encryption)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_ClientIntroductionAck

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
inline bool BandwidthUpgradeNegotiationFrame::_internal_has_event_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame::has_event_type() const {
  return _internal_has_event_type();
}
inline void BandwidthUpgradeNegotiationFrame::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::_internal_event_type() const {
  return static_cast< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType >(event_type_);
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::event_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.event_type)
  return _internal_event_type();
}
inline void BandwidthUpgradeNegotiationFrame::_internal_set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value) {
  assert(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  event_type_ = value;
}
inline void BandwidthUpgradeNegotiationFrame::set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.event_type)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
inline bool BandwidthUpgradeNegotiationFrame::_internal_has_upgrade_path_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || upgrade_path_info_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame::has_upgrade_path_info() const {
  return _internal_has_upgrade_path_info();
}
inline void BandwidthUpgradeNegotiationFrame::clear_upgrade_path_info() {
  if (upgrade_path_info_ != nullptr) upgrade_path_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& BandwidthUpgradeNegotiationFrame::_internal_upgrade_path_info() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* p = upgrade_path_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& BandwidthUpgradeNegotiationFrame::upgrade_path_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
  return _internal_upgrade_path_info();
}
inline void BandwidthUpgradeNegotiationFrame::unsafe_arena_set_allocated_upgrade_path_info(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(upgrade_path_info_);
  }
  upgrade_path_info_ = upgrade_path_info;
  if (upgrade_path_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::release_upgrade_path_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* temp = upgrade_path_info_;
  upgrade_path_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::unsafe_arena_release_upgrade_path_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* temp = upgrade_path_info_;
  upgrade_path_info_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::_internal_mutable_upgrade_path_info() {
  _has_bits_[0] |= 0x00000001u;
  if (upgrade_path_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(GetArenaForAllocation());
    upgrade_path_info_ = p;
  }
  return upgrade_path_info_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::mutable_upgrade_path_info() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* _msg = _internal_mutable_upgrade_path_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame::set_allocated_upgrade_path_info(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete upgrade_path_info_;
  }
  if (upgrade_path_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo>::GetOwningArena(upgrade_path_info);
    if (message_arena != submessage_arena) {
      upgrade_path_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upgrade_path_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  upgrade_path_info_ = upgrade_path_info;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
inline bool BandwidthUpgradeNegotiationFrame::_internal_has_client_introduction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || client_introduction_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame::has_client_introduction() const {
  return _internal_has_client_introduction();
}
inline void BandwidthUpgradeNegotiationFrame::clear_client_introduction() {
  if (client_introduction_ != nullptr) client_introduction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& BandwidthUpgradeNegotiationFrame::_internal_client_introduction() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* p = client_introduction_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& BandwidthUpgradeNegotiationFrame::client_introduction() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
  return _internal_client_introduction();
}
inline void BandwidthUpgradeNegotiationFrame::unsafe_arena_set_allocated_client_introduction(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_introduction_);
  }
  client_introduction_ = client_introduction;
  if (client_introduction) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::release_client_introduction() {
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* temp = client_introduction_;
  client_introduction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::unsafe_arena_release_client_introduction() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
  _has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* temp = client_introduction_;
  client_introduction_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::_internal_mutable_client_introduction() {
  _has_bits_[0] |= 0x00000002u;
  if (client_introduction_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction>(GetArenaForAllocation());
    client_introduction_ = p;
  }
  return client_introduction_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::mutable_client_introduction() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* _msg = _internal_mutable_client_introduction();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame::set_allocated_client_introduction(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_introduction_;
  }
  if (client_introduction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction>::GetOwningArena(client_introduction);
    if (message_arena != submessage_arena) {
      client_introduction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_introduction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_introduction_ = client_introduction;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
inline bool BandwidthUpgradeNegotiationFrame::_internal_has_client_introduction_ack() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || client_introduction_ack_ != nullptr);
  return value;
}
inline bool BandwidthUpgradeNegotiationFrame::has_client_introduction_ack() const {
  return _internal_has_client_introduction_ack();
}
inline void BandwidthUpgradeNegotiationFrame::clear_client_introduction_ack() {
  if (client_introduction_ack_ != nullptr) client_introduction_ack_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& BandwidthUpgradeNegotiationFrame::_internal_client_introduction_ack() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* p = client_introduction_ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& BandwidthUpgradeNegotiationFrame::client_introduction_ack() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
  return _internal_client_introduction_ack();
}
inline void BandwidthUpgradeNegotiationFrame::unsafe_arena_set_allocated_client_introduction_ack(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_introduction_ack_);
  }
  client_introduction_ack_ = client_introduction_ack;
  if (client_introduction_ack) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::release_client_introduction_ack() {
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* temp = client_introduction_ack_;
  client_introduction_ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::unsafe_arena_release_client_introduction_ack() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* temp = client_introduction_ack_;
  client_introduction_ack_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::_internal_mutable_client_introduction_ack() {
  _has_bits_[0] |= 0x00000004u;
  if (client_introduction_ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(GetArenaForAllocation());
    client_introduction_ack_ = p;
  }
  return client_introduction_ack_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::mutable_client_introduction_ack() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* _msg = _internal_mutable_client_introduction_ack();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame::set_allocated_client_introduction_ack(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_introduction_ack_;
  }
  if (client_introduction_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>::GetOwningArena(client_introduction_ack);
    if (message_arena != submessage_arena) {
      client_introduction_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_introduction_ack, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  client_introduction_ack_ = client_introduction_ack;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
}

// -------------------------------------------------------------------

// KeepAliveFrame

// optional bool ack = 1;
inline bool KeepAliveFrame::_internal_has_ack() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeepAliveFrame::has_ack() const {
  return _internal_has_ack();
}
inline void KeepAliveFrame::clear_ack() {
  ack_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool KeepAliveFrame::_internal_ack() const {
  return ack_;
}
inline bool KeepAliveFrame::ack() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.KeepAliveFrame.ack)
  return _internal_ack();
}
inline void KeepAliveFrame::_internal_set_ack(bool value) {
  _has_bits_[0] |= 0x00000001u;
  ack_ = value;
}
inline void KeepAliveFrame::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.KeepAliveFrame.ack)
}

// optional uint32 seq_num = 2;
inline bool KeepAliveFrame::_internal_has_seq_num() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeepAliveFrame::has_seq_num() const {
  return _internal_has_seq_num();
}
inline void KeepAliveFrame::clear_seq_num() {
  seq_num_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t KeepAliveFrame::_internal_seq_num() const {
  return seq_num_;
}
inline uint32_t KeepAliveFrame::seq_num() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.KeepAliveFrame.seq_num)
  return _internal_seq_num();
}
inline void KeepAliveFrame::_internal_set_seq_num(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  seq_num_ = value;
}
inline void KeepAliveFrame::set_seq_num(uint32_t value) {
  _internal_set_seq_num(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.KeepAliveFrame.seq_num)
}

// -------------------------------------------------------------------

// DisconnectionFrame

// optional bool request_safe_to_disconnect = 1;
inline bool DisconnectionFrame::_internal_has_request_safe_to_disconnect() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisconnectionFrame::has_request_safe_to_disconnect() const {
  return _internal_has_request_safe_to_disconnect();
}
inline void DisconnectionFrame::clear_request_safe_to_disconnect() {
  request_safe_to_disconnect_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool DisconnectionFrame::_internal_request_safe_to_disconnect() const {
  return request_safe_to_disconnect_;
}
inline bool DisconnectionFrame::request_safe_to_disconnect() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.DisconnectionFrame.request_safe_to_disconnect)
  return _internal_request_safe_to_disconnect();
}
inline void DisconnectionFrame::_internal_set_request_safe_to_disconnect(bool value) {
  _has_bits_[0] |= 0x00000001u;
  request_safe_to_disconnect_ = value;
}
inline void DisconnectionFrame::set_request_safe_to_disconnect(bool value) {
  _internal_set_request_safe_to_disconnect(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.DisconnectionFrame.request_safe_to_disconnect)
}

// optional bool ack_safe_to_disconnect = 2;
inline bool DisconnectionFrame::_internal_has_ack_safe_to_disconnect() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DisconnectionFrame::has_ack_safe_to_disconnect() const {
  return _internal_has_ack_safe_to_disconnect();
}
inline void DisconnectionFrame::clear_ack_safe_to_disconnect() {
  ack_safe_to_disconnect_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DisconnectionFrame::_internal_ack_safe_to_disconnect() const {
  return ack_safe_to_disconnect_;
}
inline bool DisconnectionFrame::ack_safe_to_disconnect() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.DisconnectionFrame.ack_safe_to_disconnect)
  return _internal_ack_safe_to_disconnect();
}
inline void DisconnectionFrame::_internal_set_ack_safe_to_disconnect(bool value) {
  _has_bits_[0] |= 0x00000002u;
  ack_safe_to_disconnect_ = value;
}
inline void DisconnectionFrame::set_ack_safe_to_disconnect(bool value) {
  _internal_set_ack_safe_to_disconnect(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.DisconnectionFrame.ack_safe_to_disconnect)
}

// -------------------------------------------------------------------

// PairedKeyEncryptionFrame

// optional bytes signed_data = 1;
inline bool PairedKeyEncryptionFrame::_internal_has_signed_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PairedKeyEncryptionFrame::has_signed_data() const {
  return _internal_has_signed_data();
}
inline void PairedKeyEncryptionFrame::clear_signed_data() {
  signed_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PairedKeyEncryptionFrame::signed_data() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
  return _internal_signed_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PairedKeyEncryptionFrame::set_signed_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 signed_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
}
inline std::string* PairedKeyEncryptionFrame::mutable_signed_data() {
  std::string* _s = _internal_mutable_signed_data();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
  return _s;
}
inline const std::string& PairedKeyEncryptionFrame::_internal_signed_data() const {
  return signed_data_.Get();
}
inline void PairedKeyEncryptionFrame::_internal_set_signed_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signed_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::_internal_mutable_signed_data() {
  _has_bits_[0] |= 0x00000001u;
  return signed_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::release_signed_data() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
  if (!_internal_has_signed_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = signed_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signed_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signed_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PairedKeyEncryptionFrame::set_allocated_signed_data(std::string* signed_data) {
  if (signed_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signed_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signed_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signed_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signed_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
}

// -------------------------------------------------------------------

// AuthenticationMessageFrame

// optional bytes auth_message = 1;
inline bool AuthenticationMessageFrame::_internal_has_auth_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticationMessageFrame::has_auth_message() const {
  return _internal_has_auth_message();
}
inline void AuthenticationMessageFrame::clear_auth_message() {
  auth_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticationMessageFrame::auth_message() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AuthenticationMessageFrame.auth_message)
  return _internal_auth_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticationMessageFrame::set_auth_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 auth_message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.AuthenticationMessageFrame.auth_message)
}
inline std::string* AuthenticationMessageFrame::mutable_auth_message() {
  std::string* _s = _internal_mutable_auth_message();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.AuthenticationMessageFrame.auth_message)
  return _s;
}
inline const std::string& AuthenticationMessageFrame::_internal_auth_message() const {
  return auth_message_.Get();
}
inline void AuthenticationMessageFrame::_internal_set_auth_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  auth_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticationMessageFrame::_internal_mutable_auth_message() {
  _has_bits_[0] |= 0x00000001u;
  return auth_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticationMessageFrame::release_auth_message() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.AuthenticationMessageFrame.auth_message)
  if (!_internal_has_auth_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = auth_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticationMessageFrame::set_allocated_auth_message(std::string* auth_message) {
  if (auth_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  auth_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.AuthenticationMessageFrame.auth_message)
}

// -------------------------------------------------------------------

// AuthenticationResultFrame

// optional int32 result = 1;
inline bool AuthenticationResultFrame::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticationResultFrame::has_result() const {
  return _internal_has_result();
}
inline void AuthenticationResultFrame::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t AuthenticationResultFrame::_internal_result() const {
  return result_;
}
inline int32_t AuthenticationResultFrame::result() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AuthenticationResultFrame.result)
  return _internal_result();
}
inline void AuthenticationResultFrame::_internal_set_result(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
}
inline void AuthenticationResultFrame::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AuthenticationResultFrame.result)
}

// -------------------------------------------------------------------

// AutoResumeFrame

// optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
inline bool AutoResumeFrame::_internal_has_event_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutoResumeFrame::has_event_type() const {
  return _internal_has_event_type();
}
inline void AutoResumeFrame::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::AutoResumeFrame_EventType AutoResumeFrame::_internal_event_type() const {
  return static_cast< ::location::nearby::connections::AutoResumeFrame_EventType >(event_type_);
}
inline ::location::nearby::connections::AutoResumeFrame_EventType AutoResumeFrame::event_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoResumeFrame.event_type)
  return _internal_event_type();
}
inline void AutoResumeFrame::_internal_set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value) {
  assert(::location::nearby::connections::AutoResumeFrame_EventType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  event_type_ = value;
}
inline void AutoResumeFrame::set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoResumeFrame.event_type)
}

// optional int64 pending_payload_id = 2;
inline bool AutoResumeFrame::_internal_has_pending_payload_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutoResumeFrame::has_pending_payload_id() const {
  return _internal_has_pending_payload_id();
}
inline void AutoResumeFrame::clear_pending_payload_id() {
  pending_payload_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t AutoResumeFrame::_internal_pending_payload_id() const {
  return pending_payload_id_;
}
inline int64_t AutoResumeFrame::pending_payload_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoResumeFrame.pending_payload_id)
  return _internal_pending_payload_id();
}
inline void AutoResumeFrame::_internal_set_pending_payload_id(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  pending_payload_id_ = value;
}
inline void AutoResumeFrame::set_pending_payload_id(int64_t value) {
  _internal_set_pending_payload_id(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoResumeFrame.pending_payload_id)
}

// optional int32 next_payload_chunk_index = 3;
inline bool AutoResumeFrame::_internal_has_next_payload_chunk_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutoResumeFrame::has_next_payload_chunk_index() const {
  return _internal_has_next_payload_chunk_index();
}
inline void AutoResumeFrame::clear_next_payload_chunk_index() {
  next_payload_chunk_index_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t AutoResumeFrame::_internal_next_payload_chunk_index() const {
  return next_payload_chunk_index_;
}
inline int32_t AutoResumeFrame::next_payload_chunk_index() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoResumeFrame.next_payload_chunk_index)
  return _internal_next_payload_chunk_index();
}
inline void AutoResumeFrame::_internal_set_next_payload_chunk_index(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  next_payload_chunk_index_ = value;
}
inline void AutoResumeFrame::set_next_payload_chunk_index(int32_t value) {
  _internal_set_next_payload_chunk_index(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoResumeFrame.next_payload_chunk_index)
}

// -------------------------------------------------------------------

// AutoReconnectFrame

// optional string endpoint_id = 1;
inline bool AutoReconnectFrame::_internal_has_endpoint_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutoReconnectFrame::has_endpoint_id() const {
  return _internal_has_endpoint_id();
}
inline void AutoReconnectFrame::clear_endpoint_id() {
  endpoint_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutoReconnectFrame::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoReconnectFrame.endpoint_id)
  return _internal_endpoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoReconnectFrame::set_endpoint_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoReconnectFrame.endpoint_id)
}
inline std::string* AutoReconnectFrame::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.AutoReconnectFrame.endpoint_id)
  return _s;
}
inline const std::string& AutoReconnectFrame::_internal_endpoint_id() const {
  return endpoint_id_.Get();
}
inline void AutoReconnectFrame::_internal_set_endpoint_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AutoReconnectFrame::_internal_mutable_endpoint_id() {
  _has_bits_[0] |= 0x00000001u;
  return endpoint_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AutoReconnectFrame::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.AutoReconnectFrame.endpoint_id)
  if (!_internal_has_endpoint_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = endpoint_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoReconnectFrame::set_allocated_endpoint_id(std::string* endpoint_id) {
  if (endpoint_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.AutoReconnectFrame.endpoint_id)
}

// optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
inline bool AutoReconnectFrame::_internal_has_event_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutoReconnectFrame::has_event_type() const {
  return _internal_has_event_type();
}
inline void AutoReconnectFrame::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::AutoReconnectFrame_EventType AutoReconnectFrame::_internal_event_type() const {
  return static_cast< ::location::nearby::connections::AutoReconnectFrame_EventType >(event_type_);
}
inline ::location::nearby::connections::AutoReconnectFrame_EventType AutoReconnectFrame::event_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoReconnectFrame.event_type)
  return _internal_event_type();
}
inline void AutoReconnectFrame::_internal_set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value) {
  assert(::location::nearby::connections::AutoReconnectFrame_EventType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  event_type_ = value;
}
inline void AutoReconnectFrame::set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoReconnectFrame.event_type)
}

// -------------------------------------------------------------------

// MediumMetadata

// optional bool supports_5_ghz = 1;
inline bool MediumMetadata::_internal_has_supports_5_ghz() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MediumMetadata::has_supports_5_ghz() const {
  return _internal_has_supports_5_ghz();
}
inline void MediumMetadata::clear_supports_5_ghz() {
  supports_5_ghz_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool MediumMetadata::_internal_supports_5_ghz() const {
  return supports_5_ghz_;
}
inline bool MediumMetadata::supports_5_ghz() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.supports_5_ghz)
  return _internal_supports_5_ghz();
}
inline void MediumMetadata::_internal_set_supports_5_ghz(bool value) {
  _has_bits_[0] |= 0x00000080u;
  supports_5_ghz_ = value;
}
inline void MediumMetadata::set_supports_5_ghz(bool value) {
  _internal_set_supports_5_ghz(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.supports_5_ghz)
}

// optional string bssid = 2;
inline bool MediumMetadata::_internal_has_bssid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MediumMetadata::has_bssid() const {
  return _internal_has_bssid();
}
inline void MediumMetadata::clear_bssid() {
  bssid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediumMetadata::bssid() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.bssid)
  return _internal_bssid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediumMetadata::set_bssid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 bssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.bssid)
}
inline std::string* MediumMetadata::mutable_bssid() {
  std::string* _s = _internal_mutable_bssid();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.bssid)
  return _s;
}
inline const std::string& MediumMetadata::_internal_bssid() const {
  return bssid_.Get();
}
inline void MediumMetadata::_internal_set_bssid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MediumMetadata::_internal_mutable_bssid() {
  _has_bits_[0] |= 0x00000001u;
  return bssid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MediumMetadata::release_bssid() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.bssid)
  if (!_internal_has_bssid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = bssid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bssid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MediumMetadata::set_allocated_bssid(std::string* bssid) {
  if (bssid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bssid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bssid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bssid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.bssid)
}

// optional bytes ip_address = 3;
inline bool MediumMetadata::_internal_has_ip_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MediumMetadata::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void MediumMetadata::clear_ip_address() {
  ip_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediumMetadata::ip_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediumMetadata::set_ip_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ip_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.ip_address)
}
inline std::string* MediumMetadata::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.ip_address)
  return _s;
}
inline const std::string& MediumMetadata::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void MediumMetadata::_internal_set_ip_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MediumMetadata::_internal_mutable_ip_address() {
  _has_bits_[0] |= 0x00000002u;
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MediumMetadata::release_ip_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.ip_address)
  if (!_internal_has_ip_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ip_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MediumMetadata::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.ip_address)
}

// optional bool supports_6_ghz = 4;
inline bool MediumMetadata::_internal_has_supports_6_ghz() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MediumMetadata::has_supports_6_ghz() const {
  return _internal_has_supports_6_ghz();
}
inline void MediumMetadata::clear_supports_6_ghz() {
  supports_6_ghz_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool MediumMetadata::_internal_supports_6_ghz() const {
  return supports_6_ghz_;
}
inline bool MediumMetadata::supports_6_ghz() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.supports_6_ghz)
  return _internal_supports_6_ghz();
}
inline void MediumMetadata::_internal_set_supports_6_ghz(bool value) {
  _has_bits_[0] |= 0x00000100u;
  supports_6_ghz_ = value;
}
inline void MediumMetadata::set_supports_6_ghz(bool value) {
  _internal_set_supports_6_ghz(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.supports_6_ghz)
}

// optional bool mobile_radio = 5;
inline bool MediumMetadata::_internal_has_mobile_radio() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MediumMetadata::has_mobile_radio() const {
  return _internal_has_mobile_radio();
}
inline void MediumMetadata::clear_mobile_radio() {
  mobile_radio_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool MediumMetadata::_internal_mobile_radio() const {
  return mobile_radio_;
}
inline bool MediumMetadata::mobile_radio() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.mobile_radio)
  return _internal_mobile_radio();
}
inline void MediumMetadata::_internal_set_mobile_radio(bool value) {
  _has_bits_[0] |= 0x00000200u;
  mobile_radio_ = value;
}
inline void MediumMetadata::set_mobile_radio(bool value) {
  _internal_set_mobile_radio(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.mobile_radio)
}

// optional int32 ap_frequency = 6 [default = -1];
inline bool MediumMetadata::_internal_has_ap_frequency() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MediumMetadata::has_ap_frequency() const {
  return _internal_has_ap_frequency();
}
inline void MediumMetadata::clear_ap_frequency() {
  ap_frequency_ = -1;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t MediumMetadata::_internal_ap_frequency() const {
  return ap_frequency_;
}
inline int32_t MediumMetadata::ap_frequency() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.ap_frequency)
  return _internal_ap_frequency();
}
inline void MediumMetadata::_internal_set_ap_frequency(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  ap_frequency_ = value;
}
inline void MediumMetadata::set_ap_frequency(int32_t value) {
  _internal_set_ap_frequency(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.ap_frequency)
}

// optional .location.nearby.connections.AvailableChannels available_channels = 7;
inline bool MediumMetadata::_internal_has_available_channels() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || available_channels_ != nullptr);
  return value;
}
inline bool MediumMetadata::has_available_channels() const {
  return _internal_has_available_channels();
}
inline void MediumMetadata::clear_available_channels() {
  if (available_channels_ != nullptr) available_channels_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::AvailableChannels& MediumMetadata::_internal_available_channels() const {
  const ::location::nearby::connections::AvailableChannels* p = available_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AvailableChannels&>(
      ::location::nearby::connections::_AvailableChannels_default_instance_);
}
inline const ::location::nearby::connections::AvailableChannels& MediumMetadata::available_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.available_channels)
  return _internal_available_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_available_channels(
    ::location::nearby::connections::AvailableChannels* available_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(available_channels_);
  }
  available_channels_ = available_channels;
  if (available_channels) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.available_channels)
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::release_available_channels() {
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::AvailableChannels* temp = available_channels_;
  available_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::unsafe_arena_release_available_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.available_channels)
  _has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::AvailableChannels* temp = available_channels_;
  available_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::_internal_mutable_available_channels() {
  _has_bits_[0] |= 0x00000004u;
  if (available_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AvailableChannels>(GetArenaForAllocation());
    available_channels_ = p;
  }
  return available_channels_;
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::mutable_available_channels() {
  ::location::nearby::connections::AvailableChannels* _msg = _internal_mutable_available_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.available_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_available_channels(::location::nearby::connections::AvailableChannels* available_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete available_channels_;
  }
  if (available_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::AvailableChannels>::GetOwningArena(available_channels);
    if (message_arena != submessage_arena) {
      available_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, available_channels, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  available_channels_ = available_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.available_channels)
}

// optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
inline bool MediumMetadata::_internal_has_wifi_direct_cli_usable_channels() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || wifi_direct_cli_usable_channels_ != nullptr);
  return value;
}
inline bool MediumMetadata::has_wifi_direct_cli_usable_channels() const {
  return _internal_has_wifi_direct_cli_usable_channels();
}
inline void MediumMetadata::clear_wifi_direct_cli_usable_channels() {
  if (wifi_direct_cli_usable_channels_ != nullptr) wifi_direct_cli_usable_channels_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::location::nearby::connections::WifiDirectCliUsableChannels& MediumMetadata::_internal_wifi_direct_cli_usable_channels() const {
  const ::location::nearby::connections::WifiDirectCliUsableChannels* p = wifi_direct_cli_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiDirectCliUsableChannels&>(
      ::location::nearby::connections::_WifiDirectCliUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiDirectCliUsableChannels& MediumMetadata::wifi_direct_cli_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
  return _internal_wifi_direct_cli_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_direct_cli_usable_channels(
    ::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_direct_cli_usable_channels_);
  }
  wifi_direct_cli_usable_channels_ = wifi_direct_cli_usable_channels;
  if (wifi_direct_cli_usable_channels) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::release_wifi_direct_cli_usable_channels() {
  _has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::WifiDirectCliUsableChannels* temp = wifi_direct_cli_usable_channels_;
  wifi_direct_cli_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::unsafe_arena_release_wifi_direct_cli_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
  _has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::WifiDirectCliUsableChannels* temp = wifi_direct_cli_usable_channels_;
  wifi_direct_cli_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::_internal_mutable_wifi_direct_cli_usable_channels() {
  _has_bits_[0] |= 0x00000008u;
  if (wifi_direct_cli_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiDirectCliUsableChannels>(GetArenaForAllocation());
    wifi_direct_cli_usable_channels_ = p;
  }
  return wifi_direct_cli_usable_channels_;
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::mutable_wifi_direct_cli_usable_channels() {
  ::location::nearby::connections::WifiDirectCliUsableChannels* _msg = _internal_mutable_wifi_direct_cli_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_direct_cli_usable_channels(::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_direct_cli_usable_channels_;
  }
  if (wifi_direct_cli_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::WifiDirectCliUsableChannels>::GetOwningArena(wifi_direct_cli_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_direct_cli_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_direct_cli_usable_channels, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  wifi_direct_cli_usable_channels_ = wifi_direct_cli_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
}

// optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
inline bool MediumMetadata::_internal_has_wifi_lan_usable_channels() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || wifi_lan_usable_channels_ != nullptr);
  return value;
}
inline bool MediumMetadata::has_wifi_lan_usable_channels() const {
  return _internal_has_wifi_lan_usable_channels();
}
inline void MediumMetadata::clear_wifi_lan_usable_channels() {
  if (wifi_lan_usable_channels_ != nullptr) wifi_lan_usable_channels_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::location::nearby::connections::WifiLanUsableChannels& MediumMetadata::_internal_wifi_lan_usable_channels() const {
  const ::location::nearby::connections::WifiLanUsableChannels* p = wifi_lan_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiLanUsableChannels&>(
      ::location::nearby::connections::_WifiLanUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiLanUsableChannels& MediumMetadata::wifi_lan_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
  return _internal_wifi_lan_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_lan_usable_channels(
    ::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_lan_usable_channels_);
  }
  wifi_lan_usable_channels_ = wifi_lan_usable_channels;
  if (wifi_lan_usable_channels) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::release_wifi_lan_usable_channels() {
  _has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::WifiLanUsableChannels* temp = wifi_lan_usable_channels_;
  wifi_lan_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::unsafe_arena_release_wifi_lan_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
  _has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::WifiLanUsableChannels* temp = wifi_lan_usable_channels_;
  wifi_lan_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::_internal_mutable_wifi_lan_usable_channels() {
  _has_bits_[0] |= 0x00000010u;
  if (wifi_lan_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiLanUsableChannels>(GetArenaForAllocation());
    wifi_lan_usable_channels_ = p;
  }
  return wifi_lan_usable_channels_;
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::mutable_wifi_lan_usable_channels() {
  ::location::nearby::connections::WifiLanUsableChannels* _msg = _internal_mutable_wifi_lan_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_lan_usable_channels(::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_lan_usable_channels_;
  }
  if (wifi_lan_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::WifiLanUsableChannels>::GetOwningArena(wifi_lan_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_lan_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_lan_usable_channels, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  wifi_lan_usable_channels_ = wifi_lan_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
}

// optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
inline bool MediumMetadata::_internal_has_wifi_aware_usable_channels() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || wifi_aware_usable_channels_ != nullptr);
  return value;
}
inline bool MediumMetadata::has_wifi_aware_usable_channels() const {
  return _internal_has_wifi_aware_usable_channels();
}
inline void MediumMetadata::clear_wifi_aware_usable_channels() {
  if (wifi_aware_usable_channels_ != nullptr) wifi_aware_usable_channels_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::WifiAwareUsableChannels& MediumMetadata::_internal_wifi_aware_usable_channels() const {
  const ::location::nearby::connections::WifiAwareUsableChannels* p = wifi_aware_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiAwareUsableChannels&>(
      ::location::nearby::connections::_WifiAwareUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiAwareUsableChannels& MediumMetadata::wifi_aware_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
  return _internal_wifi_aware_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_aware_usable_channels(
    ::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_aware_usable_channels_);
  }
  wifi_aware_usable_channels_ = wifi_aware_usable_channels;
  if (wifi_aware_usable_channels) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::release_wifi_aware_usable_channels() {
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::WifiAwareUsableChannels* temp = wifi_aware_usable_channels_;
  wifi_aware_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::unsafe_arena_release_wifi_aware_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
  _has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::WifiAwareUsableChannels* temp = wifi_aware_usable_channels_;
  wifi_aware_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::_internal_mutable_wifi_aware_usable_channels() {
  _has_bits_[0] |= 0x00000020u;
  if (wifi_aware_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiAwareUsableChannels>(GetArenaForAllocation());
    wifi_aware_usable_channels_ = p;
  }
  return wifi_aware_usable_channels_;
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::mutable_wifi_aware_usable_channels() {
  ::location::nearby::connections::WifiAwareUsableChannels* _msg = _internal_mutable_wifi_aware_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_aware_usable_channels(::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_aware_usable_channels_;
  }
  if (wifi_aware_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::WifiAwareUsableChannels>::GetOwningArena(wifi_aware_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_aware_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_aware_usable_channels, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  wifi_aware_usable_channels_ = wifi_aware_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
}

// optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
inline bool MediumMetadata::_internal_has_wifi_hotspot_sta_usable_channels() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || wifi_hotspot_sta_usable_channels_ != nullptr);
  return value;
}
inline bool MediumMetadata::has_wifi_hotspot_sta_usable_channels() const {
  return _internal_has_wifi_hotspot_sta_usable_channels();
}
inline void MediumMetadata::clear_wifi_hotspot_sta_usable_channels() {
  if (wifi_hotspot_sta_usable_channels_ != nullptr) wifi_hotspot_sta_usable_channels_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::location::nearby::connections::WifiHotspotStaUsableChannels& MediumMetadata::_internal_wifi_hotspot_sta_usable_channels() const {
  const ::location::nearby::connections::WifiHotspotStaUsableChannels* p = wifi_hotspot_sta_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiHotspotStaUsableChannels&>(
      ::location::nearby::connections::_WifiHotspotStaUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiHotspotStaUsableChannels& MediumMetadata::wifi_hotspot_sta_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
  return _internal_wifi_hotspot_sta_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_hotspot_sta_usable_channels(
    ::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wifi_hotspot_sta_usable_channels_);
  }
  wifi_hotspot_sta_usable_channels_ = wifi_hotspot_sta_usable_channels;
  if (wifi_hotspot_sta_usable_channels) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::release_wifi_hotspot_sta_usable_channels() {
  _has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::WifiHotspotStaUsableChannels* temp = wifi_hotspot_sta_usable_channels_;
  wifi_hotspot_sta_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::unsafe_arena_release_wifi_hotspot_sta_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
  _has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::WifiHotspotStaUsableChannels* temp = wifi_hotspot_sta_usable_channels_;
  wifi_hotspot_sta_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::_internal_mutable_wifi_hotspot_sta_usable_channels() {
  _has_bits_[0] |= 0x00000040u;
  if (wifi_hotspot_sta_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiHotspotStaUsableChannels>(GetArenaForAllocation());
    wifi_hotspot_sta_usable_channels_ = p;
  }
  return wifi_hotspot_sta_usable_channels_;
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::mutable_wifi_hotspot_sta_usable_channels() {
  ::location::nearby::connections::WifiHotspotStaUsableChannels* _msg = _internal_mutable_wifi_hotspot_sta_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_hotspot_sta_usable_channels(::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wifi_hotspot_sta_usable_channels_;
  }
  if (wifi_hotspot_sta_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::WifiHotspotStaUsableChannels>::GetOwningArena(wifi_hotspot_sta_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_hotspot_sta_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_hotspot_sta_usable_channels, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  wifi_hotspot_sta_usable_channels_ = wifi_hotspot_sta_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
}

// -------------------------------------------------------------------

// AvailableChannels

// repeated int32 channels = 1 [packed = true];
inline int AvailableChannels::_internal_channels_size() const {
  return channels_.size();
}
inline int AvailableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void AvailableChannels::clear_channels() {
  channels_.Clear();
}
inline int32_t AvailableChannels::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline int32_t AvailableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AvailableChannels.channels)
  return _internal_channels(index);
}
inline void AvailableChannels::set_channels(int index, int32_t value) {
  channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AvailableChannels.channels)
}
inline void AvailableChannels::_internal_add_channels(int32_t value) {
  channels_.Add(value);
}
inline void AvailableChannels::add_channels(int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.AvailableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
AvailableChannels::_internal_channels() const {
  return channels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
AvailableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.AvailableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
AvailableChannels::_internal_mutable_channels() {
  return &channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
AvailableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.AvailableChannels.channels)
  return _internal_mutable_channels();
}

// -------------------------------------------------------------------

// WifiDirectCliUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiDirectCliUsableChannels::_internal_channels_size() const {
  return channels_.size();
}
inline int WifiDirectCliUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiDirectCliUsableChannels::clear_channels() {
  channels_.Clear();
}
inline int32_t WifiDirectCliUsableChannels::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline int32_t WifiDirectCliUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiDirectCliUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiDirectCliUsableChannels::set_channels(int index, int32_t value) {
  channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiDirectCliUsableChannels.channels)
}
inline void WifiDirectCliUsableChannels::_internal_add_channels(int32_t value) {
  channels_.Add(value);
}
inline void WifiDirectCliUsableChannels::add_channels(int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiDirectCliUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiDirectCliUsableChannels::_internal_channels() const {
  return channels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiDirectCliUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiDirectCliUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiDirectCliUsableChannels::_internal_mutable_channels() {
  return &channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiDirectCliUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiDirectCliUsableChannels.channels)
  return _internal_mutable_channels();
}

// -------------------------------------------------------------------

// WifiLanUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiLanUsableChannels::_internal_channels_size() const {
  return channels_.size();
}
inline int WifiLanUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiLanUsableChannels::clear_channels() {
  channels_.Clear();
}
inline int32_t WifiLanUsableChannels::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline int32_t WifiLanUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiLanUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiLanUsableChannels::set_channels(int index, int32_t value) {
  channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiLanUsableChannels.channels)
}
inline void WifiLanUsableChannels::_internal_add_channels(int32_t value) {
  channels_.Add(value);
}
inline void WifiLanUsableChannels::add_channels(int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiLanUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiLanUsableChannels::_internal_channels() const {
  return channels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiLanUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiLanUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiLanUsableChannels::_internal_mutable_channels() {
  return &channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiLanUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiLanUsableChannels.channels)
  return _internal_mutable_channels();
}

// -------------------------------------------------------------------

// WifiAwareUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiAwareUsableChannels::_internal_channels_size() const {
  return channels_.size();
}
inline int WifiAwareUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiAwareUsableChannels::clear_channels() {
  channels_.Clear();
}
inline int32_t WifiAwareUsableChannels::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline int32_t WifiAwareUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiAwareUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiAwareUsableChannels::set_channels(int index, int32_t value) {
  channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiAwareUsableChannels.channels)
}
inline void WifiAwareUsableChannels::_internal_add_channels(int32_t value) {
  channels_.Add(value);
}
inline void WifiAwareUsableChannels::add_channels(int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiAwareUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiAwareUsableChannels::_internal_channels() const {
  return channels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiAwareUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiAwareUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiAwareUsableChannels::_internal_mutable_channels() {
  return &channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiAwareUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiAwareUsableChannels.channels)
  return _internal_mutable_channels();
}

// -------------------------------------------------------------------

// WifiHotspotStaUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiHotspotStaUsableChannels::_internal_channels_size() const {
  return channels_.size();
}
inline int WifiHotspotStaUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiHotspotStaUsableChannels::clear_channels() {
  channels_.Clear();
}
inline int32_t WifiHotspotStaUsableChannels::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline int32_t WifiHotspotStaUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiHotspotStaUsableChannels::set_channels(int index, int32_t value) {
  channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
}
inline void WifiHotspotStaUsableChannels::_internal_add_channels(int32_t value) {
  channels_.Add(value);
}
inline void WifiHotspotStaUsableChannels::add_channels(int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiHotspotStaUsableChannels::_internal_channels() const {
  return channels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
WifiHotspotStaUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiHotspotStaUsableChannels::_internal_mutable_channels() {
  return &channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
WifiHotspotStaUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
  return _internal_mutable_channels();
}

// -------------------------------------------------------------------

// LocationHint

// optional string location = 1;
inline bool LocationHint::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocationHint::has_location() const {
  return _internal_has_location();
}
inline void LocationHint::clear_location() {
  location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocationHint::location() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.LocationHint.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationHint::set_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.LocationHint.location)
}
inline std::string* LocationHint::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.LocationHint.location)
  return _s;
}
inline const std::string& LocationHint::_internal_location() const {
  return location_.Get();
}
inline void LocationHint::_internal_set_location(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocationHint::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000001u;
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocationHint::release_location() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.LocationHint.location)
  if (!_internal_has_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocationHint::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.LocationHint.location)
}

// optional .location.nearby.connections.LocationStandard.Format format = 2;
inline bool LocationHint::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocationHint::has_format() const {
  return _internal_has_format();
}
inline void LocationHint::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::LocationStandard_Format LocationHint::_internal_format() const {
  return static_cast< ::location::nearby::connections::LocationStandard_Format >(format_);
}
inline ::location::nearby::connections::LocationStandard_Format LocationHint::format() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.LocationHint.format)
  return _internal_format();
}
inline void LocationHint::_internal_set_format(::location::nearby::connections::LocationStandard_Format value) {
  assert(::location::nearby::connections::LocationStandard_Format_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  format_ = value;
}
inline void LocationHint::set_format(::location::nearby::connections::LocationStandard_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.LocationHint.format)
}

// -------------------------------------------------------------------

// LocationStandard

// -------------------------------------------------------------------

// OsInfo

// optional .location.nearby.connections.OsInfo.OsType type = 1;
inline bool OsInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OsInfo::has_type() const {
  return _internal_has_type();
}
inline void OsInfo::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::location::nearby::connections::OsInfo_OsType OsInfo::_internal_type() const {
  return static_cast< ::location::nearby::connections::OsInfo_OsType >(type_);
}
inline ::location::nearby::connections::OsInfo_OsType OsInfo::type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.OsInfo.type)
  return _internal_type();
}
inline void OsInfo::_internal_set_type(::location::nearby::connections::OsInfo_OsType value) {
  assert(::location::nearby::connections::OsInfo_OsType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void OsInfo::set_type(::location::nearby::connections::OsInfo_OsType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.OsInfo.type)
}

// -------------------------------------------------------------------

// ConnectionsDevice

// optional string endpoint_id = 1;
inline bool ConnectionsDevice::_internal_has_endpoint_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectionsDevice::has_endpoint_id() const {
  return _internal_has_endpoint_id();
}
inline void ConnectionsDevice::clear_endpoint_id() {
  endpoint_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionsDevice::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.endpoint_id)
  return _internal_endpoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionsDevice::set_endpoint_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.endpoint_id)
}
inline std::string* ConnectionsDevice::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionsDevice.endpoint_id)
  return _s;
}
inline const std::string& ConnectionsDevice::_internal_endpoint_id() const {
  return endpoint_id_.Get();
}
inline void ConnectionsDevice::_internal_set_endpoint_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::_internal_mutable_endpoint_id() {
  _has_bits_[0] |= 0x00000001u;
  return endpoint_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionsDevice.endpoint_id)
  if (!_internal_has_endpoint_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = endpoint_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionsDevice::set_allocated_endpoint_id(std::string* endpoint_id) {
  if (endpoint_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionsDevice.endpoint_id)
}

// optional .location.nearby.connections.EndpointType endpoint_type = 2;
inline bool ConnectionsDevice::_internal_has_endpoint_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnectionsDevice::has_endpoint_type() const {
  return _internal_has_endpoint_type();
}
inline void ConnectionsDevice::clear_endpoint_type() {
  endpoint_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::EndpointType ConnectionsDevice::_internal_endpoint_type() const {
  return static_cast< ::location::nearby::connections::EndpointType >(endpoint_type_);
}
inline ::location::nearby::connections::EndpointType ConnectionsDevice::endpoint_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.endpoint_type)
  return _internal_endpoint_type();
}
inline void ConnectionsDevice::_internal_set_endpoint_type(::location::nearby::connections::EndpointType value) {
  assert(::location::nearby::connections::EndpointType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  endpoint_type_ = value;
}
inline void ConnectionsDevice::set_endpoint_type(::location::nearby::connections::EndpointType value) {
  _internal_set_endpoint_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.endpoint_type)
}

// optional bytes connectivity_info_list = 3;
inline bool ConnectionsDevice::_internal_has_connectivity_info_list() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectionsDevice::has_connectivity_info_list() const {
  return _internal_has_connectivity_info_list();
}
inline void ConnectionsDevice::clear_connectivity_info_list() {
  connectivity_info_list_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectionsDevice::connectivity_info_list() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
  return _internal_connectivity_info_list();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionsDevice::set_connectivity_info_list(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 connectivity_info_list_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
}
inline std::string* ConnectionsDevice::mutable_connectivity_info_list() {
  std::string* _s = _internal_mutable_connectivity_info_list();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
  return _s;
}
inline const std::string& ConnectionsDevice::_internal_connectivity_info_list() const {
  return connectivity_info_list_.Get();
}
inline void ConnectionsDevice::_internal_set_connectivity_info_list(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  connectivity_info_list_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::_internal_mutable_connectivity_info_list() {
  _has_bits_[0] |= 0x00000002u;
  return connectivity_info_list_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::release_connectivity_info_list() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
  if (!_internal_has_connectivity_info_list()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = connectivity_info_list_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connectivity_info_list_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionsDevice::set_allocated_connectivity_info_list(std::string* connectivity_info_list) {
  if (connectivity_info_list != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connectivity_info_list_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connectivity_info_list,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connectivity_info_list_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
}

// optional bytes endpoint_info = 4;
inline bool ConnectionsDevice::_internal_has_endpoint_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnectionsDevice::has_endpoint_info() const {
  return _internal_has_endpoint_info();
}
inline void ConnectionsDevice::clear_endpoint_info() {
  endpoint_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConnectionsDevice::endpoint_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.endpoint_info)
  return _internal_endpoint_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionsDevice::set_endpoint_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 endpoint_info_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.endpoint_info)
}
inline std::string* ConnectionsDevice::mutable_endpoint_info() {
  std::string* _s = _internal_mutable_endpoint_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionsDevice.endpoint_info)
  return _s;
}
inline const std::string& ConnectionsDevice::_internal_endpoint_info() const {
  return endpoint_info_.Get();
}
inline void ConnectionsDevice::_internal_set_endpoint_info(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  endpoint_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::_internal_mutable_endpoint_info() {
  _has_bits_[0] |= 0x00000004u;
  return endpoint_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::release_endpoint_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionsDevice.endpoint_info)
  if (!_internal_has_endpoint_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = endpoint_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionsDevice::set_allocated_endpoint_info(std::string* endpoint_info) {
  if (endpoint_info != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  endpoint_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionsDevice.endpoint_info)
}

// -------------------------------------------------------------------

// PresenceDevice

// optional string endpoint_id = 1;
inline bool PresenceDevice::_internal_has_endpoint_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PresenceDevice::has_endpoint_id() const {
  return _internal_has_endpoint_id();
}
inline void PresenceDevice::clear_endpoint_id() {
  endpoint_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PresenceDevice::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.endpoint_id)
  return _internal_endpoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PresenceDevice::set_endpoint_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.endpoint_id)
}
inline std::string* PresenceDevice::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.endpoint_id)
  return _s;
}
inline const std::string& PresenceDevice::_internal_endpoint_id() const {
  return endpoint_id_.Get();
}
inline void PresenceDevice::_internal_set_endpoint_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_endpoint_id() {
  _has_bits_[0] |= 0x00000001u;
  return endpoint_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.endpoint_id)
  if (!_internal_has_endpoint_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = endpoint_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PresenceDevice::set_allocated_endpoint_id(std::string* endpoint_id) {
  if (endpoint_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.endpoint_id)
}

// optional .location.nearby.connections.EndpointType endpoint_type = 2;
inline bool PresenceDevice::_internal_has_endpoint_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PresenceDevice::has_endpoint_type() const {
  return _internal_has_endpoint_type();
}
inline void PresenceDevice::clear_endpoint_type() {
  endpoint_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::location::nearby::connections::EndpointType PresenceDevice::_internal_endpoint_type() const {
  return static_cast< ::location::nearby::connections::EndpointType >(endpoint_type_);
}
inline ::location::nearby::connections::EndpointType PresenceDevice::endpoint_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.endpoint_type)
  return _internal_endpoint_type();
}
inline void PresenceDevice::_internal_set_endpoint_type(::location::nearby::connections::EndpointType value) {
  assert(::location::nearby::connections::EndpointType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  endpoint_type_ = value;
}
inline void PresenceDevice::set_endpoint_type(::location::nearby::connections::EndpointType value) {
  _internal_set_endpoint_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.endpoint_type)
}

// optional bytes connectivity_info_list = 3;
inline bool PresenceDevice::_internal_has_connectivity_info_list() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PresenceDevice::has_connectivity_info_list() const {
  return _internal_has_connectivity_info_list();
}
inline void PresenceDevice::clear_connectivity_info_list() {
  connectivity_info_list_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PresenceDevice::connectivity_info_list() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.connectivity_info_list)
  return _internal_connectivity_info_list();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PresenceDevice::set_connectivity_info_list(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 connectivity_info_list_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.connectivity_info_list)
}
inline std::string* PresenceDevice::mutable_connectivity_info_list() {
  std::string* _s = _internal_mutable_connectivity_info_list();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.connectivity_info_list)
  return _s;
}
inline const std::string& PresenceDevice::_internal_connectivity_info_list() const {
  return connectivity_info_list_.Get();
}
inline void PresenceDevice::_internal_set_connectivity_info_list(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  connectivity_info_list_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_connectivity_info_list() {
  _has_bits_[0] |= 0x00000002u;
  return connectivity_info_list_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_connectivity_info_list() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.connectivity_info_list)
  if (!_internal_has_connectivity_info_list()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = connectivity_info_list_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connectivity_info_list_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PresenceDevice::set_allocated_connectivity_info_list(std::string* connectivity_info_list) {
  if (connectivity_info_list != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connectivity_info_list_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connectivity_info_list,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connectivity_info_list_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.connectivity_info_list)
}

// optional int64 device_id = 4;
inline bool PresenceDevice::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PresenceDevice::has_device_id() const {
  return _internal_has_device_id();
}
inline void PresenceDevice::clear_device_id() {
  device_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t PresenceDevice::_internal_device_id() const {
  return device_id_;
}
inline int64_t PresenceDevice::device_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_id)
  return _internal_device_id();
}
inline void PresenceDevice::_internal_set_device_id(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  device_id_ = value;
}
inline void PresenceDevice::set_device_id(int64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_id)
}

// optional string device_name = 5;
inline bool PresenceDevice::_internal_has_device_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PresenceDevice::has_device_name() const {
  return _internal_has_device_name();
}
inline void PresenceDevice::clear_device_name() {
  device_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PresenceDevice::device_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PresenceDevice::set_device_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_name)
}
inline std::string* PresenceDevice::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.device_name)
  return _s;
}
inline const std::string& PresenceDevice::_internal_device_name() const {
  return device_name_.Get();
}
inline void PresenceDevice::_internal_set_device_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_device_name() {
  _has_bits_[0] |= 0x00000004u;
  return device_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_device_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.device_name)
  if (!_internal_has_device_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = device_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PresenceDevice::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.device_name)
}

// optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
inline bool PresenceDevice::_internal_has_device_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PresenceDevice::has_device_type() const {
  return _internal_has_device_type();
}
inline void PresenceDevice::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::location::nearby::connections::PresenceDevice_DeviceType PresenceDevice::_internal_device_type() const {
  return static_cast< ::location::nearby::connections::PresenceDevice_DeviceType >(device_type_);
}
inline ::location::nearby::connections::PresenceDevice_DeviceType PresenceDevice::device_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_type)
  return _internal_device_type();
}
inline void PresenceDevice::_internal_set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value) {
  assert(::location::nearby::connections::PresenceDevice_DeviceType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  device_type_ = value;
}
inline void PresenceDevice::set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_type)
}

// optional string device_image_url = 7;
inline bool PresenceDevice::_internal_has_device_image_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PresenceDevice::has_device_image_url() const {
  return _internal_has_device_image_url();
}
inline void PresenceDevice::clear_device_image_url() {
  device_image_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PresenceDevice::device_image_url() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_image_url)
  return _internal_device_image_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PresenceDevice::set_device_image_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 device_image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_image_url)
}
inline std::string* PresenceDevice::mutable_device_image_url() {
  std::string* _s = _internal_mutable_device_image_url();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.device_image_url)
  return _s;
}
inline const std::string& PresenceDevice::_internal_device_image_url() const {
  return device_image_url_.Get();
}
inline void PresenceDevice::_internal_set_device_image_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  device_image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_device_image_url() {
  _has_bits_[0] |= 0x00000008u;
  return device_image_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_device_image_url() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.device_image_url)
  if (!_internal_has_device_image_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = device_image_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PresenceDevice::set_allocated_device_image_url(std::string* device_image_url) {
  if (device_image_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_image_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_image_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.device_image_url)
}

// repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
inline int PresenceDevice::_internal_discovery_medium_size() const {
  return discovery_medium_.size();
}
inline int PresenceDevice::discovery_medium_size() const {
  return _internal_discovery_medium_size();
}
inline void PresenceDevice::clear_discovery_medium() {
  discovery_medium_.Clear();
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium PresenceDevice::_internal_discovery_medium(int index) const {
  return static_cast< ::location::nearby::connections::ConnectionRequestFrame_Medium >(discovery_medium_.Get(index));
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium PresenceDevice::discovery_medium(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.discovery_medium)
  return _internal_discovery_medium(index);
}
inline void PresenceDevice::set_discovery_medium(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  discovery_medium_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.discovery_medium)
}
inline void PresenceDevice::_internal_add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  discovery_medium_.Add(value);
}
inline void PresenceDevice::add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  _internal_add_discovery_medium(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.PresenceDevice.discovery_medium)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
PresenceDevice::discovery_medium() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.PresenceDevice.discovery_medium)
  return discovery_medium_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PresenceDevice::_internal_mutable_discovery_medium() {
  return &discovery_medium_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PresenceDevice::mutable_discovery_medium() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.PresenceDevice.discovery_medium)
  return _internal_mutable_discovery_medium();
}

// repeated int32 actions = 9 [packed = true];
inline int PresenceDevice::_internal_actions_size() const {
  return actions_.size();
}
inline int PresenceDevice::actions_size() const {
  return _internal_actions_size();
}
inline void PresenceDevice::clear_actions() {
  actions_.Clear();
}
inline int32_t PresenceDevice::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline int32_t PresenceDevice::actions(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.actions)
  return _internal_actions(index);
}
inline void PresenceDevice::set_actions(int index, int32_t value) {
  actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.actions)
}
inline void PresenceDevice::_internal_add_actions(int32_t value) {
  actions_.Add(value);
}
inline void PresenceDevice::add_actions(int32_t value) {
  _internal_add_actions(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.PresenceDevice.actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PresenceDevice::_internal_actions() const {
  return actions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PresenceDevice::actions() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.PresenceDevice.actions)
  return _internal_actions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PresenceDevice::_internal_mutable_actions() {
  return &actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PresenceDevice::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.PresenceDevice.actions)
  return _internal_mutable_actions();
}

// repeated int64 identity_type = 10 [packed = true];
inline int PresenceDevice::_internal_identity_type_size() const {
  return identity_type_.size();
}
inline int PresenceDevice::identity_type_size() const {
  return _internal_identity_type_size();
}
inline void PresenceDevice::clear_identity_type() {
  identity_type_.Clear();
}
inline int64_t PresenceDevice::_internal_identity_type(int index) const {
  return identity_type_.Get(index);
}
inline int64_t PresenceDevice::identity_type(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.identity_type)
  return _internal_identity_type(index);
}
inline void PresenceDevice::set_identity_type(int index, int64_t value) {
  identity_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.identity_type)
}
inline void PresenceDevice::_internal_add_identity_type(int64_t value) {
  identity_type_.Add(value);
}
inline void PresenceDevice::add_identity_type(int64_t value) {
  _internal_add_identity_type(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.PresenceDevice.identity_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
PresenceDevice::_internal_identity_type() const {
  return identity_type_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
PresenceDevice::identity_type() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.PresenceDevice.identity_type)
  return _internal_identity_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
PresenceDevice::_internal_mutable_identity_type() {
  return &identity_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
PresenceDevice::mutable_identity_type() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.PresenceDevice.identity_type)
  return _internal_mutable_identity_type();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace connections
}  // namespace nearby
}  // namespace location

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::location::nearby::connections::OfflineFrame_Version> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::V1Frame_FrameType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::ConnectionRequestFrame_Medium> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::PayloadTransferFrame_PayloadChunk_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::PayloadTransferFrame_PacketType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::AutoResumeFrame_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::AutoReconnectFrame_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::LocationStandard_Format> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::OsInfo_OsType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::PresenceDevice_DeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::connections::EndpointType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto
