// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: connections/implementation/proto/offline_wire_formats.proto
// Protobuf C++ Version: 6.33.3

#include "connections/implementation/proto/offline_wire_formats.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace location {
namespace nearby {
namespace connections {

inline constexpr WifiLanUsableChannels::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channels_{},
        _channels_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR WifiLanUsableChannels::WifiLanUsableChannels(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(WifiLanUsableChannels_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct WifiLanUsableChannelsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WifiLanUsableChannelsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WifiLanUsableChannelsDefaultTypeInternal() {}
  union {
    WifiLanUsableChannels _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WifiLanUsableChannelsDefaultTypeInternal _WifiLanUsableChannels_default_instance_;

inline constexpr WifiHotspotStaUsableChannels::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channels_{},
        _channels_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(WifiHotspotStaUsableChannels_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct WifiHotspotStaUsableChannelsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WifiHotspotStaUsableChannelsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WifiHotspotStaUsableChannelsDefaultTypeInternal() {}
  union {
    WifiHotspotStaUsableChannels _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WifiHotspotStaUsableChannelsDefaultTypeInternal _WifiHotspotStaUsableChannels_default_instance_;

inline constexpr WifiDirectCliUsableChannels::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channels_{},
        _channels_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(WifiDirectCliUsableChannels_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct WifiDirectCliUsableChannelsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WifiDirectCliUsableChannelsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WifiDirectCliUsableChannelsDefaultTypeInternal() {}
  union {
    WifiDirectCliUsableChannels _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WifiDirectCliUsableChannelsDefaultTypeInternal _WifiDirectCliUsableChannels_default_instance_;

inline constexpr WifiAwareUsableChannels::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channels_{},
        _channels_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR WifiAwareUsableChannels::WifiAwareUsableChannels(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(WifiAwareUsableChannels_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct WifiAwareUsableChannelsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WifiAwareUsableChannelsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WifiAwareUsableChannelsDefaultTypeInternal() {}
  union {
    WifiAwareUsableChannels _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WifiAwareUsableChannelsDefaultTypeInternal _WifiAwareUsableChannels_default_instance_;

inline constexpr ServiceAddress::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        ip_address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        port_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ServiceAddress::ServiceAddress(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(ServiceAddress_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ServiceAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceAddressDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceAddressDefaultTypeInternal() {}
  union {
    ServiceAddress _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceAddressDefaultTypeInternal _ServiceAddress_default_instance_;

inline constexpr PresenceDevice::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        discovery_medium_{},
        _discovery_medium_cached_byte_size_{0},
        actions_{},
        _actions_cached_byte_size_{0},
        identity_type_{},
        _identity_type_cached_byte_size_{0},
        endpoint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        connectivity_info_list_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_image_url_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_id_{::int64_t{0}},
        endpoint_type_{static_cast< ::location::nearby::connections::EndpointType >(0)},
        device_type_{static_cast< ::location::nearby::connections::PresenceDevice_DeviceType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR PresenceDevice::PresenceDevice(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PresenceDevice_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PresenceDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PresenceDeviceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PresenceDeviceDefaultTypeInternal() {}
  union {
    PresenceDevice _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PresenceDeviceDefaultTypeInternal _PresenceDevice_default_instance_;

inline constexpr PayloadTransferFrame_PayloadHeader::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        file_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        parent_folder_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        id_{::int64_t{0}},
        total_size_{::int64_t{0}},
        type_{static_cast< ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType >(0)},
        is_sensitive_{false},
        last_modified_timestamp_millis_{::int64_t{0}} {}

template <typename>
PROTOBUF_CONSTEXPR PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PayloadTransferFrame_PayloadHeader_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PayloadTransferFrame_PayloadHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PayloadTransferFrame_PayloadHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PayloadTransferFrame_PayloadHeaderDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_PayloadHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PayloadTransferFrame_PayloadHeaderDefaultTypeInternal _PayloadTransferFrame_PayloadHeader_default_instance_;

inline constexpr PayloadTransferFrame_PayloadChunk::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        body_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        offset_{::int64_t{0}},
        flags_{0},
        index_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PayloadTransferFrame_PayloadChunk_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PayloadTransferFrame_PayloadChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PayloadTransferFrame_PayloadChunkDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PayloadTransferFrame_PayloadChunkDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_PayloadChunk _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PayloadTransferFrame_PayloadChunkDefaultTypeInternal _PayloadTransferFrame_PayloadChunk_default_instance_;

inline constexpr PayloadTransferFrame_ControlMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        offset_{::int64_t{0}},
        event_{static_cast< ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PayloadTransferFrame_ControlMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PayloadTransferFrame_ControlMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PayloadTransferFrame_ControlMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PayloadTransferFrame_ControlMessageDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_ControlMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PayloadTransferFrame_ControlMessageDefaultTypeInternal _PayloadTransferFrame_ControlMessage_default_instance_;

inline constexpr PairedKeyEncryptionFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        signed_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PairedKeyEncryptionFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PairedKeyEncryptionFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PairedKeyEncryptionFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PairedKeyEncryptionFrameDefaultTypeInternal() {}
  union {
    PairedKeyEncryptionFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;

inline constexpr OsInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        type_{static_cast< ::location::nearby::connections::OsInfo_OsType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR OsInfo::OsInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(OsInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct OsInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OsInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OsInfoDefaultTypeInternal() {}
  union {
    OsInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OsInfoDefaultTypeInternal _OsInfo_default_instance_;

inline constexpr MediumRole::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        support_wifi_direct_group_owner_{false},
        support_wifi_direct_group_client_{false},
        support_wifi_hotspot_host_{false},
        support_wifi_hotspot_client_{false},
        support_wifi_aware_publisher_{false},
        support_wifi_aware_subscriber_{false},
        support_awdl_publisher_{false},
        support_awdl_subscriber_{false} {}

template <typename>
PROTOBUF_CONSTEXPR MediumRole::MediumRole(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(MediumRole_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MediumRoleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediumRoleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediumRoleDefaultTypeInternal() {}
  union {
    MediumRole _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediumRoleDefaultTypeInternal _MediumRole_default_instance_;

inline constexpr LocationStandard::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LocationStandard::LocationStandard(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(LocationStandard_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LocationStandardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocationStandardDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocationStandardDefaultTypeInternal() {}
  union {
    LocationStandard _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocationStandardDefaultTypeInternal _LocationStandard_default_instance_;

inline constexpr LocationHint::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        location_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        format_{static_cast< ::location::nearby::connections::LocationStandard_Format >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR LocationHint::LocationHint(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(LocationHint_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LocationHintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocationHintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocationHintDefaultTypeInternal() {}
  union {
    LocationHint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocationHintDefaultTypeInternal _LocationHint_default_instance_;

inline constexpr KeepAliveFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        ack_{false},
        seq_num_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR KeepAliveFrame::KeepAliveFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(KeepAliveFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KeepAliveFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeepAliveFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeepAliveFrameDefaultTypeInternal() {}
  union {
    KeepAliveFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeepAliveFrameDefaultTypeInternal _KeepAliveFrame_default_instance_;

inline constexpr DisconnectionFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        request_safe_to_disconnect_{false},
        ack_safe_to_disconnect_{false} {}

template <typename>
PROTOBUF_CONSTEXPR DisconnectionFrame::DisconnectionFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(DisconnectionFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DisconnectionFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisconnectionFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisconnectionFrameDefaultTypeInternal() {}
  union {
    DisconnectionFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisconnectionFrameDefaultTypeInternal _DisconnectionFrame_default_instance_;

inline constexpr ConnectionsDevice::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        endpoint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        connectivity_info_list_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        endpoint_info_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        endpoint_type_{static_cast< ::location::nearby::connections::EndpointType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR ConnectionsDevice::ConnectionsDevice(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(ConnectionsDevice_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ConnectionsDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsDeviceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsDeviceDefaultTypeInternal() {}
  union {
    ConnectionsDevice _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsDeviceDefaultTypeInternal _ConnectionsDevice_default_instance_;

inline constexpr BandwidthUpgradeRetryFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        supported_medium_{},
        is_request_{false} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeRetryFrame::BandwidthUpgradeRetryFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeRetryFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeRetryFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeRetryFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeRetryFrameDefaultTypeInternal() {}
  union {
    BandwidthUpgradeRetryFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeRetryFrameDefaultTypeInternal _BandwidthUpgradeRetryFrame_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        ssid_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        password_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        gateway_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ip_v6_address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        service_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pin_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        port_{0},
        frequency_{0} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        service_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        service_info_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        password_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        service_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        mac_address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        service_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        service_type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        password_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentialsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        sta_frequency_{0} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_ClientIntroductionAck _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_ClientIntroduction::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        endpoint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        last_endpoint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        supports_disabling_encryption_{false} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_ClientIntroduction_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_ClientIntroduction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_;

inline constexpr AvailableChannels::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channels_{},
        _channels_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvailableChannels::AvailableChannels(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(AvailableChannels_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvailableChannelsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvailableChannelsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvailableChannelsDefaultTypeInternal() {}
  union {
    AvailableChannels _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvailableChannelsDefaultTypeInternal _AvailableChannels_default_instance_;

inline constexpr AutoResumeFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        pending_payload_id_{::int64_t{0}},
        event_type_{static_cast< ::location::nearby::connections::AutoResumeFrame_EventType >(0)},
        next_payload_chunk_index_{0},
        version_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AutoResumeFrame::AutoResumeFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(AutoResumeFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AutoResumeFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutoResumeFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutoResumeFrameDefaultTypeInternal() {}
  union {
    AutoResumeFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutoResumeFrameDefaultTypeInternal _AutoResumeFrame_default_instance_;

inline constexpr AutoReconnectFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        endpoint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        last_endpoint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        event_type_{static_cast< ::location::nearby::connections::AutoReconnectFrame_EventType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR AutoReconnectFrame::AutoReconnectFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(AutoReconnectFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AutoReconnectFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutoReconnectFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutoReconnectFrameDefaultTypeInternal() {}
  union {
    AutoReconnectFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutoReconnectFrameDefaultTypeInternal _AutoReconnectFrame_default_instance_;

inline constexpr AuthenticationResultFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        result_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AuthenticationResultFrame::AuthenticationResultFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(AuthenticationResultFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AuthenticationResultFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticationResultFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticationResultFrameDefaultTypeInternal() {}
  union {
    AuthenticationResultFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticationResultFrameDefaultTypeInternal _AuthenticationResultFrame_default_instance_;

inline constexpr AuthenticationMessageFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        auth_message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR AuthenticationMessageFrame::AuthenticationMessageFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(AuthenticationMessageFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AuthenticationMessageFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticationMessageFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticationMessageFrameDefaultTypeInternal() {}
  union {
    AuthenticationMessageFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticationMessageFrameDefaultTypeInternal _AuthenticationMessageFrame_default_instance_;

inline constexpr PayloadTransferFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        payload_header_{nullptr},
        payload_chunk_{nullptr},
        control_message_{nullptr},
        packet_type_{static_cast< ::location::nearby::connections::PayloadTransferFrame_PacketType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR PayloadTransferFrame::PayloadTransferFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PayloadTransferFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PayloadTransferFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PayloadTransferFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PayloadTransferFrameDefaultTypeInternal() {}
  union {
    PayloadTransferFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PayloadTransferFrameDefaultTypeInternal _PayloadTransferFrame_default_instance_;

inline constexpr MediumMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        supported_wifi_direct_auth_types_{},
        _supported_wifi_direct_auth_types_cached_byte_size_{0},
        bssid_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ip_address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        available_channels_{nullptr},
        wifi_direct_cli_usable_channels_{nullptr},
        wifi_lan_usable_channels_{nullptr},
        wifi_aware_usable_channels_{nullptr},
        wifi_hotspot_sta_usable_channels_{nullptr},
        medium_role_{nullptr},
        supports_5_ghz_{false},
        supports_6_ghz_{false},
        mobile_radio_{false},
        ap_frequency_{-1} {}

template <typename>
PROTOBUF_CONSTEXPR MediumMetadata::MediumMetadata(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(MediumMetadata_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MediumMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediumMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediumMetadataDefaultTypeInternal() {}
  union {
    MediumMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediumMetadataDefaultTypeInternal _MediumMetadata_default_instance_;

inline constexpr ConnectionResponseFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        handshake_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        os_info_{nullptr},
        location_hint_{nullptr},
        status_{0},
        response_{static_cast< ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus >(0)},
        multiplex_socket_bitmask_{0},
        nearby_connections_version_{0},
        safe_to_disconnect_version_{0},
        keep_alive_timeout_millis_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ConnectionResponseFrame::ConnectionResponseFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(ConnectionResponseFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ConnectionResponseFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionResponseFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionResponseFrameDefaultTypeInternal() {}
  union {
    ConnectionResponseFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        address_candidates_{},
        ip_address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        wifi_port_{0} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        address_candidates_{},
        ssid_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        password_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        gateway_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        port_{0},
        frequency_{-1} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        peer_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        location_hint_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_;

inline constexpr ConnectionRequestFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        mediums_{},
        endpoint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        endpoint_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        handshake_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        endpoint_info_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_info_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        medium_metadata_{nullptr},
        location_hint_{nullptr},
        nonce_{0},
        keep_alive_interval_millis_{0},
        keep_alive_timeout_millis_{0},
        device_type_{0},
        connection_mode_{static_cast< ::location::nearby::connections::ConnectionRequestFrame_ConnectionMode >(0)},
        Device_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR ConnectionRequestFrame::ConnectionRequestFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(ConnectionRequestFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ConnectionRequestFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionRequestFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionRequestFrameDefaultTypeInternal() {}
  union {
    ConnectionRequestFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionRequestFrameDefaultTypeInternal _ConnectionRequestFrame_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        mediums_{},
        _mediums_cached_byte_size_{0},
        medium_meta_data_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequestDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequestDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        wifi_hotspot_credentials_{nullptr},
        wifi_lan_socket_{nullptr},
        bluetooth_credentials_{nullptr},
        wifi_aware_credentials_{nullptr},
        wifi_direct_credentials_{nullptr},
        web_rtc_credentials_{nullptr},
        upgrade_path_request_{nullptr},
        awdl_credentials_{nullptr},
        medium_{static_cast< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium >(0)},
        supports_disabling_encryption_{false},
        supports_client_introduction_ack_{false} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_;

inline constexpr BandwidthUpgradeNegotiationFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        upgrade_path_info_{nullptr},
        client_introduction_{nullptr},
        client_introduction_ack_{nullptr},
        safe_to_close_prior_channel_{nullptr},
        event_type_{static_cast< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(BandwidthUpgradeNegotiationFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BandwidthUpgradeNegotiationFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrameDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthUpgradeNegotiationFrameDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_default_instance_;

inline constexpr V1Frame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        connection_request_{nullptr},
        connection_response_{nullptr},
        payload_transfer_{nullptr},
        bandwidth_upgrade_negotiation_{nullptr},
        keep_alive_{nullptr},
        disconnection_{nullptr},
        paired_key_encryption_{nullptr},
        authentication_message_{nullptr},
        authentication_result_{nullptr},
        auto_resume_{nullptr},
        auto_reconnect_{nullptr},
        bandwidth_upgrade_retry_{nullptr},
        type_{static_cast< ::location::nearby::connections::V1Frame_FrameType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR V1Frame::V1Frame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(V1Frame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct V1FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V1FrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~V1FrameDefaultTypeInternal() {}
  union {
    V1Frame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V1FrameDefaultTypeInternal _V1Frame_default_instance_;

inline constexpr OfflineFrame::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        v1_{nullptr},
        version_{static_cast< ::location::nearby::connections::OfflineFrame_Version >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR OfflineFrame::OfflineFrame(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(OfflineFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct OfflineFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfflineFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfflineFrameDefaultTypeInternal() {}
  union {
    OfflineFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfflineFrameDefaultTypeInternal _OfflineFrame_default_instance_;
}  // namespace connections
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace connections {
PROTOBUF_CONSTINIT const uint32_t OfflineFrame_Version_internal_data_[] = {
    131072u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    OfflineFrame_Version_strings[2] = {};

static const char OfflineFrame_Version_names[] = {
    "UNKNOWN_VERSION"
    "V1"
};

static const ::google::protobuf::internal::EnumEntry OfflineFrame_Version_entries[] = {
    {{&OfflineFrame_Version_names[0], 15}, 0},
    {{&OfflineFrame_Version_names[15], 2}, 1},
};

static const int OfflineFrame_Version_entries_by_number[] = {
    0,  // 0 -> UNKNOWN_VERSION
    1,  // 1 -> V1
};

const ::std::string& OfflineFrame_Version_Name(OfflineFrame_Version value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      OfflineFrame_Version_entries, OfflineFrame_Version_entries_by_number, 2,
      OfflineFrame_Version_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(OfflineFrame_Version_entries,
                                  OfflineFrame_Version_entries_by_number,
                                  2, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : OfflineFrame_Version_strings[idx].get();
}

bool OfflineFrame_Version_Parse(::absl::string_view name, OfflineFrame_Version* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      OfflineFrame_Version_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<OfflineFrame_Version>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t V1Frame_FrameType_internal_data_[] = {
    851968u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    V1Frame_FrameType_strings[13] = {};

static const char V1Frame_FrameType_names[] = {
    "AUTHENTICATION_MESSAGE"
    "AUTHENTICATION_RESULT"
    "AUTO_RECONNECT"
    "AUTO_RESUME"
    "BANDWIDTH_UPGRADE_NEGOTIATION"
    "BANDWIDTH_UPGRADE_RETRY"
    "CONNECTION_REQUEST"
    "CONNECTION_RESPONSE"
    "DISCONNECTION"
    "KEEP_ALIVE"
    "PAIRED_KEY_ENCRYPTION"
    "PAYLOAD_TRANSFER"
    "UNKNOWN_FRAME_TYPE"
};

static const ::google::protobuf::internal::EnumEntry V1Frame_FrameType_entries[] = {
    {{&V1Frame_FrameType_names[0], 22}, 8},
    {{&V1Frame_FrameType_names[22], 21}, 9},
    {{&V1Frame_FrameType_names[43], 14}, 11},
    {{&V1Frame_FrameType_names[57], 11}, 10},
    {{&V1Frame_FrameType_names[68], 29}, 4},
    {{&V1Frame_FrameType_names[97], 23}, 12},
    {{&V1Frame_FrameType_names[120], 18}, 1},
    {{&V1Frame_FrameType_names[138], 19}, 2},
    {{&V1Frame_FrameType_names[157], 13}, 6},
    {{&V1Frame_FrameType_names[170], 10}, 5},
    {{&V1Frame_FrameType_names[180], 21}, 7},
    {{&V1Frame_FrameType_names[201], 16}, 3},
    {{&V1Frame_FrameType_names[217], 18}, 0},
};

static const int V1Frame_FrameType_entries_by_number[] = {
    12,  // 0 -> UNKNOWN_FRAME_TYPE
    6,  // 1 -> CONNECTION_REQUEST
    7,  // 2 -> CONNECTION_RESPONSE
    11,  // 3 -> PAYLOAD_TRANSFER
    4,  // 4 -> BANDWIDTH_UPGRADE_NEGOTIATION
    9,  // 5 -> KEEP_ALIVE
    8,  // 6 -> DISCONNECTION
    10,  // 7 -> PAIRED_KEY_ENCRYPTION
    0,  // 8 -> AUTHENTICATION_MESSAGE
    1,  // 9 -> AUTHENTICATION_RESULT
    3,  // 10 -> AUTO_RESUME
    2,  // 11 -> AUTO_RECONNECT
    5,  // 12 -> BANDWIDTH_UPGRADE_RETRY
};

const ::std::string& V1Frame_FrameType_Name(V1Frame_FrameType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      V1Frame_FrameType_entries, V1Frame_FrameType_entries_by_number, 13,
      V1Frame_FrameType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(V1Frame_FrameType_entries,
                                  V1Frame_FrameType_entries_by_number,
                                  13, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : V1Frame_FrameType_strings[idx].get();
}

bool V1Frame_FrameType_Parse(::absl::string_view name, V1Frame_FrameType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      V1Frame_FrameType_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<V1Frame_FrameType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t ConnectionRequestFrame_Medium_internal_data_[] = {
    917504u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    ConnectionRequestFrame_Medium_strings[14] = {};

static const char ConnectionRequestFrame_Medium_names[] = {
    "AWDL"
    "BLE"
    "BLE_L2CAP"
    "BLUETOOTH"
    "MDNS"
    "NFC"
    "UNKNOWN_MEDIUM"
    "USB"
    "WEB_RTC"
    "WEB_RTC_NON_CELLULAR"
    "WIFI_AWARE"
    "WIFI_DIRECT"
    "WIFI_HOTSPOT"
    "WIFI_LAN"
};

static const ::google::protobuf::internal::EnumEntry ConnectionRequestFrame_Medium_entries[] = {
    {{&ConnectionRequestFrame_Medium_names[0], 4}, 13},
    {{&ConnectionRequestFrame_Medium_names[4], 3}, 4},
    {{&ConnectionRequestFrame_Medium_names[7], 9}, 10},
    {{&ConnectionRequestFrame_Medium_names[16], 9}, 2},
    {{&ConnectionRequestFrame_Medium_names[25], 4}, 1},
    {{&ConnectionRequestFrame_Medium_names[29], 3}, 7},
    {{&ConnectionRequestFrame_Medium_names[32], 14}, 0},
    {{&ConnectionRequestFrame_Medium_names[46], 3}, 11},
    {{&ConnectionRequestFrame_Medium_names[49], 7}, 9},
    {{&ConnectionRequestFrame_Medium_names[56], 20}, 12},
    {{&ConnectionRequestFrame_Medium_names[76], 10}, 6},
    {{&ConnectionRequestFrame_Medium_names[86], 11}, 8},
    {{&ConnectionRequestFrame_Medium_names[97], 12}, 3},
    {{&ConnectionRequestFrame_Medium_names[109], 8}, 5},
};

static const int ConnectionRequestFrame_Medium_entries_by_number[] = {
    6,  // 0 -> UNKNOWN_MEDIUM
    4,  // 1 -> MDNS
    3,  // 2 -> BLUETOOTH
    12,  // 3 -> WIFI_HOTSPOT
    1,  // 4 -> BLE
    13,  // 5 -> WIFI_LAN
    10,  // 6 -> WIFI_AWARE
    5,  // 7 -> NFC
    11,  // 8 -> WIFI_DIRECT
    8,  // 9 -> WEB_RTC
    2,  // 10 -> BLE_L2CAP
    7,  // 11 -> USB
    9,  // 12 -> WEB_RTC_NON_CELLULAR
    0,  // 13 -> AWDL
};

const ::std::string& ConnectionRequestFrame_Medium_Name(ConnectionRequestFrame_Medium value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      ConnectionRequestFrame_Medium_entries, ConnectionRequestFrame_Medium_entries_by_number, 14,
      ConnectionRequestFrame_Medium_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(ConnectionRequestFrame_Medium_entries,
                                  ConnectionRequestFrame_Medium_entries_by_number,
                                  14, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : ConnectionRequestFrame_Medium_strings[idx].get();
}

bool ConnectionRequestFrame_Medium_Parse(::absl::string_view name, ConnectionRequestFrame_Medium* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ConnectionRequestFrame_Medium_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionRequestFrame_Medium>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t ConnectionRequestFrame_ConnectionMode_internal_data_[] = {
    131072u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    ConnectionRequestFrame_ConnectionMode_strings[2] = {};

static const char ConnectionRequestFrame_ConnectionMode_names[] = {
    "INSTANT"
    "LEGACY"
};

static const ::google::protobuf::internal::EnumEntry ConnectionRequestFrame_ConnectionMode_entries[] = {
    {{&ConnectionRequestFrame_ConnectionMode_names[0], 7}, 1},
    {{&ConnectionRequestFrame_ConnectionMode_names[7], 6}, 0},
};

static const int ConnectionRequestFrame_ConnectionMode_entries_by_number[] = {
    1,  // 0 -> LEGACY
    0,  // 1 -> INSTANT
};

const ::std::string& ConnectionRequestFrame_ConnectionMode_Name(ConnectionRequestFrame_ConnectionMode value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      ConnectionRequestFrame_ConnectionMode_entries, ConnectionRequestFrame_ConnectionMode_entries_by_number, 2,
      ConnectionRequestFrame_ConnectionMode_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(ConnectionRequestFrame_ConnectionMode_entries,
                                  ConnectionRequestFrame_ConnectionMode_entries_by_number,
                                  2, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : ConnectionRequestFrame_ConnectionMode_strings[idx].get();
}

bool ConnectionRequestFrame_ConnectionMode_Parse(::absl::string_view name, ConnectionRequestFrame_ConnectionMode* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ConnectionRequestFrame_ConnectionMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionRequestFrame_ConnectionMode>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t ConnectionResponseFrame_ResponseStatus_internal_data_[] = {
    196608u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    ConnectionResponseFrame_ResponseStatus_strings[3] = {};

static const char ConnectionResponseFrame_ResponseStatus_names[] = {
    "ACCEPT"
    "REJECT"
    "UNKNOWN_RESPONSE_STATUS"
};

static const ::google::protobuf::internal::EnumEntry ConnectionResponseFrame_ResponseStatus_entries[] = {
    {{&ConnectionResponseFrame_ResponseStatus_names[0], 6}, 1},
    {{&ConnectionResponseFrame_ResponseStatus_names[6], 6}, 2},
    {{&ConnectionResponseFrame_ResponseStatus_names[12], 23}, 0},
};

static const int ConnectionResponseFrame_ResponseStatus_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_RESPONSE_STATUS
    0,  // 1 -> ACCEPT
    1,  // 2 -> REJECT
};

const ::std::string& ConnectionResponseFrame_ResponseStatus_Name(ConnectionResponseFrame_ResponseStatus value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      ConnectionResponseFrame_ResponseStatus_entries, ConnectionResponseFrame_ResponseStatus_entries_by_number, 3,
      ConnectionResponseFrame_ResponseStatus_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(ConnectionResponseFrame_ResponseStatus_entries,
                                  ConnectionResponseFrame_ResponseStatus_entries_by_number,
                                  3, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : ConnectionResponseFrame_ResponseStatus_strings[idx].get();
}

bool ConnectionResponseFrame_ResponseStatus_Parse(::absl::string_view name, ConnectionResponseFrame_ResponseStatus* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ConnectionResponseFrame_ResponseStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionResponseFrame_ResponseStatus>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t PayloadTransferFrame_PayloadHeader_PayloadType_internal_data_[] = {
    262144u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    PayloadTransferFrame_PayloadHeader_PayloadType_strings[4] = {};

static const char PayloadTransferFrame_PayloadHeader_PayloadType_names[] = {
    "BYTES"
    "FILE"
    "STREAM"
    "UNKNOWN_PAYLOAD_TYPE"
};

static const ::google::protobuf::internal::EnumEntry PayloadTransferFrame_PayloadHeader_PayloadType_entries[] = {
    {{&PayloadTransferFrame_PayloadHeader_PayloadType_names[0], 5}, 1},
    {{&PayloadTransferFrame_PayloadHeader_PayloadType_names[5], 4}, 2},
    {{&PayloadTransferFrame_PayloadHeader_PayloadType_names[9], 6}, 3},
    {{&PayloadTransferFrame_PayloadHeader_PayloadType_names[15], 20}, 0},
};

static const int PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number[] = {
    3,  // 0 -> UNKNOWN_PAYLOAD_TYPE
    0,  // 1 -> BYTES
    1,  // 2 -> FILE
    2,  // 3 -> STREAM
};

const ::std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(PayloadTransferFrame_PayloadHeader_PayloadType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      PayloadTransferFrame_PayloadHeader_PayloadType_entries, PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number, 4,
      PayloadTransferFrame_PayloadHeader_PayloadType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(PayloadTransferFrame_PayloadHeader_PayloadType_entries,
                                  PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number,
                                  4, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : PayloadTransferFrame_PayloadHeader_PayloadType_strings[idx].get();
}

bool PayloadTransferFrame_PayloadHeader_PayloadType_Parse(::absl::string_view name, PayloadTransferFrame_PayloadHeader_PayloadType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      PayloadTransferFrame_PayloadHeader_PayloadType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PayloadHeader_PayloadType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t PayloadTransferFrame_PayloadChunk_Flags_internal_data_[] = {
    65537u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    PayloadTransferFrame_PayloadChunk_Flags_strings[1] = {};

static const char PayloadTransferFrame_PayloadChunk_Flags_names[] = {
    "LAST_CHUNK"
};

static const ::google::protobuf::internal::EnumEntry PayloadTransferFrame_PayloadChunk_Flags_entries[] = {
    {{&PayloadTransferFrame_PayloadChunk_Flags_names[0], 10}, 1},
};

static const int PayloadTransferFrame_PayloadChunk_Flags_entries_by_number[] = {
    0,  // 1 -> LAST_CHUNK
};

const ::std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(PayloadTransferFrame_PayloadChunk_Flags value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      PayloadTransferFrame_PayloadChunk_Flags_entries, PayloadTransferFrame_PayloadChunk_Flags_entries_by_number, 1,
      PayloadTransferFrame_PayloadChunk_Flags_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(PayloadTransferFrame_PayloadChunk_Flags_entries,
                                  PayloadTransferFrame_PayloadChunk_Flags_entries_by_number,
                                  1, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : PayloadTransferFrame_PayloadChunk_Flags_strings[idx].get();
}

bool PayloadTransferFrame_PayloadChunk_Flags_Parse(::absl::string_view name, PayloadTransferFrame_PayloadChunk_Flags* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      PayloadTransferFrame_PayloadChunk_Flags_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PayloadChunk_Flags>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t PayloadTransferFrame_ControlMessage_EventType_internal_data_[] = {
    262144u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    PayloadTransferFrame_ControlMessage_EventType_strings[4] = {};

static const char PayloadTransferFrame_ControlMessage_EventType_names[] = {
    "PAYLOAD_CANCELED"
    "PAYLOAD_ERROR"
    "PAYLOAD_RECEIVED_ACK"
    "UNKNOWN_EVENT_TYPE"
};

static const ::google::protobuf::internal::EnumEntry PayloadTransferFrame_ControlMessage_EventType_entries[] = {
    {{&PayloadTransferFrame_ControlMessage_EventType_names[0], 16}, 2},
    {{&PayloadTransferFrame_ControlMessage_EventType_names[16], 13}, 1},
    {{&PayloadTransferFrame_ControlMessage_EventType_names[29], 20}, 3},
    {{&PayloadTransferFrame_ControlMessage_EventType_names[49], 18}, 0},
};

static const int PayloadTransferFrame_ControlMessage_EventType_entries_by_number[] = {
    3,  // 0 -> UNKNOWN_EVENT_TYPE
    1,  // 1 -> PAYLOAD_ERROR
    0,  // 2 -> PAYLOAD_CANCELED
    2,  // 3 -> PAYLOAD_RECEIVED_ACK
};

const ::std::string& PayloadTransferFrame_ControlMessage_EventType_Name(PayloadTransferFrame_ControlMessage_EventType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      PayloadTransferFrame_ControlMessage_EventType_entries, PayloadTransferFrame_ControlMessage_EventType_entries_by_number, 4,
      PayloadTransferFrame_ControlMessage_EventType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(PayloadTransferFrame_ControlMessage_EventType_entries,
                                  PayloadTransferFrame_ControlMessage_EventType_entries_by_number,
                                  4, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : PayloadTransferFrame_ControlMessage_EventType_strings[idx].get();
}

bool PayloadTransferFrame_ControlMessage_EventType_Parse(::absl::string_view name, PayloadTransferFrame_ControlMessage_EventType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      PayloadTransferFrame_ControlMessage_EventType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_ControlMessage_EventType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t PayloadTransferFrame_PacketType_internal_data_[] = {
    262144u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    PayloadTransferFrame_PacketType_strings[4] = {};

static const char PayloadTransferFrame_PacketType_names[] = {
    "CONTROL"
    "DATA"
    "PAYLOAD_ACK"
    "UNKNOWN_PACKET_TYPE"
};

static const ::google::protobuf::internal::EnumEntry PayloadTransferFrame_PacketType_entries[] = {
    {{&PayloadTransferFrame_PacketType_names[0], 7}, 2},
    {{&PayloadTransferFrame_PacketType_names[7], 4}, 1},
    {{&PayloadTransferFrame_PacketType_names[11], 11}, 3},
    {{&PayloadTransferFrame_PacketType_names[22], 19}, 0},
};

static const int PayloadTransferFrame_PacketType_entries_by_number[] = {
    3,  // 0 -> UNKNOWN_PACKET_TYPE
    1,  // 1 -> DATA
    0,  // 2 -> CONTROL
    2,  // 3 -> PAYLOAD_ACK
};

const ::std::string& PayloadTransferFrame_PacketType_Name(PayloadTransferFrame_PacketType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      PayloadTransferFrame_PacketType_entries, PayloadTransferFrame_PacketType_entries_by_number, 4,
      PayloadTransferFrame_PacketType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(PayloadTransferFrame_PacketType_entries,
                                  PayloadTransferFrame_PacketType_entries_by_number,
                                  4, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : PayloadTransferFrame_PacketType_strings[idx].get();
}

bool PayloadTransferFrame_PacketType_Parse(::absl::string_view name, PayloadTransferFrame_PacketType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      PayloadTransferFrame_PacketType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PacketType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_internal_data_[] = {
    655360u, 32u, 14u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings[13] = {};

static const char BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[] = {
    "AWDL"
    "BLE"
    "BLUETOOTH"
    "MDNS"
    "NFC"
    "UNKNOWN_MEDIUM"
    "USB"
    "WEB_RTC"
    "WEB_RTC_NON_CELLULAR"
    "WIFI_AWARE"
    "WIFI_DIRECT"
    "WIFI_HOTSPOT"
    "WIFI_LAN"
};

static const ::google::protobuf::internal::EnumEntry BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries[] = {
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[0], 4}, 13},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[4], 3}, 4},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[7], 9}, 2},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[16], 4}, 1},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[20], 3}, 7},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[23], 14}, 0},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[37], 3}, 11},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[40], 7}, 9},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[47], 20}, 12},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[67], 10}, 6},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[77], 11}, 8},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[88], 12}, 3},
    {{&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[100], 8}, 5},
};

static const int BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number[] = {
    5,  // 0 -> UNKNOWN_MEDIUM
    3,  // 1 -> MDNS
    2,  // 2 -> BLUETOOTH
    11,  // 3 -> WIFI_HOTSPOT
    1,  // 4 -> BLE
    12,  // 5 -> WIFI_LAN
    9,  // 6 -> WIFI_AWARE
    4,  // 7 -> NFC
    10,  // 8 -> WIFI_DIRECT
    7,  // 9 -> WEB_RTC
    6,  // 11 -> USB
    8,  // 12 -> WEB_RTC_NON_CELLULAR
    0,  // 13 -> AWDL
};

const ::std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number, 13,
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries,
                                  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number,
                                  13, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings[idx].get();
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Parse(::absl::string_view name, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t BandwidthUpgradeNegotiationFrame_EventType_internal_data_[] = {
    524288u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    BandwidthUpgradeNegotiationFrame_EventType_strings[8] = {};

static const char BandwidthUpgradeNegotiationFrame_EventType_names[] = {
    "CLIENT_INTRODUCTION"
    "CLIENT_INTRODUCTION_ACK"
    "LAST_WRITE_TO_PRIOR_CHANNEL"
    "SAFE_TO_CLOSE_PRIOR_CHANNEL"
    "UNKNOWN_EVENT_TYPE"
    "UPGRADE_FAILURE"
    "UPGRADE_PATH_AVAILABLE"
    "UPGRADE_PATH_REQUEST"
};

static const ::google::protobuf::internal::EnumEntry BandwidthUpgradeNegotiationFrame_EventType_entries[] = {
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[0], 19}, 4},
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[19], 23}, 6},
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[42], 27}, 2},
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[69], 27}, 3},
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[96], 18}, 0},
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[114], 15}, 5},
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[129], 22}, 1},
    {{&BandwidthUpgradeNegotiationFrame_EventType_names[151], 20}, 7},
};

static const int BandwidthUpgradeNegotiationFrame_EventType_entries_by_number[] = {
    4,  // 0 -> UNKNOWN_EVENT_TYPE
    6,  // 1 -> UPGRADE_PATH_AVAILABLE
    2,  // 2 -> LAST_WRITE_TO_PRIOR_CHANNEL
    3,  // 3 -> SAFE_TO_CLOSE_PRIOR_CHANNEL
    0,  // 4 -> CLIENT_INTRODUCTION
    5,  // 5 -> UPGRADE_FAILURE
    1,  // 6 -> CLIENT_INTRODUCTION_ACK
    7,  // 7 -> UPGRADE_PATH_REQUEST
};

const ::std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(BandwidthUpgradeNegotiationFrame_EventType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      BandwidthUpgradeNegotiationFrame_EventType_entries, BandwidthUpgradeNegotiationFrame_EventType_entries_by_number, 8,
      BandwidthUpgradeNegotiationFrame_EventType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(BandwidthUpgradeNegotiationFrame_EventType_entries,
                                  BandwidthUpgradeNegotiationFrame_EventType_entries_by_number,
                                  8, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : BandwidthUpgradeNegotiationFrame_EventType_strings[idx].get();
}

bool BandwidthUpgradeNegotiationFrame_EventType_Parse(::absl::string_view name, BandwidthUpgradeNegotiationFrame_EventType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      BandwidthUpgradeNegotiationFrame_EventType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeNegotiationFrame_EventType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t BandwidthUpgradeRetryFrame_Medium_internal_data_[] = {
    65536u, 32u, 8190u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    BandwidthUpgradeRetryFrame_Medium_strings[13] = {};

static const char BandwidthUpgradeRetryFrame_Medium_names[] = {
    "AWDL"
    "BLE"
    "BLE_L2CAP"
    "BLUETOOTH"
    "NFC"
    "UNKNOWN_MEDIUM"
    "USB"
    "WEB_RTC"
    "WEB_RTC_NON_CELLULAR"
    "WIFI_AWARE"
    "WIFI_DIRECT"
    "WIFI_HOTSPOT"
    "WIFI_LAN"
};

static const ::google::protobuf::internal::EnumEntry BandwidthUpgradeRetryFrame_Medium_entries[] = {
    {{&BandwidthUpgradeRetryFrame_Medium_names[0], 4}, 13},
    {{&BandwidthUpgradeRetryFrame_Medium_names[4], 3}, 4},
    {{&BandwidthUpgradeRetryFrame_Medium_names[7], 9}, 10},
    {{&BandwidthUpgradeRetryFrame_Medium_names[16], 9}, 2},
    {{&BandwidthUpgradeRetryFrame_Medium_names[25], 3}, 7},
    {{&BandwidthUpgradeRetryFrame_Medium_names[28], 14}, 0},
    {{&BandwidthUpgradeRetryFrame_Medium_names[42], 3}, 11},
    {{&BandwidthUpgradeRetryFrame_Medium_names[45], 7}, 9},
    {{&BandwidthUpgradeRetryFrame_Medium_names[52], 20}, 12},
    {{&BandwidthUpgradeRetryFrame_Medium_names[72], 10}, 6},
    {{&BandwidthUpgradeRetryFrame_Medium_names[82], 11}, 8},
    {{&BandwidthUpgradeRetryFrame_Medium_names[93], 12}, 3},
    {{&BandwidthUpgradeRetryFrame_Medium_names[105], 8}, 5},
};

static const int BandwidthUpgradeRetryFrame_Medium_entries_by_number[] = {
    5,  // 0 -> UNKNOWN_MEDIUM
    3,  // 2 -> BLUETOOTH
    11,  // 3 -> WIFI_HOTSPOT
    1,  // 4 -> BLE
    12,  // 5 -> WIFI_LAN
    9,  // 6 -> WIFI_AWARE
    4,  // 7 -> NFC
    10,  // 8 -> WIFI_DIRECT
    7,  // 9 -> WEB_RTC
    2,  // 10 -> BLE_L2CAP
    6,  // 11 -> USB
    8,  // 12 -> WEB_RTC_NON_CELLULAR
    0,  // 13 -> AWDL
};

const ::std::string& BandwidthUpgradeRetryFrame_Medium_Name(BandwidthUpgradeRetryFrame_Medium value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      BandwidthUpgradeRetryFrame_Medium_entries, BandwidthUpgradeRetryFrame_Medium_entries_by_number, 13,
      BandwidthUpgradeRetryFrame_Medium_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(BandwidthUpgradeRetryFrame_Medium_entries,
                                  BandwidthUpgradeRetryFrame_Medium_entries_by_number,
                                  13, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : BandwidthUpgradeRetryFrame_Medium_strings[idx].get();
}

bool BandwidthUpgradeRetryFrame_Medium_Parse(::absl::string_view name, BandwidthUpgradeRetryFrame_Medium* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      BandwidthUpgradeRetryFrame_Medium_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeRetryFrame_Medium>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t AutoResumeFrame_EventType_internal_data_[] = {
    196608u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    AutoResumeFrame_EventType_strings[3] = {};

static const char AutoResumeFrame_EventType_names[] = {
    "PAYLOAD_RESUME_TRANSFER_ACK"
    "PAYLOAD_RESUME_TRANSFER_START"
    "UNKNOWN_AUTO_RESUME_EVENT_TYPE"
};

static const ::google::protobuf::internal::EnumEntry AutoResumeFrame_EventType_entries[] = {
    {{&AutoResumeFrame_EventType_names[0], 27}, 2},
    {{&AutoResumeFrame_EventType_names[27], 29}, 1},
    {{&AutoResumeFrame_EventType_names[56], 30}, 0},
};

static const int AutoResumeFrame_EventType_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_AUTO_RESUME_EVENT_TYPE
    1,  // 1 -> PAYLOAD_RESUME_TRANSFER_START
    0,  // 2 -> PAYLOAD_RESUME_TRANSFER_ACK
};

const ::std::string& AutoResumeFrame_EventType_Name(AutoResumeFrame_EventType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      AutoResumeFrame_EventType_entries, AutoResumeFrame_EventType_entries_by_number, 3,
      AutoResumeFrame_EventType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(AutoResumeFrame_EventType_entries,
                                  AutoResumeFrame_EventType_entries_by_number,
                                  3, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : AutoResumeFrame_EventType_strings[idx].get();
}

bool AutoResumeFrame_EventType_Parse(::absl::string_view name, AutoResumeFrame_EventType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      AutoResumeFrame_EventType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AutoResumeFrame_EventType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t AutoReconnectFrame_EventType_internal_data_[] = {
    196608u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    AutoReconnectFrame_EventType_strings[3] = {};

static const char AutoReconnectFrame_EventType_names[] = {
    "CLIENT_INTRODUCTION"
    "CLIENT_INTRODUCTION_ACK"
    "UNKNOWN_EVENT_TYPE"
};

static const ::google::protobuf::internal::EnumEntry AutoReconnectFrame_EventType_entries[] = {
    {{&AutoReconnectFrame_EventType_names[0], 19}, 1},
    {{&AutoReconnectFrame_EventType_names[19], 23}, 2},
    {{&AutoReconnectFrame_EventType_names[42], 18}, 0},
};

static const int AutoReconnectFrame_EventType_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_EVENT_TYPE
    0,  // 1 -> CLIENT_INTRODUCTION
    1,  // 2 -> CLIENT_INTRODUCTION_ACK
};

const ::std::string& AutoReconnectFrame_EventType_Name(AutoReconnectFrame_EventType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      AutoReconnectFrame_EventType_entries, AutoReconnectFrame_EventType_entries_by_number, 3,
      AutoReconnectFrame_EventType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(AutoReconnectFrame_EventType_entries,
                                  AutoReconnectFrame_EventType_entries_by_number,
                                  3, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : AutoReconnectFrame_EventType_strings[idx].get();
}

bool AutoReconnectFrame_EventType_Parse(::absl::string_view name, AutoReconnectFrame_EventType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      AutoReconnectFrame_EventType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AutoReconnectFrame_EventType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t MediumMetadata_WifiDirectAuthType_internal_data_[] = {
    196608u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    MediumMetadata_WifiDirectAuthType_strings[3] = {};

static const char MediumMetadata_WifiDirectAuthType_names[] = {
    "WIFI_DIRECT_TYPE_UNKNOWN"
    "WIFI_DIRECT_WITH_PASSWORD"
    "WIFI_DIRECT_WITH_PIN"
};

static const ::google::protobuf::internal::EnumEntry MediumMetadata_WifiDirectAuthType_entries[] = {
    {{&MediumMetadata_WifiDirectAuthType_names[0], 24}, 0},
    {{&MediumMetadata_WifiDirectAuthType_names[24], 25}, 1},
    {{&MediumMetadata_WifiDirectAuthType_names[49], 20}, 2},
};

static const int MediumMetadata_WifiDirectAuthType_entries_by_number[] = {
    0,  // 0 -> WIFI_DIRECT_TYPE_UNKNOWN
    1,  // 1 -> WIFI_DIRECT_WITH_PASSWORD
    2,  // 2 -> WIFI_DIRECT_WITH_PIN
};

const ::std::string& MediumMetadata_WifiDirectAuthType_Name(MediumMetadata_WifiDirectAuthType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      MediumMetadata_WifiDirectAuthType_entries, MediumMetadata_WifiDirectAuthType_entries_by_number, 3,
      MediumMetadata_WifiDirectAuthType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(MediumMetadata_WifiDirectAuthType_entries,
                                  MediumMetadata_WifiDirectAuthType_entries_by_number,
                                  3, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : MediumMetadata_WifiDirectAuthType_strings[idx].get();
}

bool MediumMetadata_WifiDirectAuthType_Parse(::absl::string_view name, MediumMetadata_WifiDirectAuthType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      MediumMetadata_WifiDirectAuthType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<MediumMetadata_WifiDirectAuthType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t LocationStandard_Format_internal_data_[] = {
    196608u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    LocationStandard_Format_strings[3] = {};

static const char LocationStandard_Format_names[] = {
    "E164_CALLING"
    "ISO_3166_1_ALPHA_2"
    "UNKNOWN"
};

static const ::google::protobuf::internal::EnumEntry LocationStandard_Format_entries[] = {
    {{&LocationStandard_Format_names[0], 12}, 1},
    {{&LocationStandard_Format_names[12], 18}, 2},
    {{&LocationStandard_Format_names[30], 7}, 0},
};

static const int LocationStandard_Format_entries_by_number[] = {
    2,  // 0 -> UNKNOWN
    0,  // 1 -> E164_CALLING
    1,  // 2 -> ISO_3166_1_ALPHA_2
};

const ::std::string& LocationStandard_Format_Name(LocationStandard_Format value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      LocationStandard_Format_entries, LocationStandard_Format_entries_by_number, 3,
      LocationStandard_Format_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(LocationStandard_Format_entries,
                                  LocationStandard_Format_entries_by_number,
                                  3, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : LocationStandard_Format_strings[idx].get();
}

bool LocationStandard_Format_Parse(::absl::string_view name, LocationStandard_Format* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      LocationStandard_Format_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LocationStandard_Format>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t OsInfo_OsType_internal_data_[] = {
    327680u, 65536u, 100u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    OsInfo_OsType_strings[6] = {};

static const char OsInfo_OsType_names[] = {
    "ANDROID"
    "APPLE"
    "CHROME_OS"
    "LINUX"
    "UNKNOWN_OS_TYPE"
    "WINDOWS"
};

static const ::google::protobuf::internal::EnumEntry OsInfo_OsType_entries[] = {
    {{&OsInfo_OsType_names[0], 7}, 1},
    {{&OsInfo_OsType_names[7], 5}, 4},
    {{&OsInfo_OsType_names[12], 9}, 2},
    {{&OsInfo_OsType_names[21], 5}, 100},
    {{&OsInfo_OsType_names[26], 15}, 0},
    {{&OsInfo_OsType_names[41], 7}, 3},
};

static const int OsInfo_OsType_entries_by_number[] = {
    4,  // 0 -> UNKNOWN_OS_TYPE
    0,  // 1 -> ANDROID
    2,  // 2 -> CHROME_OS
    5,  // 3 -> WINDOWS
    1,  // 4 -> APPLE
    3,  // 100 -> LINUX
};

const ::std::string& OsInfo_OsType_Name(OsInfo_OsType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      OsInfo_OsType_entries, OsInfo_OsType_entries_by_number, 6,
      OsInfo_OsType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(OsInfo_OsType_entries,
                                  OsInfo_OsType_entries_by_number,
                                  6, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : OsInfo_OsType_strings[idx].get();
}

bool OsInfo_OsType_Parse(::absl::string_view name, OsInfo_OsType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      OsInfo_OsType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<OsInfo_OsType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t PresenceDevice_DeviceType_internal_data_[] = {
    458752u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    PresenceDevice_DeviceType_strings[7] = {};

static const char PresenceDevice_DeviceType_names[] = {
    "DISPLAY"
    "LAPTOP"
    "PHONE"
    "TABLET"
    "TV"
    "UNKNOWN"
    "WATCH"
};

static const ::google::protobuf::internal::EnumEntry PresenceDevice_DeviceType_entries[] = {
    {{&PresenceDevice_DeviceType_names[0], 7}, 3},
    {{&PresenceDevice_DeviceType_names[7], 6}, 4},
    {{&PresenceDevice_DeviceType_names[13], 5}, 1},
    {{&PresenceDevice_DeviceType_names[18], 6}, 2},
    {{&PresenceDevice_DeviceType_names[24], 2}, 5},
    {{&PresenceDevice_DeviceType_names[26], 7}, 0},
    {{&PresenceDevice_DeviceType_names[33], 5}, 6},
};

static const int PresenceDevice_DeviceType_entries_by_number[] = {
    5,  // 0 -> UNKNOWN
    2,  // 1 -> PHONE
    3,  // 2 -> TABLET
    0,  // 3 -> DISPLAY
    1,  // 4 -> LAPTOP
    4,  // 5 -> TV
    6,  // 6 -> WATCH
};

const ::std::string& PresenceDevice_DeviceType_Name(PresenceDevice_DeviceType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      PresenceDevice_DeviceType_entries, PresenceDevice_DeviceType_entries_by_number, 7,
      PresenceDevice_DeviceType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(PresenceDevice_DeviceType_entries,
                                  PresenceDevice_DeviceType_entries_by_number,
                                  7, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : PresenceDevice_DeviceType_strings[idx].get();
}

bool PresenceDevice_DeviceType_Parse(::absl::string_view name, PresenceDevice_DeviceType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      PresenceDevice_DeviceType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<PresenceDevice_DeviceType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t EndpointType_internal_data_[] = {
    196608u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    EndpointType_strings[3] = {};

static const char EndpointType_names[] = {
    "CONNECTIONS_ENDPOINT"
    "PRESENCE_ENDPOINT"
    "UNKNOWN_ENDPOINT"
};

static const ::google::protobuf::internal::EnumEntry EndpointType_entries[] = {
    {{&EndpointType_names[0], 20}, 1},
    {{&EndpointType_names[20], 17}, 2},
    {{&EndpointType_names[37], 16}, 0},
};

static const int EndpointType_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_ENDPOINT
    0,  // 1 -> CONNECTIONS_ENDPOINT
    1,  // 2 -> PRESENCE_ENDPOINT
};

const ::std::string& EndpointType_Name(EndpointType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      EndpointType_entries, EndpointType_entries_by_number, 3,
      EndpointType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(EndpointType_entries,
                                  EndpointType_entries_by_number,
                                  3, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : EndpointType_strings[idx].get();
}

bool EndpointType_Parse(::absl::string_view name, EndpointType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      EndpointType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<EndpointType>(int_value);
  }
  return success;
}
// ===================================================================

class OfflineFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<OfflineFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_._has_bits_);
};

OfflineFrame::OfflineFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, OfflineFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.OfflineFrame)
}
PROTOBUF_NDEBUG_INLINE OfflineFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::OfflineFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

OfflineFrame::OfflineFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const OfflineFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, OfflineFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  OfflineFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.v1_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.v1_)
                : nullptr;
  _impl_.version_ = from._impl_.version_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.OfflineFrame)
}
PROTOBUF_NDEBUG_INLINE OfflineFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void OfflineFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, v1_),
           0,
           offsetof(Impl_, version_) -
               offsetof(Impl_, v1_) +
               sizeof(Impl_::version_));
}
OfflineFrame::~OfflineFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.OfflineFrame)
  SharedDtor(*this);
}
inline void OfflineFrame::SharedDtor(MessageLite& self) {
  OfflineFrame& this_ = static_cast<OfflineFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.v1_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL OfflineFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) OfflineFrame(arena);
}
constexpr auto OfflineFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(OfflineFrame),
                                            alignof(OfflineFrame));
}
constexpr auto OfflineFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<41>{
      {
          &_OfflineFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &OfflineFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<OfflineFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &OfflineFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<OfflineFrame>(), &OfflineFrame::ByteSizeLong,
              &OfflineFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.OfflineFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<41> OfflineFrame_class_data_ =
    OfflineFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
OfflineFrame::GetClassData() const {
  return OfflineFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2>
OfflineFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    OfflineFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::OfflineFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .location.nearby.connections.V1Frame v1 = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_.v1_)}},
    // optional .location.nearby.connections.OfflineFrame.Version version = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 1, 1,
      PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_.version_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.OfflineFrame.Version version = 1;
    {PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_.version_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .location.nearby.connections.V1Frame v1 = 2;
    {PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_.v1_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::V1Frame>()},
      {0, 1},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void OfflineFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.OfflineFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(_impl_.v1_ != nullptr);
    _impl_.v1_->Clear();
  }
  _impl_.version_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL OfflineFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const OfflineFrame& this_ = static_cast<const OfflineFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL OfflineFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const OfflineFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.OfflineFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.OfflineFrame.Version version = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_version(), target);
  }

  // optional .location.nearby.connections.V1Frame v1 = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.v1_, this_._impl_.v1_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.OfflineFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t OfflineFrame::ByteSizeLong(const MessageLite& base) {
  const OfflineFrame& this_ = static_cast<const OfflineFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t OfflineFrame::ByteSizeLong() const {
  const OfflineFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.OfflineFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional .location.nearby.connections.V1Frame v1 = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.v1_);
    }
    // optional .location.nearby.connections.OfflineFrame.Version version = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_version());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void OfflineFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<OfflineFrame*>(&to_msg);
  auto& from = static_cast<const OfflineFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.OfflineFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.v1_ != nullptr);
      if (_this->_impl_.v1_ == nullptr) {
        _this->_impl_.v1_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.v1_);
      } else {
        _this->_impl_.v1_->MergeFrom(*from._impl_.v1_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.version_ = from._impl_.version_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void OfflineFrame::CopyFrom(const OfflineFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.OfflineFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void OfflineFrame::InternalSwap(OfflineFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_.version_)
      + sizeof(OfflineFrame::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(OfflineFrame, _impl_.v1_)>(
          reinterpret_cast<char*>(&_impl_.v1_),
          reinterpret_cast<char*>(&other->_impl_.v1_));
}

// ===================================================================

class V1Frame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<V1Frame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(V1Frame, _impl_._has_bits_);
};

V1Frame::V1Frame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, V1Frame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.V1Frame)
}
PROTOBUF_NDEBUG_INLINE V1Frame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::V1Frame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

V1Frame::V1Frame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const V1Frame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, V1Frame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  V1Frame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.connection_request_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.connection_request_)
                : nullptr;
  _impl_.connection_response_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.connection_response_)
                : nullptr;
  _impl_.payload_transfer_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.payload_transfer_)
                : nullptr;
  _impl_.bandwidth_upgrade_negotiation_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.bandwidth_upgrade_negotiation_)
                : nullptr;
  _impl_.keep_alive_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.keep_alive_)
                : nullptr;
  _impl_.disconnection_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.disconnection_)
                : nullptr;
  _impl_.paired_key_encryption_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.paired_key_encryption_)
                : nullptr;
  _impl_.authentication_message_ = (CheckHasBit(cached_has_bits, 0x00000080U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.authentication_message_)
                : nullptr;
  _impl_.authentication_result_ = (CheckHasBit(cached_has_bits, 0x00000100U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.authentication_result_)
                : nullptr;
  _impl_.auto_resume_ = (CheckHasBit(cached_has_bits, 0x00000200U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.auto_resume_)
                : nullptr;
  _impl_.auto_reconnect_ = (CheckHasBit(cached_has_bits, 0x00000400U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.auto_reconnect_)
                : nullptr;
  _impl_.bandwidth_upgrade_retry_ = (CheckHasBit(cached_has_bits, 0x00000800U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.bandwidth_upgrade_retry_)
                : nullptr;
  _impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.V1Frame)
}
PROTOBUF_NDEBUG_INLINE V1Frame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void V1Frame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, connection_request_),
           0,
           offsetof(Impl_, type_) -
               offsetof(Impl_, connection_request_) +
               sizeof(Impl_::type_));
}
V1Frame::~V1Frame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.V1Frame)
  SharedDtor(*this);
}
inline void V1Frame::SharedDtor(MessageLite& self) {
  V1Frame& this_ = static_cast<V1Frame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.connection_request_;
  delete this_._impl_.connection_response_;
  delete this_._impl_.payload_transfer_;
  delete this_._impl_.bandwidth_upgrade_negotiation_;
  delete this_._impl_.keep_alive_;
  delete this_._impl_.disconnection_;
  delete this_._impl_.paired_key_encryption_;
  delete this_._impl_.authentication_message_;
  delete this_._impl_.authentication_result_;
  delete this_._impl_.auto_resume_;
  delete this_._impl_.auto_reconnect_;
  delete this_._impl_.bandwidth_upgrade_retry_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL V1Frame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) V1Frame(arena);
}
constexpr auto V1Frame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(V1Frame),
                                            alignof(V1Frame));
}
constexpr auto V1Frame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<36>{
      {
          &_V1Frame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &V1Frame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<V1Frame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &V1Frame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<V1Frame>(), &V1Frame::ByteSizeLong,
              &V1Frame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(V1Frame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.V1Frame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<36> V1Frame_class_data_ =
    V1Frame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
V1Frame::GetClassData() const {
  return V1Frame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 13, 0, 2>
V1Frame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(V1Frame, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    13,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    V1Frame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::V1Frame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .location.nearby.connections.V1Frame.FrameType type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 12, 12,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.type_)}},
    // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.connection_request_)}},
    // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.connection_response_)}},
    // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.payload_transfer_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 3,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.bandwidth_upgrade_negotiation_)}},
    // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 4,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.keep_alive_)}},
    // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 5, 5,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.disconnection_)}},
    // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
    {::_pbi::TcParser::FastMtS1,
     {66, 6, 6,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.paired_key_encryption_)}},
    // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 7, 7,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.authentication_message_)}},
    // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 8, 8,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.authentication_result_)}},
    // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
    {::_pbi::TcParser::FastMtS1,
     {90, 9, 9,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.auto_resume_)}},
    // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 10, 10,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.auto_reconnect_)}},
    // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
    {::_pbi::TcParser::FastMtS1,
     {106, 11, 11,
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.bandwidth_upgrade_retry_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.V1Frame.FrameType type = 1;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.type_), _Internal::kHasBitsOffset + 12, 12, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.connection_request_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.connection_response_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.payload_transfer_), _Internal::kHasBitsOffset + 2, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.bandwidth_upgrade_negotiation_), _Internal::kHasBitsOffset + 3, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.keep_alive_), _Internal::kHasBitsOffset + 4, 4, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.disconnection_), _Internal::kHasBitsOffset + 5, 5, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.paired_key_encryption_), _Internal::kHasBitsOffset + 6, 6, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.authentication_message_), _Internal::kHasBitsOffset + 7, 7, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.authentication_result_), _Internal::kHasBitsOffset + 8, 8, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.auto_resume_), _Internal::kHasBitsOffset + 9, 9, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.auto_reconnect_), _Internal::kHasBitsOffset + 10, 10, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
    {PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.bandwidth_upgrade_retry_), _Internal::kHasBitsOffset + 11, 11, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::ConnectionRequestFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::ConnectionResponseFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::KeepAliveFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::DisconnectionFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::PairedKeyEncryptionFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::AuthenticationMessageFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::AuthenticationResultFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::AutoResumeFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::AutoReconnectFrame>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeRetryFrame>()},
      {0, 12},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void V1Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.V1Frame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(_impl_.connection_request_ != nullptr);
      _impl_.connection_request_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.connection_response_ != nullptr);
      _impl_.connection_response_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.payload_transfer_ != nullptr);
      _impl_.payload_transfer_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.bandwidth_upgrade_negotiation_ != nullptr);
      _impl_.bandwidth_upgrade_negotiation_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.keep_alive_ != nullptr);
      _impl_.keep_alive_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.disconnection_ != nullptr);
      _impl_.disconnection_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.paired_key_encryption_ != nullptr);
      _impl_.paired_key_encryption_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(_impl_.authentication_message_ != nullptr);
      _impl_.authentication_message_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000f00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      ABSL_DCHECK(_impl_.authentication_result_ != nullptr);
      _impl_.authentication_result_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      ABSL_DCHECK(_impl_.auto_resume_ != nullptr);
      _impl_.auto_resume_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      ABSL_DCHECK(_impl_.auto_reconnect_ != nullptr);
      _impl_.auto_reconnect_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      ABSL_DCHECK(_impl_.bandwidth_upgrade_retry_ != nullptr);
      _impl_.bandwidth_upgrade_retry_->Clear();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL V1Frame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const V1Frame& this_ = static_cast<const V1Frame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL V1Frame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const V1Frame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.V1Frame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.V1Frame.FrameType type = 1;
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_type(), target);
  }

  // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.connection_request_, this_._impl_.connection_request_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.connection_response_, this_._impl_.connection_response_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.payload_transfer_, this_._impl_.payload_transfer_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.bandwidth_upgrade_negotiation_, this_._impl_.bandwidth_upgrade_negotiation_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.keep_alive_, this_._impl_.keep_alive_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, *this_._impl_.disconnection_, this_._impl_.disconnection_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, *this_._impl_.paired_key_encryption_, this_._impl_.paired_key_encryption_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, *this_._impl_.authentication_message_, this_._impl_.authentication_message_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        10, *this_._impl_.authentication_result_, this_._impl_.authentication_result_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        11, *this_._impl_.auto_resume_, this_._impl_.auto_resume_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        12, *this_._impl_.auto_reconnect_, this_._impl_.auto_reconnect_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        13, *this_._impl_.bandwidth_upgrade_retry_, this_._impl_.bandwidth_upgrade_retry_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.V1Frame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t V1Frame::ByteSizeLong(const MessageLite& base) {
  const V1Frame& this_ = static_cast<const V1Frame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t V1Frame::ByteSizeLong() const {
  const V1Frame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.V1Frame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.connection_request_);
    }
    // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.connection_response_);
    }
    // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_transfer_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.bandwidth_upgrade_negotiation_);
    }
    // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.keep_alive_);
    }
    // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.disconnection_);
    }
    // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.paired_key_encryption_);
    }
    // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.authentication_message_);
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00001f00U)) {
    // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.authentication_result_);
    }
    // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.auto_resume_);
    }
    // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.auto_reconnect_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.bandwidth_upgrade_retry_);
    }
    // optional .location.nearby.connections.V1Frame.FrameType type = 1;
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void V1Frame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<V1Frame*>(&to_msg);
  auto& from = static_cast<const V1Frame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.V1Frame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.connection_request_ != nullptr);
      if (_this->_impl_.connection_request_ == nullptr) {
        _this->_impl_.connection_request_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.connection_request_);
      } else {
        _this->_impl_.connection_request_->MergeFrom(*from._impl_.connection_request_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.connection_response_ != nullptr);
      if (_this->_impl_.connection_response_ == nullptr) {
        _this->_impl_.connection_response_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.connection_response_);
      } else {
        _this->_impl_.connection_response_->MergeFrom(*from._impl_.connection_response_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.payload_transfer_ != nullptr);
      if (_this->_impl_.payload_transfer_ == nullptr) {
        _this->_impl_.payload_transfer_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.payload_transfer_);
      } else {
        _this->_impl_.payload_transfer_->MergeFrom(*from._impl_.payload_transfer_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.bandwidth_upgrade_negotiation_ != nullptr);
      if (_this->_impl_.bandwidth_upgrade_negotiation_ == nullptr) {
        _this->_impl_.bandwidth_upgrade_negotiation_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.bandwidth_upgrade_negotiation_);
      } else {
        _this->_impl_.bandwidth_upgrade_negotiation_->MergeFrom(*from._impl_.bandwidth_upgrade_negotiation_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.keep_alive_ != nullptr);
      if (_this->_impl_.keep_alive_ == nullptr) {
        _this->_impl_.keep_alive_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.keep_alive_);
      } else {
        _this->_impl_.keep_alive_->MergeFrom(*from._impl_.keep_alive_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.disconnection_ != nullptr);
      if (_this->_impl_.disconnection_ == nullptr) {
        _this->_impl_.disconnection_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.disconnection_);
      } else {
        _this->_impl_.disconnection_->MergeFrom(*from._impl_.disconnection_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.paired_key_encryption_ != nullptr);
      if (_this->_impl_.paired_key_encryption_ == nullptr) {
        _this->_impl_.paired_key_encryption_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.paired_key_encryption_);
      } else {
        _this->_impl_.paired_key_encryption_->MergeFrom(*from._impl_.paired_key_encryption_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(from._impl_.authentication_message_ != nullptr);
      if (_this->_impl_.authentication_message_ == nullptr) {
        _this->_impl_.authentication_message_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.authentication_message_);
      } else {
        _this->_impl_.authentication_message_->MergeFrom(*from._impl_.authentication_message_);
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00001f00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      ABSL_DCHECK(from._impl_.authentication_result_ != nullptr);
      if (_this->_impl_.authentication_result_ == nullptr) {
        _this->_impl_.authentication_result_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.authentication_result_);
      } else {
        _this->_impl_.authentication_result_->MergeFrom(*from._impl_.authentication_result_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      ABSL_DCHECK(from._impl_.auto_resume_ != nullptr);
      if (_this->_impl_.auto_resume_ == nullptr) {
        _this->_impl_.auto_resume_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.auto_resume_);
      } else {
        _this->_impl_.auto_resume_->MergeFrom(*from._impl_.auto_resume_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      ABSL_DCHECK(from._impl_.auto_reconnect_ != nullptr);
      if (_this->_impl_.auto_reconnect_ == nullptr) {
        _this->_impl_.auto_reconnect_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.auto_reconnect_);
      } else {
        _this->_impl_.auto_reconnect_->MergeFrom(*from._impl_.auto_reconnect_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      ABSL_DCHECK(from._impl_.bandwidth_upgrade_retry_ != nullptr);
      if (_this->_impl_.bandwidth_upgrade_retry_ == nullptr) {
        _this->_impl_.bandwidth_upgrade_retry_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.bandwidth_upgrade_retry_);
      } else {
        _this->_impl_.bandwidth_upgrade_retry_->MergeFrom(*from._impl_.bandwidth_upgrade_retry_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_impl_.type_ = from._impl_.type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void V1Frame::CopyFrom(const V1Frame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.V1Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void V1Frame::InternalSwap(V1Frame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.type_)
      + sizeof(V1Frame::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.connection_request_)>(
          reinterpret_cast<char*>(&_impl_.connection_request_),
          reinterpret_cast<char*>(&other->_impl_.connection_request_));
}

// ===================================================================

class ConnectionRequestFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ConnectionRequestFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::location::nearby::connections::ConnectionRequestFrame, _impl_._oneof_case_);
};

void ConnectionRequestFrame::set_allocated_connections_device(::location::nearby::connections::ConnectionsDevice* PROTOBUF_NULLABLE connections_device) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_Device();
  if (connections_device) {
    ::google::protobuf::Arena* submessage_arena = connections_device->GetArena();
    if (message_arena != submessage_arena) {
      connections_device = ::google::protobuf::internal::GetOwnedMessage(message_arena, connections_device, submessage_arena);
    }
    set_has_connections_device();
    _impl_.Device_.connections_device_ = connections_device;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.connections_device)
}
void ConnectionRequestFrame::set_allocated_presence_device(::location::nearby::connections::PresenceDevice* PROTOBUF_NULLABLE presence_device) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_Device();
  if (presence_device) {
    ::google::protobuf::Arena* submessage_arena = presence_device->GetArena();
    if (message_arena != submessage_arena) {
      presence_device = ::google::protobuf::internal::GetOwnedMessage(message_arena, presence_device, submessage_arena);
    }
    set_has_presence_device();
    _impl_.Device_.presence_device_ = presence_device;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.presence_device)
}
ConnectionRequestFrame::ConnectionRequestFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConnectionRequestFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionRequestFrame)
}
PROTOBUF_NDEBUG_INLINE ConnectionRequestFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::ConnectionRequestFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        mediums_{visibility, arena, from.mediums_},
        endpoint_id_(arena, from.endpoint_id_),
        endpoint_name_(arena, from.endpoint_name_),
        handshake_data_(arena, from.handshake_data_),
        endpoint_info_(arena, from.endpoint_info_),
        device_info_(arena, from.device_info_),
        Device_{},
        _oneof_case_{from._oneof_case_[0]} {}

ConnectionRequestFrame::ConnectionRequestFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ConnectionRequestFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConnectionRequestFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ConnectionRequestFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.medium_metadata_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.medium_metadata_)
                : nullptr;
  _impl_.location_hint_ = (CheckHasBit(cached_has_bits, 0x00000080U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.location_hint_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, nonce_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, nonce_),
           offsetof(Impl_, connection_mode_) -
               offsetof(Impl_, nonce_) +
               sizeof(Impl_::connection_mode_));
  switch (Device_case()) {
    case DEVICE_NOT_SET:
      break;
      case kConnectionsDevice:
        _impl_.Device_.connections_device_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.Device_.connections_device_);
        break;
      case kPresenceDevice:
        _impl_.Device_.presence_device_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.Device_.presence_device_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionRequestFrame)
}
PROTOBUF_NDEBUG_INLINE ConnectionRequestFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        mediums_{visibility, arena},
        endpoint_id_(arena),
        endpoint_name_(arena),
        handshake_data_(arena),
        endpoint_info_(arena),
        device_info_(arena),
        Device_{},
        _oneof_case_{} {}

inline void ConnectionRequestFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, medium_metadata_),
           0,
           offsetof(Impl_, connection_mode_) -
               offsetof(Impl_, medium_metadata_) +
               sizeof(Impl_::connection_mode_));
}
ConnectionRequestFrame::~ConnectionRequestFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionRequestFrame)
  SharedDtor(*this);
}
inline void ConnectionRequestFrame::SharedDtor(MessageLite& self) {
  ConnectionRequestFrame& this_ = static_cast<ConnectionRequestFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.endpoint_id_.Destroy();
  this_._impl_.endpoint_name_.Destroy();
  this_._impl_.handshake_data_.Destroy();
  this_._impl_.endpoint_info_.Destroy();
  this_._impl_.device_info_.Destroy();
  delete this_._impl_.medium_metadata_;
  delete this_._impl_.location_hint_;
  if (this_.has_Device()) {
    this_.clear_Device();
  }
  this_._impl_.~Impl_();
}

void ConnectionRequestFrame::clear_Device() {
// @@protoc_insertion_point(one_of_clear_start:location.nearby.connections.ConnectionRequestFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (Device_case()) {
    case kConnectionsDevice: {
      if (GetArena() == nullptr) {
        delete _impl_.Device_.connections_device_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        if (_impl_.Device_.connections_device_ != nullptr) {
          _impl_.Device_.connections_device_->Clear();
        }
      }
      break;
    }
    case kPresenceDevice: {
      if (GetArena() == nullptr) {
        delete _impl_.Device_.presence_device_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        if (_impl_.Device_.presence_device_ != nullptr) {
          _impl_.Device_.presence_device_->Clear();
        }
      }
      break;
    }
    case DEVICE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DEVICE_NOT_SET;
}


inline void* PROTOBUF_NONNULL ConnectionRequestFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ConnectionRequestFrame(arena);
}
constexpr auto ConnectionRequestFrame::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.mediums_) +
          decltype(ConnectionRequestFrame::_impl_.mediums_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ConnectionRequestFrame), alignof(ConnectionRequestFrame), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ConnectionRequestFrame::PlacementNew_,
                                 sizeof(ConnectionRequestFrame),
                                 alignof(ConnectionRequestFrame));
  }
}
constexpr auto ConnectionRequestFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<51>{
      {
          &_ConnectionRequestFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ConnectionRequestFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<ConnectionRequestFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ConnectionRequestFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<ConnectionRequestFrame>(), &ConnectionRequestFrame::ByteSizeLong,
              &ConnectionRequestFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.ConnectionRequestFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<51> ConnectionRequestFrame_class_data_ =
    ConnectionRequestFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ConnectionRequestFrame::GetClassData() const {
  return ConnectionRequestFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 6, 0, 2>
ConnectionRequestFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_._has_bits_),
    0, // no _extensions_
    15, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294934528,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ConnectionRequestFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::ConnectionRequestFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string endpoint_id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.endpoint_id_)}},
    // optional string endpoint_name = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 2, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.endpoint_name_)}},
    // optional bytes handshake_data = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 3, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.handshake_data_)}},
    // optional int32 nonce = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 8, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.nonce_)}},
    // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
    {::_pbi::TcParser::FastEr0R1,
     {40, 0, 13,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.mediums_)}},
    // optional bytes endpoint_info = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 4, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.endpoint_info_)}},
    // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 6, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.medium_metadata_)}},
    // optional int32 keep_alive_interval_millis = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 9, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.keep_alive_interval_millis_)}},
    // optional int32 keep_alive_timeout_millis = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 10, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.keep_alive_timeout_millis_)}},
    // optional int32 device_type = 10 [default = 0, deprecated = true];
    {::_pbi::TcParser::FastV32S1,
     {80, 11, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.device_type_)}},
    // optional bytes device_info = 11 [deprecated = true];
    {::_pbi::TcParser::FastBS1,
     {90, 5, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.device_info_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .location.nearby.connections.ConnectionRequestFrame.ConnectionMode connection_mode = 14;
    {::_pbi::TcParser::FastEr0S1,
     {112, 12, 1,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.connection_mode_)}},
    // optional .location.nearby.connections.LocationHint location_hint = 15;
    {::_pbi::TcParser::FastMtS1,
     {122, 7, 3,
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.location_hint_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string endpoint_id = 1;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.endpoint_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string endpoint_name = 2;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.endpoint_name_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes handshake_data = 3;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.handshake_data_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 nonce = 4;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.nonce_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.mediums_), _Internal::kHasBitsOffset + 0, 4, (0 | ::_fl::kFcRepeated | ::_fl::kEnumRange)},
    // optional bytes endpoint_info = 6;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.endpoint_info_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.medium_metadata_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 keep_alive_interval_millis = 8;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.keep_alive_interval_millis_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 keep_alive_timeout_millis = 9;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.keep_alive_timeout_millis_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 device_type = 10 [default = 0, deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.device_type_), _Internal::kHasBitsOffset + 11, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bytes device_info = 11 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.device_info_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // .location.nearby.connections.ConnectionsDevice connections_device = 12;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.Device_.connections_device_), _Internal::kOneofCaseOffset + 0, 1, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .location.nearby.connections.PresenceDevice presence_device = 13;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.Device_.presence_device_), _Internal::kOneofCaseOffset + 0, 2, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.ConnectionRequestFrame.ConnectionMode connection_mode = 14;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.connection_mode_), _Internal::kHasBitsOffset + 12, 5, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .location.nearby.connections.LocationHint location_hint = 15;
    {PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.location_hint_), _Internal::kHasBitsOffset + 7, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::MediumMetadata>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::ConnectionsDevice>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::PresenceDevice>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::LocationHint>()},
      {0, 13},
      {0, 1},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ConnectionRequestFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionRequestFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.mediums_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.endpoint_name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.handshake_data_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.endpoint_info_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.device_info_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.medium_metadata_ != nullptr);
      _impl_.medium_metadata_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(_impl_.location_hint_ != nullptr);
      _impl_.location_hint_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00001f00U)) {
    ::memset(&_impl_.nonce_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.connection_mode_) -
        reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.connection_mode_));
  }
  clear_Device();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ConnectionRequestFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ConnectionRequestFrame& this_ = static_cast<const ConnectionRequestFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ConnectionRequestFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ConnectionRequestFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionRequestFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string endpoint_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_endpoint_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string endpoint_name = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_endpoint_name();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional bytes handshake_data = 3;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_handshake_data();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional int32 nonce = 4;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
            stream, this_._internal_nonce(), target);
  }

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_mediums_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, static_cast<::location::nearby::connections::ConnectionRequestFrame_Medium>(this_._internal_mediums().Get(i)),
          target);
    }
  }

  // optional bytes endpoint_info = 6;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    const ::std::string& _s = this_._internal_endpoint_info();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, *this_._impl_.medium_metadata_, this_._impl_.medium_metadata_->GetCachedSize(), target,
        stream);
  }

  // optional int32 keep_alive_interval_millis = 8;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<8>(
            stream, this_._internal_keep_alive_interval_millis(), target);
  }

  // optional int32 keep_alive_timeout_millis = 9;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<9>(
            stream, this_._internal_keep_alive_timeout_millis(), target);
  }

  // optional int32 device_type = 10 [default = 0, deprecated = true];
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<10>(
            stream, this_._internal_device_type(), target);
  }

  // optional bytes device_info = 11 [deprecated = true];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    const ::std::string& _s = this_._internal_device_info();
    target = stream->WriteBytesMaybeAliased(11, _s, target);
  }

  switch (this_.Device_case()) {
    case kConnectionsDevice: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.Device_.connections_device_, this_._impl_.Device_.connections_device_->GetCachedSize(), target,
          stream);
      break;
    }
    case kPresenceDevice: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *this_._impl_.Device_.presence_device_, this_._impl_.Device_.presence_device_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  // optional .location.nearby.connections.ConnectionRequestFrame.ConnectionMode connection_mode = 14;
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this_._internal_connection_mode(), target);
  }

  // optional .location.nearby.connections.LocationHint location_hint = 15;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        15, *this_._impl_.location_hint_, this_._impl_.location_hint_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionRequestFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ConnectionRequestFrame::ByteSizeLong(const MessageLite& base) {
  const ConnectionRequestFrame& this_ = static_cast<const ConnectionRequestFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ConnectionRequestFrame::ByteSizeLong() const {
  const ConnectionRequestFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionRequestFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size =
          ::_pbi::WireFormatLite::EnumSize(this_._internal_mediums());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_mediums_size());
      total_size += data_size + tag_size;
    }
    // optional string endpoint_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_endpoint_id());
    }
    // optional string endpoint_name = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_endpoint_name());
    }
    // optional bytes handshake_data = 3;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_handshake_data());
    }
    // optional bytes endpoint_info = 6;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_endpoint_info());
    }
    // optional bytes device_info = 11 [deprecated = true];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_device_info());
    }
    // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.medium_metadata_);
    }
    // optional .location.nearby.connections.LocationHint location_hint = 15;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.location_hint_);
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00001f00U)) {
    // optional int32 nonce = 4;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_nonce());
    }
    // optional int32 keep_alive_interval_millis = 8;
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_keep_alive_interval_millis());
    }
    // optional int32 keep_alive_timeout_millis = 9;
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_keep_alive_timeout_millis());
    }
    // optional int32 device_type = 10 [default = 0, deprecated = true];
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_device_type());
    }
    // optional .location.nearby.connections.ConnectionRequestFrame.ConnectionMode connection_mode = 14;
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_connection_mode());
    }
  }
  switch (this_.Device_case()) {
    // .location.nearby.connections.ConnectionsDevice connections_device = 12;
    case kConnectionsDevice: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.Device_.connections_device_);
      break;
    }
    // .location.nearby.connections.PresenceDevice presence_device = 13;
    case kPresenceDevice: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.Device_.presence_device_);
      break;
    }
    case DEVICE_NOT_SET: {
      break;
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void ConnectionRequestFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ConnectionRequestFrame*>(&to_msg);
  auto& from = static_cast<const ConnectionRequestFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionRequestFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_mediums()->MergeFrom(from._internal_mediums());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_endpoint_name(from._internal_endpoint_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_handshake_data(from._internal_handshake_data());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_internal_set_endpoint_info(from._internal_endpoint_info());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_internal_set_device_info(from._internal_device_info());
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.medium_metadata_ != nullptr);
      if (_this->_impl_.medium_metadata_ == nullptr) {
        _this->_impl_.medium_metadata_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.medium_metadata_);
      } else {
        _this->_impl_.medium_metadata_->MergeFrom(*from._impl_.medium_metadata_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(from._impl_.location_hint_ != nullptr);
      if (_this->_impl_.location_hint_ == nullptr) {
        _this->_impl_.location_hint_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.location_hint_);
      } else {
        _this->_impl_.location_hint_->MergeFrom(*from._impl_.location_hint_);
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00001f00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.nonce_ = from._impl_.nonce_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.keep_alive_interval_millis_ = from._impl_.keep_alive_interval_millis_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.keep_alive_timeout_millis_ = from._impl_.keep_alive_timeout_millis_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _this->_impl_.device_type_ = from._impl_.device_type_;
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_impl_.connection_mode_ = from._impl_.connection_mode_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case =
          from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_Device();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kConnectionsDevice: {
        if (oneof_needs_init) {
          _this->_impl_.Device_.connections_device_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.Device_.connections_device_);
        } else {
          _this->_impl_.Device_.connections_device_->MergeFrom(*from._impl_.Device_.connections_device_);
        }
        break;
      }
      case kPresenceDevice: {
        if (oneof_needs_init) {
          _this->_impl_.Device_.presence_device_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.Device_.presence_device_);
        } else {
          _this->_impl_.Device_.presence_device_->MergeFrom(*from._impl_.Device_.presence_device_);
        }
        break;
      }
      case DEVICE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void ConnectionRequestFrame::CopyFrom(const ConnectionRequestFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionRequestFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ConnectionRequestFrame::InternalSwap(ConnectionRequestFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mediums_.InternalSwap(&other->_impl_.mediums_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_id_, &other->_impl_.endpoint_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_name_, &other->_impl_.endpoint_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.handshake_data_, &other->_impl_.handshake_data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_info_, &other->_impl_.endpoint_info_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_info_, &other->_impl_.device_info_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.connection_mode_)
      + sizeof(ConnectionRequestFrame::_impl_.connection_mode_)
      - PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, _impl_.medium_metadata_)>(
          reinterpret_cast<char*>(&_impl_.medium_metadata_),
          reinterpret_cast<char*>(&other->_impl_.medium_metadata_));
  swap(_impl_.Device_, other->_impl_.Device_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

// ===================================================================

class ConnectionResponseFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ConnectionResponseFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_._has_bits_);
};

ConnectionResponseFrame::ConnectionResponseFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConnectionResponseFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionResponseFrame)
}
PROTOBUF_NDEBUG_INLINE ConnectionResponseFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::ConnectionResponseFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        handshake_data_(arena, from.handshake_data_) {}

ConnectionResponseFrame::ConnectionResponseFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ConnectionResponseFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConnectionResponseFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ConnectionResponseFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.os_info_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.os_info_)
                : nullptr;
  _impl_.location_hint_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.location_hint_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, status_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, status_),
           offsetof(Impl_, keep_alive_timeout_millis_) -
               offsetof(Impl_, status_) +
               sizeof(Impl_::keep_alive_timeout_millis_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionResponseFrame)
}
PROTOBUF_NDEBUG_INLINE ConnectionResponseFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        handshake_data_(arena) {}

inline void ConnectionResponseFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, os_info_),
           0,
           offsetof(Impl_, keep_alive_timeout_millis_) -
               offsetof(Impl_, os_info_) +
               sizeof(Impl_::keep_alive_timeout_millis_));
}
ConnectionResponseFrame::~ConnectionResponseFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionResponseFrame)
  SharedDtor(*this);
}
inline void ConnectionResponseFrame::SharedDtor(MessageLite& self) {
  ConnectionResponseFrame& this_ = static_cast<ConnectionResponseFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.handshake_data_.Destroy();
  delete this_._impl_.os_info_;
  delete this_._impl_.location_hint_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ConnectionResponseFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ConnectionResponseFrame(arena);
}
constexpr auto ConnectionResponseFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ConnectionResponseFrame),
                                            alignof(ConnectionResponseFrame));
}
constexpr auto ConnectionResponseFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<52>{
      {
          &_ConnectionResponseFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ConnectionResponseFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<ConnectionResponseFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ConnectionResponseFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<ConnectionResponseFrame>(), &ConnectionResponseFrame::ByteSizeLong,
              &ConnectionResponseFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.ConnectionResponseFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<52> ConnectionResponseFrame_class_data_ =
    ConnectionResponseFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ConnectionResponseFrame::GetClassData() const {
  return ConnectionResponseFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 3, 0, 2>
ConnectionResponseFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ConnectionResponseFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::ConnectionResponseFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 status = 1 [deprecated = true];
    {::_pbi::TcParser::FastV32S1,
     {8, 3, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.status_)}},
    // optional bytes handshake_data = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.handshake_data_)}},
    // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
    {::_pbi::TcParser::FastEr0S1,
     {24, 4, 2,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.response_)}},
    // optional .location.nearby.connections.OsInfo os_info = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.os_info_)}},
    // optional int32 multiplex_socket_bitmask = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 5, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.multiplex_socket_bitmask_)}},
    // optional int32 nearby_connections_version = 6 [deprecated = true];
    {::_pbi::TcParser::FastV32S1,
     {48, 6, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.nearby_connections_version_)}},
    // optional int32 safe_to_disconnect_version = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 7, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.safe_to_disconnect_version_)}},
    // optional .location.nearby.connections.LocationHint location_hint = 8;
    {::_pbi::TcParser::FastMtS1,
     {66, 2, 1,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.location_hint_)}},
    // optional int32 keep_alive_timeout_millis = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 8, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.keep_alive_timeout_millis_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 status = 1 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.status_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bytes handshake_data = 2;
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.handshake_data_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.response_), _Internal::kHasBitsOffset + 4, 2, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .location.nearby.connections.OsInfo os_info = 4;
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.os_info_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 multiplex_socket_bitmask = 5;
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.multiplex_socket_bitmask_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 nearby_connections_version = 6 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.nearby_connections_version_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 safe_to_disconnect_version = 7;
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.safe_to_disconnect_version_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional .location.nearby.connections.LocationHint location_hint = 8;
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.location_hint_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 keep_alive_timeout_millis = 9;
    {PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.keep_alive_timeout_millis_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::OsInfo>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::LocationHint>()},
      {0, 2},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ConnectionResponseFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionResponseFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.handshake_data_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.os_info_ != nullptr);
      _impl_.os_info_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.location_hint_ != nullptr);
      _impl_.location_hint_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000f8U)) {
    ::memset(&_impl_.status_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.safe_to_disconnect_version_) -
        reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.safe_to_disconnect_version_));
  }
  _impl_.keep_alive_timeout_millis_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ConnectionResponseFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ConnectionResponseFrame& this_ = static_cast<const ConnectionResponseFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ConnectionResponseFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ConnectionResponseFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionResponseFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 status = 1 [deprecated = true];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_status(), target);
  }

  // optional bytes handshake_data = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_handshake_data();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this_._internal_response(), target);
  }

  // optional .location.nearby.connections.OsInfo os_info = 4;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.os_info_, this_._impl_.os_info_->GetCachedSize(), target,
        stream);
  }

  // optional int32 multiplex_socket_bitmask = 5;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<5>(
            stream, this_._internal_multiplex_socket_bitmask(), target);
  }

  // optional int32 nearby_connections_version = 6 [deprecated = true];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<6>(
            stream, this_._internal_nearby_connections_version(), target);
  }

  // optional int32 safe_to_disconnect_version = 7;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<7>(
            stream, this_._internal_safe_to_disconnect_version(), target);
  }

  // optional .location.nearby.connections.LocationHint location_hint = 8;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, *this_._impl_.location_hint_, this_._impl_.location_hint_->GetCachedSize(), target,
        stream);
  }

  // optional int32 keep_alive_timeout_millis = 9;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<9>(
            stream, this_._internal_keep_alive_timeout_millis(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionResponseFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ConnectionResponseFrame::ByteSizeLong(const MessageLite& base) {
  const ConnectionResponseFrame& this_ = static_cast<const ConnectionResponseFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ConnectionResponseFrame::ByteSizeLong() const {
  const ConnectionResponseFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionResponseFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // optional bytes handshake_data = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_handshake_data());
    }
    // optional .location.nearby.connections.OsInfo os_info = 4;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.os_info_);
    }
    // optional .location.nearby.connections.LocationHint location_hint = 8;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.location_hint_);
    }
    // optional int32 status = 1 [deprecated = true];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_status());
    }
    // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_response());
    }
    // optional int32 multiplex_socket_bitmask = 5;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_multiplex_socket_bitmask());
    }
    // optional int32 nearby_connections_version = 6 [deprecated = true];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_nearby_connections_version());
    }
    // optional int32 safe_to_disconnect_version = 7;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_safe_to_disconnect_version());
    }
  }
   {
    // optional int32 keep_alive_timeout_millis = 9;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_keep_alive_timeout_millis());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void ConnectionResponseFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ConnectionResponseFrame*>(&to_msg);
  auto& from = static_cast<const ConnectionResponseFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionResponseFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_handshake_data(from._internal_handshake_data());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.os_info_ != nullptr);
      if (_this->_impl_.os_info_ == nullptr) {
        _this->_impl_.os_info_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.os_info_);
      } else {
        _this->_impl_.os_info_->MergeFrom(*from._impl_.os_info_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.location_hint_ != nullptr);
      if (_this->_impl_.location_hint_ == nullptr) {
        _this->_impl_.location_hint_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.location_hint_);
      } else {
        _this->_impl_.location_hint_->MergeFrom(*from._impl_.location_hint_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.response_ = from._impl_.response_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.multiplex_socket_bitmask_ = from._impl_.multiplex_socket_bitmask_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.nearby_connections_version_ = from._impl_.nearby_connections_version_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.safe_to_disconnect_version_ = from._impl_.safe_to_disconnect_version_;
    }
  }
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    _this->_impl_.keep_alive_timeout_millis_ = from._impl_.keep_alive_timeout_millis_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void ConnectionResponseFrame::CopyFrom(const ConnectionResponseFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionResponseFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ConnectionResponseFrame::InternalSwap(ConnectionResponseFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.handshake_data_, &other->_impl_.handshake_data_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.keep_alive_timeout_millis_)
      + sizeof(ConnectionResponseFrame::_impl_.keep_alive_timeout_millis_)
      - PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_.os_info_)>(
          reinterpret_cast<char*>(&_impl_.os_info_),
          reinterpret_cast<char*>(&other->_impl_.os_info_));
}

// ===================================================================

class PayloadTransferFrame_PayloadHeader::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PayloadTransferFrame_PayloadHeader>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_._has_bits_);
};

PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_PayloadHeader_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
}
PROTOBUF_NDEBUG_INLINE PayloadTransferFrame_PayloadHeader::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        file_name_(arena, from.file_name_),
        parent_folder_(arena, from.parent_folder_) {}

PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PayloadTransferFrame_PayloadHeader& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_PayloadHeader_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PayloadTransferFrame_PayloadHeader* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, id_),
           offsetof(Impl_, last_modified_timestamp_millis_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::last_modified_timestamp_millis_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
}
PROTOBUF_NDEBUG_INLINE PayloadTransferFrame_PayloadHeader::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        file_name_(arena),
        parent_folder_(arena) {}

inline void PayloadTransferFrame_PayloadHeader::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, last_modified_timestamp_millis_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::last_modified_timestamp_millis_));
}
PayloadTransferFrame_PayloadHeader::~PayloadTransferFrame_PayloadHeader() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  SharedDtor(*this);
}
inline void PayloadTransferFrame_PayloadHeader::SharedDtor(MessageLite& self) {
  PayloadTransferFrame_PayloadHeader& this_ = static_cast<PayloadTransferFrame_PayloadHeader&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.file_name_.Destroy();
  this_._impl_.parent_folder_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PayloadTransferFrame_PayloadHeader::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PayloadTransferFrame_PayloadHeader(arena);
}
constexpr auto PayloadTransferFrame_PayloadHeader::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PayloadTransferFrame_PayloadHeader),
                                            alignof(PayloadTransferFrame_PayloadHeader));
}
constexpr auto PayloadTransferFrame_PayloadHeader::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<63>{
      {
          &_PayloadTransferFrame_PayloadHeader_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PayloadTransferFrame_PayloadHeader::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PayloadTransferFrame_PayloadHeader>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PayloadTransferFrame_PayloadHeader::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PayloadTransferFrame_PayloadHeader>(), &PayloadTransferFrame_PayloadHeader::ByteSizeLong,
              &PayloadTransferFrame_PayloadHeader::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.PayloadTransferFrame.PayloadHeader",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<63> PayloadTransferFrame_PayloadHeader_class_data_ =
    PayloadTransferFrame_PayloadHeader::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PayloadTransferFrame_PayloadHeader::GetClassData() const {
  return PayloadTransferFrame_PayloadHeader_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 0, 2>
PayloadTransferFrame_PayloadHeader::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PayloadTransferFrame_PayloadHeader_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame_PayloadHeader>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.id_)}},
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 4, 3,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.type_)}},
    // optional int64 total_size = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.total_size_)}},
    // optional bool is_sensitive = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 5, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.is_sensitive_)}},
    // optional string file_name = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.file_name_)}},
    // optional string parent_folder = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 1, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.parent_folder_)}},
    // optional int64 last_modified_timestamp_millis = 7;
    {::_pbi::TcParser::FastV64S1,
     {56, 6, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.last_modified_timestamp_millis_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.type_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional int64 total_size = 3;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.total_size_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bool is_sensitive = 4;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.is_sensitive_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string file_name = 5;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.file_name_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string parent_folder = 6;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.parent_folder_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 last_modified_timestamp_millis = 7;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.last_modified_timestamp_millis_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  {{
      {0, 3},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PayloadTransferFrame_PayloadHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.file_name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.parent_folder_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000007cU)) {
    ::memset(&_impl_.id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.last_modified_timestamp_millis_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.last_modified_timestamp_millis_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame_PayloadHeader::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PayloadTransferFrame_PayloadHeader& this_ = static_cast<const PayloadTransferFrame_PayloadHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame_PayloadHeader::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PayloadTransferFrame_PayloadHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int64 id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<1>(
            stream, this_._internal_id(), target);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this_._internal_type(), target);
  }

  // optional int64 total_size = 3;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<3>(
            stream, this_._internal_total_size(), target);
  }

  // optional bool is_sensitive = 4;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_is_sensitive(), target);
  }

  // optional string file_name = 5;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_file_name();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string parent_folder = 6;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_parent_folder();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional int64 last_modified_timestamp_millis = 7;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<7>(
            stream, this_._internal_last_modified_timestamp_millis(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PayloadTransferFrame_PayloadHeader::ByteSizeLong(const MessageLite& base) {
  const PayloadTransferFrame_PayloadHeader& this_ = static_cast<const PayloadTransferFrame_PayloadHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PayloadTransferFrame_PayloadHeader::ByteSizeLong() const {
  const PayloadTransferFrame_PayloadHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x0000005fU)) {
    // optional string file_name = 5;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_file_name());
    }
    // optional string parent_folder = 6;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_parent_folder());
    }
    // optional int64 id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_id());
    }
    // optional int64 total_size = 3;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_total_size());
    }
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
    // optional int64 last_modified_timestamp_millis = 7;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_last_modified_timestamp_millis());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PayloadTransferFrame_PayloadHeader::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PayloadTransferFrame_PayloadHeader*>(&to_msg);
  auto& from = static_cast<const PayloadTransferFrame_PayloadHeader&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_file_name(from._internal_file_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_parent_folder(from._internal_parent_folder());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.total_size_ = from._impl_.total_size_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.is_sensitive_ = from._impl_.is_sensitive_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.last_modified_timestamp_millis_ = from._impl_.last_modified_timestamp_millis_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PayloadTransferFrame_PayloadHeader::CopyFrom(const PayloadTransferFrame_PayloadHeader& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PayloadTransferFrame_PayloadHeader::InternalSwap(PayloadTransferFrame_PayloadHeader* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.file_name_, &other->_impl_.file_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.parent_folder_, &other->_impl_.parent_folder_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.last_modified_timestamp_millis_)
      + sizeof(PayloadTransferFrame_PayloadHeader::_impl_.last_modified_timestamp_millis_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

// ===================================================================

class PayloadTransferFrame_PayloadChunk::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PayloadTransferFrame_PayloadChunk>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_._has_bits_);
};

PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_PayloadChunk_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
}
PROTOBUF_NDEBUG_INLINE PayloadTransferFrame_PayloadChunk::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        body_(arena, from.body_) {}

PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PayloadTransferFrame_PayloadChunk& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_PayloadChunk_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PayloadTransferFrame_PayloadChunk* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, offset_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, offset_),
           offsetof(Impl_, index_) -
               offsetof(Impl_, offset_) +
               sizeof(Impl_::index_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
}
PROTOBUF_NDEBUG_INLINE PayloadTransferFrame_PayloadChunk::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        body_(arena) {}

inline void PayloadTransferFrame_PayloadChunk::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, offset_),
           0,
           offsetof(Impl_, index_) -
               offsetof(Impl_, offset_) +
               sizeof(Impl_::index_));
}
PayloadTransferFrame_PayloadChunk::~PayloadTransferFrame_PayloadChunk() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  SharedDtor(*this);
}
inline void PayloadTransferFrame_PayloadChunk::SharedDtor(MessageLite& self) {
  PayloadTransferFrame_PayloadChunk& this_ = static_cast<PayloadTransferFrame_PayloadChunk&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.body_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PayloadTransferFrame_PayloadChunk::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PayloadTransferFrame_PayloadChunk(arena);
}
constexpr auto PayloadTransferFrame_PayloadChunk::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PayloadTransferFrame_PayloadChunk),
                                            alignof(PayloadTransferFrame_PayloadChunk));
}
constexpr auto PayloadTransferFrame_PayloadChunk::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<62>{
      {
          &_PayloadTransferFrame_PayloadChunk_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PayloadTransferFrame_PayloadChunk::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PayloadTransferFrame_PayloadChunk>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PayloadTransferFrame_PayloadChunk::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PayloadTransferFrame_PayloadChunk>(), &PayloadTransferFrame_PayloadChunk::ByteSizeLong,
              &PayloadTransferFrame_PayloadChunk::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.PayloadTransferFrame.PayloadChunk",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<62> PayloadTransferFrame_PayloadChunk_class_data_ =
    PayloadTransferFrame_PayloadChunk::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PayloadTransferFrame_PayloadChunk::GetClassData() const {
  return PayloadTransferFrame_PayloadChunk_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
PayloadTransferFrame_PayloadChunk::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PayloadTransferFrame_PayloadChunk_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame_PayloadChunk>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 index = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.index_)}},
    // optional int32 flags = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 2, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.flags_)}},
    // optional int64 offset = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.offset_)}},
    // optional bytes body = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.body_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 flags = 1;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.flags_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int64 offset = 2;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.offset_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bytes body = 3;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.body_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 index = 4;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.index_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PayloadTransferFrame_PayloadChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.body_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000eU)) {
    ::memset(&_impl_.offset_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame_PayloadChunk::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PayloadTransferFrame_PayloadChunk& this_ = static_cast<const PayloadTransferFrame_PayloadChunk&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame_PayloadChunk::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PayloadTransferFrame_PayloadChunk& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 flags = 1;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_flags(), target);
  }

  // optional int64 offset = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<2>(
            stream, this_._internal_offset(), target);
  }

  // optional bytes body = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_body();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional int32 index = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
            stream, this_._internal_index(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PayloadTransferFrame_PayloadChunk::ByteSizeLong(const MessageLite& base) {
  const PayloadTransferFrame_PayloadChunk& this_ = static_cast<const PayloadTransferFrame_PayloadChunk&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PayloadTransferFrame_PayloadChunk::ByteSizeLong() const {
  const PayloadTransferFrame_PayloadChunk& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional bytes body = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_body());
    }
    // optional int64 offset = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_offset());
    }
    // optional int32 flags = 1;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_flags());
    }
    // optional int32 index = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_index());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PayloadTransferFrame_PayloadChunk::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PayloadTransferFrame_PayloadChunk*>(&to_msg);
  auto& from = static_cast<const PayloadTransferFrame_PayloadChunk&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_body(from._internal_body());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.index_ = from._impl_.index_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PayloadTransferFrame_PayloadChunk::CopyFrom(const PayloadTransferFrame_PayloadChunk& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PayloadTransferFrame_PayloadChunk::InternalSwap(PayloadTransferFrame_PayloadChunk* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.body_, &other->_impl_.body_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.index_)
      + sizeof(PayloadTransferFrame_PayloadChunk::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

// ===================================================================

class PayloadTransferFrame_ControlMessage::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PayloadTransferFrame_ControlMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_._has_bits_);
};

PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_ControlMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
}
PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PayloadTransferFrame_ControlMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_ControlMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE PayloadTransferFrame_ControlMessage::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PayloadTransferFrame_ControlMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, offset_),
           0,
           offsetof(Impl_, event_) -
               offsetof(Impl_, offset_) +
               sizeof(Impl_::event_));
}
PayloadTransferFrame_ControlMessage::~PayloadTransferFrame_ControlMessage() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  SharedDtor(*this);
}
inline void PayloadTransferFrame_ControlMessage::SharedDtor(MessageLite& self) {
  PayloadTransferFrame_ControlMessage& this_ = static_cast<PayloadTransferFrame_ControlMessage&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PayloadTransferFrame_ControlMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PayloadTransferFrame_ControlMessage(arena);
}
constexpr auto PayloadTransferFrame_ControlMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PayloadTransferFrame_ControlMessage),
                                            alignof(PayloadTransferFrame_ControlMessage));
}
constexpr auto PayloadTransferFrame_ControlMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<64>{
      {
          &_PayloadTransferFrame_ControlMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PayloadTransferFrame_ControlMessage::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PayloadTransferFrame_ControlMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PayloadTransferFrame_ControlMessage::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PayloadTransferFrame_ControlMessage>(), &PayloadTransferFrame_ControlMessage::ByteSizeLong,
              &PayloadTransferFrame_ControlMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.PayloadTransferFrame.ControlMessage",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<64> PayloadTransferFrame_ControlMessage_class_data_ =
    PayloadTransferFrame_ControlMessage::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PayloadTransferFrame_ControlMessage::GetClassData() const {
  return PayloadTransferFrame_ControlMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
PayloadTransferFrame_ControlMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PayloadTransferFrame_ControlMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame_ControlMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int64 offset = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 0, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_.offset_)}},
    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 1, 3,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_.event_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_.event_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional int64 offset = 2;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_.offset_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  {{
      {0, 3},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PayloadTransferFrame_ControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    ::memset(&_impl_.offset_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.event_) -
        reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.event_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame_ControlMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PayloadTransferFrame_ControlMessage& this_ = static_cast<const PayloadTransferFrame_ControlMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame_ControlMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PayloadTransferFrame_ControlMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_event(), target);
  }

  // optional int64 offset = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<2>(
            stream, this_._internal_offset(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PayloadTransferFrame_ControlMessage::ByteSizeLong(const MessageLite& base) {
  const PayloadTransferFrame_ControlMessage& this_ = static_cast<const PayloadTransferFrame_ControlMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PayloadTransferFrame_ControlMessage::ByteSizeLong() const {
  const PayloadTransferFrame_ControlMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional int64 offset = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_offset());
    }
    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_event());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PayloadTransferFrame_ControlMessage::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PayloadTransferFrame_ControlMessage*>(&to_msg);
  auto& from = static_cast<const PayloadTransferFrame_ControlMessage&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.event_ = from._impl_.event_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PayloadTransferFrame_ControlMessage::CopyFrom(const PayloadTransferFrame_ControlMessage& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PayloadTransferFrame_ControlMessage::InternalSwap(PayloadTransferFrame_ControlMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_.event_)
      + sizeof(PayloadTransferFrame_ControlMessage::_impl_.event_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

// ===================================================================

class PayloadTransferFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PayloadTransferFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_._has_bits_);
};

PayloadTransferFrame::PayloadTransferFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame)
}
PROTOBUF_NDEBUG_INLINE PayloadTransferFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::PayloadTransferFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PayloadTransferFrame::PayloadTransferFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PayloadTransferFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PayloadTransferFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PayloadTransferFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.payload_header_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.payload_header_)
                : nullptr;
  _impl_.payload_chunk_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.payload_chunk_)
                : nullptr;
  _impl_.control_message_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.control_message_)
                : nullptr;
  _impl_.packet_type_ = from._impl_.packet_type_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame)
}
PROTOBUF_NDEBUG_INLINE PayloadTransferFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PayloadTransferFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, payload_header_),
           0,
           offsetof(Impl_, packet_type_) -
               offsetof(Impl_, payload_header_) +
               sizeof(Impl_::packet_type_));
}
PayloadTransferFrame::~PayloadTransferFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame)
  SharedDtor(*this);
}
inline void PayloadTransferFrame::SharedDtor(MessageLite& self) {
  PayloadTransferFrame& this_ = static_cast<PayloadTransferFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.payload_header_;
  delete this_._impl_.payload_chunk_;
  delete this_._impl_.control_message_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PayloadTransferFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PayloadTransferFrame(arena);
}
constexpr auto PayloadTransferFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PayloadTransferFrame),
                                            alignof(PayloadTransferFrame));
}
constexpr auto PayloadTransferFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<49>{
      {
          &_PayloadTransferFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PayloadTransferFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PayloadTransferFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PayloadTransferFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PayloadTransferFrame>(), &PayloadTransferFrame::ByteSizeLong,
              &PayloadTransferFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.PayloadTransferFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<49> PayloadTransferFrame_class_data_ =
    PayloadTransferFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PayloadTransferFrame::GetClassData() const {
  return PayloadTransferFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 4, 0, 2>
PayloadTransferFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PayloadTransferFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.control_message_)}},
    // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 3, 3,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.packet_type_)}},
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.payload_header_)}},
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1,
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.payload_chunk_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.packet_type_), _Internal::kHasBitsOffset + 3, 3, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.payload_header_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.payload_chunk_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
    {PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.control_message_), _Internal::kHasBitsOffset + 2, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame_PayloadHeader>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame_PayloadChunk>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::PayloadTransferFrame_ControlMessage>()},
      {0, 3},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PayloadTransferFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(_impl_.payload_header_ != nullptr);
      _impl_.payload_header_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.payload_chunk_ != nullptr);
      _impl_.payload_chunk_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.control_message_ != nullptr);
      _impl_.control_message_->Clear();
    }
  }
  _impl_.packet_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PayloadTransferFrame& this_ = static_cast<const PayloadTransferFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PayloadTransferFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PayloadTransferFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_packet_type(), target);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.payload_header_, this_._impl_.payload_header_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.payload_chunk_, this_._impl_.payload_chunk_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.control_message_, this_._impl_.control_message_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PayloadTransferFrame::ByteSizeLong(const MessageLite& base) {
  const PayloadTransferFrame& this_ = static_cast<const PayloadTransferFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PayloadTransferFrame::ByteSizeLong() const {
  const PayloadTransferFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_header_);
    }
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_chunk_);
    }
    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.control_message_);
    }
    // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_packet_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PayloadTransferFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PayloadTransferFrame*>(&to_msg);
  auto& from = static_cast<const PayloadTransferFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.payload_header_ != nullptr);
      if (_this->_impl_.payload_header_ == nullptr) {
        _this->_impl_.payload_header_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.payload_header_);
      } else {
        _this->_impl_.payload_header_->MergeFrom(*from._impl_.payload_header_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.payload_chunk_ != nullptr);
      if (_this->_impl_.payload_chunk_ == nullptr) {
        _this->_impl_.payload_chunk_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.payload_chunk_);
      } else {
        _this->_impl_.payload_chunk_->MergeFrom(*from._impl_.payload_chunk_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.control_message_ != nullptr);
      if (_this->_impl_.control_message_ == nullptr) {
        _this->_impl_.control_message_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.control_message_);
      } else {
        _this->_impl_.control_message_->MergeFrom(*from._impl_.control_message_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.packet_type_ = from._impl_.packet_type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PayloadTransferFrame::CopyFrom(const PayloadTransferFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PayloadTransferFrame::InternalSwap(PayloadTransferFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.packet_type_)
      + sizeof(PayloadTransferFrame::_impl_.packet_type_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, _impl_.payload_header_)>(
          reinterpret_cast<char*>(&_impl_.payload_header_),
          reinterpret_cast<char*>(&other->_impl_.payload_header_));
}

// ===================================================================

class ServiceAddress::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ServiceAddress>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ServiceAddress, _impl_._has_bits_);
};

ServiceAddress::ServiceAddress(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ServiceAddress_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ServiceAddress)
}
PROTOBUF_NDEBUG_INLINE ServiceAddress::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::ServiceAddress& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        ip_address_(arena, from.ip_address_) {}

ServiceAddress::ServiceAddress(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ServiceAddress& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ServiceAddress_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ServiceAddress* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.port_ = from._impl_.port_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ServiceAddress)
}
PROTOBUF_NDEBUG_INLINE ServiceAddress::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        ip_address_(arena) {}

inline void ServiceAddress::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.port_ = {};
}
ServiceAddress::~ServiceAddress() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ServiceAddress)
  SharedDtor(*this);
}
inline void ServiceAddress::SharedDtor(MessageLite& self) {
  ServiceAddress& this_ = static_cast<ServiceAddress&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.ip_address_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ServiceAddress::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ServiceAddress(arena);
}
constexpr auto ServiceAddress::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ServiceAddress),
                                            alignof(ServiceAddress));
}
constexpr auto ServiceAddress::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<43>{
      {
          &_ServiceAddress_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ServiceAddress::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<ServiceAddress>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ServiceAddress::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<ServiceAddress>(), &ServiceAddress::ByteSizeLong,
              &ServiceAddress::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ServiceAddress, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.ServiceAddress",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<43> ServiceAddress_class_data_ =
    ServiceAddress::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ServiceAddress::GetClassData() const {
  return ServiceAddress_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
ServiceAddress::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ServiceAddress, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ServiceAddress_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::ServiceAddress>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 port = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(ServiceAddress, _impl_.port_)}},
    // optional bytes ip_address = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(ServiceAddress, _impl_.ip_address_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes ip_address = 1;
    {PROTOBUF_FIELD_OFFSET(ServiceAddress, _impl_.ip_address_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 port = 2;
    {PROTOBUF_FIELD_OFFSET(ServiceAddress, _impl_.port_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ServiceAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ServiceAddress)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.ip_address_.ClearNonDefaultToEmpty();
  }
  _impl_.port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ServiceAddress::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ServiceAddress& this_ = static_cast<const ServiceAddress&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ServiceAddress::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ServiceAddress& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ServiceAddress)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes ip_address = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_ip_address();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional int32 port = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_port(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ServiceAddress)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ServiceAddress::ByteSizeLong(const MessageLite& base) {
  const ServiceAddress& this_ = static_cast<const ServiceAddress&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ServiceAddress::ByteSizeLong() const {
  const ServiceAddress& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ServiceAddress)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional bytes ip_address = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_ip_address());
    }
    // optional int32 port = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_port());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void ServiceAddress::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ServiceAddress*>(&to_msg);
  auto& from = static_cast<const ServiceAddress&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ServiceAddress)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_ip_address(from._internal_ip_address());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.port_ = from._impl_.port_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void ServiceAddress::CopyFrom(const ServiceAddress& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ServiceAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ServiceAddress::InternalSwap(ServiceAddress* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ip_address_, &other->_impl_.ip_address_, arena);
  swap(_impl_.port_, other->_impl_.port_);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_._has_bits_);
};

/*static*/ const ::_pbi::LazyString BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_{
    {{"0.0.0.0", 7}},
    {nullptr},
};
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        address_candidates_{visibility, arena, from.address_candidates_},
        ssid_(arena, from.ssid_),
        password_(arena, from.password_),
        gateway_(arena, from.gateway_, _i_give_permission_to_break_this_code_default_gateway_) {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, port_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, port_),
           offsetof(Impl_, frequency_) -
               offsetof(Impl_, port_) +
               sizeof(Impl_::frequency_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        address_candidates_{visibility, arena},
        ssid_(arena),
        password_(arena),
        gateway_(arena, Impl_::_i_give_permission_to_break_this_code_default_gateway_),
        frequency_{-1} {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.port_ = {};
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.ssid_.Destroy();
  this_._impl_.password_.Destroy();
  this_._impl_.gateway_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.address_candidates_) +
          decltype(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_impl_.address_candidates_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials), alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::PlacementNew_,
                                 sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials),
                                 alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials));
  }
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<100>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<100> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string ssid = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.ssid_)}},
    // optional string password = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 2, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.password_)}},
    // optional int32 port = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 4, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.port_)}},
    // optional string gateway = 4 [default = "0.0.0.0"];
    {::_pbi::TcParser::FastBS1,
     {34, 3, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.gateway_)}},
    // optional int32 frequency = 5 [default = -1];
    {::_pbi::TcParser::FastV32S1,
     {40, 5, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.frequency_)}},
    // repeated .location.nearby.connections.ServiceAddress address_candidates = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.address_candidates_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string ssid = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.ssid_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string password = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.password_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 port = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.port_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional string gateway = 4 [default = "0.0.0.0"];
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.gateway_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 frequency = 5 [default = -1];
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.frequency_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated .location.nearby.connections.ServiceAddress address_candidates = 6;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.address_candidates_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::ServiceAddress>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.address_candidates_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.ssid_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_, GetArena());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000030U)) {
    _impl_.port_ = 0;
    _impl_.frequency_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string ssid = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_ssid();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string password = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_password();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int32 port = 3;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
            stream, this_._internal_port(), target);
  }

  // optional string gateway = 4 [default = "0.0.0.0"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_gateway();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional int32 frequency = 5 [default = -1];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<5>(
            stream, this_._internal_frequency(), target);
  }

  // repeated .location.nearby.connections.ServiceAddress address_candidates = 6;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_address_candidates_size());
         i < n; i++) {
      const auto& repfield = this_._internal_address_candidates().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              6, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // repeated .location.nearby.connections.ServiceAddress address_candidates = 6;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_address_candidates_size();
      for (const auto& msg : this_._internal_address_candidates()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // optional string ssid = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_ssid());
    }
    // optional string password = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_password());
    }
    // optional string gateway = 4 [default = "0.0.0.0"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_gateway());
    }
    // optional int32 port = 3;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_port());
    }
    // optional int32 frequency = 5 [default = -1];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_frequency());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_address_candidates()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_address_candidates());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_ssid(from._internal_ssid());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_password(from._internal_password());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_gateway(from._internal_gateway());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.frequency_ = from._impl_.frequency_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_candidates_.InternalSwap(&other->_impl_.address_candidates_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ssid_, &other->_impl_.ssid_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, &other->_impl_.password_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.gateway_, &other->_impl_.gateway_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.frequency_)
      + sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_impl_.frequency_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials, _impl_.port_)>(
          reinterpret_cast<char*>(&_impl_.port_),
          reinterpret_cast<char*>(&other->_impl_.port_));
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        address_candidates_{visibility, arena, from.address_candidates_},
        ip_address_(arena, from.ip_address_) {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.wifi_port_ = from._impl_.wifi_port_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        address_candidates_{visibility, arena},
        ip_address_(arena) {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.wifi_port_ = {};
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.ip_address_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_.address_candidates_) +
          decltype(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_impl_.address_candidates_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket), alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::PlacementNew_,
                                 sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket),
                                 alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket));
  }
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<91>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<91> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes ip_address = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_.ip_address_)}},
    // optional int32 wifi_port = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_.wifi_port_)}},
    // repeated .location.nearby.connections.ServiceAddress address_candidates = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_.address_candidates_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes ip_address = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_.ip_address_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 wifi_port = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_.wifi_port_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated .location.nearby.connections.ServiceAddress address_candidates = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket, _impl_.address_candidates_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::ServiceAddress>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.address_candidates_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.ip_address_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.wifi_port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes ip_address = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_ip_address();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional int32 wifi_port = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_wifi_port(), target);
  }

  // repeated .location.nearby.connections.ServiceAddress address_candidates = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_address_candidates_size());
         i < n; i++) {
      const auto& repfield = this_._internal_address_candidates().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated .location.nearby.connections.ServiceAddress address_candidates = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_address_candidates_size();
      for (const auto& msg : this_._internal_address_candidates()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // optional bytes ip_address = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_ip_address());
    }
    // optional int32 wifi_port = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_wifi_port());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_address_candidates()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_address_candidates());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_ip_address(from._internal_ip_address());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.wifi_port_ = from._impl_.wifi_port_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_candidates_.InternalSwap(&other->_impl_.address_candidates_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ip_address_, &other->_impl_.ip_address_, arena);
  swap(_impl_.wifi_port_, other->_impl_.wifi_port_);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        service_name_(arena, from.service_name_),
        mac_address_(arena, from.mac_address_) {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        service_name_(arena),
        mac_address_(arena) {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.service_name_.Destroy();
  this_._impl_.mac_address_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials),
                                            alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials));
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<98>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<98> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string mac_address = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials, _impl_.mac_address_)}},
    // optional string service_name = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials, _impl_.service_name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string service_name = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials, _impl_.service_name_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string mac_address = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials, _impl_.mac_address_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.service_name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.mac_address_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string service_name = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_service_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string mac_address = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_mac_address();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional string service_name = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_service_name());
    }
    // optional string mac_address = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_mac_address());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_service_name(from._internal_service_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_mac_address(from._internal_mac_address());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_name_, &other->_impl_.service_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mac_address_, &other->_impl_.mac_address_, arena);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        service_id_(arena, from.service_id_),
        service_info_(arena, from.service_info_),
        password_(arena, from.password_) {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        service_id_(arena),
        service_info_(arena),
        password_(arena) {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.service_id_.Destroy();
  this_._impl_.service_info_.Destroy();
  this_._impl_.password_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials),
                                            alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials));
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<98>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<98> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string service_id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_.service_id_)}},
    // optional bytes service_info = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_.service_info_)}},
    // optional string password = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_.password_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string service_id = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_.service_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes service_info = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_.service_info_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string password = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials, _impl_.password_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.service_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.service_info_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string service_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_service_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional bytes service_info = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_service_info();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional string password = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_password();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // optional string service_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_service_id());
    }
    // optional bytes service_info = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_service_info());
    }
    // optional string password = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_password());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_service_id(from._internal_service_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_service_info(from._internal_service_info());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_password(from._internal_password());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_id_, &other->_impl_.service_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_info_, &other->_impl_.service_info_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, &other->_impl_.password_, arena);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_._has_bits_);
};

/*static*/ const ::_pbi::LazyString BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_{
    {{"0.0.0.0", 7}},
    {nullptr},
};
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        ssid_(arena, from.ssid_),
        password_(arena, from.password_),
        gateway_(arena, from.gateway_, _i_give_permission_to_break_this_code_default_gateway_),
        ip_v6_address_(arena, from.ip_v6_address_),
        service_name_(arena, from.service_name_),
        pin_(arena, from.pin_) {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, port_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, port_),
           offsetof(Impl_, frequency_) -
               offsetof(Impl_, port_) +
               sizeof(Impl_::frequency_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        ssid_(arena),
        password_(arena),
        gateway_(arena, Impl_::_i_give_permission_to_break_this_code_default_gateway_),
        ip_v6_address_(arena),
        service_name_(arena),
        pin_(arena) {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, port_),
           0,
           offsetof(Impl_, frequency_) -
               offsetof(Impl_, port_) +
               sizeof(Impl_::frequency_));
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.ssid_.Destroy();
  this_._impl_.password_.Destroy();
  this_._impl_.gateway_.Destroy();
  this_._impl_.ip_v6_address_.Destroy();
  this_._impl_.service_name_.Destroy();
  this_._impl_.pin_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials),
                                            alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials));
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<99>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<99> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string pin = 8;
    {::_pbi::TcParser::FastBS1,
     {66, 5, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.pin_)}},
    // optional string ssid = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.ssid_)}},
    // optional string password = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.password_)}},
    // optional int32 port = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 6, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.port_)}},
    // optional int32 frequency = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 7, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.frequency_)}},
    // optional string gateway = 5 [default = "0.0.0.0"];
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.gateway_)}},
    // optional bytes ip_v6_address = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 3, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.ip_v6_address_)}},
    // optional string service_name = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 4, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.service_name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string ssid = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.ssid_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string password = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.password_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 port = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.port_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 frequency = 4;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.frequency_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional string gateway = 5 [default = "0.0.0.0"];
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.gateway_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes ip_v6_address = 6;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.ip_v6_address_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string service_name = 7;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.service_name_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string pin = 8;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.pin_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.ssid_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_, GetArena());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.ip_v6_address_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.service_name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.pin_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000c0U)) {
    ::memset(&_impl_.port_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.frequency_) -
        reinterpret_cast<char*>(&_impl_.port_)) + sizeof(_impl_.frequency_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string ssid = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_ssid();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string password = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_password();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int32 port = 3;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
            stream, this_._internal_port(), target);
  }

  // optional int32 frequency = 4;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
            stream, this_._internal_frequency(), target);
  }

  // optional string gateway = 5 [default = "0.0.0.0"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_gateway();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional bytes ip_v6_address = 6;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_ip_v6_address();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  // optional string service_name = 7;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    const ::std::string& _s = this_._internal_service_name();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional string pin = 8;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    const ::std::string& _s = this_._internal_pin();
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // optional string ssid = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_ssid());
    }
    // optional string password = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_password());
    }
    // optional string gateway = 5 [default = "0.0.0.0"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_gateway());
    }
    // optional bytes ip_v6_address = 6;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_ip_v6_address());
    }
    // optional string service_name = 7;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_service_name());
    }
    // optional string pin = 8;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_pin());
    }
    // optional int32 port = 3;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_port());
    }
    // optional int32 frequency = 4;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_frequency());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_ssid(from._internal_ssid());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_password(from._internal_password());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_gateway(from._internal_gateway());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_ip_v6_address(from._internal_ip_v6_address());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_internal_set_service_name(from._internal_service_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_internal_set_pin(from._internal_pin());
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.frequency_ = from._impl_.frequency_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ssid_, &other->_impl_.ssid_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, &other->_impl_.password_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.gateway_, &other->_impl_.gateway_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ip_v6_address_, &other->_impl_.ip_v6_address_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_name_, &other->_impl_.service_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pin_, &other->_impl_.pin_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.frequency_)
      + sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_impl_.frequency_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, _impl_.port_)>(
          reinterpret_cast<char*>(&_impl_.port_),
          reinterpret_cast<char*>(&other->_impl_.port_));
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        peer_id_(arena, from.peer_id_) {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.location_hint_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.location_hint_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        peer_id_(arena) {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.location_hint_ = {};
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.peer_id_.Destroy();
  delete this_._impl_.location_hint_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials),
                                            alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials));
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<95>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<95> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .location.nearby.connections.LocationHint location_hint = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials, _impl_.location_hint_)}},
    // optional string peer_id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials, _impl_.peer_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string peer_id = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials, _impl_.peer_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.LocationHint location_hint = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials, _impl_.location_hint_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::LocationHint>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.peer_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.location_hint_ != nullptr);
      _impl_.location_hint_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string peer_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_peer_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .location.nearby.connections.LocationHint location_hint = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.location_hint_, this_._impl_.location_hint_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional string peer_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_peer_id());
    }
    // optional .location.nearby.connections.LocationHint location_hint = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.location_hint_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_peer_id(from._internal_peer_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.location_hint_ != nullptr);
      if (_this->_impl_.location_hint_ == nullptr) {
        _this->_impl_.location_hint_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.location_hint_);
      } else {
        _this->_impl_.location_hint_->MergeFrom(*from._impl_.location_hint_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.peer_id_, &other->_impl_.peer_id_, arena);
  swap(_impl_.location_hint_, other->_impl_.location_hint_);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        service_name_(arena, from.service_name_),
        service_type_(arena, from.service_type_),
        password_(arena, from.password_) {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        service_name_(arena),
        service_type_(arena),
        password_(arena) {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.service_name_.Destroy();
  this_._impl_.service_type_.Destroy();
  this_._impl_.password_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials),
                                            alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials));
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<93>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<93> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string service_name = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_.service_name_)}},
    // optional string service_type = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_.service_type_)}},
    // optional string password = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_.password_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string service_name = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_.service_name_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string service_type = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_.service_type_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string password = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials, _impl_.password_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.service_name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.service_type_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string service_name = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_service_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string service_type = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_service_type();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string password = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_password();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // optional string service_name = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_service_name());
    }
    // optional string service_type = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_service_type());
    }
    // optional string password = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_password());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_service_name(from._internal_service_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_service_type(from._internal_service_type());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_password(from._internal_password());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_name_, &other->_impl_.service_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_type_, &other->_impl_.service_type_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, &other->_impl_.password_, arena);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        mediums_{visibility, arena, from.mediums_},
        _mediums_cached_byte_size_{0} {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.medium_meta_data_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.medium_meta_data_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        mediums_{visibility, arena},
        _mediums_cached_byte_size_{0} {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.medium_meta_data_ = {};
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.medium_meta_data_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_.mediums_) +
          decltype(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::_impl_.mediums_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest), alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::PlacementNew_,
                                 sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest),
                                 alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest));
  }
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<96>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<96> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .location.nearby.connections.MediumMetadata medium_meta_data = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_.medium_meta_data_)}},
    // repeated .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium mediums = 1 [packed = true];
    {::_pbi::TcParser::FastEvP1,
     {10, 0, 1,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_.mediums_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium mediums = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_.mediums_), _Internal::kHasBitsOffset + 0, 1, (0 | ::_fl::kFcRepeated | ::_fl::kPackedEnum)},
    // optional .location.nearby.connections.MediumMetadata medium_meta_data = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest, _impl_.medium_meta_data_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::MediumMetadata>()},
      {::_pbi::FieldAuxEnumData{}, ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_internal_data_},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.mediums_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.medium_meta_data_ != nullptr);
      _impl_.medium_meta_data_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium mediums = 1 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      ::size_t byte_size = this_._impl_._mediums_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteEnumPacked(
            1, this_._internal_mediums(), byte_size, target);
      }
    }
  }

  // optional .location.nearby.connections.MediumMetadata medium_meta_data = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.medium_meta_data_, this_._impl_.medium_meta_data_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium mediums = 1 [packed = true];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_mediums(), 1, this_._impl_._mediums_cached_byte_size_);
    }
    // optional .location.nearby.connections.MediumMetadata medium_meta_data = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.medium_meta_data_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_mediums()->MergeFrom(from._internal_mediums());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.medium_meta_data_ != nullptr);
      if (_this->_impl_.medium_meta_data_ == nullptr) {
        _this->_impl_.medium_meta_data_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.medium_meta_data_);
      } else {
        _this->_impl_.medium_meta_data_->MergeFrom(*from._impl_.medium_meta_data_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mediums_.InternalSwap(&other->_impl_.mediums_);
  swap(_impl_.medium_meta_data_, other->_impl_.medium_meta_data_);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.wifi_hotspot_credentials_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_hotspot_credentials_)
                : nullptr;
  _impl_.wifi_lan_socket_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_lan_socket_)
                : nullptr;
  _impl_.bluetooth_credentials_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.bluetooth_credentials_)
                : nullptr;
  _impl_.wifi_aware_credentials_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_aware_credentials_)
                : nullptr;
  _impl_.wifi_direct_credentials_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_direct_credentials_)
                : nullptr;
  _impl_.web_rtc_credentials_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.web_rtc_credentials_)
                : nullptr;
  _impl_.upgrade_path_request_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.upgrade_path_request_)
                : nullptr;
  _impl_.awdl_credentials_ = (CheckHasBit(cached_has_bits, 0x00000080U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.awdl_credentials_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, medium_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, medium_),
           offsetof(Impl_, supports_client_introduction_ack_) -
               offsetof(Impl_, medium_) +
               sizeof(Impl_::supports_client_introduction_ack_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, wifi_hotspot_credentials_),
           0,
           offsetof(Impl_, supports_client_introduction_ack_) -
               offsetof(Impl_, wifi_hotspot_credentials_) +
               sizeof(Impl_::supports_client_introduction_ack_));
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo& this_ = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.wifi_hotspot_credentials_;
  delete this_._impl_.wifi_lan_socket_;
  delete this_._impl_.bluetooth_credentials_;
  delete this_._impl_.wifi_aware_credentials_;
  delete this_._impl_.wifi_direct_credentials_;
  delete this_._impl_.web_rtc_credentials_;
  delete this_._impl_.upgrade_path_request_;
  delete this_._impl_.awdl_credentials_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_UpgradePathInfo(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo),
                                            alignof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo));
}
constexpr auto BandwidthUpgradeNegotiationFrame_UpgradePathInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<77>{
      {
          &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(), &BandwidthUpgradeNegotiationFrame_UpgradePathInfo::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<77> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_class_data_ =
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 9, 0, 2>
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    9,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
    {::_pbi::TcParser::FastEvS1,
     {8, 8, 8,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.medium_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_hotspot_credentials_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_lan_socket_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.bluetooth_credentials_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 3,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_aware_credentials_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 4,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_direct_credentials_)}},
    // optional bool supports_disabling_encryption = 7;
    {::_pbi::TcParser::FastV8S1,
     {56, 9, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.supports_disabling_encryption_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
    {::_pbi::TcParser::FastMtS1,
     {66, 5, 5,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.web_rtc_credentials_)}},
    // optional bool supports_client_introduction_ack = 9;
    {::_pbi::TcParser::FastV8S1,
     {72, 10, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.supports_client_introduction_ack_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest upgrade_path_request = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 6, 6,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.upgrade_path_request_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials awdl_credentials = 11;
    {::_pbi::TcParser::FastMtS1,
     {90, 7, 7,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.awdl_credentials_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.medium_), _Internal::kHasBitsOffset + 8, 8, (0 | ::_fl::kFcOptional | ::_fl::kEnum)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_hotspot_credentials_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_lan_socket_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.bluetooth_credentials_), _Internal::kHasBitsOffset + 2, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_aware_credentials_), _Internal::kHasBitsOffset + 3, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_direct_credentials_), _Internal::kHasBitsOffset + 4, 4, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool supports_disabling_encryption = 7;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.supports_disabling_encryption_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.web_rtc_credentials_), _Internal::kHasBitsOffset + 5, 5, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool supports_client_introduction_ack = 9;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.supports_client_introduction_ack_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest upgrade_path_request = 10;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.upgrade_path_request_), _Internal::kHasBitsOffset + 6, 6, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials awdl_credentials = 11;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.awdl_credentials_), _Internal::kHasBitsOffset + 7, 7, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_UpgradePathRequest>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_AwdlCredentials>()},
      {::_pbi::FieldAuxEnumData{}, ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_internal_data_},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(_impl_.wifi_hotspot_credentials_ != nullptr);
      _impl_.wifi_hotspot_credentials_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.wifi_lan_socket_ != nullptr);
      _impl_.wifi_lan_socket_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.bluetooth_credentials_ != nullptr);
      _impl_.bluetooth_credentials_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.wifi_aware_credentials_ != nullptr);
      _impl_.wifi_aware_credentials_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.wifi_direct_credentials_ != nullptr);
      _impl_.wifi_direct_credentials_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.web_rtc_credentials_ != nullptr);
      _impl_.web_rtc_credentials_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.upgrade_path_request_ != nullptr);
      _impl_.upgrade_path_request_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(_impl_.awdl_credentials_ != nullptr);
      _impl_.awdl_credentials_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    ::memset(&_impl_.medium_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.supports_client_introduction_ack_) -
        reinterpret_cast<char*>(&_impl_.medium_)) + sizeof(_impl_.supports_client_introduction_ack_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_medium(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.wifi_hotspot_credentials_, this_._impl_.wifi_hotspot_credentials_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.wifi_lan_socket_, this_._impl_.wifi_lan_socket_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.bluetooth_credentials_, this_._impl_.bluetooth_credentials_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.wifi_aware_credentials_, this_._impl_.wifi_aware_credentials_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.wifi_direct_credentials_, this_._impl_.wifi_direct_credentials_->GetCachedSize(), target,
        stream);
  }

  // optional bool supports_disabling_encryption = 7;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this_._internal_supports_disabling_encryption(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, *this_._impl_.web_rtc_credentials_, this_._impl_.web_rtc_credentials_->GetCachedSize(), target,
        stream);
  }

  // optional bool supports_client_introduction_ack = 9;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this_._internal_supports_client_introduction_ack(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest upgrade_path_request = 10;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        10, *this_._impl_.upgrade_path_request_, this_._impl_.upgrade_path_request_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials awdl_credentials = 11;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        11, *this_._impl_.awdl_credentials_, this_._impl_.awdl_credentials_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000600U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_hotspot_credentials_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_lan_socket_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.bluetooth_credentials_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_aware_credentials_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_direct_credentials_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.web_rtc_credentials_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.UpgradePathRequest upgrade_path_request = 10;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.upgrade_path_request_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.AwdlCredentials awdl_credentials = 11;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.awdl_credentials_);
    }
  }
   {
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_medium());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.wifi_hotspot_credentials_ != nullptr);
      if (_this->_impl_.wifi_hotspot_credentials_ == nullptr) {
        _this->_impl_.wifi_hotspot_credentials_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_hotspot_credentials_);
      } else {
        _this->_impl_.wifi_hotspot_credentials_->MergeFrom(*from._impl_.wifi_hotspot_credentials_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.wifi_lan_socket_ != nullptr);
      if (_this->_impl_.wifi_lan_socket_ == nullptr) {
        _this->_impl_.wifi_lan_socket_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_lan_socket_);
      } else {
        _this->_impl_.wifi_lan_socket_->MergeFrom(*from._impl_.wifi_lan_socket_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.bluetooth_credentials_ != nullptr);
      if (_this->_impl_.bluetooth_credentials_ == nullptr) {
        _this->_impl_.bluetooth_credentials_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.bluetooth_credentials_);
      } else {
        _this->_impl_.bluetooth_credentials_->MergeFrom(*from._impl_.bluetooth_credentials_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.wifi_aware_credentials_ != nullptr);
      if (_this->_impl_.wifi_aware_credentials_ == nullptr) {
        _this->_impl_.wifi_aware_credentials_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_aware_credentials_);
      } else {
        _this->_impl_.wifi_aware_credentials_->MergeFrom(*from._impl_.wifi_aware_credentials_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.wifi_direct_credentials_ != nullptr);
      if (_this->_impl_.wifi_direct_credentials_ == nullptr) {
        _this->_impl_.wifi_direct_credentials_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_direct_credentials_);
      } else {
        _this->_impl_.wifi_direct_credentials_->MergeFrom(*from._impl_.wifi_direct_credentials_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.web_rtc_credentials_ != nullptr);
      if (_this->_impl_.web_rtc_credentials_ == nullptr) {
        _this->_impl_.web_rtc_credentials_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.web_rtc_credentials_);
      } else {
        _this->_impl_.web_rtc_credentials_->MergeFrom(*from._impl_.web_rtc_credentials_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.upgrade_path_request_ != nullptr);
      if (_this->_impl_.upgrade_path_request_ == nullptr) {
        _this->_impl_.upgrade_path_request_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.upgrade_path_request_);
      } else {
        _this->_impl_.upgrade_path_request_->MergeFrom(*from._impl_.upgrade_path_request_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(from._impl_.awdl_credentials_ != nullptr);
      if (_this->_impl_.awdl_credentials_ == nullptr) {
        _this->_impl_.awdl_credentials_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.awdl_credentials_);
      } else {
        _this->_impl_.awdl_credentials_->MergeFrom(*from._impl_.awdl_credentials_);
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.medium_ = from._impl_.medium_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.supports_disabling_encryption_ = from._impl_.supports_disabling_encryption_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.supports_client_introduction_ack_ = from._impl_.supports_client_introduction_ack_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.supports_client_introduction_ack_)
      + sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_impl_.supports_client_introduction_ack_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, _impl_.wifi_hotspot_credentials_)>(
          reinterpret_cast<char*>(&_impl_.wifi_hotspot_credentials_),
          reinterpret_cast<char*>(&other->_impl_.wifi_hotspot_credentials_));
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
}
BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.sta_frequency_ = {};
}
BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::~BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& this_ = static_cast<BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel),
                                            alignof(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel));
}
constexpr auto BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<85>{
      {
          &_BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel>(), &BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<85> BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_class_data_ =
    BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 sta_frequency = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel, _impl_.sta_frequency_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 sta_frequency = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel, _impl_.sta_frequency_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sta_frequency_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 sta_frequency = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_sta_frequency(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional int32 sta_frequency = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_sta_frequency());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_impl_.sta_frequency_ = from._impl_.sta_frequency_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::CopyFrom(const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::InternalSwap(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.sta_frequency_, other->_impl_.sta_frequency_);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_ClientIntroduction::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame_ClientIntroduction>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_ClientIntroduction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_ClientIntroduction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        endpoint_id_(arena, from.endpoint_id_),
        last_endpoint_id_(arena, from.last_endpoint_id_) {}

BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_ClientIntroduction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame_ClientIntroduction* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.supports_disabling_encryption_ = from._impl_.supports_disabling_encryption_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_ClientIntroduction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        endpoint_id_(arena),
        last_endpoint_id_(arena) {}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.supports_disabling_encryption_ = {};
}
BandwidthUpgradeNegotiationFrame_ClientIntroduction::~BandwidthUpgradeNegotiationFrame_ClientIntroduction() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_ClientIntroduction& this_ = static_cast<BandwidthUpgradeNegotiationFrame_ClientIntroduction&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.endpoint_id_.Destroy();
  this_._impl_.last_endpoint_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_ClientIntroduction::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_ClientIntroduction(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_ClientIntroduction::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BandwidthUpgradeNegotiationFrame_ClientIntroduction),
                                            alignof(BandwidthUpgradeNegotiationFrame_ClientIntroduction));
}
constexpr auto BandwidthUpgradeNegotiationFrame_ClientIntroduction::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<80>{
      {
          &_BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_ClientIntroduction::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_ClientIntroduction>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_ClientIntroduction::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_ClientIntroduction>(), &BandwidthUpgradeNegotiationFrame_ClientIntroduction::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_ClientIntroduction::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<80> BandwidthUpgradeNegotiationFrame_ClientIntroduction_class_data_ =
    BandwidthUpgradeNegotiationFrame_ClientIntroduction::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_ClientIntroduction::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_ClientIntroduction_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
BandwidthUpgradeNegotiationFrame_ClientIntroduction::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BandwidthUpgradeNegotiationFrame_ClientIntroduction_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string endpoint_id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_.endpoint_id_)}},
    // optional bool supports_disabling_encryption = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_.supports_disabling_encryption_)}},
    // optional string last_endpoint_id = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_.last_endpoint_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string endpoint_id = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_.endpoint_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool supports_disabling_encryption = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_.supports_disabling_encryption_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string last_endpoint_id = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroduction, _impl_.last_endpoint_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_ClientIntroduction::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.last_endpoint_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.supports_disabling_encryption_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_ClientIntroduction::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_ClientIntroduction& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroduction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_ClientIntroduction::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_ClientIntroduction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string endpoint_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_endpoint_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional bool supports_disabling_encryption = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_supports_disabling_encryption(), target);
  }

  // optional string last_endpoint_id = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_last_endpoint_id();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_ClientIntroduction::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_ClientIntroduction& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroduction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_ClientIntroduction::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_ClientIntroduction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000004U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional string endpoint_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_endpoint_id());
    }
    // optional string last_endpoint_id = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_last_endpoint_id());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_ClientIntroduction*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroduction&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_last_endpoint_id(from._internal_last_endpoint_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.supports_disabling_encryption_ = from._impl_.supports_disabling_encryption_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_ClientIntroduction::InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_id_, &other->_impl_.endpoint_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_endpoint_id_, &other->_impl_.last_endpoint_id_, arena);
  swap(_impl_.supports_disabling_encryption_, other->_impl_.supports_disabling_encryption_);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_Internal {
 public:
};

BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
}
BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::~BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& this_ = static_cast<BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck),
                                            alignof(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck));
}
constexpr auto BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<83>{
      {
          &_BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(), &BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<83> BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_class_data_ =
    BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 0, 0, 0, 2>
BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    0, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967295,  // skipmap
    offsetof(decltype(_table_), field_names),  // no field_entries
    0,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, // no field_entries, or aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& this_ = static_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame_ClientIntroductionAck*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

// ===================================================================

class BandwidthUpgradeNegotiationFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeNegotiationFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_._has_bits_);
};

BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeNegotiationFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeNegotiationFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeNegotiationFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.upgrade_path_info_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.upgrade_path_info_)
                : nullptr;
  _impl_.client_introduction_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.client_introduction_)
                : nullptr;
  _impl_.client_introduction_ack_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.client_introduction_ack_)
                : nullptr;
  _impl_.safe_to_close_prior_channel_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.safe_to_close_prior_channel_)
                : nullptr;
  _impl_.event_type_ = from._impl_.event_type_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeNegotiationFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void BandwidthUpgradeNegotiationFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, upgrade_path_info_),
           0,
           offsetof(Impl_, event_type_) -
               offsetof(Impl_, upgrade_path_info_) +
               sizeof(Impl_::event_type_));
}
BandwidthUpgradeNegotiationFrame::~BandwidthUpgradeNegotiationFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  SharedDtor(*this);
}
inline void BandwidthUpgradeNegotiationFrame::SharedDtor(MessageLite& self) {
  BandwidthUpgradeNegotiationFrame& this_ = static_cast<BandwidthUpgradeNegotiationFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.upgrade_path_info_;
  delete this_._impl_.client_introduction_;
  delete this_._impl_.client_introduction_ack_;
  delete this_._impl_.safe_to_close_prior_channel_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeNegotiationFrame(arena);
}
constexpr auto BandwidthUpgradeNegotiationFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(BandwidthUpgradeNegotiationFrame),
                                            alignof(BandwidthUpgradeNegotiationFrame));
}
constexpr auto BandwidthUpgradeNegotiationFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<61>{
      {
          &_BandwidthUpgradeNegotiationFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeNegotiationFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeNegotiationFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeNegotiationFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeNegotiationFrame>(), &BandwidthUpgradeNegotiationFrame::ByteSizeLong,
              &BandwidthUpgradeNegotiationFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeNegotiationFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<61> BandwidthUpgradeNegotiationFrame_class_data_ =
    BandwidthUpgradeNegotiationFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeNegotiationFrame::GetClassData() const {
  return BandwidthUpgradeNegotiationFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2>
BandwidthUpgradeNegotiationFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BandwidthUpgradeNegotiationFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 4, 7,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.event_type_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.upgrade_path_info_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.client_introduction_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.client_introduction_ack_)}},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel safe_to_close_prior_channel = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 3,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.safe_to_close_prior_channel_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.event_type_), _Internal::kHasBitsOffset + 4, 4, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.upgrade_path_info_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.client_introduction_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.client_introduction_ack_), _Internal::kHasBitsOffset + 2, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel safe_to_close_prior_channel = 5;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.safe_to_close_prior_channel_), _Internal::kHasBitsOffset + 3, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel>()},
      {0, 7},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeNegotiationFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(_impl_.upgrade_path_info_ != nullptr);
      _impl_.upgrade_path_info_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.client_introduction_ != nullptr);
      _impl_.client_introduction_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.client_introduction_ack_ != nullptr);
      _impl_.client_introduction_ack_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.safe_to_close_prior_channel_ != nullptr);
      _impl_.safe_to_close_prior_channel_->Clear();
    }
  }
  _impl_.event_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeNegotiationFrame& this_ = static_cast<const BandwidthUpgradeNegotiationFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeNegotiationFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeNegotiationFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_event_type(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.upgrade_path_info_, this_._impl_.upgrade_path_info_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.client_introduction_, this_._impl_.client_introduction_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.client_introduction_ack_, this_._impl_.client_introduction_ack_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel safe_to_close_prior_channel = 5;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.safe_to_close_prior_channel_, this_._impl_.safe_to_close_prior_channel_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeNegotiationFrame::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeNegotiationFrame& this_ = static_cast<const BandwidthUpgradeNegotiationFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeNegotiationFrame::ByteSizeLong() const {
  const BandwidthUpgradeNegotiationFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.upgrade_path_info_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.client_introduction_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.client_introduction_ack_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel safe_to_close_prior_channel = 5;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.safe_to_close_prior_channel_);
    }
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_event_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeNegotiationFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeNegotiationFrame*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeNegotiationFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.upgrade_path_info_ != nullptr);
      if (_this->_impl_.upgrade_path_info_ == nullptr) {
        _this->_impl_.upgrade_path_info_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.upgrade_path_info_);
      } else {
        _this->_impl_.upgrade_path_info_->MergeFrom(*from._impl_.upgrade_path_info_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.client_introduction_ != nullptr);
      if (_this->_impl_.client_introduction_ == nullptr) {
        _this->_impl_.client_introduction_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.client_introduction_);
      } else {
        _this->_impl_.client_introduction_->MergeFrom(*from._impl_.client_introduction_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.client_introduction_ack_ != nullptr);
      if (_this->_impl_.client_introduction_ack_ == nullptr) {
        _this->_impl_.client_introduction_ack_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.client_introduction_ack_);
      } else {
        _this->_impl_.client_introduction_ack_->MergeFrom(*from._impl_.client_introduction_ack_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.safe_to_close_prior_channel_ != nullptr);
      if (_this->_impl_.safe_to_close_prior_channel_ == nullptr) {
        _this->_impl_.safe_to_close_prior_channel_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.safe_to_close_prior_channel_);
      } else {
        _this->_impl_.safe_to_close_prior_channel_->MergeFrom(*from._impl_.safe_to_close_prior_channel_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame::CopyFrom(const BandwidthUpgradeNegotiationFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeNegotiationFrame::InternalSwap(BandwidthUpgradeNegotiationFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.event_type_)
      + sizeof(BandwidthUpgradeNegotiationFrame::_impl_.event_type_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, _impl_.upgrade_path_info_)>(
          reinterpret_cast<char*>(&_impl_.upgrade_path_info_),
          reinterpret_cast<char*>(&other->_impl_.upgrade_path_info_));
}

// ===================================================================

class BandwidthUpgradeRetryFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BandwidthUpgradeRetryFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_._has_bits_);
};

BandwidthUpgradeRetryFrame::BandwidthUpgradeRetryFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeRetryFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeRetryFrame)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeRetryFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::BandwidthUpgradeRetryFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        supported_medium_{visibility, arena, from.supported_medium_} {}

BandwidthUpgradeRetryFrame::BandwidthUpgradeRetryFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BandwidthUpgradeRetryFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, BandwidthUpgradeRetryFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BandwidthUpgradeRetryFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.is_request_ = from._impl_.is_request_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeRetryFrame)
}
PROTOBUF_NDEBUG_INLINE BandwidthUpgradeRetryFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        supported_medium_{visibility, arena} {}

inline void BandwidthUpgradeRetryFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.is_request_ = {};
}
BandwidthUpgradeRetryFrame::~BandwidthUpgradeRetryFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeRetryFrame)
  SharedDtor(*this);
}
inline void BandwidthUpgradeRetryFrame::SharedDtor(MessageLite& self) {
  BandwidthUpgradeRetryFrame& this_ = static_cast<BandwidthUpgradeRetryFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BandwidthUpgradeRetryFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BandwidthUpgradeRetryFrame(arena);
}
constexpr auto BandwidthUpgradeRetryFrame::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_.supported_medium_) +
          decltype(BandwidthUpgradeRetryFrame::_impl_.supported_medium_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(BandwidthUpgradeRetryFrame), alignof(BandwidthUpgradeRetryFrame), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BandwidthUpgradeRetryFrame::PlacementNew_,
                                 sizeof(BandwidthUpgradeRetryFrame),
                                 alignof(BandwidthUpgradeRetryFrame));
  }
}
constexpr auto BandwidthUpgradeRetryFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<55>{
      {
          &_BandwidthUpgradeRetryFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BandwidthUpgradeRetryFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<BandwidthUpgradeRetryFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BandwidthUpgradeRetryFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<BandwidthUpgradeRetryFrame>(), &BandwidthUpgradeRetryFrame::ByteSizeLong,
              &BandwidthUpgradeRetryFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.BandwidthUpgradeRetryFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<55> BandwidthUpgradeRetryFrame_class_data_ =
    BandwidthUpgradeRetryFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BandwidthUpgradeRetryFrame::GetClassData() const {
  return BandwidthUpgradeRetryFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
BandwidthUpgradeRetryFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BandwidthUpgradeRetryFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::BandwidthUpgradeRetryFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool is_request = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_.is_request_)}},
    // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
    {::_pbi::TcParser::FastEvR1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_.supported_medium_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_.supported_medium_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kEnum)},
    // optional bool is_request = 2;
    {PROTOBUF_FIELD_OFFSET(BandwidthUpgradeRetryFrame, _impl_.is_request_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::FieldAuxEnumData{}, ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium_internal_data_},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BandwidthUpgradeRetryFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.supported_medium_.Clear();
  }
  _impl_.is_request_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeRetryFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BandwidthUpgradeRetryFrame& this_ = static_cast<const BandwidthUpgradeRetryFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BandwidthUpgradeRetryFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BandwidthUpgradeRetryFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_supported_medium_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, static_cast<::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium>(this_._internal_supported_medium().Get(i)),
          target);
    }
  }

  // optional bool is_request = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_is_request(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeRetryFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BandwidthUpgradeRetryFrame::ByteSizeLong(const MessageLite& base) {
  const BandwidthUpgradeRetryFrame& this_ = static_cast<const BandwidthUpgradeRetryFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BandwidthUpgradeRetryFrame::ByteSizeLong() const {
  const BandwidthUpgradeRetryFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000002U & cached_has_bits) * 2;
   {
    // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size =
          ::_pbi::WireFormatLite::EnumSize(this_._internal_supported_medium());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_supported_medium_size());
      total_size += data_size + tag_size;
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BandwidthUpgradeRetryFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BandwidthUpgradeRetryFrame*>(&to_msg);
  auto& from = static_cast<const BandwidthUpgradeRetryFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_supported_medium()->MergeFrom(from._internal_supported_medium());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.is_request_ = from._impl_.is_request_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void BandwidthUpgradeRetryFrame::CopyFrom(const BandwidthUpgradeRetryFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BandwidthUpgradeRetryFrame::InternalSwap(BandwidthUpgradeRetryFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.supported_medium_.InternalSwap(&other->_impl_.supported_medium_);
  swap(_impl_.is_request_, other->_impl_.is_request_);
}

// ===================================================================

class KeepAliveFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<KeepAliveFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_._has_bits_);
};

KeepAliveFrame::KeepAliveFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, KeepAliveFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.KeepAliveFrame)
}
KeepAliveFrame::KeepAliveFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const KeepAliveFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, KeepAliveFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE KeepAliveFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void KeepAliveFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, ack_),
           0,
           offsetof(Impl_, seq_num_) -
               offsetof(Impl_, ack_) +
               sizeof(Impl_::seq_num_));
}
KeepAliveFrame::~KeepAliveFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.KeepAliveFrame)
  SharedDtor(*this);
}
inline void KeepAliveFrame::SharedDtor(MessageLite& self) {
  KeepAliveFrame& this_ = static_cast<KeepAliveFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL KeepAliveFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) KeepAliveFrame(arena);
}
constexpr auto KeepAliveFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(KeepAliveFrame),
                                            alignof(KeepAliveFrame));
}
constexpr auto KeepAliveFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<43>{
      {
          &_KeepAliveFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &KeepAliveFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<KeepAliveFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &KeepAliveFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<KeepAliveFrame>(), &KeepAliveFrame::ByteSizeLong,
              &KeepAliveFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.KeepAliveFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<43> KeepAliveFrame_class_data_ =
    KeepAliveFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
KeepAliveFrame::GetClassData() const {
  return KeepAliveFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
KeepAliveFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    KeepAliveFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::KeepAliveFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint32 seq_num = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_.seq_num_)}},
    // optional bool ack = 1;
    {::_pbi::TcParser::FastV8S1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_.ack_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool ack = 1;
    {PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_.ack_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 seq_num = 2;
    {PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_.seq_num_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void KeepAliveFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.KeepAliveFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    ::memset(&_impl_.ack_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.seq_num_) -
        reinterpret_cast<char*>(&_impl_.ack_)) + sizeof(_impl_.seq_num_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL KeepAliveFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const KeepAliveFrame& this_ = static_cast<const KeepAliveFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL KeepAliveFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const KeepAliveFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.KeepAliveFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool ack = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_ack(), target);
  }

  // optional uint32 seq_num = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_seq_num(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.KeepAliveFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t KeepAliveFrame::ByteSizeLong(const MessageLite& base) {
  const KeepAliveFrame& this_ = static_cast<const KeepAliveFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t KeepAliveFrame::ByteSizeLong() const {
  const KeepAliveFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.KeepAliveFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000001U & cached_has_bits) * 2;
   {
    // optional uint32 seq_num = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_seq_num());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void KeepAliveFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<KeepAliveFrame*>(&to_msg);
  auto& from = static_cast<const KeepAliveFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.KeepAliveFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.ack_ = from._impl_.ack_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.seq_num_ = from._impl_.seq_num_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void KeepAliveFrame::CopyFrom(const KeepAliveFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.KeepAliveFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void KeepAliveFrame::InternalSwap(KeepAliveFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_.seq_num_)
      + sizeof(KeepAliveFrame::_impl_.seq_num_)
      - PROTOBUF_FIELD_OFFSET(KeepAliveFrame, _impl_.ack_)>(
          reinterpret_cast<char*>(&_impl_.ack_),
          reinterpret_cast<char*>(&other->_impl_.ack_));
}

// ===================================================================

class DisconnectionFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DisconnectionFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_._has_bits_);
};

DisconnectionFrame::DisconnectionFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, DisconnectionFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.DisconnectionFrame)
}
DisconnectionFrame::DisconnectionFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DisconnectionFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, DisconnectionFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE DisconnectionFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void DisconnectionFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, request_safe_to_disconnect_),
           0,
           offsetof(Impl_, ack_safe_to_disconnect_) -
               offsetof(Impl_, request_safe_to_disconnect_) +
               sizeof(Impl_::ack_safe_to_disconnect_));
}
DisconnectionFrame::~DisconnectionFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.DisconnectionFrame)
  SharedDtor(*this);
}
inline void DisconnectionFrame::SharedDtor(MessageLite& self) {
  DisconnectionFrame& this_ = static_cast<DisconnectionFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DisconnectionFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DisconnectionFrame(arena);
}
constexpr auto DisconnectionFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(DisconnectionFrame),
                                            alignof(DisconnectionFrame));
}
constexpr auto DisconnectionFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<47>{
      {
          &_DisconnectionFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DisconnectionFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<DisconnectionFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DisconnectionFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<DisconnectionFrame>(), &DisconnectionFrame::ByteSizeLong,
              &DisconnectionFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.DisconnectionFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<47> DisconnectionFrame_class_data_ =
    DisconnectionFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DisconnectionFrame::GetClassData() const {
  return DisconnectionFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
DisconnectionFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DisconnectionFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::DisconnectionFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ack_safe_to_disconnect = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_.ack_safe_to_disconnect_)}},
    // optional bool request_safe_to_disconnect = 1;
    {::_pbi::TcParser::FastV8S1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_.request_safe_to_disconnect_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool request_safe_to_disconnect = 1;
    {PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_.request_safe_to_disconnect_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool ack_safe_to_disconnect = 2;
    {PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_.ack_safe_to_disconnect_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void DisconnectionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.DisconnectionFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.request_safe_to_disconnect_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ack_safe_to_disconnect_) -
      reinterpret_cast<char*>(&_impl_.request_safe_to_disconnect_)) + sizeof(_impl_.ack_safe_to_disconnect_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DisconnectionFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DisconnectionFrame& this_ = static_cast<const DisconnectionFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DisconnectionFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DisconnectionFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.DisconnectionFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool request_safe_to_disconnect = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_request_safe_to_disconnect(), target);
  }

  // optional bool ack_safe_to_disconnect = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_ack_safe_to_disconnect(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.DisconnectionFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DisconnectionFrame::ByteSizeLong(const MessageLite& base) {
  const DisconnectionFrame& this_ = static_cast<const DisconnectionFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DisconnectionFrame::ByteSizeLong() const {
  const DisconnectionFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.DisconnectionFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000003U & cached_has_bits) * 2;
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void DisconnectionFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DisconnectionFrame*>(&to_msg);
  auto& from = static_cast<const DisconnectionFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.DisconnectionFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.request_safe_to_disconnect_ = from._impl_.request_safe_to_disconnect_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.ack_safe_to_disconnect_ = from._impl_.ack_safe_to_disconnect_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void DisconnectionFrame::CopyFrom(const DisconnectionFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.DisconnectionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DisconnectionFrame::InternalSwap(DisconnectionFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_.ack_safe_to_disconnect_)
      + sizeof(DisconnectionFrame::_impl_.ack_safe_to_disconnect_)
      - PROTOBUF_FIELD_OFFSET(DisconnectionFrame, _impl_.request_safe_to_disconnect_)>(
          reinterpret_cast<char*>(&_impl_.request_safe_to_disconnect_),
          reinterpret_cast<char*>(&other->_impl_.request_safe_to_disconnect_));
}

// ===================================================================

class PairedKeyEncryptionFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PairedKeyEncryptionFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PairedKeyEncryptionFrame, _impl_._has_bits_);
};

PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PairedKeyEncryptionFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PairedKeyEncryptionFrame)
}
PROTOBUF_NDEBUG_INLINE PairedKeyEncryptionFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::PairedKeyEncryptionFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        signed_data_(arena, from.signed_data_) {}

PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PairedKeyEncryptionFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PairedKeyEncryptionFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PairedKeyEncryptionFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PairedKeyEncryptionFrame)
}
PROTOBUF_NDEBUG_INLINE PairedKeyEncryptionFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        signed_data_(arena) {}

inline void PairedKeyEncryptionFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PairedKeyEncryptionFrame::~PairedKeyEncryptionFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PairedKeyEncryptionFrame)
  SharedDtor(*this);
}
inline void PairedKeyEncryptionFrame::SharedDtor(MessageLite& self) {
  PairedKeyEncryptionFrame& this_ = static_cast<PairedKeyEncryptionFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.signed_data_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PairedKeyEncryptionFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PairedKeyEncryptionFrame(arena);
}
constexpr auto PairedKeyEncryptionFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PairedKeyEncryptionFrame),
                                            alignof(PairedKeyEncryptionFrame));
}
constexpr auto PairedKeyEncryptionFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<53>{
      {
          &_PairedKeyEncryptionFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PairedKeyEncryptionFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PairedKeyEncryptionFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PairedKeyEncryptionFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PairedKeyEncryptionFrame>(), &PairedKeyEncryptionFrame::ByteSizeLong,
              &PairedKeyEncryptionFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PairedKeyEncryptionFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.PairedKeyEncryptionFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<53> PairedKeyEncryptionFrame_class_data_ =
    PairedKeyEncryptionFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PairedKeyEncryptionFrame::GetClassData() const {
  return PairedKeyEncryptionFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
PairedKeyEncryptionFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PairedKeyEncryptionFrame, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PairedKeyEncryptionFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::PairedKeyEncryptionFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bytes signed_data = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PairedKeyEncryptionFrame, _impl_.signed_data_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes signed_data = 1;
    {PROTOBUF_FIELD_OFFSET(PairedKeyEncryptionFrame, _impl_.signed_data_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PairedKeyEncryptionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PairedKeyEncryptionFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.signed_data_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PairedKeyEncryptionFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PairedKeyEncryptionFrame& this_ = static_cast<const PairedKeyEncryptionFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PairedKeyEncryptionFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PairedKeyEncryptionFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PairedKeyEncryptionFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes signed_data = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_signed_data();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PairedKeyEncryptionFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PairedKeyEncryptionFrame::ByteSizeLong(const MessageLite& base) {
  const PairedKeyEncryptionFrame& this_ = static_cast<const PairedKeyEncryptionFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PairedKeyEncryptionFrame::ByteSizeLong() const {
  const PairedKeyEncryptionFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PairedKeyEncryptionFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional bytes signed_data = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_signed_data());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PairedKeyEncryptionFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PairedKeyEncryptionFrame*>(&to_msg);
  auto& from = static_cast<const PairedKeyEncryptionFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PairedKeyEncryptionFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_internal_set_signed_data(from._internal_signed_data());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PairedKeyEncryptionFrame::CopyFrom(const PairedKeyEncryptionFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PairedKeyEncryptionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PairedKeyEncryptionFrame::InternalSwap(PairedKeyEncryptionFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.signed_data_, &other->_impl_.signed_data_, arena);
}

// ===================================================================

class AuthenticationMessageFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AuthenticationMessageFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AuthenticationMessageFrame, _impl_._has_bits_);
};

AuthenticationMessageFrame::AuthenticationMessageFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AuthenticationMessageFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AuthenticationMessageFrame)
}
PROTOBUF_NDEBUG_INLINE AuthenticationMessageFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::AuthenticationMessageFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        auth_message_(arena, from.auth_message_) {}

AuthenticationMessageFrame::AuthenticationMessageFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AuthenticationMessageFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AuthenticationMessageFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AuthenticationMessageFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AuthenticationMessageFrame)
}
PROTOBUF_NDEBUG_INLINE AuthenticationMessageFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        auth_message_(arena) {}

inline void AuthenticationMessageFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AuthenticationMessageFrame::~AuthenticationMessageFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AuthenticationMessageFrame)
  SharedDtor(*this);
}
inline void AuthenticationMessageFrame::SharedDtor(MessageLite& self) {
  AuthenticationMessageFrame& this_ = static_cast<AuthenticationMessageFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.auth_message_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AuthenticationMessageFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AuthenticationMessageFrame(arena);
}
constexpr auto AuthenticationMessageFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AuthenticationMessageFrame),
                                            alignof(AuthenticationMessageFrame));
}
constexpr auto AuthenticationMessageFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<55>{
      {
          &_AuthenticationMessageFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AuthenticationMessageFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<AuthenticationMessageFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AuthenticationMessageFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<AuthenticationMessageFrame>(), &AuthenticationMessageFrame::ByteSizeLong,
              &AuthenticationMessageFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AuthenticationMessageFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.AuthenticationMessageFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<55> AuthenticationMessageFrame_class_data_ =
    AuthenticationMessageFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AuthenticationMessageFrame::GetClassData() const {
  return AuthenticationMessageFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
AuthenticationMessageFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AuthenticationMessageFrame, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    AuthenticationMessageFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::AuthenticationMessageFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bytes auth_message = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(AuthenticationMessageFrame, _impl_.auth_message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes auth_message = 1;
    {PROTOBUF_FIELD_OFFSET(AuthenticationMessageFrame, _impl_.auth_message_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void AuthenticationMessageFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AuthenticationMessageFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.auth_message_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AuthenticationMessageFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AuthenticationMessageFrame& this_ = static_cast<const AuthenticationMessageFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AuthenticationMessageFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AuthenticationMessageFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AuthenticationMessageFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes auth_message = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_auth_message();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AuthenticationMessageFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AuthenticationMessageFrame::ByteSizeLong(const MessageLite& base) {
  const AuthenticationMessageFrame& this_ = static_cast<const AuthenticationMessageFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AuthenticationMessageFrame::ByteSizeLong() const {
  const AuthenticationMessageFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AuthenticationMessageFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional bytes auth_message = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_auth_message());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AuthenticationMessageFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AuthenticationMessageFrame*>(&to_msg);
  auto& from = static_cast<const AuthenticationMessageFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AuthenticationMessageFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_internal_set_auth_message(from._internal_auth_message());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void AuthenticationMessageFrame::CopyFrom(const AuthenticationMessageFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AuthenticationMessageFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AuthenticationMessageFrame::InternalSwap(AuthenticationMessageFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.auth_message_, &other->_impl_.auth_message_, arena);
}

// ===================================================================

class AuthenticationResultFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AuthenticationResultFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AuthenticationResultFrame, _impl_._has_bits_);
};

AuthenticationResultFrame::AuthenticationResultFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AuthenticationResultFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AuthenticationResultFrame)
}
AuthenticationResultFrame::AuthenticationResultFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AuthenticationResultFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AuthenticationResultFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE AuthenticationResultFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void AuthenticationResultFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.result_ = {};
}
AuthenticationResultFrame::~AuthenticationResultFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AuthenticationResultFrame)
  SharedDtor(*this);
}
inline void AuthenticationResultFrame::SharedDtor(MessageLite& self) {
  AuthenticationResultFrame& this_ = static_cast<AuthenticationResultFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AuthenticationResultFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AuthenticationResultFrame(arena);
}
constexpr auto AuthenticationResultFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(AuthenticationResultFrame),
                                            alignof(AuthenticationResultFrame));
}
constexpr auto AuthenticationResultFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<54>{
      {
          &_AuthenticationResultFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AuthenticationResultFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<AuthenticationResultFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AuthenticationResultFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<AuthenticationResultFrame>(), &AuthenticationResultFrame::ByteSizeLong,
              &AuthenticationResultFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AuthenticationResultFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.AuthenticationResultFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<54> AuthenticationResultFrame_class_data_ =
    AuthenticationResultFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AuthenticationResultFrame::GetClassData() const {
  return AuthenticationResultFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
AuthenticationResultFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AuthenticationResultFrame, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    AuthenticationResultFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::AuthenticationResultFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 result = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(AuthenticationResultFrame, _impl_.result_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 result = 1;
    {PROTOBUF_FIELD_OFFSET(AuthenticationResultFrame, _impl_.result_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void AuthenticationResultFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AuthenticationResultFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AuthenticationResultFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AuthenticationResultFrame& this_ = static_cast<const AuthenticationResultFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AuthenticationResultFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AuthenticationResultFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AuthenticationResultFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 result = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_result(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AuthenticationResultFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AuthenticationResultFrame::ByteSizeLong(const MessageLite& base) {
  const AuthenticationResultFrame& this_ = static_cast<const AuthenticationResultFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AuthenticationResultFrame::ByteSizeLong() const {
  const AuthenticationResultFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AuthenticationResultFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional int32 result = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_result());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AuthenticationResultFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AuthenticationResultFrame*>(&to_msg);
  auto& from = static_cast<const AuthenticationResultFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AuthenticationResultFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_impl_.result_ = from._impl_.result_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void AuthenticationResultFrame::CopyFrom(const AuthenticationResultFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AuthenticationResultFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AuthenticationResultFrame::InternalSwap(AuthenticationResultFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

// ===================================================================

class AutoResumeFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AutoResumeFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_._has_bits_);
};

AutoResumeFrame::AutoResumeFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AutoResumeFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AutoResumeFrame)
}
AutoResumeFrame::AutoResumeFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AutoResumeFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AutoResumeFrame_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE AutoResumeFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void AutoResumeFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, pending_payload_id_),
           0,
           offsetof(Impl_, version_) -
               offsetof(Impl_, pending_payload_id_) +
               sizeof(Impl_::version_));
}
AutoResumeFrame::~AutoResumeFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AutoResumeFrame)
  SharedDtor(*this);
}
inline void AutoResumeFrame::SharedDtor(MessageLite& self) {
  AutoResumeFrame& this_ = static_cast<AutoResumeFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AutoResumeFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AutoResumeFrame(arena);
}
constexpr auto AutoResumeFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(AutoResumeFrame),
                                            alignof(AutoResumeFrame));
}
constexpr auto AutoResumeFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<44>{
      {
          &_AutoResumeFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AutoResumeFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<AutoResumeFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AutoResumeFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<AutoResumeFrame>(), &AutoResumeFrame::ByteSizeLong,
              &AutoResumeFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.AutoResumeFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<44> AutoResumeFrame_class_data_ =
    AutoResumeFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AutoResumeFrame::GetClassData() const {
  return AutoResumeFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2>
AutoResumeFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    AutoResumeFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::AutoResumeFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 version = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.version_)}},
    // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 1, 2,
      PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.event_type_)}},
    // optional int64 pending_payload_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 0, 0,
      PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.pending_payload_id_)}},
    // optional int32 next_payload_chunk_index = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.next_payload_chunk_index_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
    {PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.event_type_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional int64 pending_payload_id = 2;
    {PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.pending_payload_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int32 next_payload_chunk_index = 3;
    {PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.next_payload_chunk_index_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 version = 4;
    {PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.version_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  {{
      {0, 2},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void AutoResumeFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AutoResumeFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    ::memset(&_impl_.pending_payload_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.version_) -
        reinterpret_cast<char*>(&_impl_.pending_payload_id_)) + sizeof(_impl_.version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AutoResumeFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AutoResumeFrame& this_ = static_cast<const AutoResumeFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AutoResumeFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AutoResumeFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AutoResumeFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_event_type(), target);
  }

  // optional int64 pending_payload_id = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<2>(
            stream, this_._internal_pending_payload_id(), target);
  }

  // optional int32 next_payload_chunk_index = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
            stream, this_._internal_next_payload_chunk_index(), target);
  }

  // optional int32 version = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
            stream, this_._internal_version(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AutoResumeFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AutoResumeFrame::ByteSizeLong(const MessageLite& base) {
  const AutoResumeFrame& this_ = static_cast<const AutoResumeFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AutoResumeFrame::ByteSizeLong() const {
  const AutoResumeFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AutoResumeFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional int64 pending_payload_id = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_pending_payload_id());
    }
    // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_event_type());
    }
    // optional int32 next_payload_chunk_index = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_next_payload_chunk_index());
    }
    // optional int32 version = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_version());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AutoResumeFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AutoResumeFrame*>(&to_msg);
  auto& from = static_cast<const AutoResumeFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AutoResumeFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.pending_payload_id_ = from._impl_.pending_payload_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.next_payload_chunk_index_ = from._impl_.next_payload_chunk_index_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.version_ = from._impl_.version_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void AutoResumeFrame::CopyFrom(const AutoResumeFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AutoResumeFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AutoResumeFrame::InternalSwap(AutoResumeFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.version_)
      + sizeof(AutoResumeFrame::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(AutoResumeFrame, _impl_.pending_payload_id_)>(
          reinterpret_cast<char*>(&_impl_.pending_payload_id_),
          reinterpret_cast<char*>(&other->_impl_.pending_payload_id_));
}

// ===================================================================

class AutoReconnectFrame::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AutoReconnectFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_._has_bits_);
};

AutoReconnectFrame::AutoReconnectFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AutoReconnectFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AutoReconnectFrame)
}
PROTOBUF_NDEBUG_INLINE AutoReconnectFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::AutoReconnectFrame& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        endpoint_id_(arena, from.endpoint_id_),
        last_endpoint_id_(arena, from.last_endpoint_id_) {}

AutoReconnectFrame::AutoReconnectFrame(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AutoReconnectFrame& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AutoReconnectFrame_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AutoReconnectFrame* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.event_type_ = from._impl_.event_type_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AutoReconnectFrame)
}
PROTOBUF_NDEBUG_INLINE AutoReconnectFrame::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        endpoint_id_(arena),
        last_endpoint_id_(arena) {}

inline void AutoReconnectFrame::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.event_type_ = {};
}
AutoReconnectFrame::~AutoReconnectFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AutoReconnectFrame)
  SharedDtor(*this);
}
inline void AutoReconnectFrame::SharedDtor(MessageLite& self) {
  AutoReconnectFrame& this_ = static_cast<AutoReconnectFrame&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.endpoint_id_.Destroy();
  this_._impl_.last_endpoint_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AutoReconnectFrame::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AutoReconnectFrame(arena);
}
constexpr auto AutoReconnectFrame::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AutoReconnectFrame),
                                            alignof(AutoReconnectFrame));
}
constexpr auto AutoReconnectFrame::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<47>{
      {
          &_AutoReconnectFrame_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AutoReconnectFrame::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<AutoReconnectFrame>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AutoReconnectFrame::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<AutoReconnectFrame>(), &AutoReconnectFrame::ByteSizeLong,
              &AutoReconnectFrame::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.AutoReconnectFrame",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<47> AutoReconnectFrame_class_data_ =
    AutoReconnectFrame::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AutoReconnectFrame::GetClassData() const {
  return AutoReconnectFrame_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2>
AutoReconnectFrame::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    AutoReconnectFrame_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::AutoReconnectFrame>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string endpoint_id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_.endpoint_id_)}},
    // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 2, 2,
      PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_.event_type_)}},
    // optional string last_endpoint_id = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_.last_endpoint_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string endpoint_id = 1;
    {PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_.endpoint_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
    {PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_.event_type_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string last_endpoint_id = 3;
    {PROTOBUF_FIELD_OFFSET(AutoReconnectFrame, _impl_.last_endpoint_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  {{
      {0, 2},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void AutoReconnectFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AutoReconnectFrame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.last_endpoint_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.event_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AutoReconnectFrame::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AutoReconnectFrame& this_ = static_cast<const AutoReconnectFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AutoReconnectFrame::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AutoReconnectFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AutoReconnectFrame)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string endpoint_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_endpoint_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this_._internal_event_type(), target);
  }

  // optional string last_endpoint_id = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_last_endpoint_id();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AutoReconnectFrame)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AutoReconnectFrame::ByteSizeLong(const MessageLite& base) {
  const AutoReconnectFrame& this_ = static_cast<const AutoReconnectFrame&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AutoReconnectFrame::ByteSizeLong() const {
  const AutoReconnectFrame& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AutoReconnectFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // optional string endpoint_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_endpoint_id());
    }
    // optional string last_endpoint_id = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_last_endpoint_id());
    }
    // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_event_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AutoReconnectFrame::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AutoReconnectFrame*>(&to_msg);
  auto& from = static_cast<const AutoReconnectFrame&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AutoReconnectFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_last_endpoint_id(from._internal_last_endpoint_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void AutoReconnectFrame::CopyFrom(const AutoReconnectFrame& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AutoReconnectFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AutoReconnectFrame::InternalSwap(AutoReconnectFrame* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_id_, &other->_impl_.endpoint_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_endpoint_id_, &other->_impl_.last_endpoint_id_, arena);
  swap(_impl_.event_type_, other->_impl_.event_type_);
}

// ===================================================================

class MediumMetadata::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MediumMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_._has_bits_);
};

MediumMetadata::MediumMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, MediumMetadata_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.MediumMetadata)
}
PROTOBUF_NDEBUG_INLINE MediumMetadata::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::MediumMetadata& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        supported_wifi_direct_auth_types_{visibility, arena, from.supported_wifi_direct_auth_types_},
        _supported_wifi_direct_auth_types_cached_byte_size_{0},
        bssid_(arena, from.bssid_),
        ip_address_(arena, from.ip_address_) {}

MediumMetadata::MediumMetadata(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MediumMetadata& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, MediumMetadata_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MediumMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.available_channels_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.available_channels_)
                : nullptr;
  _impl_.wifi_direct_cli_usable_channels_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_direct_cli_usable_channels_)
                : nullptr;
  _impl_.wifi_lan_usable_channels_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_lan_usable_channels_)
                : nullptr;
  _impl_.wifi_aware_usable_channels_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_aware_usable_channels_)
                : nullptr;
  _impl_.wifi_hotspot_sta_usable_channels_ = (CheckHasBit(cached_has_bits, 0x00000080U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_hotspot_sta_usable_channels_)
                : nullptr;
  _impl_.medium_role_ = (CheckHasBit(cached_has_bits, 0x00000100U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.medium_role_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, supports_5_ghz_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, supports_5_ghz_),
           offsetof(Impl_, ap_frequency_) -
               offsetof(Impl_, supports_5_ghz_) +
               sizeof(Impl_::ap_frequency_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.MediumMetadata)
}
PROTOBUF_NDEBUG_INLINE MediumMetadata::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        supported_wifi_direct_auth_types_{visibility, arena},
        _supported_wifi_direct_auth_types_cached_byte_size_{0},
        bssid_(arena),
        ip_address_(arena),
        ap_frequency_{-1} {}

inline void MediumMetadata::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, available_channels_),
           0,
           offsetof(Impl_, mobile_radio_) -
               offsetof(Impl_, available_channels_) +
               sizeof(Impl_::mobile_radio_));
}
MediumMetadata::~MediumMetadata() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.MediumMetadata)
  SharedDtor(*this);
}
inline void MediumMetadata::SharedDtor(MessageLite& self) {
  MediumMetadata& this_ = static_cast<MediumMetadata&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.bssid_.Destroy();
  this_._impl_.ip_address_.Destroy();
  delete this_._impl_.available_channels_;
  delete this_._impl_.wifi_direct_cli_usable_channels_;
  delete this_._impl_.wifi_lan_usable_channels_;
  delete this_._impl_.wifi_aware_usable_channels_;
  delete this_._impl_.wifi_hotspot_sta_usable_channels_;
  delete this_._impl_.medium_role_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MediumMetadata::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MediumMetadata(arena);
}
constexpr auto MediumMetadata::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.supported_wifi_direct_auth_types_) +
          decltype(MediumMetadata::_impl_.supported_wifi_direct_auth_types_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(MediumMetadata), alignof(MediumMetadata), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MediumMetadata::PlacementNew_,
                                 sizeof(MediumMetadata),
                                 alignof(MediumMetadata));
  }
}
constexpr auto MediumMetadata::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<43>{
      {
          &_MediumMetadata_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MediumMetadata::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<MediumMetadata>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MediumMetadata::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<MediumMetadata>(), &MediumMetadata::ByteSizeLong,
              &MediumMetadata::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.MediumMetadata",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<43> MediumMetadata_class_data_ =
    MediumMetadata::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MediumMetadata::GetClassData() const {
  return MediumMetadata_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 7, 0, 2>
MediumMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MediumMetadata_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::MediumMetadata>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool supports_5_ghz = 1;
    {::_pbi::TcParser::FastV8S1,
     {8, 9, 0,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.supports_5_ghz_)}},
    // optional string bssid = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.bssid_)}},
    // optional bytes ip_address = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.ip_address_)}},
    // optional bool supports_6_ghz = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 10, 0,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.supports_6_ghz_)}},
    // optional bool mobile_radio = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 11, 0,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.mobile_radio_)}},
    // optional int32 ap_frequency = 6 [default = -1];
    {::_pbi::TcParser::FastV32S1,
     {48, 12, 0,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.ap_frequency_)}},
    // optional .location.nearby.connections.AvailableChannels available_channels = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 3, 0,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.available_channels_)}},
    // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
    {::_pbi::TcParser::FastMtS1,
     {66, 4, 1,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_direct_cli_usable_channels_)}},
    // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 5, 2,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_lan_usable_channels_)}},
    // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 6, 3,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_aware_usable_channels_)}},
    // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
    {::_pbi::TcParser::FastMtS1,
     {90, 7, 4,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_hotspot_sta_usable_channels_)}},
    // optional .location.nearby.connections.MediumRole medium_role = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 8, 5,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.medium_role_)}},
    // repeated .location.nearby.connections.MediumMetadata.WifiDirectAuthType supported_wifi_direct_auth_types = 13 [packed = true];
    {::_pbi::TcParser::FastEr0P1,
     {106, 0, 2,
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.supported_wifi_direct_auth_types_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool supports_5_ghz = 1;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.supports_5_ghz_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string bssid = 2;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.bssid_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes ip_address = 3;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.ip_address_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool supports_6_ghz = 4;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.supports_6_ghz_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool mobile_radio = 5;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.mobile_radio_), _Internal::kHasBitsOffset + 11, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 ap_frequency = 6 [default = -1];
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.ap_frequency_), _Internal::kHasBitsOffset + 12, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional .location.nearby.connections.AvailableChannels available_channels = 7;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.available_channels_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_direct_cli_usable_channels_), _Internal::kHasBitsOffset + 4, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_lan_usable_channels_), _Internal::kHasBitsOffset + 5, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_aware_usable_channels_), _Internal::kHasBitsOffset + 6, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.wifi_hotspot_sta_usable_channels_), _Internal::kHasBitsOffset + 7, 4, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .location.nearby.connections.MediumRole medium_role = 12;
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.medium_role_), _Internal::kHasBitsOffset + 8, 5, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .location.nearby.connections.MediumMetadata.WifiDirectAuthType supported_wifi_direct_auth_types = 13 [packed = true];
    {PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.supported_wifi_direct_auth_types_), _Internal::kHasBitsOffset + 0, 6, (0 | ::_fl::kFcRepeated | ::_fl::kPackedEnumRange)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::location::nearby::connections::AvailableChannels>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::WifiDirectCliUsableChannels>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::WifiLanUsableChannels>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::WifiAwareUsableChannels>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::WifiHotspotStaUsableChannels>()},
      {::_pbi::TcParser::GetTable<::location::nearby::connections::MediumRole>()},
      {0, 2},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void MediumMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.MediumMetadata)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.supported_wifi_direct_auth_types_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.bssid_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.ip_address_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.available_channels_ != nullptr);
      _impl_.available_channels_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.wifi_direct_cli_usable_channels_ != nullptr);
      _impl_.wifi_direct_cli_usable_channels_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.wifi_lan_usable_channels_ != nullptr);
      _impl_.wifi_lan_usable_channels_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.wifi_aware_usable_channels_ != nullptr);
      _impl_.wifi_aware_usable_channels_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(_impl_.wifi_hotspot_sta_usable_channels_ != nullptr);
      _impl_.wifi_hotspot_sta_usable_channels_->Clear();
    }
  }
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    ABSL_DCHECK(_impl_.medium_role_ != nullptr);
    _impl_.medium_role_->Clear();
  }
  ::memset(&_impl_.supports_5_ghz_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.mobile_radio_) -
      reinterpret_cast<char*>(&_impl_.supports_5_ghz_)) + sizeof(_impl_.mobile_radio_));
  _impl_.ap_frequency_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MediumMetadata::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MediumMetadata& this_ = static_cast<const MediumMetadata&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MediumMetadata::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MediumMetadata& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.MediumMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool supports_5_ghz = 1;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_supports_5_ghz(), target);
  }

  // optional string bssid = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_bssid();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional bytes ip_address = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_ip_address();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional bool supports_6_ghz = 4;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_supports_6_ghz(), target);
  }

  // optional bool mobile_radio = 5;
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_mobile_radio(), target);
  }

  // optional int32 ap_frequency = 6 [default = -1];
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<6>(
            stream, this_._internal_ap_frequency(), target);
  }

  // optional .location.nearby.connections.AvailableChannels available_channels = 7;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, *this_._impl_.available_channels_, this_._impl_.available_channels_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, *this_._impl_.wifi_direct_cli_usable_channels_, this_._impl_.wifi_direct_cli_usable_channels_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, *this_._impl_.wifi_lan_usable_channels_, this_._impl_.wifi_lan_usable_channels_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        10, *this_._impl_.wifi_aware_usable_channels_, this_._impl_.wifi_aware_usable_channels_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        11, *this_._impl_.wifi_hotspot_sta_usable_channels_, this_._impl_.wifi_hotspot_sta_usable_channels_->GetCachedSize(), target,
        stream);
  }

  // optional .location.nearby.connections.MediumRole medium_role = 12;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        12, *this_._impl_.medium_role_, this_._impl_.medium_role_->GetCachedSize(), target,
        stream);
  }

  // repeated .location.nearby.connections.MediumMetadata.WifiDirectAuthType supported_wifi_direct_auth_types = 13 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      ::size_t byte_size = this_._impl_._supported_wifi_direct_auth_types_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteEnumPacked(
            13, this_._internal_supported_wifi_direct_auth_types(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.MediumMetadata)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MediumMetadata::ByteSizeLong(const MessageLite& base) {
  const MediumMetadata& this_ = static_cast<const MediumMetadata&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MediumMetadata::ByteSizeLong() const {
  const MediumMetadata& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.MediumMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000e00U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated .location.nearby.connections.MediumMetadata.WifiDirectAuthType supported_wifi_direct_auth_types = 13 [packed = true];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_supported_wifi_direct_auth_types(), 1, this_._impl_._supported_wifi_direct_auth_types_cached_byte_size_);
    }
    // optional string bssid = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_bssid());
    }
    // optional bytes ip_address = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_ip_address());
    }
    // optional .location.nearby.connections.AvailableChannels available_channels = 7;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.available_channels_);
    }
    // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_direct_cli_usable_channels_);
    }
    // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_lan_usable_channels_);
    }
    // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_aware_usable_channels_);
    }
    // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.wifi_hotspot_sta_usable_channels_);
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00001100U)) {
    // optional .location.nearby.connections.MediumRole medium_role = 12;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.medium_role_);
    }
    // optional int32 ap_frequency = 6 [default = -1];
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_ap_frequency());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void MediumMetadata::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MediumMetadata*>(&to_msg);
  auto& from = static_cast<const MediumMetadata&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.MediumMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_supported_wifi_direct_auth_types()->MergeFrom(from._internal_supported_wifi_direct_auth_types());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_bssid(from._internal_bssid());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_ip_address(from._internal_ip_address());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.available_channels_ != nullptr);
      if (_this->_impl_.available_channels_ == nullptr) {
        _this->_impl_.available_channels_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.available_channels_);
      } else {
        _this->_impl_.available_channels_->MergeFrom(*from._impl_.available_channels_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.wifi_direct_cli_usable_channels_ != nullptr);
      if (_this->_impl_.wifi_direct_cli_usable_channels_ == nullptr) {
        _this->_impl_.wifi_direct_cli_usable_channels_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_direct_cli_usable_channels_);
      } else {
        _this->_impl_.wifi_direct_cli_usable_channels_->MergeFrom(*from._impl_.wifi_direct_cli_usable_channels_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.wifi_lan_usable_channels_ != nullptr);
      if (_this->_impl_.wifi_lan_usable_channels_ == nullptr) {
        _this->_impl_.wifi_lan_usable_channels_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_lan_usable_channels_);
      } else {
        _this->_impl_.wifi_lan_usable_channels_->MergeFrom(*from._impl_.wifi_lan_usable_channels_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.wifi_aware_usable_channels_ != nullptr);
      if (_this->_impl_.wifi_aware_usable_channels_ == nullptr) {
        _this->_impl_.wifi_aware_usable_channels_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_aware_usable_channels_);
      } else {
        _this->_impl_.wifi_aware_usable_channels_->MergeFrom(*from._impl_.wifi_aware_usable_channels_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(from._impl_.wifi_hotspot_sta_usable_channels_ != nullptr);
      if (_this->_impl_.wifi_hotspot_sta_usable_channels_ == nullptr) {
        _this->_impl_.wifi_hotspot_sta_usable_channels_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.wifi_hotspot_sta_usable_channels_);
      } else {
        _this->_impl_.wifi_hotspot_sta_usable_channels_->MergeFrom(*from._impl_.wifi_hotspot_sta_usable_channels_);
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00001f00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      ABSL_DCHECK(from._impl_.medium_role_ != nullptr);
      if (_this->_impl_.medium_role_ == nullptr) {
        _this->_impl_.medium_role_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.medium_role_);
      } else {
        _this->_impl_.medium_role_->MergeFrom(*from._impl_.medium_role_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.supports_5_ghz_ = from._impl_.supports_5_ghz_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.supports_6_ghz_ = from._impl_.supports_6_ghz_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _this->_impl_.mobile_radio_ = from._impl_.mobile_radio_;
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_impl_.ap_frequency_ = from._impl_.ap_frequency_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void MediumMetadata::CopyFrom(const MediumMetadata& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.MediumMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MediumMetadata::InternalSwap(MediumMetadata* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.supported_wifi_direct_auth_types_.InternalSwap(&other->_impl_.supported_wifi_direct_auth_types_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.bssid_, &other->_impl_.bssid_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ip_address_, &other->_impl_.ip_address_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.ap_frequency_)
      + sizeof(MediumMetadata::_impl_.ap_frequency_)
      - PROTOBUF_FIELD_OFFSET(MediumMetadata, _impl_.available_channels_)>(
          reinterpret_cast<char*>(&_impl_.available_channels_),
          reinterpret_cast<char*>(&other->_impl_.available_channels_));
}

// ===================================================================

class AvailableChannels::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AvailableChannels>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AvailableChannels, _impl_._has_bits_);
};

AvailableChannels::AvailableChannels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AvailableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AvailableChannels)
}
PROTOBUF_NDEBUG_INLINE AvailableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::AvailableChannels& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        channels_{visibility, arena, from.channels_},
        _channels_cached_byte_size_{0} {}

AvailableChannels::AvailableChannels(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AvailableChannels& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, AvailableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvailableChannels* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AvailableChannels)
}
PROTOBUF_NDEBUG_INLINE AvailableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        channels_{visibility, arena},
        _channels_cached_byte_size_{0} {}

inline void AvailableChannels::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AvailableChannels::~AvailableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AvailableChannels)
  SharedDtor(*this);
}
inline void AvailableChannels::SharedDtor(MessageLite& self) {
  AvailableChannels& this_ = static_cast<AvailableChannels&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AvailableChannels::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AvailableChannels(arena);
}
constexpr auto AvailableChannels::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AvailableChannels, _impl_.channels_) +
          decltype(AvailableChannels::_impl_.channels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(AvailableChannels), alignof(AvailableChannels), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AvailableChannels::PlacementNew_,
                                 sizeof(AvailableChannels),
                                 alignof(AvailableChannels));
  }
}
constexpr auto AvailableChannels::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<46>{
      {
          &_AvailableChannels_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AvailableChannels::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<AvailableChannels>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AvailableChannels::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<AvailableChannels>(), &AvailableChannels::ByteSizeLong,
              &AvailableChannels::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AvailableChannels, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.AvailableChannels",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<46> AvailableChannels_class_data_ =
    AvailableChannels::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AvailableChannels::GetClassData() const {
  return AvailableChannels_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
AvailableChannels::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AvailableChannels, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    AvailableChannels_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::AvailableChannels>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 channels = 1 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(AvailableChannels, _impl_.channels_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 channels = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(AvailableChannels, _impl_.channels_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void AvailableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AvailableChannels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.channels_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AvailableChannels::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AvailableChannels& this_ = static_cast<const AvailableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AvailableChannels::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AvailableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AvailableChannels)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 channels = 1 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._channels_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_channels(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AvailableChannels)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AvailableChannels::ByteSizeLong(const MessageLite& base) {
  const AvailableChannels& this_ = static_cast<const AvailableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AvailableChannels::ByteSizeLong() const {
  const AvailableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AvailableChannels)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 channels = 1 [packed = true];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_channels(), 1,
              this_._impl_._channels_cached_byte_size_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AvailableChannels::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AvailableChannels*>(&to_msg);
  auto& from = static_cast<const AvailableChannels&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AvailableChannels)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_channels()->MergeFrom(from._internal_channels());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void AvailableChannels::CopyFrom(const AvailableChannels& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AvailableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvailableChannels::InternalSwap(AvailableChannels* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.channels_.InternalSwap(&other->_impl_.channels_);
}

// ===================================================================

class WifiDirectCliUsableChannels::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<WifiDirectCliUsableChannels>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(WifiDirectCliUsableChannels, _impl_._has_bits_);
};

WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiDirectCliUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiDirectCliUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiDirectCliUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::WifiDirectCliUsableChannels& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        channels_{visibility, arena, from.channels_},
        _channels_cached_byte_size_{0} {}

WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const WifiDirectCliUsableChannels& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiDirectCliUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  WifiDirectCliUsableChannels* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiDirectCliUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiDirectCliUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        channels_{visibility, arena},
        _channels_cached_byte_size_{0} {}

inline void WifiDirectCliUsableChannels::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
WifiDirectCliUsableChannels::~WifiDirectCliUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiDirectCliUsableChannels)
  SharedDtor(*this);
}
inline void WifiDirectCliUsableChannels::SharedDtor(MessageLite& self) {
  WifiDirectCliUsableChannels& this_ = static_cast<WifiDirectCliUsableChannels&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL WifiDirectCliUsableChannels::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) WifiDirectCliUsableChannels(arena);
}
constexpr auto WifiDirectCliUsableChannels::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(WifiDirectCliUsableChannels, _impl_.channels_) +
          decltype(WifiDirectCliUsableChannels::_impl_.channels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(WifiDirectCliUsableChannels), alignof(WifiDirectCliUsableChannels), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&WifiDirectCliUsableChannels::PlacementNew_,
                                 sizeof(WifiDirectCliUsableChannels),
                                 alignof(WifiDirectCliUsableChannels));
  }
}
constexpr auto WifiDirectCliUsableChannels::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<56>{
      {
          &_WifiDirectCliUsableChannels_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &WifiDirectCliUsableChannels::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<WifiDirectCliUsableChannels>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &WifiDirectCliUsableChannels::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<WifiDirectCliUsableChannels>(), &WifiDirectCliUsableChannels::ByteSizeLong,
              &WifiDirectCliUsableChannels::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(WifiDirectCliUsableChannels, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.WifiDirectCliUsableChannels",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<56> WifiDirectCliUsableChannels_class_data_ =
    WifiDirectCliUsableChannels::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
WifiDirectCliUsableChannels::GetClassData() const {
  return WifiDirectCliUsableChannels_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
WifiDirectCliUsableChannels::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WifiDirectCliUsableChannels, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    WifiDirectCliUsableChannels_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::WifiDirectCliUsableChannels>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 channels = 1 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(WifiDirectCliUsableChannels, _impl_.channels_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 channels = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(WifiDirectCliUsableChannels, _impl_.channels_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void WifiDirectCliUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiDirectCliUsableChannels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.channels_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL WifiDirectCliUsableChannels::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const WifiDirectCliUsableChannels& this_ = static_cast<const WifiDirectCliUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL WifiDirectCliUsableChannels::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const WifiDirectCliUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiDirectCliUsableChannels)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 channels = 1 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._channels_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_channels(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiDirectCliUsableChannels)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t WifiDirectCliUsableChannels::ByteSizeLong(const MessageLite& base) {
  const WifiDirectCliUsableChannels& this_ = static_cast<const WifiDirectCliUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t WifiDirectCliUsableChannels::ByteSizeLong() const {
  const WifiDirectCliUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiDirectCliUsableChannels)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 channels = 1 [packed = true];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_channels(), 1,
              this_._impl_._channels_cached_byte_size_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void WifiDirectCliUsableChannels::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<WifiDirectCliUsableChannels*>(&to_msg);
  auto& from = static_cast<const WifiDirectCliUsableChannels&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiDirectCliUsableChannels)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_channels()->MergeFrom(from._internal_channels());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void WifiDirectCliUsableChannels::CopyFrom(const WifiDirectCliUsableChannels& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiDirectCliUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void WifiDirectCliUsableChannels::InternalSwap(WifiDirectCliUsableChannels* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.channels_.InternalSwap(&other->_impl_.channels_);
}

// ===================================================================

class WifiLanUsableChannels::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<WifiLanUsableChannels>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(WifiLanUsableChannels, _impl_._has_bits_);
};

WifiLanUsableChannels::WifiLanUsableChannels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiLanUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiLanUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiLanUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::WifiLanUsableChannels& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        channels_{visibility, arena, from.channels_},
        _channels_cached_byte_size_{0} {}

WifiLanUsableChannels::WifiLanUsableChannels(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const WifiLanUsableChannels& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiLanUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  WifiLanUsableChannels* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiLanUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiLanUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        channels_{visibility, arena},
        _channels_cached_byte_size_{0} {}

inline void WifiLanUsableChannels::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
WifiLanUsableChannels::~WifiLanUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiLanUsableChannels)
  SharedDtor(*this);
}
inline void WifiLanUsableChannels::SharedDtor(MessageLite& self) {
  WifiLanUsableChannels& this_ = static_cast<WifiLanUsableChannels&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL WifiLanUsableChannels::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) WifiLanUsableChannels(arena);
}
constexpr auto WifiLanUsableChannels::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(WifiLanUsableChannels, _impl_.channels_) +
          decltype(WifiLanUsableChannels::_impl_.channels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(WifiLanUsableChannels), alignof(WifiLanUsableChannels), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&WifiLanUsableChannels::PlacementNew_,
                                 sizeof(WifiLanUsableChannels),
                                 alignof(WifiLanUsableChannels));
  }
}
constexpr auto WifiLanUsableChannels::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<50>{
      {
          &_WifiLanUsableChannels_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &WifiLanUsableChannels::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<WifiLanUsableChannels>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &WifiLanUsableChannels::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<WifiLanUsableChannels>(), &WifiLanUsableChannels::ByteSizeLong,
              &WifiLanUsableChannels::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(WifiLanUsableChannels, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.WifiLanUsableChannels",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<50> WifiLanUsableChannels_class_data_ =
    WifiLanUsableChannels::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
WifiLanUsableChannels::GetClassData() const {
  return WifiLanUsableChannels_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
WifiLanUsableChannels::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WifiLanUsableChannels, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    WifiLanUsableChannels_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::WifiLanUsableChannels>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 channels = 1 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(WifiLanUsableChannels, _impl_.channels_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 channels = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(WifiLanUsableChannels, _impl_.channels_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void WifiLanUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiLanUsableChannels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.channels_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL WifiLanUsableChannels::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const WifiLanUsableChannels& this_ = static_cast<const WifiLanUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL WifiLanUsableChannels::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const WifiLanUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiLanUsableChannels)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 channels = 1 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._channels_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_channels(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiLanUsableChannels)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t WifiLanUsableChannels::ByteSizeLong(const MessageLite& base) {
  const WifiLanUsableChannels& this_ = static_cast<const WifiLanUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t WifiLanUsableChannels::ByteSizeLong() const {
  const WifiLanUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiLanUsableChannels)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 channels = 1 [packed = true];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_channels(), 1,
              this_._impl_._channels_cached_byte_size_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void WifiLanUsableChannels::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<WifiLanUsableChannels*>(&to_msg);
  auto& from = static_cast<const WifiLanUsableChannels&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiLanUsableChannels)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_channels()->MergeFrom(from._internal_channels());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void WifiLanUsableChannels::CopyFrom(const WifiLanUsableChannels& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiLanUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void WifiLanUsableChannels::InternalSwap(WifiLanUsableChannels* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.channels_.InternalSwap(&other->_impl_.channels_);
}

// ===================================================================

class WifiAwareUsableChannels::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<WifiAwareUsableChannels>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(WifiAwareUsableChannels, _impl_._has_bits_);
};

WifiAwareUsableChannels::WifiAwareUsableChannels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiAwareUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiAwareUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiAwareUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::WifiAwareUsableChannels& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        channels_{visibility, arena, from.channels_},
        _channels_cached_byte_size_{0} {}

WifiAwareUsableChannels::WifiAwareUsableChannels(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const WifiAwareUsableChannels& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiAwareUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  WifiAwareUsableChannels* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiAwareUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiAwareUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        channels_{visibility, arena},
        _channels_cached_byte_size_{0} {}

inline void WifiAwareUsableChannels::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
WifiAwareUsableChannels::~WifiAwareUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiAwareUsableChannels)
  SharedDtor(*this);
}
inline void WifiAwareUsableChannels::SharedDtor(MessageLite& self) {
  WifiAwareUsableChannels& this_ = static_cast<WifiAwareUsableChannels&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL WifiAwareUsableChannels::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) WifiAwareUsableChannels(arena);
}
constexpr auto WifiAwareUsableChannels::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(WifiAwareUsableChannels, _impl_.channels_) +
          decltype(WifiAwareUsableChannels::_impl_.channels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(WifiAwareUsableChannels), alignof(WifiAwareUsableChannels), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&WifiAwareUsableChannels::PlacementNew_,
                                 sizeof(WifiAwareUsableChannels),
                                 alignof(WifiAwareUsableChannels));
  }
}
constexpr auto WifiAwareUsableChannels::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<52>{
      {
          &_WifiAwareUsableChannels_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &WifiAwareUsableChannels::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<WifiAwareUsableChannels>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &WifiAwareUsableChannels::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<WifiAwareUsableChannels>(), &WifiAwareUsableChannels::ByteSizeLong,
              &WifiAwareUsableChannels::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(WifiAwareUsableChannels, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.WifiAwareUsableChannels",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<52> WifiAwareUsableChannels_class_data_ =
    WifiAwareUsableChannels::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
WifiAwareUsableChannels::GetClassData() const {
  return WifiAwareUsableChannels_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
WifiAwareUsableChannels::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WifiAwareUsableChannels, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    WifiAwareUsableChannels_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::WifiAwareUsableChannels>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 channels = 1 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(WifiAwareUsableChannels, _impl_.channels_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 channels = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(WifiAwareUsableChannels, _impl_.channels_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void WifiAwareUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiAwareUsableChannels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.channels_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL WifiAwareUsableChannels::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const WifiAwareUsableChannels& this_ = static_cast<const WifiAwareUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL WifiAwareUsableChannels::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const WifiAwareUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiAwareUsableChannels)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 channels = 1 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._channels_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_channels(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiAwareUsableChannels)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t WifiAwareUsableChannels::ByteSizeLong(const MessageLite& base) {
  const WifiAwareUsableChannels& this_ = static_cast<const WifiAwareUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t WifiAwareUsableChannels::ByteSizeLong() const {
  const WifiAwareUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiAwareUsableChannels)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 channels = 1 [packed = true];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_channels(), 1,
              this_._impl_._channels_cached_byte_size_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void WifiAwareUsableChannels::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<WifiAwareUsableChannels*>(&to_msg);
  auto& from = static_cast<const WifiAwareUsableChannels&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiAwareUsableChannels)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_channels()->MergeFrom(from._internal_channels());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void WifiAwareUsableChannels::CopyFrom(const WifiAwareUsableChannels& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiAwareUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void WifiAwareUsableChannels::InternalSwap(WifiAwareUsableChannels* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.channels_.InternalSwap(&other->_impl_.channels_);
}

// ===================================================================

class WifiHotspotStaUsableChannels::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<WifiHotspotStaUsableChannels>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(WifiHotspotStaUsableChannels, _impl_._has_bits_);
};

WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiHotspotStaUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiHotspotStaUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiHotspotStaUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::WifiHotspotStaUsableChannels& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        channels_{visibility, arena, from.channels_},
        _channels_cached_byte_size_{0} {}

WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const WifiHotspotStaUsableChannels& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, WifiHotspotStaUsableChannels_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  WifiHotspotStaUsableChannels* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiHotspotStaUsableChannels)
}
PROTOBUF_NDEBUG_INLINE WifiHotspotStaUsableChannels::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        channels_{visibility, arena},
        _channels_cached_byte_size_{0} {}

inline void WifiHotspotStaUsableChannels::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
WifiHotspotStaUsableChannels::~WifiHotspotStaUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiHotspotStaUsableChannels)
  SharedDtor(*this);
}
inline void WifiHotspotStaUsableChannels::SharedDtor(MessageLite& self) {
  WifiHotspotStaUsableChannels& this_ = static_cast<WifiHotspotStaUsableChannels&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL WifiHotspotStaUsableChannels::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) WifiHotspotStaUsableChannels(arena);
}
constexpr auto WifiHotspotStaUsableChannels::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(WifiHotspotStaUsableChannels, _impl_.channels_) +
          decltype(WifiHotspotStaUsableChannels::_impl_.channels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(WifiHotspotStaUsableChannels), alignof(WifiHotspotStaUsableChannels), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&WifiHotspotStaUsableChannels::PlacementNew_,
                                 sizeof(WifiHotspotStaUsableChannels),
                                 alignof(WifiHotspotStaUsableChannels));
  }
}
constexpr auto WifiHotspotStaUsableChannels::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<57>{
      {
          &_WifiHotspotStaUsableChannels_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &WifiHotspotStaUsableChannels::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<WifiHotspotStaUsableChannels>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &WifiHotspotStaUsableChannels::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<WifiHotspotStaUsableChannels>(), &WifiHotspotStaUsableChannels::ByteSizeLong,
              &WifiHotspotStaUsableChannels::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(WifiHotspotStaUsableChannels, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.WifiHotspotStaUsableChannels",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<57> WifiHotspotStaUsableChannels_class_data_ =
    WifiHotspotStaUsableChannels::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
WifiHotspotStaUsableChannels::GetClassData() const {
  return WifiHotspotStaUsableChannels_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
WifiHotspotStaUsableChannels::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WifiHotspotStaUsableChannels, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    WifiHotspotStaUsableChannels_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::WifiHotspotStaUsableChannels>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 channels = 1 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(WifiHotspotStaUsableChannels, _impl_.channels_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 channels = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(WifiHotspotStaUsableChannels, _impl_.channels_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void WifiHotspotStaUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.channels_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL WifiHotspotStaUsableChannels::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const WifiHotspotStaUsableChannels& this_ = static_cast<const WifiHotspotStaUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL WifiHotspotStaUsableChannels::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const WifiHotspotStaUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 channels = 1 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._channels_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_channels(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiHotspotStaUsableChannels)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t WifiHotspotStaUsableChannels::ByteSizeLong(const MessageLite& base) {
  const WifiHotspotStaUsableChannels& this_ = static_cast<const WifiHotspotStaUsableChannels&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t WifiHotspotStaUsableChannels::ByteSizeLong() const {
  const WifiHotspotStaUsableChannels& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 channels = 1 [packed = true];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_channels(), 1,
              this_._impl_._channels_cached_byte_size_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void WifiHotspotStaUsableChannels::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<WifiHotspotStaUsableChannels*>(&to_msg);
  auto& from = static_cast<const WifiHotspotStaUsableChannels&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_channels()->MergeFrom(from._internal_channels());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void WifiHotspotStaUsableChannels::CopyFrom(const WifiHotspotStaUsableChannels& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void WifiHotspotStaUsableChannels::InternalSwap(WifiHotspotStaUsableChannels* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.channels_.InternalSwap(&other->_impl_.channels_);
}

// ===================================================================

class MediumRole::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MediumRole>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MediumRole, _impl_._has_bits_);
};

MediumRole::MediumRole(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, MediumRole_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.MediumRole)
}
MediumRole::MediumRole(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MediumRole& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, MediumRole_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE MediumRole::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void MediumRole::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, support_wifi_direct_group_owner_),
           0,
           offsetof(Impl_, support_awdl_subscriber_) -
               offsetof(Impl_, support_wifi_direct_group_owner_) +
               sizeof(Impl_::support_awdl_subscriber_));
}
MediumRole::~MediumRole() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.MediumRole)
  SharedDtor(*this);
}
inline void MediumRole::SharedDtor(MessageLite& self) {
  MediumRole& this_ = static_cast<MediumRole&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MediumRole::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MediumRole(arena);
}
constexpr auto MediumRole::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(MediumRole),
                                            alignof(MediumRole));
}
constexpr auto MediumRole::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<39>{
      {
          &_MediumRole_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MediumRole::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<MediumRole>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MediumRole::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<MediumRole>(), &MediumRole::ByteSizeLong,
              &MediumRole::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MediumRole, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.MediumRole",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<39> MediumRole_class_data_ =
    MediumRole::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MediumRole::GetClassData() const {
  return MediumRole_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
MediumRole::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MediumRole, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    MediumRole_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::MediumRole>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool support_awdl_subscriber = 8;
    {::_pbi::TcParser::FastV8S1,
     {64, 7, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_awdl_subscriber_)}},
    // optional bool support_wifi_direct_group_owner = 1;
    {::_pbi::TcParser::FastV8S1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_direct_group_owner_)}},
    // optional bool support_wifi_direct_group_client = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_direct_group_client_)}},
    // optional bool support_wifi_hotspot_host = 3;
    {::_pbi::TcParser::FastV8S1,
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_hotspot_host_)}},
    // optional bool support_wifi_hotspot_client = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_hotspot_client_)}},
    // optional bool support_wifi_aware_publisher = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_aware_publisher_)}},
    // optional bool support_wifi_aware_subscriber = 6;
    {::_pbi::TcParser::FastV8S1,
     {48, 5, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_aware_subscriber_)}},
    // optional bool support_awdl_publisher = 7;
    {::_pbi::TcParser::FastV8S1,
     {56, 6, 0,
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_awdl_publisher_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool support_wifi_direct_group_owner = 1;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_direct_group_owner_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool support_wifi_direct_group_client = 2;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_direct_group_client_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool support_wifi_hotspot_host = 3;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_hotspot_host_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool support_wifi_hotspot_client = 4;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_hotspot_client_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool support_wifi_aware_publisher = 5;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_aware_publisher_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool support_wifi_aware_subscriber = 6;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_aware_subscriber_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool support_awdl_publisher = 7;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_awdl_publisher_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool support_awdl_subscriber = 8;
    {PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_awdl_subscriber_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void MediumRole::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.MediumRole)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    ::memset(&_impl_.support_wifi_direct_group_owner_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.support_awdl_subscriber_) -
        reinterpret_cast<char*>(&_impl_.support_wifi_direct_group_owner_)) + sizeof(_impl_.support_awdl_subscriber_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MediumRole::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MediumRole& this_ = static_cast<const MediumRole&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MediumRole::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MediumRole& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.MediumRole)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool support_wifi_direct_group_owner = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_support_wifi_direct_group_owner(), target);
  }

  // optional bool support_wifi_direct_group_client = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_support_wifi_direct_group_client(), target);
  }

  // optional bool support_wifi_hotspot_host = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_support_wifi_hotspot_host(), target);
  }

  // optional bool support_wifi_hotspot_client = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_support_wifi_hotspot_client(), target);
  }

  // optional bool support_wifi_aware_publisher = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_support_wifi_aware_publisher(), target);
  }

  // optional bool support_wifi_aware_subscriber = 6;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this_._internal_support_wifi_aware_subscriber(), target);
  }

  // optional bool support_awdl_publisher = 7;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this_._internal_support_awdl_publisher(), target);
  }

  // optional bool support_awdl_subscriber = 8;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_support_awdl_subscriber(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.MediumRole)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MediumRole::ByteSizeLong(const MessageLite& base) {
  const MediumRole& this_ = static_cast<const MediumRole&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MediumRole::ByteSizeLong() const {
  const MediumRole& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.MediumRole)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x000000ffU & cached_has_bits) * 2;
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void MediumRole::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MediumRole*>(&to_msg);
  auto& from = static_cast<const MediumRole&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.MediumRole)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.support_wifi_direct_group_owner_ = from._impl_.support_wifi_direct_group_owner_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.support_wifi_direct_group_client_ = from._impl_.support_wifi_direct_group_client_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.support_wifi_hotspot_host_ = from._impl_.support_wifi_hotspot_host_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.support_wifi_hotspot_client_ = from._impl_.support_wifi_hotspot_client_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.support_wifi_aware_publisher_ = from._impl_.support_wifi_aware_publisher_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.support_wifi_aware_subscriber_ = from._impl_.support_wifi_aware_subscriber_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.support_awdl_publisher_ = from._impl_.support_awdl_publisher_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.support_awdl_subscriber_ = from._impl_.support_awdl_subscriber_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void MediumRole::CopyFrom(const MediumRole& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.MediumRole)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MediumRole::InternalSwap(MediumRole* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_awdl_subscriber_)
      + sizeof(MediumRole::_impl_.support_awdl_subscriber_)
      - PROTOBUF_FIELD_OFFSET(MediumRole, _impl_.support_wifi_direct_group_owner_)>(
          reinterpret_cast<char*>(&_impl_.support_wifi_direct_group_owner_),
          reinterpret_cast<char*>(&other->_impl_.support_wifi_direct_group_owner_));
}

// ===================================================================

class LocationHint::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LocationHint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LocationHint, _impl_._has_bits_);
};

LocationHint::LocationHint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, LocationHint_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.LocationHint)
}
PROTOBUF_NDEBUG_INLINE LocationHint::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::LocationHint& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        location_(arena, from.location_) {}

LocationHint::LocationHint(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LocationHint& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, LocationHint_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LocationHint* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.format_ = from._impl_.format_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.LocationHint)
}
PROTOBUF_NDEBUG_INLINE LocationHint::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        location_(arena) {}

inline void LocationHint::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.format_ = {};
}
LocationHint::~LocationHint() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.LocationHint)
  SharedDtor(*this);
}
inline void LocationHint::SharedDtor(MessageLite& self) {
  LocationHint& this_ = static_cast<LocationHint&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.location_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LocationHint::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LocationHint(arena);
}
constexpr auto LocationHint::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(LocationHint),
                                            alignof(LocationHint));
}
constexpr auto LocationHint::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<41>{
      {
          &_LocationHint_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LocationHint::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<LocationHint>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LocationHint::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<LocationHint>(), &LocationHint::ByteSizeLong,
              &LocationHint::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LocationHint, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.LocationHint",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<41> LocationHint_class_data_ =
    LocationHint::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LocationHint::GetClassData() const {
  return LocationHint_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
LocationHint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LocationHint, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    LocationHint_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::LocationHint>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .location.nearby.connections.LocationStandard.Format format = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 1, 2,
      PROTOBUF_FIELD_OFFSET(LocationHint, _impl_.format_)}},
    // optional string location = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(LocationHint, _impl_.location_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string location = 1;
    {PROTOBUF_FIELD_OFFSET(LocationHint, _impl_.location_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.LocationStandard.Format format = 2;
    {PROTOBUF_FIELD_OFFSET(LocationHint, _impl_.format_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }},
  {{
      {0, 2},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void LocationHint::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.LocationHint)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.location_.ClearNonDefaultToEmpty();
  }
  _impl_.format_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LocationHint::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LocationHint& this_ = static_cast<const LocationHint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LocationHint::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LocationHint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.LocationHint)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string location = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_location();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .location.nearby.connections.LocationStandard.Format format = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this_._internal_format(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.LocationHint)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LocationHint::ByteSizeLong(const MessageLite& base) {
  const LocationHint& this_ = static_cast<const LocationHint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LocationHint::ByteSizeLong() const {
  const LocationHint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.LocationHint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional string location = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_location());
    }
    // optional .location.nearby.connections.LocationStandard.Format format = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_format());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void LocationHint::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LocationHint*>(&to_msg);
  auto& from = static_cast<const LocationHint&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.LocationHint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_location(from._internal_location());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.format_ = from._impl_.format_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void LocationHint::CopyFrom(const LocationHint& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.LocationHint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LocationHint::InternalSwap(LocationHint* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.location_, &other->_impl_.location_, arena);
  swap(_impl_.format_, other->_impl_.format_);
}

// ===================================================================

class LocationStandard::_Internal {
 public:
};

LocationStandard::LocationStandard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, LocationStandard_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.LocationStandard)
}
LocationStandard::LocationStandard(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LocationStandard& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, LocationStandard_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE LocationStandard::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void LocationStandard::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
LocationStandard::~LocationStandard() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.LocationStandard)
  SharedDtor(*this);
}
inline void LocationStandard::SharedDtor(MessageLite& self) {
  LocationStandard& this_ = static_cast<LocationStandard&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LocationStandard::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LocationStandard(arena);
}
constexpr auto LocationStandard::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LocationStandard),
                                            alignof(LocationStandard));
}
constexpr auto LocationStandard::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<45>{
      {
          &_LocationStandard_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LocationStandard::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<LocationStandard>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LocationStandard::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<LocationStandard>(), &LocationStandard::ByteSizeLong,
              &LocationStandard::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LocationStandard, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.LocationStandard",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<45> LocationStandard_class_data_ =
    LocationStandard::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LocationStandard::GetClassData() const {
  return LocationStandard_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 0, 0, 0, 2>
LocationStandard::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    0, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967295,  // skipmap
    offsetof(decltype(_table_), field_names),  // no field_entries
    0,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LocationStandard_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::LocationStandard>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, // no field_entries, or aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void LocationStandard::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.LocationStandard)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LocationStandard::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LocationStandard& this_ = static_cast<const LocationStandard&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LocationStandard::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LocationStandard& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.LocationStandard)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.LocationStandard)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LocationStandard::ByteSizeLong(const MessageLite& base) {
  const LocationStandard& this_ = static_cast<const LocationStandard&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LocationStandard::ByteSizeLong() const {
  const LocationStandard& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.LocationStandard)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void LocationStandard::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LocationStandard*>(&to_msg);
  auto& from = static_cast<const LocationStandard&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.LocationStandard)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void LocationStandard::CopyFrom(const LocationStandard& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.LocationStandard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LocationStandard::InternalSwap(LocationStandard* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

// ===================================================================

class OsInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<OsInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(OsInfo, _impl_._has_bits_);
};

OsInfo::OsInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, OsInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.OsInfo)
}
OsInfo::OsInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OsInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, OsInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE OsInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void OsInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.type_ = {};
}
OsInfo::~OsInfo() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.OsInfo)
  SharedDtor(*this);
}
inline void OsInfo::SharedDtor(MessageLite& self) {
  OsInfo& this_ = static_cast<OsInfo&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL OsInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) OsInfo(arena);
}
constexpr auto OsInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(OsInfo),
                                            alignof(OsInfo));
}
constexpr auto OsInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<35>{
      {
          &_OsInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &OsInfo::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<OsInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &OsInfo::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<OsInfo>(), &OsInfo::ByteSizeLong,
              &OsInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(OsInfo, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.OsInfo",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<35> OsInfo_class_data_ =
    OsInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
OsInfo::GetClassData() const {
  return OsInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
OsInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OsInfo, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    OsInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::OsInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .location.nearby.connections.OsInfo.OsType type = 1;
    {::_pbi::TcParser::FastEvS1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(OsInfo, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .location.nearby.connections.OsInfo.OsType type = 1;
    {PROTOBUF_FIELD_OFFSET(OsInfo, _impl_.type_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnum)},
  }},
  {{
      {::_pbi::FieldAuxEnumData{}, ::location::nearby::connections::OsInfo_OsType_internal_data_},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void OsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.OsInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL OsInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const OsInfo& this_ = static_cast<const OsInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL OsInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const OsInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.OsInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .location.nearby.connections.OsInfo.OsType type = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_type(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.OsInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t OsInfo::ByteSizeLong(const MessageLite& base) {
  const OsInfo& this_ = static_cast<const OsInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t OsInfo::ByteSizeLong() const {
  const OsInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.OsInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional .location.nearby.connections.OsInfo.OsType type = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void OsInfo::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<OsInfo*>(&to_msg);
  auto& from = static_cast<const OsInfo&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.OsInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void OsInfo::CopyFrom(const OsInfo& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.OsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void OsInfo::InternalSwap(OsInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

// ===================================================================

class ConnectionsDevice::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ConnectionsDevice>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_._has_bits_);
};

ConnectionsDevice::ConnectionsDevice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConnectionsDevice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionsDevice)
}
PROTOBUF_NDEBUG_INLINE ConnectionsDevice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::ConnectionsDevice& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        endpoint_id_(arena, from.endpoint_id_),
        connectivity_info_list_(arena, from.connectivity_info_list_),
        endpoint_info_(arena, from.endpoint_info_) {}

ConnectionsDevice::ConnectionsDevice(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ConnectionsDevice& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConnectionsDevice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ConnectionsDevice* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.endpoint_type_ = from._impl_.endpoint_type_;

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionsDevice)
}
PROTOBUF_NDEBUG_INLINE ConnectionsDevice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        endpoint_id_(arena),
        connectivity_info_list_(arena),
        endpoint_info_(arena) {}

inline void ConnectionsDevice::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.endpoint_type_ = {};
}
ConnectionsDevice::~ConnectionsDevice() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionsDevice)
  SharedDtor(*this);
}
inline void ConnectionsDevice::SharedDtor(MessageLite& self) {
  ConnectionsDevice& this_ = static_cast<ConnectionsDevice&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.endpoint_id_.Destroy();
  this_._impl_.connectivity_info_list_.Destroy();
  this_._impl_.endpoint_info_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ConnectionsDevice::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ConnectionsDevice(arena);
}
constexpr auto ConnectionsDevice::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ConnectionsDevice),
                                            alignof(ConnectionsDevice));
}
constexpr auto ConnectionsDevice::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<46>{
      {
          &_ConnectionsDevice_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ConnectionsDevice::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<ConnectionsDevice>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ConnectionsDevice::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<ConnectionsDevice>(), &ConnectionsDevice::ByteSizeLong,
              &ConnectionsDevice::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.ConnectionsDevice",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<46> ConnectionsDevice_class_data_ =
    ConnectionsDevice::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ConnectionsDevice::GetClassData() const {
  return ConnectionsDevice_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2>
ConnectionsDevice::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ConnectionsDevice_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::ConnectionsDevice>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bytes endpoint_info = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 2, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.endpoint_info_)}},
    // optional string endpoint_id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.endpoint_id_)}},
    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 3, 2,
      PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.endpoint_type_)}},
    // optional bytes connectivity_info_list = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.connectivity_info_list_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string endpoint_id = 1;
    {PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.endpoint_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    {PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.endpoint_type_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bytes connectivity_info_list = 3;
    {PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.connectivity_info_list_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes endpoint_info = 4;
    {PROTOBUF_FIELD_OFFSET(ConnectionsDevice, _impl_.endpoint_info_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  {{
      {0, 2},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ConnectionsDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionsDevice)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.connectivity_info_list_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.endpoint_info_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.endpoint_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ConnectionsDevice::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ConnectionsDevice& this_ = static_cast<const ConnectionsDevice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ConnectionsDevice::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ConnectionsDevice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionsDevice)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string endpoint_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_endpoint_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this_._internal_endpoint_type(), target);
  }

  // optional bytes connectivity_info_list = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_connectivity_info_list();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional bytes endpoint_info = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_endpoint_info();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionsDevice)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ConnectionsDevice::ByteSizeLong(const MessageLite& base) {
  const ConnectionsDevice& this_ = static_cast<const ConnectionsDevice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ConnectionsDevice::ByteSizeLong() const {
  const ConnectionsDevice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionsDevice)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional string endpoint_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_endpoint_id());
    }
    // optional bytes connectivity_info_list = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_connectivity_info_list());
    }
    // optional bytes endpoint_info = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_endpoint_info());
    }
    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_endpoint_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void ConnectionsDevice::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ConnectionsDevice*>(&to_msg);
  auto& from = static_cast<const ConnectionsDevice&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionsDevice)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_connectivity_info_list(from._internal_connectivity_info_list());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_endpoint_info(from._internal_endpoint_info());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.endpoint_type_ = from._impl_.endpoint_type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void ConnectionsDevice::CopyFrom(const ConnectionsDevice& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionsDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ConnectionsDevice::InternalSwap(ConnectionsDevice* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_id_, &other->_impl_.endpoint_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connectivity_info_list_, &other->_impl_.connectivity_info_list_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_info_, &other->_impl_.endpoint_info_, arena);
  swap(_impl_.endpoint_type_, other->_impl_.endpoint_type_);
}

// ===================================================================

class PresenceDevice::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PresenceDevice>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_._has_bits_);
};

PresenceDevice::PresenceDevice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PresenceDevice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PresenceDevice)
}
PROTOBUF_NDEBUG_INLINE PresenceDevice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::location::nearby::connections::PresenceDevice& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        discovery_medium_{visibility, arena, from.discovery_medium_},
        _discovery_medium_cached_byte_size_{0},
        actions_{visibility, arena, from.actions_},
        _actions_cached_byte_size_{0},
        identity_type_{visibility, arena, from.identity_type_},
        _identity_type_cached_byte_size_{0},
        endpoint_id_(arena, from.endpoint_id_),
        connectivity_info_list_(arena, from.connectivity_info_list_),
        device_name_(arena, from.device_name_),
        device_image_url_(arena, from.device_image_url_) {}

PresenceDevice::PresenceDevice(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PresenceDevice& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PresenceDevice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PresenceDevice* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, device_id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, device_id_),
           offsetof(Impl_, device_type_) -
               offsetof(Impl_, device_id_) +
               sizeof(Impl_::device_type_));

  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PresenceDevice)
}
PROTOBUF_NDEBUG_INLINE PresenceDevice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        discovery_medium_{visibility, arena},
        _discovery_medium_cached_byte_size_{0},
        actions_{visibility, arena},
        _actions_cached_byte_size_{0},
        identity_type_{visibility, arena},
        _identity_type_cached_byte_size_{0},
        endpoint_id_(arena),
        connectivity_info_list_(arena),
        device_name_(arena),
        device_image_url_(arena) {}

inline void PresenceDevice::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, device_id_),
           0,
           offsetof(Impl_, device_type_) -
               offsetof(Impl_, device_id_) +
               sizeof(Impl_::device_type_));
}
PresenceDevice::~PresenceDevice() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PresenceDevice)
  SharedDtor(*this);
}
inline void PresenceDevice::SharedDtor(MessageLite& self) {
  PresenceDevice& this_ = static_cast<PresenceDevice&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.endpoint_id_.Destroy();
  this_._impl_.connectivity_info_list_.Destroy();
  this_._impl_.device_name_.Destroy();
  this_._impl_.device_image_url_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PresenceDevice::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PresenceDevice(arena);
}
constexpr auto PresenceDevice::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.discovery_medium_) +
          decltype(PresenceDevice::_impl_.discovery_medium_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.actions_) +
          decltype(PresenceDevice::_impl_.actions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.identity_type_) +
          decltype(PresenceDevice::_impl_.identity_type_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(PresenceDevice), alignof(PresenceDevice), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PresenceDevice::PlacementNew_,
                                 sizeof(PresenceDevice),
                                 alignof(PresenceDevice));
  }
}
constexpr auto PresenceDevice::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<43>{
      {
          &_PresenceDevice_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PresenceDevice::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PresenceDevice>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PresenceDevice::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PresenceDevice>(), &PresenceDevice::ByteSizeLong,
              &PresenceDevice::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_._cached_size_),
          true,
      },
      "location.nearby.connections.PresenceDevice",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<43> PresenceDevice_class_data_ =
    PresenceDevice::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PresenceDevice::GetClassData() const {
  return PresenceDevice_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 3, 0, 2>
PresenceDevice::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PresenceDevice_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::location::nearby::connections::PresenceDevice>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string endpoint_id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 3, 0,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.endpoint_id_)}},
    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 8, 2,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.endpoint_type_)}},
    // optional bytes connectivity_info_list = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 4, 0,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.connectivity_info_list_)}},
    // optional int64 device_id = 4;
    {::_pbi::TcParser::FastV64S1,
     {32, 7, 0,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_id_)}},
    // optional string device_name = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 5, 0,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_name_)}},
    // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
    {::_pbi::TcParser::FastEr0S1,
     {48, 9, 6,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_type_)}},
    // optional string device_image_url = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 6, 0,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_image_url_)}},
    // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
    {::_pbi::TcParser::FastEr0P1,
     {66, 0, 13,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.discovery_medium_)}},
    // repeated int32 actions = 9 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {74, 1, 0,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.actions_)}},
    // repeated int64 identity_type = 10 [packed = true];
    {::_pbi::TcParser::FastV64P1,
     {82, 2, 0,
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.identity_type_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string endpoint_id = 1;
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.endpoint_id_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.endpoint_type_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bytes connectivity_info_list = 3;
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.connectivity_info_list_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 device_id = 4;
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_id_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional string device_name = 5;
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_name_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_type_), _Internal::kHasBitsOffset + 9, 1, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string device_image_url = 7;
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_image_url_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.discovery_medium_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kPackedEnumRange)},
    // repeated int32 actions = 9 [packed = true];
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.actions_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int64 identity_type = 10 [packed = true];
    {PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.identity_type_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
  }},
  {{
      {0, 2},
      {0, 6},
      {0, 13},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PresenceDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PresenceDevice)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.discovery_medium_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.actions_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.identity_type_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.connectivity_info_list_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.device_name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _impl_.device_image_url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.device_id_ = ::int64_t{0};
  if (BatchCheckHasBit(cached_has_bits, 0x00000300U)) {
    ::memset(&_impl_.endpoint_type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.device_type_) -
        reinterpret_cast<char*>(&_impl_.endpoint_type_)) + sizeof(_impl_.device_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PresenceDevice::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PresenceDevice& this_ = static_cast<const PresenceDevice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PresenceDevice::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PresenceDevice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PresenceDevice)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string endpoint_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_endpoint_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this_._internal_endpoint_type(), target);
  }

  // optional bytes connectivity_info_list = 3;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    const ::std::string& _s = this_._internal_connectivity_info_list();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional int64 device_id = 4;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<4>(
            stream, this_._internal_device_id(), target);
  }

  // optional string device_name = 5;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    const ::std::string& _s = this_._internal_device_name();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this_._internal_device_type(), target);
  }

  // optional string device_image_url = 7;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    const ::std::string& _s = this_._internal_device_image_url();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      ::size_t byte_size = this_._impl_._discovery_medium_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteEnumPacked(
            8, this_._internal_discovery_medium(), byte_size, target);
      }
    }
  }

  // repeated int32 actions = 9 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._actions_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            9, this_._internal_actions(), byte_size, target);
      }
    }
  }

  // repeated int64 identity_type = 10 [packed = true];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    {
      int byte_size = this_._impl_._identity_type_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            10, this_._internal_identity_type(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PresenceDevice)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PresenceDevice::ByteSizeLong(const MessageLite& base) {
  const PresenceDevice& this_ = static_cast<const PresenceDevice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PresenceDevice::ByteSizeLong() const {
  const PresenceDevice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PresenceDevice)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_discovery_medium(), 1, this_._impl_._discovery_medium_cached_byte_size_);
    }
    // repeated int32 actions = 9 [packed = true];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_actions(), 1,
              this_._impl_._actions_cached_byte_size_);
    }
    // repeated int64 identity_type = 10 [packed = true];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_identity_type(), 1,
              this_._impl_._identity_type_cached_byte_size_);
    }
    // optional string endpoint_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_endpoint_id());
    }
    // optional bytes connectivity_info_list = 3;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_connectivity_info_list());
    }
    // optional string device_name = 5;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_name());
    }
    // optional string device_image_url = 7;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_image_url());
    }
    // optional int64 device_id = 4;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_device_id());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000300U)) {
    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_endpoint_type());
    }
    // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_device_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PresenceDevice::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PresenceDevice*>(&to_msg);
  auto& from = static_cast<const PresenceDevice&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PresenceDevice)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_discovery_medium()->MergeFrom(from._internal_discovery_medium());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_actions()->MergeFrom(from._internal_actions());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_identity_type()->MergeFrom(from._internal_identity_type());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_internal_set_connectivity_info_list(from._internal_connectivity_info_list());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_internal_set_device_name(from._internal_device_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_internal_set_device_image_url(from._internal_device_image_url());
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.device_id_ = from._impl_.device_id_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000300U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.endpoint_type_ = from._impl_.endpoint_type_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.device_type_ = from._impl_.device_type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PresenceDevice::CopyFrom(const PresenceDevice& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PresenceDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PresenceDevice::InternalSwap(PresenceDevice* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.discovery_medium_.InternalSwap(&other->_impl_.discovery_medium_);
  _impl_.actions_.InternalSwap(&other->_impl_.actions_);
  _impl_.identity_type_.InternalSwap(&other->_impl_.identity_type_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_id_, &other->_impl_.endpoint_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connectivity_info_list_, &other->_impl_.connectivity_info_list_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_name_, &other->_impl_.device_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_image_url_, &other->_impl_.device_image_url_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_type_)
      + sizeof(PresenceDevice::_impl_.device_type_)
      - PROTOBUF_FIELD_OFFSET(PresenceDevice, _impl_.device_id_)>(
          reinterpret_cast<char*>(&_impl_.device_id_),
          reinterpret_cast<char*>(&other->_impl_.device_id_));
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace connections
}  // namespace nearby
}  // namespace location
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
