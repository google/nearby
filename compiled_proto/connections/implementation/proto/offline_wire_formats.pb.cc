// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connections/implementation/proto/offline_wire_formats.proto

#include "connections/implementation/proto/offline_wire_formats.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace location {
namespace nearby {
namespace connections {
constexpr OfflineFrame::OfflineFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : v1_(nullptr)
  , version_(0)
{}
struct OfflineFrameDefaultTypeInternal {
  constexpr OfflineFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OfflineFrameDefaultTypeInternal() {}
  union {
    OfflineFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OfflineFrameDefaultTypeInternal _OfflineFrame_default_instance_;
constexpr V1Frame::V1Frame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : connection_request_(nullptr)
  , connection_response_(nullptr)
  , payload_transfer_(nullptr)
  , bandwidth_upgrade_negotiation_(nullptr)
  , keep_alive_(nullptr)
  , disconnection_(nullptr)
  , paired_key_encryption_(nullptr)
  , authentication_message_(nullptr)
  , authentication_result_(nullptr)
  , auto_resume_(nullptr)
  , auto_reconnect_(nullptr)
  , bandwidth_upgrade_retry_(nullptr)
  , type_(0)
{}
struct V1FrameDefaultTypeInternal {
  constexpr V1FrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~V1FrameDefaultTypeInternal() {}
  union {
    V1Frame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT V1FrameDefaultTypeInternal _V1Frame_default_instance_;
constexpr ConnectionRequestFrame::ConnectionRequestFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mediums_()
  , endpoint_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , endpoint_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , handshake_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , endpoint_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , medium_metadata_(nullptr)
  , nonce_(0)
  , keep_alive_interval_millis_(0)
  , keep_alive_timeout_millis_(0)
  , device_type_(0)
  , connection_mode_(0)

  , _oneof_case_{}{}
struct ConnectionRequestFrameDefaultTypeInternal {
  constexpr ConnectionRequestFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConnectionRequestFrameDefaultTypeInternal() {}
  union {
    ConnectionRequestFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConnectionRequestFrameDefaultTypeInternal _ConnectionRequestFrame_default_instance_;
constexpr ConnectionResponseFrame::ConnectionResponseFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : handshake_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , os_info_(nullptr)
  , status_(0)
  , response_(0)

  , multiplex_socket_bitmask_(0)
  , nearby_connections_version_(0)
  , safe_to_disconnect_version_(0){}
struct ConnectionResponseFrameDefaultTypeInternal {
  constexpr ConnectionResponseFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConnectionResponseFrameDefaultTypeInternal() {}
  union {
    ConnectionResponseFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
constexpr PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : file_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , parent_folder_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(int64_t{0})
  , total_size_(int64_t{0})
  , type_(0)

  , is_sensitive_(false){}
struct PayloadTransferFrame_PayloadHeaderDefaultTypeInternal {
  constexpr PayloadTransferFrame_PayloadHeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrame_PayloadHeaderDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_PayloadHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrame_PayloadHeaderDefaultTypeInternal _PayloadTransferFrame_PayloadHeader_default_instance_;
constexpr PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : body_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , offset_(int64_t{0})
  , flags_(0)
  , index_(0){}
struct PayloadTransferFrame_PayloadChunkDefaultTypeInternal {
  constexpr PayloadTransferFrame_PayloadChunkDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrame_PayloadChunkDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_PayloadChunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrame_PayloadChunkDefaultTypeInternal _PayloadTransferFrame_PayloadChunk_default_instance_;
constexpr PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : offset_(int64_t{0})
  , event_(0)
{}
struct PayloadTransferFrame_ControlMessageDefaultTypeInternal {
  constexpr PayloadTransferFrame_ControlMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrame_ControlMessageDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_ControlMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrame_ControlMessageDefaultTypeInternal _PayloadTransferFrame_ControlMessage_default_instance_;
constexpr PayloadTransferFrame::PayloadTransferFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : payload_header_(nullptr)
  , payload_chunk_(nullptr)
  , control_message_(nullptr)
  , packet_type_(0)
{}
struct PayloadTransferFrameDefaultTypeInternal {
  constexpr PayloadTransferFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrameDefaultTypeInternal() {}
  union {
    PayloadTransferFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrameDefaultTypeInternal _PayloadTransferFrame_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gateway_(nullptr)
  , port_(0)
  , frequency_(-1){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , wifi_port_(0){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : service_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , mac_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : service_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , service_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gateway_(nullptr)
  , ip_v6_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , port_(0)
  , frequency_(0){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : peer_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , location_hint_(nullptr){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : wifi_hotspot_credentials_(nullptr)
  , wifi_lan_socket_(nullptr)
  , bluetooth_credentials_(nullptr)
  , wifi_aware_credentials_(nullptr)
  , wifi_direct_credentials_(nullptr)
  , web_rtc_credentials_(nullptr)
  , medium_(0)

  , supports_disabling_encryption_(false)
  , supports_client_introduction_ack_(false){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sta_frequency_(0){}
struct BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannelDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpoint_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , supports_disabling_encryption_(false){}
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_ClientIntroduction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_ClientIntroductionAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : upgrade_path_info_(nullptr)
  , client_introduction_(nullptr)
  , client_introduction_ack_(nullptr)
  , safe_to_close_prior_channel_(nullptr)
  , event_type_(0)
{}
struct BandwidthUpgradeNegotiationFrameDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrameDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrameDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_default_instance_;
constexpr BandwidthUpgradeRetryFrame::BandwidthUpgradeRetryFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : supported_medium_()
  , is_request_(false){}
struct BandwidthUpgradeRetryFrameDefaultTypeInternal {
  constexpr BandwidthUpgradeRetryFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeRetryFrameDefaultTypeInternal() {}
  union {
    BandwidthUpgradeRetryFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeRetryFrameDefaultTypeInternal _BandwidthUpgradeRetryFrame_default_instance_;
constexpr KeepAliveFrame::KeepAliveFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ack_(false)
  , seq_num_(0u){}
struct KeepAliveFrameDefaultTypeInternal {
  constexpr KeepAliveFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeepAliveFrameDefaultTypeInternal() {}
  union {
    KeepAliveFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeepAliveFrameDefaultTypeInternal _KeepAliveFrame_default_instance_;
constexpr DisconnectionFrame::DisconnectionFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_safe_to_disconnect_(false)
  , ack_safe_to_disconnect_(false){}
struct DisconnectionFrameDefaultTypeInternal {
  constexpr DisconnectionFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DisconnectionFrameDefaultTypeInternal() {}
  union {
    DisconnectionFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DisconnectionFrameDefaultTypeInternal _DisconnectionFrame_default_instance_;
constexpr PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signed_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct PairedKeyEncryptionFrameDefaultTypeInternal {
  constexpr PairedKeyEncryptionFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PairedKeyEncryptionFrameDefaultTypeInternal() {}
  union {
    PairedKeyEncryptionFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;
constexpr AuthenticationMessageFrame::AuthenticationMessageFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : auth_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AuthenticationMessageFrameDefaultTypeInternal {
  constexpr AuthenticationMessageFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AuthenticationMessageFrameDefaultTypeInternal() {}
  union {
    AuthenticationMessageFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AuthenticationMessageFrameDefaultTypeInternal _AuthenticationMessageFrame_default_instance_;
constexpr AuthenticationResultFrame::AuthenticationResultFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(0){}
struct AuthenticationResultFrameDefaultTypeInternal {
  constexpr AuthenticationResultFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AuthenticationResultFrameDefaultTypeInternal() {}
  union {
    AuthenticationResultFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AuthenticationResultFrameDefaultTypeInternal _AuthenticationResultFrame_default_instance_;
constexpr AutoResumeFrame::AutoResumeFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pending_payload_id_(int64_t{0})
  , event_type_(0)

  , next_payload_chunk_index_(0){}
struct AutoResumeFrameDefaultTypeInternal {
  constexpr AutoResumeFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AutoResumeFrameDefaultTypeInternal() {}
  union {
    AutoResumeFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AutoResumeFrameDefaultTypeInternal _AutoResumeFrame_default_instance_;
constexpr AutoReconnectFrame::AutoReconnectFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpoint_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , event_type_(0)
{}
struct AutoReconnectFrameDefaultTypeInternal {
  constexpr AutoReconnectFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AutoReconnectFrameDefaultTypeInternal() {}
  union {
    AutoReconnectFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AutoReconnectFrameDefaultTypeInternal _AutoReconnectFrame_default_instance_;
constexpr MediumMetadata::MediumMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ip_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , available_channels_(nullptr)
  , wifi_direct_cli_usable_channels_(nullptr)
  , wifi_lan_usable_channels_(nullptr)
  , wifi_aware_usable_channels_(nullptr)
  , wifi_hotspot_sta_usable_channels_(nullptr)
  , supports_5_ghz_(false)
  , supports_6_ghz_(false)
  , mobile_radio_(false)
  , ap_frequency_(-1){}
struct MediumMetadataDefaultTypeInternal {
  constexpr MediumMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MediumMetadataDefaultTypeInternal() {}
  union {
    MediumMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MediumMetadataDefaultTypeInternal _MediumMetadata_default_instance_;
constexpr AvailableChannels::AvailableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct AvailableChannelsDefaultTypeInternal {
  constexpr AvailableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvailableChannelsDefaultTypeInternal() {}
  union {
    AvailableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvailableChannelsDefaultTypeInternal _AvailableChannels_default_instance_;
constexpr WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiDirectCliUsableChannelsDefaultTypeInternal {
  constexpr WifiDirectCliUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiDirectCliUsableChannelsDefaultTypeInternal() {}
  union {
    WifiDirectCliUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiDirectCliUsableChannelsDefaultTypeInternal _WifiDirectCliUsableChannels_default_instance_;
constexpr WifiLanUsableChannels::WifiLanUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiLanUsableChannelsDefaultTypeInternal {
  constexpr WifiLanUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiLanUsableChannelsDefaultTypeInternal() {}
  union {
    WifiLanUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiLanUsableChannelsDefaultTypeInternal _WifiLanUsableChannels_default_instance_;
constexpr WifiAwareUsableChannels::WifiAwareUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiAwareUsableChannelsDefaultTypeInternal {
  constexpr WifiAwareUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiAwareUsableChannelsDefaultTypeInternal() {}
  union {
    WifiAwareUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiAwareUsableChannelsDefaultTypeInternal _WifiAwareUsableChannels_default_instance_;
constexpr WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiHotspotStaUsableChannelsDefaultTypeInternal {
  constexpr WifiHotspotStaUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiHotspotStaUsableChannelsDefaultTypeInternal() {}
  union {
    WifiHotspotStaUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiHotspotStaUsableChannelsDefaultTypeInternal _WifiHotspotStaUsableChannels_default_instance_;
constexpr LocationHint::LocationHint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : location_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , format_(0)
{}
struct LocationHintDefaultTypeInternal {
  constexpr LocationHintDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LocationHintDefaultTypeInternal() {}
  union {
    LocationHint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LocationHintDefaultTypeInternal _LocationHint_default_instance_;
constexpr LocationStandard::LocationStandard(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LocationStandardDefaultTypeInternal {
  constexpr LocationStandardDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LocationStandardDefaultTypeInternal() {}
  union {
    LocationStandard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LocationStandardDefaultTypeInternal _LocationStandard_default_instance_;
constexpr OsInfo::OsInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)
{}
struct OsInfoDefaultTypeInternal {
  constexpr OsInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OsInfoDefaultTypeInternal() {}
  union {
    OsInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OsInfoDefaultTypeInternal _OsInfo_default_instance_;
constexpr ConnectionsDevice::ConnectionsDevice(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpoint_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , connectivity_info_list_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , endpoint_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , endpoint_type_(0)
{}
struct ConnectionsDeviceDefaultTypeInternal {
  constexpr ConnectionsDeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConnectionsDeviceDefaultTypeInternal() {}
  union {
    ConnectionsDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConnectionsDeviceDefaultTypeInternal _ConnectionsDevice_default_instance_;
constexpr PresenceDevice::PresenceDevice(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : discovery_medium_()
  , _discovery_medium_cached_byte_size_(0)
  , actions_()
  , _actions_cached_byte_size_(0)
  , identity_type_()
  , _identity_type_cached_byte_size_(0)
  , endpoint_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , connectivity_info_list_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_image_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_id_(int64_t{0})
  , endpoint_type_(0)

  , device_type_(0)
{}
struct PresenceDeviceDefaultTypeInternal {
  constexpr PresenceDeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PresenceDeviceDefaultTypeInternal() {}
  union {
    PresenceDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PresenceDeviceDefaultTypeInternal _PresenceDevice_default_instance_;
}  // namespace connections
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace connections {
bool OfflineFrame_Version_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OfflineFrame_Version_strings[2] = {};

static const char OfflineFrame_Version_names[] =
  "UNKNOWN_VERSION"
  "V1";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OfflineFrame_Version_entries[] = {
  { {OfflineFrame_Version_names + 0, 15}, 0 },
  { {OfflineFrame_Version_names + 15, 2}, 1 },
};

static const int OfflineFrame_Version_entries_by_number[] = {
  0, // 0 -> UNKNOWN_VERSION
  1, // 1 -> V1
};

const std::string& OfflineFrame_Version_Name(
    OfflineFrame_Version value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OfflineFrame_Version_entries,
          OfflineFrame_Version_entries_by_number,
          2, OfflineFrame_Version_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OfflineFrame_Version_entries,
      OfflineFrame_Version_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OfflineFrame_Version_strings[idx].get();
}
bool OfflineFrame_Version_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfflineFrame_Version* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OfflineFrame_Version_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<OfflineFrame_Version>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr OfflineFrame_Version OfflineFrame::UNKNOWN_VERSION;
constexpr OfflineFrame_Version OfflineFrame::V1;
constexpr OfflineFrame_Version OfflineFrame::Version_MIN;
constexpr OfflineFrame_Version OfflineFrame::Version_MAX;
constexpr int OfflineFrame::Version_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool V1Frame_FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> V1Frame_FrameType_strings[13] = {};

static const char V1Frame_FrameType_names[] =
  "AUTHENTICATION_MESSAGE"
  "AUTHENTICATION_RESULT"
  "AUTO_RECONNECT"
  "AUTO_RESUME"
  "BANDWIDTH_UPGRADE_NEGOTIATION"
  "BANDWIDTH_UPGRADE_RETRY"
  "CONNECTION_REQUEST"
  "CONNECTION_RESPONSE"
  "DISCONNECTION"
  "KEEP_ALIVE"
  "PAIRED_KEY_ENCRYPTION"
  "PAYLOAD_TRANSFER"
  "UNKNOWN_FRAME_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry V1Frame_FrameType_entries[] = {
  { {V1Frame_FrameType_names + 0, 22}, 8 },
  { {V1Frame_FrameType_names + 22, 21}, 9 },
  { {V1Frame_FrameType_names + 43, 14}, 11 },
  { {V1Frame_FrameType_names + 57, 11}, 10 },
  { {V1Frame_FrameType_names + 68, 29}, 4 },
  { {V1Frame_FrameType_names + 97, 23}, 12 },
  { {V1Frame_FrameType_names + 120, 18}, 1 },
  { {V1Frame_FrameType_names + 138, 19}, 2 },
  { {V1Frame_FrameType_names + 157, 13}, 6 },
  { {V1Frame_FrameType_names + 170, 10}, 5 },
  { {V1Frame_FrameType_names + 180, 21}, 7 },
  { {V1Frame_FrameType_names + 201, 16}, 3 },
  { {V1Frame_FrameType_names + 217, 18}, 0 },
};

static const int V1Frame_FrameType_entries_by_number[] = {
  12, // 0 -> UNKNOWN_FRAME_TYPE
  6, // 1 -> CONNECTION_REQUEST
  7, // 2 -> CONNECTION_RESPONSE
  11, // 3 -> PAYLOAD_TRANSFER
  4, // 4 -> BANDWIDTH_UPGRADE_NEGOTIATION
  9, // 5 -> KEEP_ALIVE
  8, // 6 -> DISCONNECTION
  10, // 7 -> PAIRED_KEY_ENCRYPTION
  0, // 8 -> AUTHENTICATION_MESSAGE
  1, // 9 -> AUTHENTICATION_RESULT
  3, // 10 -> AUTO_RESUME
  2, // 11 -> AUTO_RECONNECT
  5, // 12 -> BANDWIDTH_UPGRADE_RETRY
};

const std::string& V1Frame_FrameType_Name(
    V1Frame_FrameType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          V1Frame_FrameType_entries,
          V1Frame_FrameType_entries_by_number,
          13, V1Frame_FrameType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      V1Frame_FrameType_entries,
      V1Frame_FrameType_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     V1Frame_FrameType_strings[idx].get();
}
bool V1Frame_FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V1Frame_FrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      V1Frame_FrameType_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<V1Frame_FrameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr V1Frame_FrameType V1Frame::UNKNOWN_FRAME_TYPE;
constexpr V1Frame_FrameType V1Frame::CONNECTION_REQUEST;
constexpr V1Frame_FrameType V1Frame::CONNECTION_RESPONSE;
constexpr V1Frame_FrameType V1Frame::PAYLOAD_TRANSFER;
constexpr V1Frame_FrameType V1Frame::BANDWIDTH_UPGRADE_NEGOTIATION;
constexpr V1Frame_FrameType V1Frame::KEEP_ALIVE;
constexpr V1Frame_FrameType V1Frame::DISCONNECTION;
constexpr V1Frame_FrameType V1Frame::PAIRED_KEY_ENCRYPTION;
constexpr V1Frame_FrameType V1Frame::AUTHENTICATION_MESSAGE;
constexpr V1Frame_FrameType V1Frame::AUTHENTICATION_RESULT;
constexpr V1Frame_FrameType V1Frame::AUTO_RESUME;
constexpr V1Frame_FrameType V1Frame::AUTO_RECONNECT;
constexpr V1Frame_FrameType V1Frame::BANDWIDTH_UPGRADE_RETRY;
constexpr V1Frame_FrameType V1Frame::FrameType_MIN;
constexpr V1Frame_FrameType V1Frame::FrameType_MAX;
constexpr int V1Frame::FrameType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionRequestFrame_Medium_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionRequestFrame_Medium_strings[13] = {};

static const char ConnectionRequestFrame_Medium_names[] =
  "BLE"
  "BLE_L2CAP"
  "BLUETOOTH"
  "MDNS"
  "NFC"
  "UNKNOWN_MEDIUM"
  "USB"
  "WEB_RTC"
  "WEB_RTC_NON_CELLULAR"
  "WIFI_AWARE"
  "WIFI_DIRECT"
  "WIFI_HOTSPOT"
  "WIFI_LAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionRequestFrame_Medium_entries[] = {
  { {ConnectionRequestFrame_Medium_names + 0, 3}, 4 },
  { {ConnectionRequestFrame_Medium_names + 3, 9}, 10 },
  { {ConnectionRequestFrame_Medium_names + 12, 9}, 2 },
  { {ConnectionRequestFrame_Medium_names + 21, 4}, 1 },
  { {ConnectionRequestFrame_Medium_names + 25, 3}, 7 },
  { {ConnectionRequestFrame_Medium_names + 28, 14}, 0 },
  { {ConnectionRequestFrame_Medium_names + 42, 3}, 11 },
  { {ConnectionRequestFrame_Medium_names + 45, 7}, 9 },
  { {ConnectionRequestFrame_Medium_names + 52, 20}, 12 },
  { {ConnectionRequestFrame_Medium_names + 72, 10}, 6 },
  { {ConnectionRequestFrame_Medium_names + 82, 11}, 8 },
  { {ConnectionRequestFrame_Medium_names + 93, 12}, 3 },
  { {ConnectionRequestFrame_Medium_names + 105, 8}, 5 },
};

static const int ConnectionRequestFrame_Medium_entries_by_number[] = {
  5, // 0 -> UNKNOWN_MEDIUM
  3, // 1 -> MDNS
  2, // 2 -> BLUETOOTH
  11, // 3 -> WIFI_HOTSPOT
  0, // 4 -> BLE
  12, // 5 -> WIFI_LAN
  9, // 6 -> WIFI_AWARE
  4, // 7 -> NFC
  10, // 8 -> WIFI_DIRECT
  7, // 9 -> WEB_RTC
  1, // 10 -> BLE_L2CAP
  6, // 11 -> USB
  8, // 12 -> WEB_RTC_NON_CELLULAR
};

const std::string& ConnectionRequestFrame_Medium_Name(
    ConnectionRequestFrame_Medium value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionRequestFrame_Medium_entries,
          ConnectionRequestFrame_Medium_entries_by_number,
          13, ConnectionRequestFrame_Medium_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionRequestFrame_Medium_entries,
      ConnectionRequestFrame_Medium_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionRequestFrame_Medium_strings[idx].get();
}
bool ConnectionRequestFrame_Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionRequestFrame_Medium* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionRequestFrame_Medium_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionRequestFrame_Medium>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::UNKNOWN_MEDIUM;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::MDNS;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::BLUETOOTH;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_HOTSPOT;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::BLE;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_LAN;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_AWARE;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::NFC;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_DIRECT;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WEB_RTC;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::BLE_L2CAP;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::USB;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WEB_RTC_NON_CELLULAR;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::Medium_MIN;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::Medium_MAX;
constexpr int ConnectionRequestFrame::Medium_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionRequestFrame_ConnectionMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionRequestFrame_ConnectionMode_strings[2] = {};

static const char ConnectionRequestFrame_ConnectionMode_names[] =
  "INSTANT"
  "LEGACY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionRequestFrame_ConnectionMode_entries[] = {
  { {ConnectionRequestFrame_ConnectionMode_names + 0, 7}, 1 },
  { {ConnectionRequestFrame_ConnectionMode_names + 7, 6}, 0 },
};

static const int ConnectionRequestFrame_ConnectionMode_entries_by_number[] = {
  1, // 0 -> LEGACY
  0, // 1 -> INSTANT
};

const std::string& ConnectionRequestFrame_ConnectionMode_Name(
    ConnectionRequestFrame_ConnectionMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionRequestFrame_ConnectionMode_entries,
          ConnectionRequestFrame_ConnectionMode_entries_by_number,
          2, ConnectionRequestFrame_ConnectionMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionRequestFrame_ConnectionMode_entries,
      ConnectionRequestFrame_ConnectionMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionRequestFrame_ConnectionMode_strings[idx].get();
}
bool ConnectionRequestFrame_ConnectionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionRequestFrame_ConnectionMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionRequestFrame_ConnectionMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionRequestFrame_ConnectionMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionRequestFrame_ConnectionMode ConnectionRequestFrame::LEGACY;
constexpr ConnectionRequestFrame_ConnectionMode ConnectionRequestFrame::INSTANT;
constexpr ConnectionRequestFrame_ConnectionMode ConnectionRequestFrame::ConnectionMode_MIN;
constexpr ConnectionRequestFrame_ConnectionMode ConnectionRequestFrame::ConnectionMode_MAX;
constexpr int ConnectionRequestFrame::ConnectionMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionResponseFrame_ResponseStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionResponseFrame_ResponseStatus_strings[3] = {};

static const char ConnectionResponseFrame_ResponseStatus_names[] =
  "ACCEPT"
  "REJECT"
  "UNKNOWN_RESPONSE_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionResponseFrame_ResponseStatus_entries[] = {
  { {ConnectionResponseFrame_ResponseStatus_names + 0, 6}, 1 },
  { {ConnectionResponseFrame_ResponseStatus_names + 6, 6}, 2 },
  { {ConnectionResponseFrame_ResponseStatus_names + 12, 23}, 0 },
};

static const int ConnectionResponseFrame_ResponseStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_RESPONSE_STATUS
  0, // 1 -> ACCEPT
  1, // 2 -> REJECT
};

const std::string& ConnectionResponseFrame_ResponseStatus_Name(
    ConnectionResponseFrame_ResponseStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionResponseFrame_ResponseStatus_entries,
          ConnectionResponseFrame_ResponseStatus_entries_by_number,
          3, ConnectionResponseFrame_ResponseStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionResponseFrame_ResponseStatus_entries,
      ConnectionResponseFrame_ResponseStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionResponseFrame_ResponseStatus_strings[idx].get();
}
bool ConnectionResponseFrame_ResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionResponseFrame_ResponseStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionResponseFrame_ResponseStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionResponseFrame_ResponseStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::UNKNOWN_RESPONSE_STATUS;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::ACCEPT;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::REJECT;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::ResponseStatus_MIN;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::ResponseStatus_MAX;
constexpr int ConnectionResponseFrame::ResponseStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_PayloadHeader_PayloadType_strings[4] = {};

static const char PayloadTransferFrame_PayloadHeader_PayloadType_names[] =
  "BYTES"
  "FILE"
  "STREAM"
  "UNKNOWN_PAYLOAD_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_PayloadHeader_PayloadType_entries[] = {
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 0, 5}, 1 },
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 5, 4}, 2 },
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 9, 6}, 3 },
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 15, 20}, 0 },
};

static const int PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_PAYLOAD_TYPE
  0, // 1 -> BYTES
  1, // 2 -> FILE
  2, // 3 -> STREAM
};

const std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(
    PayloadTransferFrame_PayloadHeader_PayloadType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_PayloadHeader_PayloadType_entries,
          PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number,
          4, PayloadTransferFrame_PayloadHeader_PayloadType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_PayloadHeader_PayloadType_entries,
      PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_PayloadHeader_PayloadType_strings[idx].get();
}
bool PayloadTransferFrame_PayloadHeader_PayloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PayloadHeader_PayloadType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_PayloadHeader_PayloadType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PayloadHeader_PayloadType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::UNKNOWN_PAYLOAD_TYPE;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::BYTES;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::FILE;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::STREAM;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::PayloadType_MIN;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::PayloadType_MAX;
constexpr int PayloadTransferFrame_PayloadHeader::PayloadType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_PayloadChunk_Flags_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_PayloadChunk_Flags_strings[1] = {};

static const char PayloadTransferFrame_PayloadChunk_Flags_names[] =
  "LAST_CHUNK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_PayloadChunk_Flags_entries[] = {
  { {PayloadTransferFrame_PayloadChunk_Flags_names + 0, 10}, 1 },
};

static const int PayloadTransferFrame_PayloadChunk_Flags_entries_by_number[] = {
  0, // 1 -> LAST_CHUNK
};

const std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(
    PayloadTransferFrame_PayloadChunk_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_PayloadChunk_Flags_entries,
          PayloadTransferFrame_PayloadChunk_Flags_entries_by_number,
          1, PayloadTransferFrame_PayloadChunk_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_PayloadChunk_Flags_entries,
      PayloadTransferFrame_PayloadChunk_Flags_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_PayloadChunk_Flags_strings[idx].get();
}
bool PayloadTransferFrame_PayloadChunk_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PayloadChunk_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_PayloadChunk_Flags_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PayloadChunk_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk::LAST_CHUNK;
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk::Flags_MIN;
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk::Flags_MAX;
constexpr int PayloadTransferFrame_PayloadChunk::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_ControlMessage_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_ControlMessage_EventType_strings[4] = {};

static const char PayloadTransferFrame_ControlMessage_EventType_names[] =
  "PAYLOAD_CANCELED"
  "PAYLOAD_ERROR"
  "PAYLOAD_RECEIVED_ACK"
  "UNKNOWN_EVENT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_ControlMessage_EventType_entries[] = {
  { {PayloadTransferFrame_ControlMessage_EventType_names + 0, 16}, 2 },
  { {PayloadTransferFrame_ControlMessage_EventType_names + 16, 13}, 1 },
  { {PayloadTransferFrame_ControlMessage_EventType_names + 29, 20}, 3 },
  { {PayloadTransferFrame_ControlMessage_EventType_names + 49, 18}, 0 },
};

static const int PayloadTransferFrame_ControlMessage_EventType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_EVENT_TYPE
  1, // 1 -> PAYLOAD_ERROR
  0, // 2 -> PAYLOAD_CANCELED
  2, // 3 -> PAYLOAD_RECEIVED_ACK
};

const std::string& PayloadTransferFrame_ControlMessage_EventType_Name(
    PayloadTransferFrame_ControlMessage_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_ControlMessage_EventType_entries,
          PayloadTransferFrame_ControlMessage_EventType_entries_by_number,
          4, PayloadTransferFrame_ControlMessage_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_ControlMessage_EventType_entries,
      PayloadTransferFrame_ControlMessage_EventType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_ControlMessage_EventType_strings[idx].get();
}
bool PayloadTransferFrame_ControlMessage_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_ControlMessage_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_ControlMessage_EventType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_ControlMessage_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::UNKNOWN_EVENT_TYPE;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::PAYLOAD_ERROR;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::PAYLOAD_CANCELED;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::PAYLOAD_RECEIVED_ACK;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::EventType_MIN;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::EventType_MAX;
constexpr int PayloadTransferFrame_ControlMessage::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_PacketType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_PacketType_strings[4] = {};

static const char PayloadTransferFrame_PacketType_names[] =
  "CONTROL"
  "DATA"
  "PAYLOAD_ACK"
  "UNKNOWN_PACKET_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_PacketType_entries[] = {
  { {PayloadTransferFrame_PacketType_names + 0, 7}, 2 },
  { {PayloadTransferFrame_PacketType_names + 7, 4}, 1 },
  { {PayloadTransferFrame_PacketType_names + 11, 11}, 3 },
  { {PayloadTransferFrame_PacketType_names + 22, 19}, 0 },
};

static const int PayloadTransferFrame_PacketType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_PACKET_TYPE
  1, // 1 -> DATA
  0, // 2 -> CONTROL
  2, // 3 -> PAYLOAD_ACK
};

const std::string& PayloadTransferFrame_PacketType_Name(
    PayloadTransferFrame_PacketType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_PacketType_entries,
          PayloadTransferFrame_PacketType_entries_by_number,
          4, PayloadTransferFrame_PacketType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_PacketType_entries,
      PayloadTransferFrame_PacketType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_PacketType_strings[idx].get();
}
bool PayloadTransferFrame_PacketType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PacketType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_PacketType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PacketType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::UNKNOWN_PACKET_TYPE;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::DATA;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::CONTROL;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::PAYLOAD_ACK;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::PacketType_MIN;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::PacketType_MAX;
constexpr int PayloadTransferFrame::PacketType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings[12] = {};

static const char BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[] =
  "BLE"
  "BLUETOOTH"
  "MDNS"
  "NFC"
  "UNKNOWN_MEDIUM"
  "USB"
  "WEB_RTC"
  "WEB_RTC_NON_CELLULAR"
  "WIFI_AWARE"
  "WIFI_DIRECT"
  "WIFI_HOTSPOT"
  "WIFI_LAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries[] = {
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 0, 3}, 4 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 3, 9}, 2 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 12, 4}, 1 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 16, 3}, 7 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 19, 14}, 0 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 33, 3}, 11 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 36, 7}, 9 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 43, 20}, 12 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 63, 10}, 6 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 73, 11}, 8 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 84, 12}, 3 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 96, 8}, 5 },
};

static const int BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number[] = {
  4, // 0 -> UNKNOWN_MEDIUM
  2, // 1 -> MDNS
  1, // 2 -> BLUETOOTH
  10, // 3 -> WIFI_HOTSPOT
  0, // 4 -> BLE
  11, // 5 -> WIFI_LAN
  8, // 6 -> WIFI_AWARE
  3, // 7 -> NFC
  9, // 8 -> WIFI_DIRECT
  6, // 9 -> WEB_RTC
  5, // 11 -> USB
  7, // 12 -> WEB_RTC_NON_CELLULAR
};

const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries,
          BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number,
          12, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries,
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings[idx].get();
}
bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::UNKNOWN_MEDIUM;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MDNS;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BLUETOOTH;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_HOTSPOT;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BLE;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_LAN;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_AWARE;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::NFC;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_DIRECT;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WEB_RTC;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::USB;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WEB_RTC_NON_CELLULAR;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Medium_MIN;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Medium_MAX;
constexpr int BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Medium_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BandwidthUpgradeNegotiationFrame_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BandwidthUpgradeNegotiationFrame_EventType_strings[7] = {};

static const char BandwidthUpgradeNegotiationFrame_EventType_names[] =
  "CLIENT_INTRODUCTION"
  "CLIENT_INTRODUCTION_ACK"
  "LAST_WRITE_TO_PRIOR_CHANNEL"
  "SAFE_TO_CLOSE_PRIOR_CHANNEL"
  "UNKNOWN_EVENT_TYPE"
  "UPGRADE_FAILURE"
  "UPGRADE_PATH_AVAILABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BandwidthUpgradeNegotiationFrame_EventType_entries[] = {
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 0, 19}, 4 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 19, 23}, 6 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 42, 27}, 2 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 69, 27}, 3 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 96, 18}, 0 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 114, 15}, 5 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 129, 22}, 1 },
};

static const int BandwidthUpgradeNegotiationFrame_EventType_entries_by_number[] = {
  4, // 0 -> UNKNOWN_EVENT_TYPE
  6, // 1 -> UPGRADE_PATH_AVAILABLE
  2, // 2 -> LAST_WRITE_TO_PRIOR_CHANNEL
  3, // 3 -> SAFE_TO_CLOSE_PRIOR_CHANNEL
  0, // 4 -> CLIENT_INTRODUCTION
  5, // 5 -> UPGRADE_FAILURE
  1, // 6 -> CLIENT_INTRODUCTION_ACK
};

const std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(
    BandwidthUpgradeNegotiationFrame_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BandwidthUpgradeNegotiationFrame_EventType_entries,
          BandwidthUpgradeNegotiationFrame_EventType_entries_by_number,
          7, BandwidthUpgradeNegotiationFrame_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BandwidthUpgradeNegotiationFrame_EventType_entries,
      BandwidthUpgradeNegotiationFrame_EventType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BandwidthUpgradeNegotiationFrame_EventType_strings[idx].get();
}
bool BandwidthUpgradeNegotiationFrame_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeNegotiationFrame_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BandwidthUpgradeNegotiationFrame_EventType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeNegotiationFrame_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::UNKNOWN_EVENT_TYPE;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::UPGRADE_PATH_AVAILABLE;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::LAST_WRITE_TO_PRIOR_CHANNEL;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::SAFE_TO_CLOSE_PRIOR_CHANNEL;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::CLIENT_INTRODUCTION;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::UPGRADE_FAILURE;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::CLIENT_INTRODUCTION_ACK;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::EventType_MIN;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::EventType_MAX;
constexpr int BandwidthUpgradeNegotiationFrame::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BandwidthUpgradeRetryFrame_Medium_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BandwidthUpgradeRetryFrame_Medium_strings[12] = {};

static const char BandwidthUpgradeRetryFrame_Medium_names[] =
  "BLE"
  "BLE_L2CAP"
  "BLUETOOTH"
  "NFC"
  "UNKNOWN_MEDIUM"
  "USB"
  "WEB_RTC"
  "WEB_RTC_NON_CELLULAR"
  "WIFI_AWARE"
  "WIFI_DIRECT"
  "WIFI_HOTSPOT"
  "WIFI_LAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BandwidthUpgradeRetryFrame_Medium_entries[] = {
  { {BandwidthUpgradeRetryFrame_Medium_names + 0, 3}, 4 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 3, 9}, 10 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 12, 9}, 2 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 21, 3}, 7 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 24, 14}, 0 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 38, 3}, 11 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 41, 7}, 9 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 48, 20}, 12 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 68, 10}, 6 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 78, 11}, 8 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 89, 12}, 3 },
  { {BandwidthUpgradeRetryFrame_Medium_names + 101, 8}, 5 },
};

static const int BandwidthUpgradeRetryFrame_Medium_entries_by_number[] = {
  4, // 0 -> UNKNOWN_MEDIUM
  2, // 2 -> BLUETOOTH
  10, // 3 -> WIFI_HOTSPOT
  0, // 4 -> BLE
  11, // 5 -> WIFI_LAN
  8, // 6 -> WIFI_AWARE
  3, // 7 -> NFC
  9, // 8 -> WIFI_DIRECT
  6, // 9 -> WEB_RTC
  1, // 10 -> BLE_L2CAP
  5, // 11 -> USB
  7, // 12 -> WEB_RTC_NON_CELLULAR
};

const std::string& BandwidthUpgradeRetryFrame_Medium_Name(
    BandwidthUpgradeRetryFrame_Medium value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BandwidthUpgradeRetryFrame_Medium_entries,
          BandwidthUpgradeRetryFrame_Medium_entries_by_number,
          12, BandwidthUpgradeRetryFrame_Medium_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BandwidthUpgradeRetryFrame_Medium_entries,
      BandwidthUpgradeRetryFrame_Medium_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BandwidthUpgradeRetryFrame_Medium_strings[idx].get();
}
bool BandwidthUpgradeRetryFrame_Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeRetryFrame_Medium* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BandwidthUpgradeRetryFrame_Medium_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeRetryFrame_Medium>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::UNKNOWN_MEDIUM;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::BLUETOOTH;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::WIFI_HOTSPOT;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::BLE;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::WIFI_LAN;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::WIFI_AWARE;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::NFC;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::WIFI_DIRECT;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::WEB_RTC;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::BLE_L2CAP;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::USB;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::WEB_RTC_NON_CELLULAR;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::Medium_MIN;
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::Medium_MAX;
constexpr int BandwidthUpgradeRetryFrame::Medium_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutoResumeFrame_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutoResumeFrame_EventType_strings[3] = {};

static const char AutoResumeFrame_EventType_names[] =
  "PAYLOAD_RESUME_TRANSFER_ACK"
  "PAYLOAD_RESUME_TRANSFER_START"
  "UNKNOWN_AUTO_RESUME_EVENT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutoResumeFrame_EventType_entries[] = {
  { {AutoResumeFrame_EventType_names + 0, 27}, 2 },
  { {AutoResumeFrame_EventType_names + 27, 29}, 1 },
  { {AutoResumeFrame_EventType_names + 56, 30}, 0 },
};

static const int AutoResumeFrame_EventType_entries_by_number[] = {
  2, // 0 -> UNKNOWN_AUTO_RESUME_EVENT_TYPE
  1, // 1 -> PAYLOAD_RESUME_TRANSFER_START
  0, // 2 -> PAYLOAD_RESUME_TRANSFER_ACK
};

const std::string& AutoResumeFrame_EventType_Name(
    AutoResumeFrame_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutoResumeFrame_EventType_entries,
          AutoResumeFrame_EventType_entries_by_number,
          3, AutoResumeFrame_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutoResumeFrame_EventType_entries,
      AutoResumeFrame_EventType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutoResumeFrame_EventType_strings[idx].get();
}
bool AutoResumeFrame_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoResumeFrame_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutoResumeFrame_EventType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AutoResumeFrame_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutoResumeFrame_EventType AutoResumeFrame::UNKNOWN_AUTO_RESUME_EVENT_TYPE;
constexpr AutoResumeFrame_EventType AutoResumeFrame::PAYLOAD_RESUME_TRANSFER_START;
constexpr AutoResumeFrame_EventType AutoResumeFrame::PAYLOAD_RESUME_TRANSFER_ACK;
constexpr AutoResumeFrame_EventType AutoResumeFrame::EventType_MIN;
constexpr AutoResumeFrame_EventType AutoResumeFrame::EventType_MAX;
constexpr int AutoResumeFrame::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutoReconnectFrame_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutoReconnectFrame_EventType_strings[3] = {};

static const char AutoReconnectFrame_EventType_names[] =
  "CLIENT_INTRODUCTION"
  "CLIENT_INTRODUCTION_ACK"
  "UNKNOWN_EVENT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutoReconnectFrame_EventType_entries[] = {
  { {AutoReconnectFrame_EventType_names + 0, 19}, 1 },
  { {AutoReconnectFrame_EventType_names + 19, 23}, 2 },
  { {AutoReconnectFrame_EventType_names + 42, 18}, 0 },
};

static const int AutoReconnectFrame_EventType_entries_by_number[] = {
  2, // 0 -> UNKNOWN_EVENT_TYPE
  0, // 1 -> CLIENT_INTRODUCTION
  1, // 2 -> CLIENT_INTRODUCTION_ACK
};

const std::string& AutoReconnectFrame_EventType_Name(
    AutoReconnectFrame_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutoReconnectFrame_EventType_entries,
          AutoReconnectFrame_EventType_entries_by_number,
          3, AutoReconnectFrame_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutoReconnectFrame_EventType_entries,
      AutoReconnectFrame_EventType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutoReconnectFrame_EventType_strings[idx].get();
}
bool AutoReconnectFrame_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoReconnectFrame_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutoReconnectFrame_EventType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AutoReconnectFrame_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutoReconnectFrame_EventType AutoReconnectFrame::UNKNOWN_EVENT_TYPE;
constexpr AutoReconnectFrame_EventType AutoReconnectFrame::CLIENT_INTRODUCTION;
constexpr AutoReconnectFrame_EventType AutoReconnectFrame::CLIENT_INTRODUCTION_ACK;
constexpr AutoReconnectFrame_EventType AutoReconnectFrame::EventType_MIN;
constexpr AutoReconnectFrame_EventType AutoReconnectFrame::EventType_MAX;
constexpr int AutoReconnectFrame::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LocationStandard_Format_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LocationStandard_Format_strings[3] = {};

static const char LocationStandard_Format_names[] =
  "E164_CALLING"
  "ISO_3166_1_ALPHA_2"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LocationStandard_Format_entries[] = {
  { {LocationStandard_Format_names + 0, 12}, 1 },
  { {LocationStandard_Format_names + 12, 18}, 2 },
  { {LocationStandard_Format_names + 30, 7}, 0 },
};

static const int LocationStandard_Format_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> E164_CALLING
  1, // 2 -> ISO_3166_1_ALPHA_2
};

const std::string& LocationStandard_Format_Name(
    LocationStandard_Format value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LocationStandard_Format_entries,
          LocationStandard_Format_entries_by_number,
          3, LocationStandard_Format_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LocationStandard_Format_entries,
      LocationStandard_Format_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LocationStandard_Format_strings[idx].get();
}
bool LocationStandard_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocationStandard_Format* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LocationStandard_Format_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LocationStandard_Format>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LocationStandard_Format LocationStandard::UNKNOWN;
constexpr LocationStandard_Format LocationStandard::E164_CALLING;
constexpr LocationStandard_Format LocationStandard::ISO_3166_1_ALPHA_2;
constexpr LocationStandard_Format LocationStandard::Format_MIN;
constexpr LocationStandard_Format LocationStandard::Format_MAX;
constexpr int LocationStandard::Format_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool OsInfo_OsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 100:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OsInfo_OsType_strings[6] = {};

static const char OsInfo_OsType_names[] =
  "ANDROID"
  "APPLE"
  "CHROME_OS"
  "LINUX"
  "UNKNOWN_OS_TYPE"
  "WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OsInfo_OsType_entries[] = {
  { {OsInfo_OsType_names + 0, 7}, 1 },
  { {OsInfo_OsType_names + 7, 5}, 4 },
  { {OsInfo_OsType_names + 12, 9}, 2 },
  { {OsInfo_OsType_names + 21, 5}, 100 },
  { {OsInfo_OsType_names + 26, 15}, 0 },
  { {OsInfo_OsType_names + 41, 7}, 3 },
};

static const int OsInfo_OsType_entries_by_number[] = {
  4, // 0 -> UNKNOWN_OS_TYPE
  0, // 1 -> ANDROID
  2, // 2 -> CHROME_OS
  5, // 3 -> WINDOWS
  1, // 4 -> APPLE
  3, // 100 -> LINUX
};

const std::string& OsInfo_OsType_Name(
    OsInfo_OsType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OsInfo_OsType_entries,
          OsInfo_OsType_entries_by_number,
          6, OsInfo_OsType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OsInfo_OsType_entries,
      OsInfo_OsType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OsInfo_OsType_strings[idx].get();
}
bool OsInfo_OsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OsInfo_OsType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OsInfo_OsType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<OsInfo_OsType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr OsInfo_OsType OsInfo::UNKNOWN_OS_TYPE;
constexpr OsInfo_OsType OsInfo::ANDROID;
constexpr OsInfo_OsType OsInfo::CHROME_OS;
constexpr OsInfo_OsType OsInfo::WINDOWS;
constexpr OsInfo_OsType OsInfo::APPLE;
constexpr OsInfo_OsType OsInfo::LINUX;
constexpr OsInfo_OsType OsInfo::OsType_MIN;
constexpr OsInfo_OsType OsInfo::OsType_MAX;
constexpr int OsInfo::OsType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PresenceDevice_DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PresenceDevice_DeviceType_strings[7] = {};

static const char PresenceDevice_DeviceType_names[] =
  "DISPLAY"
  "LAPTOP"
  "PHONE"
  "TABLET"
  "TV"
  "UNKNOWN"
  "WATCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PresenceDevice_DeviceType_entries[] = {
  { {PresenceDevice_DeviceType_names + 0, 7}, 3 },
  { {PresenceDevice_DeviceType_names + 7, 6}, 4 },
  { {PresenceDevice_DeviceType_names + 13, 5}, 1 },
  { {PresenceDevice_DeviceType_names + 18, 6}, 2 },
  { {PresenceDevice_DeviceType_names + 24, 2}, 5 },
  { {PresenceDevice_DeviceType_names + 26, 7}, 0 },
  { {PresenceDevice_DeviceType_names + 33, 5}, 6 },
};

static const int PresenceDevice_DeviceType_entries_by_number[] = {
  5, // 0 -> UNKNOWN
  2, // 1 -> PHONE
  3, // 2 -> TABLET
  0, // 3 -> DISPLAY
  1, // 4 -> LAPTOP
  4, // 5 -> TV
  6, // 6 -> WATCH
};

const std::string& PresenceDevice_DeviceType_Name(
    PresenceDevice_DeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PresenceDevice_DeviceType_entries,
          PresenceDevice_DeviceType_entries_by_number,
          7, PresenceDevice_DeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PresenceDevice_DeviceType_entries,
      PresenceDevice_DeviceType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PresenceDevice_DeviceType_strings[idx].get();
}
bool PresenceDevice_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PresenceDevice_DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PresenceDevice_DeviceType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<PresenceDevice_DeviceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PresenceDevice_DeviceType PresenceDevice::UNKNOWN;
constexpr PresenceDevice_DeviceType PresenceDevice::PHONE;
constexpr PresenceDevice_DeviceType PresenceDevice::TABLET;
constexpr PresenceDevice_DeviceType PresenceDevice::DISPLAY;
constexpr PresenceDevice_DeviceType PresenceDevice::LAPTOP;
constexpr PresenceDevice_DeviceType PresenceDevice::TV;
constexpr PresenceDevice_DeviceType PresenceDevice::WATCH;
constexpr PresenceDevice_DeviceType PresenceDevice::DeviceType_MIN;
constexpr PresenceDevice_DeviceType PresenceDevice::DeviceType_MAX;
constexpr int PresenceDevice::DeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool EndpointType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EndpointType_strings[3] = {};

static const char EndpointType_names[] =
  "CONNECTIONS_ENDPOINT"
  "PRESENCE_ENDPOINT"
  "UNKNOWN_ENDPOINT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EndpointType_entries[] = {
  { {EndpointType_names + 0, 20}, 1 },
  { {EndpointType_names + 20, 17}, 2 },
  { {EndpointType_names + 37, 16}, 0 },
};

static const int EndpointType_entries_by_number[] = {
  2, // 0 -> UNKNOWN_ENDPOINT
  0, // 1 -> CONNECTIONS_ENDPOINT
  1, // 2 -> PRESENCE_ENDPOINT
};

const std::string& EndpointType_Name(
    EndpointType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EndpointType_entries,
          EndpointType_entries_by_number,
          3, EndpointType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EndpointType_entries,
      EndpointType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EndpointType_strings[idx].get();
}
bool EndpointType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EndpointType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EndpointType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<EndpointType>(int_value);
  }
  return success;
}

// ===================================================================

class OfflineFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<OfflineFrame>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::V1Frame& v1(const OfflineFrame* msg);
  static void set_has_v1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::location::nearby::connections::V1Frame&
OfflineFrame::_Internal::v1(const OfflineFrame* msg) {
  return *msg->v1_;
}
OfflineFrame::OfflineFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.OfflineFrame)
}
OfflineFrame::OfflineFrame(const OfflineFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_v1()) {
    v1_ = new ::location::nearby::connections::V1Frame(*from.v1_);
  } else {
    v1_ = nullptr;
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.OfflineFrame)
}

inline void OfflineFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&v1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&v1_)) + sizeof(version_));
}

OfflineFrame::~OfflineFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.OfflineFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void OfflineFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete v1_;
}

void OfflineFrame::ArenaDtor(void* object) {
  OfflineFrame* _this = reinterpret_cast< OfflineFrame* >(object);
  (void)_this;
}
void OfflineFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OfflineFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OfflineFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.OfflineFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(v1_ != nullptr);
    v1_->Clear();
  }
  version_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OfflineFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.OfflineFrame.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::OfflineFrame_Version_IsValid(val))) {
            _internal_set_version(static_cast<::location::nearby::connections::OfflineFrame_Version>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.V1Frame v1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_v1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfflineFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.OfflineFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.OfflineFrame.Version version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_version(), target);
  }

  // optional .location.nearby.connections.V1Frame v1 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::v1(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.OfflineFrame)
  return target;
}

size_t OfflineFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.OfflineFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .location.nearby.connections.V1Frame v1 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *v1_);
    }

    // optional .location.nearby.connections.OfflineFrame.Version version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OfflineFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const OfflineFrame*>(
      &from));
}

void OfflineFrame::MergeFrom(const OfflineFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.OfflineFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_v1()->::location::nearby::connections::V1Frame::MergeFrom(from._internal_v1());
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OfflineFrame::CopyFrom(const OfflineFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.OfflineFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFrame::IsInitialized() const {
  return true;
}

void OfflineFrame::InternalSwap(OfflineFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfflineFrame, version_)
      + sizeof(OfflineFrame::version_)
      - PROTOBUF_FIELD_OFFSET(OfflineFrame, v1_)>(
          reinterpret_cast<char*>(&v1_),
          reinterpret_cast<char*>(&other->v1_));
}

std::string OfflineFrame::GetTypeName() const {
  return "location.nearby.connections.OfflineFrame";
}


// ===================================================================

class V1Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<V1Frame>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::location::nearby::connections::ConnectionRequestFrame& connection_request(const V1Frame* msg);
  static void set_has_connection_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::ConnectionResponseFrame& connection_response(const V1Frame* msg);
  static void set_has_connection_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame& payload_transfer(const V1Frame* msg);
  static void set_has_payload_transfer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& bandwidth_upgrade_negotiation(const V1Frame* msg);
  static void set_has_bandwidth_upgrade_negotiation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::KeepAliveFrame& keep_alive(const V1Frame* msg);
  static void set_has_keep_alive(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::DisconnectionFrame& disconnection(const V1Frame* msg);
  static void set_has_disconnection(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::location::nearby::connections::PairedKeyEncryptionFrame& paired_key_encryption(const V1Frame* msg);
  static void set_has_paired_key_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::location::nearby::connections::AuthenticationMessageFrame& authentication_message(const V1Frame* msg);
  static void set_has_authentication_message(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::location::nearby::connections::AuthenticationResultFrame& authentication_result(const V1Frame* msg);
  static void set_has_authentication_result(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::location::nearby::connections::AutoResumeFrame& auto_resume(const V1Frame* msg);
  static void set_has_auto_resume(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::location::nearby::connections::AutoReconnectFrame& auto_reconnect(const V1Frame* msg);
  static void set_has_auto_reconnect(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeRetryFrame& bandwidth_upgrade_retry(const V1Frame* msg);
  static void set_has_bandwidth_upgrade_retry(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::location::nearby::connections::ConnectionRequestFrame&
V1Frame::_Internal::connection_request(const V1Frame* msg) {
  return *msg->connection_request_;
}
const ::location::nearby::connections::ConnectionResponseFrame&
V1Frame::_Internal::connection_response(const V1Frame* msg) {
  return *msg->connection_response_;
}
const ::location::nearby::connections::PayloadTransferFrame&
V1Frame::_Internal::payload_transfer(const V1Frame* msg) {
  return *msg->payload_transfer_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame&
V1Frame::_Internal::bandwidth_upgrade_negotiation(const V1Frame* msg) {
  return *msg->bandwidth_upgrade_negotiation_;
}
const ::location::nearby::connections::KeepAliveFrame&
V1Frame::_Internal::keep_alive(const V1Frame* msg) {
  return *msg->keep_alive_;
}
const ::location::nearby::connections::DisconnectionFrame&
V1Frame::_Internal::disconnection(const V1Frame* msg) {
  return *msg->disconnection_;
}
const ::location::nearby::connections::PairedKeyEncryptionFrame&
V1Frame::_Internal::paired_key_encryption(const V1Frame* msg) {
  return *msg->paired_key_encryption_;
}
const ::location::nearby::connections::AuthenticationMessageFrame&
V1Frame::_Internal::authentication_message(const V1Frame* msg) {
  return *msg->authentication_message_;
}
const ::location::nearby::connections::AuthenticationResultFrame&
V1Frame::_Internal::authentication_result(const V1Frame* msg) {
  return *msg->authentication_result_;
}
const ::location::nearby::connections::AutoResumeFrame&
V1Frame::_Internal::auto_resume(const V1Frame* msg) {
  return *msg->auto_resume_;
}
const ::location::nearby::connections::AutoReconnectFrame&
V1Frame::_Internal::auto_reconnect(const V1Frame* msg) {
  return *msg->auto_reconnect_;
}
const ::location::nearby::connections::BandwidthUpgradeRetryFrame&
V1Frame::_Internal::bandwidth_upgrade_retry(const V1Frame* msg) {
  return *msg->bandwidth_upgrade_retry_;
}
V1Frame::V1Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.V1Frame)
}
V1Frame::V1Frame(const V1Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_connection_request()) {
    connection_request_ = new ::location::nearby::connections::ConnectionRequestFrame(*from.connection_request_);
  } else {
    connection_request_ = nullptr;
  }
  if (from._internal_has_connection_response()) {
    connection_response_ = new ::location::nearby::connections::ConnectionResponseFrame(*from.connection_response_);
  } else {
    connection_response_ = nullptr;
  }
  if (from._internal_has_payload_transfer()) {
    payload_transfer_ = new ::location::nearby::connections::PayloadTransferFrame(*from.payload_transfer_);
  } else {
    payload_transfer_ = nullptr;
  }
  if (from._internal_has_bandwidth_upgrade_negotiation()) {
    bandwidth_upgrade_negotiation_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame(*from.bandwidth_upgrade_negotiation_);
  } else {
    bandwidth_upgrade_negotiation_ = nullptr;
  }
  if (from._internal_has_keep_alive()) {
    keep_alive_ = new ::location::nearby::connections::KeepAliveFrame(*from.keep_alive_);
  } else {
    keep_alive_ = nullptr;
  }
  if (from._internal_has_disconnection()) {
    disconnection_ = new ::location::nearby::connections::DisconnectionFrame(*from.disconnection_);
  } else {
    disconnection_ = nullptr;
  }
  if (from._internal_has_paired_key_encryption()) {
    paired_key_encryption_ = new ::location::nearby::connections::PairedKeyEncryptionFrame(*from.paired_key_encryption_);
  } else {
    paired_key_encryption_ = nullptr;
  }
  if (from._internal_has_authentication_message()) {
    authentication_message_ = new ::location::nearby::connections::AuthenticationMessageFrame(*from.authentication_message_);
  } else {
    authentication_message_ = nullptr;
  }
  if (from._internal_has_authentication_result()) {
    authentication_result_ = new ::location::nearby::connections::AuthenticationResultFrame(*from.authentication_result_);
  } else {
    authentication_result_ = nullptr;
  }
  if (from._internal_has_auto_resume()) {
    auto_resume_ = new ::location::nearby::connections::AutoResumeFrame(*from.auto_resume_);
  } else {
    auto_resume_ = nullptr;
  }
  if (from._internal_has_auto_reconnect()) {
    auto_reconnect_ = new ::location::nearby::connections::AutoReconnectFrame(*from.auto_reconnect_);
  } else {
    auto_reconnect_ = nullptr;
  }
  if (from._internal_has_bandwidth_upgrade_retry()) {
    bandwidth_upgrade_retry_ = new ::location::nearby::connections::BandwidthUpgradeRetryFrame(*from.bandwidth_upgrade_retry_);
  } else {
    bandwidth_upgrade_retry_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.V1Frame)
}

inline void V1Frame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&connection_request_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&connection_request_)) + sizeof(type_));
}

V1Frame::~V1Frame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.V1Frame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void V1Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete connection_request_;
  if (this != internal_default_instance()) delete connection_response_;
  if (this != internal_default_instance()) delete payload_transfer_;
  if (this != internal_default_instance()) delete bandwidth_upgrade_negotiation_;
  if (this != internal_default_instance()) delete keep_alive_;
  if (this != internal_default_instance()) delete disconnection_;
  if (this != internal_default_instance()) delete paired_key_encryption_;
  if (this != internal_default_instance()) delete authentication_message_;
  if (this != internal_default_instance()) delete authentication_result_;
  if (this != internal_default_instance()) delete auto_resume_;
  if (this != internal_default_instance()) delete auto_reconnect_;
  if (this != internal_default_instance()) delete bandwidth_upgrade_retry_;
}

void V1Frame::ArenaDtor(void* object) {
  V1Frame* _this = reinterpret_cast< V1Frame* >(object);
  (void)_this;
}
void V1Frame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void V1Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void V1Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.V1Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(connection_request_ != nullptr);
      connection_request_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(connection_response_ != nullptr);
      connection_response_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(payload_transfer_ != nullptr);
      payload_transfer_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(bandwidth_upgrade_negotiation_ != nullptr);
      bandwidth_upgrade_negotiation_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(keep_alive_ != nullptr);
      keep_alive_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(disconnection_ != nullptr);
      disconnection_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(paired_key_encryption_ != nullptr);
      paired_key_encryption_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(authentication_message_ != nullptr);
      authentication_message_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(authentication_result_ != nullptr);
      authentication_result_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(auto_resume_ != nullptr);
      auto_resume_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(auto_reconnect_ != nullptr);
      auto_reconnect_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(bandwidth_upgrade_retry_ != nullptr);
      bandwidth_upgrade_retry_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V1Frame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.V1Frame.FrameType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::V1Frame_FrameType_IsValid(val))) {
            _internal_set_type(static_cast<::location::nearby::connections::V1Frame_FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_payload_transfer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_bandwidth_upgrade_negotiation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_keep_alive(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_disconnection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_paired_key_encryption(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_authentication_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_authentication_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_auto_resume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_auto_reconnect(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_bandwidth_upgrade_retry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V1Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.V1Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.V1Frame.FrameType type = 1;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::connection_request(this), target, stream);
  }

  // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::connection_response(this), target, stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::payload_transfer(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::bandwidth_upgrade_negotiation(this), target, stream);
  }

  // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::keep_alive(this), target, stream);
  }

  // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::disconnection(this), target, stream);
  }

  // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::paired_key_encryption(this), target, stream);
  }

  // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::authentication_message(this), target, stream);
  }

  // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::authentication_result(this), target, stream);
  }

  // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::auto_resume(this), target, stream);
  }

  // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::auto_reconnect(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::bandwidth_upgrade_retry(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.V1Frame)
  return target;
}

size_t V1Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.V1Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connection_request_);
    }

    // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connection_response_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_transfer_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bandwidth_upgrade_negotiation_);
    }

    // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *keep_alive_);
    }

    // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *disconnection_);
    }

    // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *paired_key_encryption_);
    }

    // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *authentication_message_);
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *authentication_result_);
    }

    // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *auto_resume_);
    }

    // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *auto_reconnect_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bandwidth_upgrade_retry_);
    }

    // optional .location.nearby.connections.V1Frame.FrameType type = 1;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V1Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const V1Frame*>(
      &from));
}

void V1Frame::MergeFrom(const V1Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.V1Frame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_connection_request()->::location::nearby::connections::ConnectionRequestFrame::MergeFrom(from._internal_connection_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_connection_response()->::location::nearby::connections::ConnectionResponseFrame::MergeFrom(from._internal_connection_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_payload_transfer()->::location::nearby::connections::PayloadTransferFrame::MergeFrom(from._internal_payload_transfer());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_bandwidth_upgrade_negotiation()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame::MergeFrom(from._internal_bandwidth_upgrade_negotiation());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_keep_alive()->::location::nearby::connections::KeepAliveFrame::MergeFrom(from._internal_keep_alive());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_disconnection()->::location::nearby::connections::DisconnectionFrame::MergeFrom(from._internal_disconnection());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_paired_key_encryption()->::location::nearby::connections::PairedKeyEncryptionFrame::MergeFrom(from._internal_paired_key_encryption());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_authentication_message()->::location::nearby::connections::AuthenticationMessageFrame::MergeFrom(from._internal_authentication_message());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_authentication_result()->::location::nearby::connections::AuthenticationResultFrame::MergeFrom(from._internal_authentication_result());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_auto_resume()->::location::nearby::connections::AutoResumeFrame::MergeFrom(from._internal_auto_resume());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_auto_reconnect()->::location::nearby::connections::AutoReconnectFrame::MergeFrom(from._internal_auto_reconnect());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_bandwidth_upgrade_retry()->::location::nearby::connections::BandwidthUpgradeRetryFrame::MergeFrom(from._internal_bandwidth_upgrade_retry());
    }
    if (cached_has_bits & 0x00001000u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V1Frame::CopyFrom(const V1Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.V1Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V1Frame::IsInitialized() const {
  return true;
}

void V1Frame::InternalSwap(V1Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V1Frame, type_)
      + sizeof(V1Frame::type_)
      - PROTOBUF_FIELD_OFFSET(V1Frame, connection_request_)>(
          reinterpret_cast<char*>(&connection_request_),
          reinterpret_cast<char*>(&other->connection_request_));
}

std::string V1Frame::GetTypeName() const {
  return "location.nearby.connections.V1Frame";
}


// ===================================================================

class ConnectionRequestFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionRequestFrame>()._has_bits_);
  static void set_has_endpoint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_endpoint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_handshake_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nonce(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_endpoint_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::MediumMetadata& medium_metadata(const ConnectionRequestFrame* msg);
  static void set_has_medium_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_keep_alive_interval_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_keep_alive_timeout_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_device_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::ConnectionsDevice& connections_device(const ConnectionRequestFrame* msg);
  static const ::location::nearby::connections::PresenceDevice& presence_device(const ConnectionRequestFrame* msg);
  static void set_has_connection_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::location::nearby::connections::MediumMetadata&
ConnectionRequestFrame::_Internal::medium_metadata(const ConnectionRequestFrame* msg) {
  return *msg->medium_metadata_;
}
const ::location::nearby::connections::ConnectionsDevice&
ConnectionRequestFrame::_Internal::connections_device(const ConnectionRequestFrame* msg) {
  return *msg->Device_.connections_device_;
}
const ::location::nearby::connections::PresenceDevice&
ConnectionRequestFrame::_Internal::presence_device(const ConnectionRequestFrame* msg) {
  return *msg->Device_.presence_device_;
}
void ConnectionRequestFrame::set_allocated_connections_device(::location::nearby::connections::ConnectionsDevice* connections_device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Device();
  if (connections_device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::ConnectionsDevice>::GetOwningArena(connections_device);
    if (message_arena != submessage_arena) {
      connections_device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connections_device, submessage_arena);
    }
    set_has_connections_device();
    Device_.connections_device_ = connections_device;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.connections_device)
}
void ConnectionRequestFrame::set_allocated_presence_device(::location::nearby::connections::PresenceDevice* presence_device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Device();
  if (presence_device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::connections::PresenceDevice>::GetOwningArena(presence_device);
    if (message_arena != submessage_arena) {
      presence_device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence_device, submessage_arena);
    }
    set_has_presence_device();
    Device_.presence_device_ = presence_device;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.presence_device)
}
ConnectionRequestFrame::ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  mediums_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionRequestFrame)
}
ConnectionRequestFrame::ConnectionRequestFrame(const ConnectionRequestFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      mediums_(from.mediums_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_id()) {
    endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_id(), 
      GetArenaForAllocation());
  }
  endpoint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_name()) {
    endpoint_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_name(), 
      GetArenaForAllocation());
  }
  handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_handshake_data()) {
    handshake_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_handshake_data(), 
      GetArenaForAllocation());
  }
  endpoint_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_info()) {
    endpoint_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_info(), 
      GetArenaForAllocation());
  }
  device_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_info()) {
    device_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_info(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_medium_metadata()) {
    medium_metadata_ = new ::location::nearby::connections::MediumMetadata(*from.medium_metadata_);
  } else {
    medium_metadata_ = nullptr;
  }
  ::memcpy(&nonce_, &from.nonce_,
    static_cast<size_t>(reinterpret_cast<char*>(&connection_mode_) -
    reinterpret_cast<char*>(&nonce_)) + sizeof(connection_mode_));
  clear_has_Device();
  switch (from.Device_case()) {
    case kConnectionsDevice: {
      _internal_mutable_connections_device()->::location::nearby::connections::ConnectionsDevice::MergeFrom(from._internal_connections_device());
      break;
    }
    case kPresenceDevice: {
      _internal_mutable_presence_device()->::location::nearby::connections::PresenceDevice::MergeFrom(from._internal_presence_device());
      break;
    }
    case DEVICE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionRequestFrame)
}

inline void ConnectionRequestFrame::SharedCtor() {
endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
endpoint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
endpoint_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&medium_metadata_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&connection_mode_) -
    reinterpret_cast<char*>(&medium_metadata_)) + sizeof(connection_mode_));
clear_has_Device();
}

ConnectionRequestFrame::~ConnectionRequestFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionRequestFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConnectionRequestFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  endpoint_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  handshake_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete medium_metadata_;
  if (has_Device()) {
    clear_Device();
  }
}

void ConnectionRequestFrame::ArenaDtor(void* object) {
  ConnectionRequestFrame* _this = reinterpret_cast< ConnectionRequestFrame* >(object);
  (void)_this;
}
void ConnectionRequestFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConnectionRequestFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConnectionRequestFrame::clear_Device() {
// @@protoc_insertion_point(one_of_clear_start:location.nearby.connections.ConnectionRequestFrame)
  switch (Device_case()) {
    case kConnectionsDevice: {
      if (GetArenaForAllocation() == nullptr) {
        delete Device_.connections_device_;
      }
      break;
    }
    case kPresenceDevice: {
      if (GetArenaForAllocation() == nullptr) {
        delete Device_.presence_device_;
      }
      break;
    }
    case DEVICE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DEVICE_NOT_SET;
}


void ConnectionRequestFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionRequestFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mediums_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      endpoint_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      handshake_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      endpoint_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      device_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(medium_metadata_ != nullptr);
      medium_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&nonce_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&keep_alive_interval_millis_) -
        reinterpret_cast<char*>(&nonce_)) + sizeof(keep_alive_interval_millis_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&keep_alive_timeout_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&connection_mode_) -
        reinterpret_cast<char*>(&keep_alive_timeout_millis_)) + sizeof(connection_mode_));
  }
  clear_Device();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionRequestFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string endpoint_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string endpoint_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_endpoint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes handshake_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_handshake_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nonce = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_nonce(&has_bits);
          nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(val))) {
              _internal_add_mediums(static_cast<::location::nearby::connections::ConnectionRequestFrame_Medium>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_mediums(), ptr, ctx, ::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes endpoint_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_endpoint_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_medium_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 keep_alive_interval_millis = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_keep_alive_interval_millis(&has_bits);
          keep_alive_interval_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 keep_alive_timeout_millis = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_keep_alive_timeout_millis(&has_bits);
          keep_alive_timeout_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 device_type = 10 [default = 0, deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_device_type(&has_bits);
          device_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes device_info = 11 [deprecated = true];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_device_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .location.nearby.connections.ConnectionsDevice connections_device = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_connections_device(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .location.nearby.connections.PresenceDevice presence_device = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_presence_device(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.ConnectionRequestFrame.ConnectionMode connection_mode = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::ConnectionRequestFrame_ConnectionMode_IsValid(val))) {
            _internal_set_connection_mode(static_cast<::location::nearby::connections::ConnectionRequestFrame_ConnectionMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionRequestFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionRequestFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string endpoint_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint_id(), target);
  }

  // optional string endpoint_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_endpoint_name(), target);
  }

  // optional bytes handshake_data = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_handshake_data(), target);
  }

  // optional int32 nonce = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_nonce(), target);
  }

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
  for (int i = 0, n = this->_internal_mediums_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        5, this->_internal_mediums(i), target);
  }

  // optional bytes endpoint_info = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_endpoint_info(), target);
  }

  // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::medium_metadata(this), target, stream);
  }

  // optional int32 keep_alive_interval_millis = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_keep_alive_interval_millis(), target);
  }

  // optional int32 keep_alive_timeout_millis = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_keep_alive_timeout_millis(), target);
  }

  // optional int32 device_type = 10 [default = 0, deprecated = true];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_device_type(), target);
  }

  // optional bytes device_info = 11 [deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_device_info(), target);
  }

  switch (Device_case()) {
    case kConnectionsDevice: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          12, _Internal::connections_device(this), target, stream);
      break;
    }
    case kPresenceDevice: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          13, _Internal::presence_device(this), target, stream);
      break;
    }
    default: ;
  }
  // optional .location.nearby.connections.ConnectionRequestFrame.ConnectionMode connection_mode = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      14, this->_internal_connection_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionRequestFrame)
  return target;
}

size_t ConnectionRequestFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionRequestFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_mediums_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_mediums(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string endpoint_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_id());
    }

    // optional string endpoint_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_name());
    }

    // optional bytes handshake_data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_handshake_data());
    }

    // optional bytes endpoint_info = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_endpoint_info());
    }

    // optional bytes device_info = 11 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_device_info());
    }

    // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *medium_metadata_);
    }

    // optional int32 nonce = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_nonce());
    }

    // optional int32 keep_alive_interval_millis = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_keep_alive_interval_millis());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 keep_alive_timeout_millis = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_keep_alive_timeout_millis());
    }

    // optional int32 device_type = 10 [default = 0, deprecated = true];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_device_type());
    }

    // optional .location.nearby.connections.ConnectionRequestFrame.ConnectionMode connection_mode = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_connection_mode());
    }

  }
  switch (Device_case()) {
    // .location.nearby.connections.ConnectionsDevice connections_device = 12;
    case kConnectionsDevice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Device_.connections_device_);
      break;
    }
    // .location.nearby.connections.PresenceDevice presence_device = 13;
    case kPresenceDevice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Device_.presence_device_);
      break;
    }
    case DEVICE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionRequestFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConnectionRequestFrame*>(
      &from));
}

void ConnectionRequestFrame::MergeFrom(const ConnectionRequestFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionRequestFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mediums_.MergeFrom(from.mediums_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_endpoint_name(from._internal_endpoint_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_handshake_data(from._internal_handshake_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_endpoint_info(from._internal_endpoint_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_device_info(from._internal_device_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_medium_metadata()->::location::nearby::connections::MediumMetadata::MergeFrom(from._internal_medium_metadata());
    }
    if (cached_has_bits & 0x00000040u) {
      nonce_ = from.nonce_;
    }
    if (cached_has_bits & 0x00000080u) {
      keep_alive_interval_millis_ = from.keep_alive_interval_millis_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      keep_alive_timeout_millis_ = from.keep_alive_timeout_millis_;
    }
    if (cached_has_bits & 0x00000200u) {
      device_type_ = from.device_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      connection_mode_ = from.connection_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.Device_case()) {
    case kConnectionsDevice: {
      _internal_mutable_connections_device()->::location::nearby::connections::ConnectionsDevice::MergeFrom(from._internal_connections_device());
      break;
    }
    case kPresenceDevice: {
      _internal_mutable_presence_device()->::location::nearby::connections::PresenceDevice::MergeFrom(from._internal_presence_device());
      break;
    }
    case DEVICE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionRequestFrame::CopyFrom(const ConnectionRequestFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionRequestFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionRequestFrame::IsInitialized() const {
  return true;
}

void ConnectionRequestFrame::InternalSwap(ConnectionRequestFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mediums_.InternalSwap(&other->mediums_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_id_, lhs_arena,
      &other->endpoint_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_name_, lhs_arena,
      &other->endpoint_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &handshake_data_, lhs_arena,
      &other->handshake_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_info_, lhs_arena,
      &other->endpoint_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_info_, lhs_arena,
      &other->device_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, connection_mode_)
      + sizeof(ConnectionRequestFrame::connection_mode_)
      - PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, medium_metadata_)>(
          reinterpret_cast<char*>(&medium_metadata_),
          reinterpret_cast<char*>(&other->medium_metadata_));
  swap(Device_, other->Device_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ConnectionRequestFrame::GetTypeName() const {
  return "location.nearby.connections.ConnectionRequestFrame";
}


// ===================================================================

class ConnectionResponseFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionResponseFrame>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_handshake_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::OsInfo& os_info(const ConnectionResponseFrame* msg);
  static void set_has_os_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_multiplex_socket_bitmask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nearby_connections_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_safe_to_disconnect_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::location::nearby::connections::OsInfo&
ConnectionResponseFrame::_Internal::os_info(const ConnectionResponseFrame* msg) {
  return *msg->os_info_;
}
ConnectionResponseFrame::ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionResponseFrame)
}
ConnectionResponseFrame::ConnectionResponseFrame(const ConnectionResponseFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_handshake_data()) {
    handshake_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_handshake_data(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_os_info()) {
    os_info_ = new ::location::nearby::connections::OsInfo(*from.os_info_);
  } else {
    os_info_ = nullptr;
  }
  ::memcpy(&status_, &from.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&safe_to_disconnect_version_) -
    reinterpret_cast<char*>(&status_)) + sizeof(safe_to_disconnect_version_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionResponseFrame)
}

inline void ConnectionResponseFrame::SharedCtor() {
handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&os_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&safe_to_disconnect_version_) -
    reinterpret_cast<char*>(&os_info_)) + sizeof(safe_to_disconnect_version_));
}

ConnectionResponseFrame::~ConnectionResponseFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionResponseFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConnectionResponseFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  handshake_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete os_info_;
}

void ConnectionResponseFrame::ArenaDtor(void* object) {
  ConnectionResponseFrame* _this = reinterpret_cast< ConnectionResponseFrame* >(object);
  (void)_this;
}
void ConnectionResponseFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConnectionResponseFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConnectionResponseFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionResponseFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      handshake_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(os_info_ != nullptr);
      os_info_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&safe_to_disconnect_version_) -
        reinterpret_cast<char*>(&status_)) + sizeof(safe_to_disconnect_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionResponseFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 status = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes handshake_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_handshake_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus_IsValid(val))) {
            _internal_set_response(static_cast<::location::nearby::connections::ConnectionResponseFrame_ResponseStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.OsInfo os_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_os_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 multiplex_socket_bitmask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_multiplex_socket_bitmask(&has_bits);
          multiplex_socket_bitmask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nearby_connections_version = 6 [deprecated = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nearby_connections_version(&has_bits);
          nearby_connections_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 safe_to_disconnect_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_safe_to_disconnect_version(&has_bits);
          safe_to_disconnect_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionResponseFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionResponseFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 status = 1 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_status(), target);
  }

  // optional bytes handshake_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_handshake_data(), target);
  }

  // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_response(), target);
  }

  // optional .location.nearby.connections.OsInfo os_info = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::os_info(this), target, stream);
  }

  // optional int32 multiplex_socket_bitmask = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_multiplex_socket_bitmask(), target);
  }

  // optional int32 nearby_connections_version = 6 [deprecated = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_nearby_connections_version(), target);
  }

  // optional int32 safe_to_disconnect_version = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_safe_to_disconnect_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionResponseFrame)
  return target;
}

size_t ConnectionResponseFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionResponseFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes handshake_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_handshake_data());
    }

    // optional .location.nearby.connections.OsInfo os_info = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *os_info_);
    }

    // optional int32 status = 1 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_status());
    }

    // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_response());
    }

    // optional int32 multiplex_socket_bitmask = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_multiplex_socket_bitmask());
    }

    // optional int32 nearby_connections_version = 6 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_nearby_connections_version());
    }

    // optional int32 safe_to_disconnect_version = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_safe_to_disconnect_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionResponseFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConnectionResponseFrame*>(
      &from));
}

void ConnectionResponseFrame::MergeFrom(const ConnectionResponseFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionResponseFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_handshake_data(from._internal_handshake_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_os_info()->::location::nearby::connections::OsInfo::MergeFrom(from._internal_os_info());
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000008u) {
      response_ = from.response_;
    }
    if (cached_has_bits & 0x00000010u) {
      multiplex_socket_bitmask_ = from.multiplex_socket_bitmask_;
    }
    if (cached_has_bits & 0x00000020u) {
      nearby_connections_version_ = from.nearby_connections_version_;
    }
    if (cached_has_bits & 0x00000040u) {
      safe_to_disconnect_version_ = from.safe_to_disconnect_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionResponseFrame::CopyFrom(const ConnectionResponseFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionResponseFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionResponseFrame::IsInitialized() const {
  return true;
}

void ConnectionResponseFrame::InternalSwap(ConnectionResponseFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &handshake_data_, lhs_arena,
      &other->handshake_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, safe_to_disconnect_version_)
      + sizeof(ConnectionResponseFrame::safe_to_disconnect_version_)
      - PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, os_info_)>(
          reinterpret_cast<char*>(&os_info_),
          reinterpret_cast<char*>(&other->os_info_));
}

std::string ConnectionResponseFrame::GetTypeName() const {
  return "location.nearby.connections.ConnectionResponseFrame";
}


// ===================================================================

class PayloadTransferFrame_PayloadHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame_PayloadHeader>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_total_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_sensitive(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_folder(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
}
PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(const PayloadTransferFrame_PayloadHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_name()) {
    file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_name(), 
      GetArenaForAllocation());
  }
  parent_folder_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    parent_folder_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_parent_folder()) {
    parent_folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_parent_folder(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_sensitive_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_sensitive_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
}

inline void PayloadTransferFrame_PayloadHeader::SharedCtor() {
file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
parent_folder_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  parent_folder_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_sensitive_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_sensitive_));
}

PayloadTransferFrame_PayloadHeader::~PayloadTransferFrame_PayloadHeader() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame_PayloadHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  file_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  parent_folder_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PayloadTransferFrame_PayloadHeader::ArenaDtor(void* object) {
  PayloadTransferFrame_PayloadHeader* _this = reinterpret_cast< PayloadTransferFrame_PayloadHeader* >(object);
  (void)_this;
}
void PayloadTransferFrame_PayloadHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame_PayloadHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame_PayloadHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      file_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      parent_folder_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_sensitive_) -
        reinterpret_cast<char*>(&id_)) + sizeof(is_sensitive_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame_PayloadHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(val))) {
            _internal_set_type(static_cast<::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 total_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total_size(&has_bits);
          total_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_sensitive = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_sensitive(&has_bits);
          is_sensitive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string file_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_file_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string parent_folder = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_parent_folder();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame_PayloadHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_id(), target);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional int64 total_size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_total_size(), target);
  }

  // optional bool is_sensitive = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_sensitive(), target);
  }

  // optional string file_name = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_file_name(), target);
  }

  // optional string parent_folder = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_parent_folder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  return target;
}

size_t PayloadTransferFrame_PayloadHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string file_name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_name());
    }

    // optional string parent_folder = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parent_folder());
    }

    // optional int64 id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_id());
    }

    // optional int64 total_size = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_total_size());
    }

    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool is_sensitive = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame_PayloadHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame_PayloadHeader*>(
      &from));
}

void PayloadTransferFrame_PayloadHeader::MergeFrom(const PayloadTransferFrame_PayloadHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_file_name(from._internal_file_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_parent_folder(from._internal_parent_folder());
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      total_size_ = from.total_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_sensitive_ = from.is_sensitive_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame_PayloadHeader::CopyFrom(const PayloadTransferFrame_PayloadHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame_PayloadHeader::IsInitialized() const {
  return true;
}

void PayloadTransferFrame_PayloadHeader::InternalSwap(PayloadTransferFrame_PayloadHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_name_, lhs_arena,
      &other->file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &parent_folder_, lhs_arena,
      &other->parent_folder_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, is_sensitive_)
      + sizeof(PayloadTransferFrame_PayloadHeader::is_sensitive_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

std::string PayloadTransferFrame_PayloadHeader::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame.PayloadHeader";
}


// ===================================================================

class PayloadTransferFrame_PayloadChunk::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame_PayloadChunk>()._has_bits_);
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
}
PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(const PayloadTransferFrame_PayloadChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  body_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_body(), 
      GetArenaForAllocation());
  }
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
}

inline void PayloadTransferFrame_PayloadChunk::SharedCtor() {
body_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&offset_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(index_));
}

PayloadTransferFrame_PayloadChunk::~PayloadTransferFrame_PayloadChunk() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame_PayloadChunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  body_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PayloadTransferFrame_PayloadChunk::ArenaDtor(void* object) {
  PayloadTransferFrame_PayloadChunk* _this = reinterpret_cast< PayloadTransferFrame_PayloadChunk* >(object);
  (void)_this;
}
void PayloadTransferFrame_PayloadChunk::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame_PayloadChunk::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame_PayloadChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    body_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame_PayloadChunk::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_body();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame_PayloadChunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 flags = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_flags(), target);
  }

  // optional int64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_offset(), target);
  }

  // optional bytes body = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_body(), target);
  }

  // optional int32 index = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  return target;
}

size_t PayloadTransferFrame_PayloadChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes body = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_body());
    }

    // optional int64 offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int32 flags = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional int32 index = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame_PayloadChunk::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame_PayloadChunk*>(
      &from));
}

void PayloadTransferFrame_PayloadChunk::MergeFrom(const PayloadTransferFrame_PayloadChunk& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame_PayloadChunk::CopyFrom(const PayloadTransferFrame_PayloadChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame_PayloadChunk::IsInitialized() const {
  return true;
}

void PayloadTransferFrame_PayloadChunk::InternalSwap(PayloadTransferFrame_PayloadChunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &body_, lhs_arena,
      &other->body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, index_)
      + sizeof(PayloadTransferFrame_PayloadChunk::index_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, offset_)>(
          reinterpret_cast<char*>(&offset_),
          reinterpret_cast<char*>(&other->offset_));
}

std::string PayloadTransferFrame_PayloadChunk::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame.PayloadChunk";
}


// ===================================================================

class PayloadTransferFrame_ControlMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame_ControlMessage>()._has_bits_);
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
}
PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(const PayloadTransferFrame_ControlMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&event_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(event_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
}

inline void PayloadTransferFrame_ControlMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&offset_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&event_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(event_));
}

PayloadTransferFrame_ControlMessage::~PayloadTransferFrame_ControlMessage() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame_ControlMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PayloadTransferFrame_ControlMessage::ArenaDtor(void* object) {
  PayloadTransferFrame_ControlMessage* _this = reinterpret_cast< PayloadTransferFrame_ControlMessage* >(object);
  (void)_this;
}
void PayloadTransferFrame_ControlMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame_ControlMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame_ControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&event_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(event_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame_ControlMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType_IsValid(val))) {
            _internal_set_event(static_cast<::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame_ControlMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event(), target);
  }

  // optional int64 offset = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  return target;
}

size_t PayloadTransferFrame_ControlMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 offset = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame_ControlMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame_ControlMessage*>(
      &from));
}

void PayloadTransferFrame_ControlMessage::MergeFrom(const PayloadTransferFrame_ControlMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000002u) {
      event_ = from.event_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame_ControlMessage::CopyFrom(const PayloadTransferFrame_ControlMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame_ControlMessage::IsInitialized() const {
  return true;
}

void PayloadTransferFrame_ControlMessage::InternalSwap(PayloadTransferFrame_ControlMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, event_)
      + sizeof(PayloadTransferFrame_ControlMessage::event_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, offset_)>(
          reinterpret_cast<char*>(&offset_),
          reinterpret_cast<char*>(&other->offset_));
}

std::string PayloadTransferFrame_ControlMessage::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame.ControlMessage";
}


// ===================================================================

class PayloadTransferFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame>()._has_bits_);
  static void set_has_packet_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& payload_header(const PayloadTransferFrame* msg);
  static void set_has_payload_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& payload_chunk(const PayloadTransferFrame* msg);
  static void set_has_payload_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& control_message(const PayloadTransferFrame* msg);
  static void set_has_control_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader&
PayloadTransferFrame::_Internal::payload_header(const PayloadTransferFrame* msg) {
  return *msg->payload_header_;
}
const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk&
PayloadTransferFrame::_Internal::payload_chunk(const PayloadTransferFrame* msg) {
  return *msg->payload_chunk_;
}
const ::location::nearby::connections::PayloadTransferFrame_ControlMessage&
PayloadTransferFrame::_Internal::control_message(const PayloadTransferFrame* msg) {
  return *msg->control_message_;
}
PayloadTransferFrame::PayloadTransferFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame)
}
PayloadTransferFrame::PayloadTransferFrame(const PayloadTransferFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_payload_header()) {
    payload_header_ = new ::location::nearby::connections::PayloadTransferFrame_PayloadHeader(*from.payload_header_);
  } else {
    payload_header_ = nullptr;
  }
  if (from._internal_has_payload_chunk()) {
    payload_chunk_ = new ::location::nearby::connections::PayloadTransferFrame_PayloadChunk(*from.payload_chunk_);
  } else {
    payload_chunk_ = nullptr;
  }
  if (from._internal_has_control_message()) {
    control_message_ = new ::location::nearby::connections::PayloadTransferFrame_ControlMessage(*from.control_message_);
  } else {
    control_message_ = nullptr;
  }
  packet_type_ = from.packet_type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame)
}

inline void PayloadTransferFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&payload_header_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&packet_type_) -
    reinterpret_cast<char*>(&payload_header_)) + sizeof(packet_type_));
}

PayloadTransferFrame::~PayloadTransferFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete payload_header_;
  if (this != internal_default_instance()) delete payload_chunk_;
  if (this != internal_default_instance()) delete control_message_;
}

void PayloadTransferFrame::ArenaDtor(void* object) {
  PayloadTransferFrame* _this = reinterpret_cast< PayloadTransferFrame* >(object);
  (void)_this;
}
void PayloadTransferFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(payload_header_ != nullptr);
      payload_header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(payload_chunk_ != nullptr);
      payload_chunk_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(control_message_ != nullptr);
      control_message_->Clear();
    }
  }
  packet_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::PayloadTransferFrame_PacketType_IsValid(val))) {
            _internal_set_packet_type(static_cast<::location::nearby::connections::PayloadTransferFrame_PacketType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_payload_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_payload_chunk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_control_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_packet_type(), target);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::payload_header(this), target, stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::payload_chunk(this), target, stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::control_message(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame)
  return target;
}

size_t PayloadTransferFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_header_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_chunk_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *control_message_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_packet_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame*>(
      &from));
}

void PayloadTransferFrame::MergeFrom(const PayloadTransferFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_payload_header()->::location::nearby::connections::PayloadTransferFrame_PayloadHeader::MergeFrom(from._internal_payload_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_payload_chunk()->::location::nearby::connections::PayloadTransferFrame_PayloadChunk::MergeFrom(from._internal_payload_chunk());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_control_message()->::location::nearby::connections::PayloadTransferFrame_ControlMessage::MergeFrom(from._internal_control_message());
    }
    if (cached_has_bits & 0x00000008u) {
      packet_type_ = from.packet_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame::CopyFrom(const PayloadTransferFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame::IsInitialized() const {
  return true;
}

void PayloadTransferFrame::InternalSwap(PayloadTransferFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, packet_type_)
      + sizeof(PayloadTransferFrame::packet_type_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, payload_header_)>(
          reinterpret_cast<char*>(&payload_header_),
          reinterpret_cast<char*>(&other->payload_header_));
}

std::string PayloadTransferFrame::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>()._has_bits_);
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gateway(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::internal::LazyString BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_i_give_permission_to_break_this_code_default_gateway_{{{"0.0.0.0", 7}}, {nullptr}};
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssid()) {
    ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ssid(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  gateway_.UnsafeSetDefault(nullptr);
  if (from._internal_has_gateway()) {
    gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_gateway(), 
      GetArenaForAllocation());
  }
  ::memcpy(&port_, &from.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&frequency_) -
    reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SharedCtor() {
ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gateway_.UnsafeSetDefault(nullptr);
port_ = 0;
frequency_ = -1;
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  gateway_.DestroyNoArena(nullptr);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ssid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
       }
  }
  if (cached_has_bits & 0x00000018u) {
    port_ = 0;
    frequency_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ssid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gateway = 4 [default = "0.0.0.0"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_gateway();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 frequency = 5 [default = -1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_frequency(&has_bits);
          frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ssid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ssid(), target);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional int32 port = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  // optional string gateway = 4 [default = "0.0.0.0"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_gateway(), target);
  }

  // optional int32 frequency = 5 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_frequency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ssid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ssid());
    }

    // optional string password = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional string gateway = 4 [default = "0.0.0.0"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gateway());
    }

    // optional int32 port = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

    // optional int32 frequency = 5 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ssid(from._internal_ssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_gateway(from._internal_gateway());
    }
    if (cached_has_bits & 0x00000008u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00000010u) {
      frequency_ = from.frequency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ssid_, lhs_arena,
      &other->ssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      nullptr,
      &gateway_, lhs_arena,
      &other->gateway_, rhs_arena
  );
  swap(port_, other->port_);
  swap(frequency_, other->frequency_);
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>()._has_bits_);
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wifi_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_address(), 
      GetArenaForAllocation());
  }
  wifi_port_ = from.wifi_port_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SharedCtor() {
ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
wifi_port_ = 0;
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_address_.ClearNonDefaultToEmpty();
  }
  wifi_port_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wifi_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_wifi_port(&has_bits);
          wifi_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes ip_address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ip_address(), target);
  }

  // optional int32 wifi_port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_wifi_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes ip_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip_address());
    }

    // optional int32 wifi_port = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_wifi_port());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000002u) {
      wifi_port_ = from.wifi_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_address_, lhs_arena,
      &other->ip_address_, rhs_arena
  );
  swap(wifi_port_, other->wifi_port_);
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>()._has_bits_);
  static void set_has_service_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mac_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  service_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service_name()) {
    service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service_name(), 
      GetArenaForAllocation());
  }
  mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac_address()) {
    mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mac_address(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SharedCtor() {
service_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  service_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mac_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      service_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      mac_address_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string service_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mac_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string service_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service_name(), target);
  }

  // optional string mac_address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mac_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string service_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_service_name());
    }

    // optional string mac_address = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mac_address());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_service_name(from._internal_service_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_mac_address(from._internal_mac_address());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_name_, lhs_arena,
      &other->service_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mac_address_, lhs_arena,
      &other->mac_address_, rhs_arena
  );
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>()._has_bits_);
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_service_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  service_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service_id()) {
    service_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service_id(), 
      GetArenaForAllocation());
  }
  service_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service_info()) {
    service_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service_info(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SharedCtor() {
service_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
service_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  service_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  service_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      service_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      service_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      password_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string service_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes service_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_service_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string service_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service_id(), target);
  }

  // optional bytes service_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_service_info(), target);
  }

  // optional string password = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string service_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_service_id());
    }

    // optional bytes service_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_service_info());
    }

    // optional string password = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_service_id(from._internal_service_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_service_info(from._internal_service_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_password(from._internal_password());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_id_, lhs_arena,
      &other->service_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_info_, lhs_arena,
      &other->service_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>()._has_bits_);
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_gateway(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ip_v6_address(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::internal::LazyString BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_i_give_permission_to_break_this_code_default_gateway_{{{"0.0.0.0", 7}}, {nullptr}};
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssid()) {
    ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ssid(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  gateway_.UnsafeSetDefault(nullptr);
  if (from._internal_has_gateway()) {
    gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_gateway(), 
      GetArenaForAllocation());
  }
  ip_v6_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_v6_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_v6_address()) {
    ip_v6_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_v6_address(), 
      GetArenaForAllocation());
  }
  ::memcpy(&port_, &from.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&frequency_) -
    reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SharedCtor() {
ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gateway_.UnsafeSetDefault(nullptr);
ip_v6_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_v6_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&port_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frequency_) -
    reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  gateway_.DestroyNoArena(nullptr);
  ip_v6_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ssid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
       }
    if (cached_has_bits & 0x00000008u) {
      ip_v6_address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&frequency_) -
        reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ssid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 frequency = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_frequency(&has_bits);
          frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gateway = 5 [default = "0.0.0.0"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gateway();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ip_v6_address = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_ip_v6_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ssid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ssid(), target);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional int32 port = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  // optional int32 frequency = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_frequency(), target);
  }

  // optional string gateway = 5 [default = "0.0.0.0"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_gateway(), target);
  }

  // optional bytes ip_v6_address = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_ip_v6_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string ssid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ssid());
    }

    // optional string password = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional string gateway = 5 [default = "0.0.0.0"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gateway());
    }

    // optional bytes ip_v6_address = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip_v6_address());
    }

    // optional int32 port = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

    // optional int32 frequency = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ssid(from._internal_ssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_gateway(from._internal_gateway());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_ip_v6_address(from._internal_ip_v6_address());
    }
    if (cached_has_bits & 0x00000010u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00000020u) {
      frequency_ = from.frequency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ssid_, lhs_arena,
      &other->ssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      nullptr,
      &gateway_, lhs_arena,
      &other->gateway_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_v6_address_, lhs_arena,
      &other->ip_v6_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, frequency_)
      + sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::frequency_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, port_)>(
          reinterpret_cast<char*>(&port_),
          reinterpret_cast<char*>(&other->port_));
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>()._has_bits_);
  static void set_has_peer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::LocationHint& location_hint(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* msg);
  static void set_has_location_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::location::nearby::connections::LocationHint&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_Internal::location_hint(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* msg) {
  return *msg->location_hint_;
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  peer_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    peer_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_peer_id()) {
    peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_peer_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_location_hint()) {
    location_hint_ = new ::location::nearby::connections::LocationHint(*from.location_hint_);
  } else {
    location_hint_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SharedCtor() {
peer_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  peer_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
location_hint_ = nullptr;
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  peer_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete location_hint_;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      peer_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(location_hint_ != nullptr);
      location_hint_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string peer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_peer_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.LocationHint location_hint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_location_hint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string peer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_peer_id(), target);
  }

  // optional .location.nearby.connections.LocationHint location_hint = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::location_hint(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string peer_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_peer_id());
    }

    // optional .location.nearby.connections.LocationHint location_hint = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *location_hint_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_peer_id(from._internal_peer_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_location_hint()->::location::nearby::connections::LocationHint::MergeFrom(from._internal_location_hint());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &peer_id_, lhs_arena,
      &other->peer_id_, rhs_arena
  );
  swap(location_hint_, other->location_hint_);
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo>()._has_bits_);
  static void set_has_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& wifi_hotspot_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_hotspot_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& wifi_lan_socket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_lan_socket(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& bluetooth_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_bluetooth_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& wifi_aware_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_aware_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& wifi_direct_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_direct_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& web_rtc_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_web_rtc_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_supports_disabling_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_supports_client_introduction_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_hotspot_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_hotspot_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_lan_socket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_lan_socket_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::bluetooth_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->bluetooth_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_aware_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_aware_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_direct_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_direct_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::web_rtc_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->web_rtc_credentials_;
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_wifi_hotspot_credentials()) {
    wifi_hotspot_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(*from.wifi_hotspot_credentials_);
  } else {
    wifi_hotspot_credentials_ = nullptr;
  }
  if (from._internal_has_wifi_lan_socket()) {
    wifi_lan_socket_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(*from.wifi_lan_socket_);
  } else {
    wifi_lan_socket_ = nullptr;
  }
  if (from._internal_has_bluetooth_credentials()) {
    bluetooth_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(*from.bluetooth_credentials_);
  } else {
    bluetooth_credentials_ = nullptr;
  }
  if (from._internal_has_wifi_aware_credentials()) {
    wifi_aware_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(*from.wifi_aware_credentials_);
  } else {
    wifi_aware_credentials_ = nullptr;
  }
  if (from._internal_has_wifi_direct_credentials()) {
    wifi_direct_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(*from.wifi_direct_credentials_);
  } else {
    wifi_direct_credentials_ = nullptr;
  }
  if (from._internal_has_web_rtc_credentials()) {
    web_rtc_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(*from.web_rtc_credentials_);
  } else {
    web_rtc_credentials_ = nullptr;
  }
  ::memcpy(&medium_, &from.medium_,
    static_cast<size_t>(reinterpret_cast<char*>(&supports_client_introduction_ack_) -
    reinterpret_cast<char*>(&medium_)) + sizeof(supports_client_introduction_ack_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&wifi_hotspot_credentials_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&supports_client_introduction_ack_) -
    reinterpret_cast<char*>(&wifi_hotspot_credentials_)) + sizeof(supports_client_introduction_ack_));
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete wifi_hotspot_credentials_;
  if (this != internal_default_instance()) delete wifi_lan_socket_;
  if (this != internal_default_instance()) delete bluetooth_credentials_;
  if (this != internal_default_instance()) delete wifi_aware_credentials_;
  if (this != internal_default_instance()) delete wifi_direct_credentials_;
  if (this != internal_default_instance()) delete web_rtc_credentials_;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(wifi_hotspot_credentials_ != nullptr);
      wifi_hotspot_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(wifi_lan_socket_ != nullptr);
      wifi_lan_socket_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(bluetooth_credentials_ != nullptr);
      bluetooth_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(wifi_aware_credentials_ != nullptr);
      wifi_aware_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(wifi_direct_credentials_ != nullptr);
      wifi_direct_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(web_rtc_credentials_ != nullptr);
      web_rtc_credentials_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&medium_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&supports_disabling_encryption_) -
        reinterpret_cast<char*>(&medium_)) + sizeof(supports_disabling_encryption_));
  }
  supports_client_introduction_ack_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(val))) {
            _internal_set_medium(static_cast<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_hotspot_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_lan_socket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_bluetooth_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_aware_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_direct_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_disabling_encryption = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_supports_disabling_encryption(&has_bits);
          supports_disabling_encryption_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_web_rtc_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_client_introduction_ack = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_supports_client_introduction_ack(&has_bits);
          supports_client_introduction_ack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_medium(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::wifi_hotspot_credentials(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::wifi_lan_socket(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::bluetooth_credentials(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::wifi_aware_credentials(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::wifi_direct_credentials(this), target, stream);
  }

  // optional bool supports_disabling_encryption = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_supports_disabling_encryption(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::web_rtc_credentials(this), target, stream);
  }

  // optional bool supports_client_introduction_ack = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_supports_client_introduction_ack(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_hotspot_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_lan_socket_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bluetooth_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_aware_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_direct_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *web_rtc_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_medium());
    }

    // optional bool supports_disabling_encryption = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool supports_client_introduction_ack = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_wifi_hotspot_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::MergeFrom(from._internal_wifi_hotspot_credentials());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_wifi_lan_socket()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::MergeFrom(from._internal_wifi_lan_socket());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_bluetooth_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::MergeFrom(from._internal_bluetooth_credentials());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_wifi_aware_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::MergeFrom(from._internal_wifi_aware_credentials());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_wifi_direct_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::MergeFrom(from._internal_wifi_direct_credentials());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_web_rtc_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::MergeFrom(from._internal_web_rtc_credentials());
    }
    if (cached_has_bits & 0x00000040u) {
      medium_ = from.medium_;
    }
    if (cached_has_bits & 0x00000080u) {
      supports_disabling_encryption_ = from.supports_disabling_encryption_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_supports_client_introduction_ack(from._internal_supports_client_introduction_ack());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, supports_client_introduction_ack_)
      + sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo::supports_client_introduction_ack_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, wifi_hotspot_credentials_)>(
          reinterpret_cast<char*>(&wifi_hotspot_credentials_),
          reinterpret_cast<char*>(&other->wifi_hotspot_credentials_));
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel>()._has_bits_);
  static void set_has_sta_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
}
BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sta_frequency_ = from.sta_frequency_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
}

inline void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::SharedCtor() {
sta_frequency_ = 0;
}

BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::~BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sta_frequency_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 sta_frequency = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sta_frequency(&has_bits);
          sta_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 sta_frequency = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sta_frequency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 sta_frequency = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sta_frequency());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::MergeFrom(const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sta_frequency()) {
    _internal_set_sta_frequency(from._internal_sta_frequency());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::CopyFrom(const BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::InternalSwap(BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sta_frequency_, other->sta_frequency_);
}

std::string BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_ClientIntroduction::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_ClientIntroduction>()._has_bits_);
  static void set_has_endpoint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_disabling_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
}
BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_id()) {
    endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_id(), 
      GetArenaForAllocation());
  }
  supports_disabling_encryption_ = from.supports_disabling_encryption_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SharedCtor() {
endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
supports_disabling_encryption_ = false;
}

BandwidthUpgradeNegotiationFrame_ClientIntroduction::~BandwidthUpgradeNegotiationFrame_ClientIntroduction() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  endpoint_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_ClientIntroduction* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_ClientIntroduction* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_ClientIntroduction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    endpoint_id_.ClearNonDefaultToEmpty();
  }
  supports_disabling_encryption_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_ClientIntroduction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string endpoint_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_disabling_encryption = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_supports_disabling_encryption(&has_bits);
          supports_disabling_encryption_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_ClientIntroduction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string endpoint_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint_id(), target);
  }

  // optional bool supports_disabling_encryption = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_supports_disabling_encryption(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_ClientIntroduction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string endpoint_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_id());
    }

    // optional bool supports_disabling_encryption = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_ClientIntroduction*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (cached_has_bits & 0x00000002u) {
      supports_disabling_encryption_ = from.supports_disabling_encryption_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_id_, lhs_arena,
      &other->endpoint_id_, rhs_arena
  );
  swap(supports_disabling_encryption_, other->supports_disabling_encryption_);
}

std::string BandwidthUpgradeNegotiationFrame_ClientIntroduction::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_Internal {
 public:
};

BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
}
BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SharedCtor() {
}

BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::~BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame>()._has_bits_);
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& upgrade_path_info(const BandwidthUpgradeNegotiationFrame* msg);
  static void set_has_upgrade_path_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& client_introduction(const BandwidthUpgradeNegotiationFrame* msg);
  static void set_has_client_introduction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& client_introduction_ack(const BandwidthUpgradeNegotiationFrame* msg);
  static void set_has_client_introduction_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel& safe_to_close_prior_channel(const BandwidthUpgradeNegotiationFrame* msg);
  static void set_has_safe_to_close_prior_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo&
BandwidthUpgradeNegotiationFrame::_Internal::upgrade_path_info(const BandwidthUpgradeNegotiationFrame* msg) {
  return *msg->upgrade_path_info_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction&
BandwidthUpgradeNegotiationFrame::_Internal::client_introduction(const BandwidthUpgradeNegotiationFrame* msg) {
  return *msg->client_introduction_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&
BandwidthUpgradeNegotiationFrame::_Internal::client_introduction_ack(const BandwidthUpgradeNegotiationFrame* msg) {
  return *msg->client_introduction_ack_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel&
BandwidthUpgradeNegotiationFrame::_Internal::safe_to_close_prior_channel(const BandwidthUpgradeNegotiationFrame* msg) {
  return *msg->safe_to_close_prior_channel_;
}
BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
}
BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(const BandwidthUpgradeNegotiationFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_upgrade_path_info()) {
    upgrade_path_info_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(*from.upgrade_path_info_);
  } else {
    upgrade_path_info_ = nullptr;
  }
  if (from._internal_has_client_introduction()) {
    client_introduction_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction(*from.client_introduction_);
  } else {
    client_introduction_ = nullptr;
  }
  if (from._internal_has_client_introduction_ack()) {
    client_introduction_ack_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(*from.client_introduction_ack_);
  } else {
    client_introduction_ack_ = nullptr;
  }
  if (from._internal_has_safe_to_close_prior_channel()) {
    safe_to_close_prior_channel_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel(*from.safe_to_close_prior_channel_);
  } else {
    safe_to_close_prior_channel_ = nullptr;
  }
  event_type_ = from.event_type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
}

inline void BandwidthUpgradeNegotiationFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&upgrade_path_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&event_type_) -
    reinterpret_cast<char*>(&upgrade_path_info_)) + sizeof(event_type_));
}

BandwidthUpgradeNegotiationFrame::~BandwidthUpgradeNegotiationFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete upgrade_path_info_;
  if (this != internal_default_instance()) delete client_introduction_;
  if (this != internal_default_instance()) delete client_introduction_ack_;
  if (this != internal_default_instance()) delete safe_to_close_prior_channel_;
}

void BandwidthUpgradeNegotiationFrame::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(upgrade_path_info_ != nullptr);
      upgrade_path_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_introduction_ != nullptr);
      client_introduction_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(client_introduction_ack_ != nullptr);
      client_introduction_ack_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(safe_to_close_prior_channel_ != nullptr);
      safe_to_close_prior_channel_->Clear();
    }
  }
  event_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_upgrade_path_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_introduction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_introduction_ack(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel safe_to_close_prior_channel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_safe_to_close_prior_channel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_type(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::upgrade_path_info(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::client_introduction(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::client_introduction_ack(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel safe_to_close_prior_channel = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::safe_to_close_prior_channel(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *upgrade_path_info_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_introduction_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_introduction_ack_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.SafeToClosePriorChannel safe_to_close_prior_channel = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *safe_to_close_prior_channel_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame::MergeFrom(const BandwidthUpgradeNegotiationFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_upgrade_path_info()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MergeFrom(from._internal_upgrade_path_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_introduction()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction::MergeFrom(from._internal_client_introduction());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_client_introduction_ack()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::MergeFrom(from._internal_client_introduction_ack());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_safe_to_close_prior_channel()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel::MergeFrom(from._internal_safe_to_close_prior_channel());
    }
    if (cached_has_bits & 0x00000010u) {
      event_type_ = from.event_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame::CopyFrom(const BandwidthUpgradeNegotiationFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame::InternalSwap(BandwidthUpgradeNegotiationFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, event_type_)
      + sizeof(BandwidthUpgradeNegotiationFrame::event_type_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, upgrade_path_info_)>(
          reinterpret_cast<char*>(&upgrade_path_info_),
          reinterpret_cast<char*>(&other->upgrade_path_info_));
}

std::string BandwidthUpgradeNegotiationFrame::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame";
}


// ===================================================================

class BandwidthUpgradeRetryFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeRetryFrame>()._has_bits_);
  static void set_has_is_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BandwidthUpgradeRetryFrame::BandwidthUpgradeRetryFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  supported_medium_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeRetryFrame)
}
BandwidthUpgradeRetryFrame::BandwidthUpgradeRetryFrame(const BandwidthUpgradeRetryFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      supported_medium_(from.supported_medium_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  is_request_ = from.is_request_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeRetryFrame)
}

inline void BandwidthUpgradeRetryFrame::SharedCtor() {
is_request_ = false;
}

BandwidthUpgradeRetryFrame::~BandwidthUpgradeRetryFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeRetryFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeRetryFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BandwidthUpgradeRetryFrame::ArenaDtor(void* object) {
  BandwidthUpgradeRetryFrame* _this = reinterpret_cast< BandwidthUpgradeRetryFrame* >(object);
  (void)_this;
}
void BandwidthUpgradeRetryFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeRetryFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeRetryFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_medium_.Clear();
  is_request_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeRetryFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium_IsValid(val))) {
              _internal_add_supported_medium(static_cast<::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_supported_medium(), ptr, ctx, ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_request(&has_bits);
          is_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeRetryFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
  for (int i = 0, n = this->_internal_supported_medium_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        1, this->_internal_supported_medium(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool is_request = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_request(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeRetryFrame)
  return target;
}

size_t BandwidthUpgradeRetryFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_medium_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_supported_medium(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // optional bool is_request = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeRetryFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeRetryFrame*>(
      &from));
}

void BandwidthUpgradeRetryFrame::MergeFrom(const BandwidthUpgradeRetryFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_medium_.MergeFrom(from.supported_medium_);
  if (from._internal_has_is_request()) {
    _internal_set_is_request(from._internal_is_request());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeRetryFrame::CopyFrom(const BandwidthUpgradeRetryFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeRetryFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeRetryFrame::IsInitialized() const {
  return true;
}

void BandwidthUpgradeRetryFrame::InternalSwap(BandwidthUpgradeRetryFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_medium_.InternalSwap(&other->supported_medium_);
  swap(is_request_, other->is_request_);
}

std::string BandwidthUpgradeRetryFrame::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeRetryFrame";
}


// ===================================================================

class KeepAliveFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<KeepAliveFrame>()._has_bits_);
  static void set_has_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KeepAliveFrame::KeepAliveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.KeepAliveFrame)
}
KeepAliveFrame::KeepAliveFrame(const KeepAliveFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&ack_, &from.ack_,
    static_cast<size_t>(reinterpret_cast<char*>(&seq_num_) -
    reinterpret_cast<char*>(&ack_)) + sizeof(seq_num_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.KeepAliveFrame)
}

inline void KeepAliveFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ack_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seq_num_) -
    reinterpret_cast<char*>(&ack_)) + sizeof(seq_num_));
}

KeepAliveFrame::~KeepAliveFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.KeepAliveFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KeepAliveFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeepAliveFrame::ArenaDtor(void* object) {
  KeepAliveFrame* _this = reinterpret_cast< KeepAliveFrame* >(object);
  (void)_this;
}
void KeepAliveFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeepAliveFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeepAliveFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.KeepAliveFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ack_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seq_num_) -
        reinterpret_cast<char*>(&ack_)) + sizeof(seq_num_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeepAliveFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool ack = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ack(&has_bits);
          ack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_seq_num(&has_bits);
          seq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeepAliveFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.KeepAliveFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool ack = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_ack(), target);
  }

  // optional uint32 seq_num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_seq_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.KeepAliveFrame)
  return target;
}

size_t KeepAliveFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.KeepAliveFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool ack = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional uint32 seq_num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeepAliveFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KeepAliveFrame*>(
      &from));
}

void KeepAliveFrame::MergeFrom(const KeepAliveFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.KeepAliveFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ack_ = from.ack_;
    }
    if (cached_has_bits & 0x00000002u) {
      seq_num_ = from.seq_num_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeepAliveFrame::CopyFrom(const KeepAliveFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.KeepAliveFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeepAliveFrame::IsInitialized() const {
  return true;
}

void KeepAliveFrame::InternalSwap(KeepAliveFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeepAliveFrame, seq_num_)
      + sizeof(KeepAliveFrame::seq_num_)
      - PROTOBUF_FIELD_OFFSET(KeepAliveFrame, ack_)>(
          reinterpret_cast<char*>(&ack_),
          reinterpret_cast<char*>(&other->ack_));
}

std::string KeepAliveFrame::GetTypeName() const {
  return "location.nearby.connections.KeepAliveFrame";
}


// ===================================================================

class DisconnectionFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<DisconnectionFrame>()._has_bits_);
  static void set_has_request_safe_to_disconnect(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ack_safe_to_disconnect(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DisconnectionFrame::DisconnectionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.DisconnectionFrame)
}
DisconnectionFrame::DisconnectionFrame(const DisconnectionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_safe_to_disconnect_, &from.request_safe_to_disconnect_,
    static_cast<size_t>(reinterpret_cast<char*>(&ack_safe_to_disconnect_) -
    reinterpret_cast<char*>(&request_safe_to_disconnect_)) + sizeof(ack_safe_to_disconnect_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.DisconnectionFrame)
}

inline void DisconnectionFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_safe_to_disconnect_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ack_safe_to_disconnect_) -
    reinterpret_cast<char*>(&request_safe_to_disconnect_)) + sizeof(ack_safe_to_disconnect_));
}

DisconnectionFrame::~DisconnectionFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.DisconnectionFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DisconnectionFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DisconnectionFrame::ArenaDtor(void* object) {
  DisconnectionFrame* _this = reinterpret_cast< DisconnectionFrame* >(object);
  (void)_this;
}
void DisconnectionFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DisconnectionFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DisconnectionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.DisconnectionFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&request_safe_to_disconnect_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ack_safe_to_disconnect_) -
      reinterpret_cast<char*>(&request_safe_to_disconnect_)) + sizeof(ack_safe_to_disconnect_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DisconnectionFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool request_safe_to_disconnect = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_safe_to_disconnect(&has_bits);
          request_safe_to_disconnect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ack_safe_to_disconnect = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ack_safe_to_disconnect(&has_bits);
          ack_safe_to_disconnect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DisconnectionFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.DisconnectionFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool request_safe_to_disconnect = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_request_safe_to_disconnect(), target);
  }

  // optional bool ack_safe_to_disconnect = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_ack_safe_to_disconnect(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.DisconnectionFrame)
  return target;
}

size_t DisconnectionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.DisconnectionFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool request_safe_to_disconnect = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool ack_safe_to_disconnect = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DisconnectionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DisconnectionFrame*>(
      &from));
}

void DisconnectionFrame::MergeFrom(const DisconnectionFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.DisconnectionFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      request_safe_to_disconnect_ = from.request_safe_to_disconnect_;
    }
    if (cached_has_bits & 0x00000002u) {
      ack_safe_to_disconnect_ = from.ack_safe_to_disconnect_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisconnectionFrame::CopyFrom(const DisconnectionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.DisconnectionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisconnectionFrame::IsInitialized() const {
  return true;
}

void DisconnectionFrame::InternalSwap(DisconnectionFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DisconnectionFrame, ack_safe_to_disconnect_)
      + sizeof(DisconnectionFrame::ack_safe_to_disconnect_)
      - PROTOBUF_FIELD_OFFSET(DisconnectionFrame, request_safe_to_disconnect_)>(
          reinterpret_cast<char*>(&request_safe_to_disconnect_),
          reinterpret_cast<char*>(&other->request_safe_to_disconnect_));
}

std::string DisconnectionFrame::GetTypeName() const {
  return "location.nearby.connections.DisconnectionFrame";
}


// ===================================================================

class PairedKeyEncryptionFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PairedKeyEncryptionFrame>()._has_bits_);
  static void set_has_signed_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PairedKeyEncryptionFrame)
}
PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  signed_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signed_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signed_data()) {
    signed_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signed_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PairedKeyEncryptionFrame)
}

inline void PairedKeyEncryptionFrame::SharedCtor() {
signed_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signed_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PairedKeyEncryptionFrame::~PairedKeyEncryptionFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PairedKeyEncryptionFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PairedKeyEncryptionFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signed_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PairedKeyEncryptionFrame::ArenaDtor(void* object) {
  PairedKeyEncryptionFrame* _this = reinterpret_cast< PairedKeyEncryptionFrame* >(object);
  (void)_this;
}
void PairedKeyEncryptionFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PairedKeyEncryptionFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PairedKeyEncryptionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PairedKeyEncryptionFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    signed_data_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PairedKeyEncryptionFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes signed_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_signed_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PairedKeyEncryptionFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PairedKeyEncryptionFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signed_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_signed_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PairedKeyEncryptionFrame)
  return target;
}

size_t PairedKeyEncryptionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PairedKeyEncryptionFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes signed_data = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signed_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairedKeyEncryptionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PairedKeyEncryptionFrame*>(
      &from));
}

void PairedKeyEncryptionFrame::MergeFrom(const PairedKeyEncryptionFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PairedKeyEncryptionFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_signed_data()) {
    _internal_set_signed_data(from._internal_signed_data());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PairedKeyEncryptionFrame::CopyFrom(const PairedKeyEncryptionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PairedKeyEncryptionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairedKeyEncryptionFrame::IsInitialized() const {
  return true;
}

void PairedKeyEncryptionFrame::InternalSwap(PairedKeyEncryptionFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signed_data_, lhs_arena,
      &other->signed_data_, rhs_arena
  );
}

std::string PairedKeyEncryptionFrame::GetTypeName() const {
  return "location.nearby.connections.PairedKeyEncryptionFrame";
}


// ===================================================================

class AuthenticationMessageFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthenticationMessageFrame>()._has_bits_);
  static void set_has_auth_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AuthenticationMessageFrame::AuthenticationMessageFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AuthenticationMessageFrame)
}
AuthenticationMessageFrame::AuthenticationMessageFrame(const AuthenticationMessageFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  auth_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    auth_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_message()) {
    auth_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_message(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AuthenticationMessageFrame)
}

inline void AuthenticationMessageFrame::SharedCtor() {
auth_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  auth_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthenticationMessageFrame::~AuthenticationMessageFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AuthenticationMessageFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AuthenticationMessageFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  auth_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AuthenticationMessageFrame::ArenaDtor(void* object) {
  AuthenticationMessageFrame* _this = reinterpret_cast< AuthenticationMessageFrame* >(object);
  (void)_this;
}
void AuthenticationMessageFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AuthenticationMessageFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthenticationMessageFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AuthenticationMessageFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    auth_message_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AuthenticationMessageFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes auth_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_auth_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthenticationMessageFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AuthenticationMessageFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes auth_message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_auth_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AuthenticationMessageFrame)
  return target;
}

size_t AuthenticationMessageFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AuthenticationMessageFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes auth_message = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_auth_message());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthenticationMessageFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthenticationMessageFrame*>(
      &from));
}

void AuthenticationMessageFrame::MergeFrom(const AuthenticationMessageFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AuthenticationMessageFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_auth_message()) {
    _internal_set_auth_message(from._internal_auth_message());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthenticationMessageFrame::CopyFrom(const AuthenticationMessageFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AuthenticationMessageFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationMessageFrame::IsInitialized() const {
  return true;
}

void AuthenticationMessageFrame::InternalSwap(AuthenticationMessageFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_message_, lhs_arena,
      &other->auth_message_, rhs_arena
  );
}

std::string AuthenticationMessageFrame::GetTypeName() const {
  return "location.nearby.connections.AuthenticationMessageFrame";
}


// ===================================================================

class AuthenticationResultFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthenticationResultFrame>()._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AuthenticationResultFrame::AuthenticationResultFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AuthenticationResultFrame)
}
AuthenticationResultFrame::AuthenticationResultFrame(const AuthenticationResultFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  result_ = from.result_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AuthenticationResultFrame)
}

inline void AuthenticationResultFrame::SharedCtor() {
result_ = 0;
}

AuthenticationResultFrame::~AuthenticationResultFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AuthenticationResultFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AuthenticationResultFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AuthenticationResultFrame::ArenaDtor(void* object) {
  AuthenticationResultFrame* _this = reinterpret_cast< AuthenticationResultFrame* >(object);
  (void)_this;
}
void AuthenticationResultFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AuthenticationResultFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthenticationResultFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AuthenticationResultFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  result_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AuthenticationResultFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthenticationResultFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AuthenticationResultFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AuthenticationResultFrame)
  return target;
}

size_t AuthenticationResultFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AuthenticationResultFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthenticationResultFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthenticationResultFrame*>(
      &from));
}

void AuthenticationResultFrame::MergeFrom(const AuthenticationResultFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AuthenticationResultFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_set_result(from._internal_result());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthenticationResultFrame::CopyFrom(const AuthenticationResultFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AuthenticationResultFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationResultFrame::IsInitialized() const {
  return true;
}

void AuthenticationResultFrame::InternalSwap(AuthenticationResultFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

std::string AuthenticationResultFrame::GetTypeName() const {
  return "location.nearby.connections.AuthenticationResultFrame";
}


// ===================================================================

class AutoResumeFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<AutoResumeFrame>()._has_bits_);
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pending_payload_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_next_payload_chunk_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AutoResumeFrame::AutoResumeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AutoResumeFrame)
}
AutoResumeFrame::AutoResumeFrame(const AutoResumeFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&pending_payload_id_, &from.pending_payload_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&next_payload_chunk_index_) -
    reinterpret_cast<char*>(&pending_payload_id_)) + sizeof(next_payload_chunk_index_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AutoResumeFrame)
}

inline void AutoResumeFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pending_payload_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&next_payload_chunk_index_) -
    reinterpret_cast<char*>(&pending_payload_id_)) + sizeof(next_payload_chunk_index_));
}

AutoResumeFrame::~AutoResumeFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AutoResumeFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AutoResumeFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AutoResumeFrame::ArenaDtor(void* object) {
  AutoResumeFrame* _this = reinterpret_cast< AutoResumeFrame* >(object);
  (void)_this;
}
void AutoResumeFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AutoResumeFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutoResumeFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AutoResumeFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&pending_payload_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&next_payload_chunk_index_) -
        reinterpret_cast<char*>(&pending_payload_id_)) + sizeof(next_payload_chunk_index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutoResumeFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::AutoResumeFrame_EventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::location::nearby::connections::AutoResumeFrame_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 pending_payload_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pending_payload_id(&has_bits);
          pending_payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 next_payload_chunk_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_next_payload_chunk_index(&has_bits);
          next_payload_chunk_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoResumeFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AutoResumeFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_type(), target);
  }

  // optional int64 pending_payload_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_pending_payload_id(), target);
  }

  // optional int32 next_payload_chunk_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_next_payload_chunk_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AutoResumeFrame)
  return target;
}

size_t AutoResumeFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AutoResumeFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 pending_payload_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_pending_payload_id());
    }

    // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional int32 next_payload_chunk_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_next_payload_chunk_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutoResumeFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AutoResumeFrame*>(
      &from));
}

void AutoResumeFrame::MergeFrom(const AutoResumeFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AutoResumeFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      pending_payload_id_ = from.pending_payload_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      event_type_ = from.event_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      next_payload_chunk_index_ = from.next_payload_chunk_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutoResumeFrame::CopyFrom(const AutoResumeFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AutoResumeFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoResumeFrame::IsInitialized() const {
  return true;
}

void AutoResumeFrame::InternalSwap(AutoResumeFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutoResumeFrame, next_payload_chunk_index_)
      + sizeof(AutoResumeFrame::next_payload_chunk_index_)
      - PROTOBUF_FIELD_OFFSET(AutoResumeFrame, pending_payload_id_)>(
          reinterpret_cast<char*>(&pending_payload_id_),
          reinterpret_cast<char*>(&other->pending_payload_id_));
}

std::string AutoResumeFrame::GetTypeName() const {
  return "location.nearby.connections.AutoResumeFrame";
}


// ===================================================================

class AutoReconnectFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<AutoReconnectFrame>()._has_bits_);
  static void set_has_endpoint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AutoReconnectFrame::AutoReconnectFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AutoReconnectFrame)
}
AutoReconnectFrame::AutoReconnectFrame(const AutoReconnectFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_id()) {
    endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_id(), 
      GetArenaForAllocation());
  }
  event_type_ = from.event_type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AutoReconnectFrame)
}

inline void AutoReconnectFrame::SharedCtor() {
endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
event_type_ = 0;
}

AutoReconnectFrame::~AutoReconnectFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AutoReconnectFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AutoReconnectFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  endpoint_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AutoReconnectFrame::ArenaDtor(void* object) {
  AutoReconnectFrame* _this = reinterpret_cast< AutoReconnectFrame* >(object);
  (void)_this;
}
void AutoReconnectFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AutoReconnectFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutoReconnectFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AutoReconnectFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    endpoint_id_.ClearNonDefaultToEmpty();
  }
  event_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutoReconnectFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string endpoint_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::AutoReconnectFrame_EventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::location::nearby::connections::AutoReconnectFrame_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoReconnectFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AutoReconnectFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string endpoint_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint_id(), target);
  }

  // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AutoReconnectFrame)
  return target;
}

size_t AutoReconnectFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AutoReconnectFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string endpoint_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_id());
    }

    // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutoReconnectFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AutoReconnectFrame*>(
      &from));
}

void AutoReconnectFrame::MergeFrom(const AutoReconnectFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AutoReconnectFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (cached_has_bits & 0x00000002u) {
      event_type_ = from.event_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutoReconnectFrame::CopyFrom(const AutoReconnectFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AutoReconnectFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoReconnectFrame::IsInitialized() const {
  return true;
}

void AutoReconnectFrame::InternalSwap(AutoReconnectFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_id_, lhs_arena,
      &other->endpoint_id_, rhs_arena
  );
  swap(event_type_, other->event_type_);
}

std::string AutoReconnectFrame::GetTypeName() const {
  return "location.nearby.connections.AutoReconnectFrame";
}


// ===================================================================

class MediumMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<MediumMetadata>()._has_bits_);
  static void set_has_supports_5_ghz(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_supports_6_ghz(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mobile_radio(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ap_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::location::nearby::connections::AvailableChannels& available_channels(const MediumMetadata* msg);
  static void set_has_available_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::connections::WifiDirectCliUsableChannels& wifi_direct_cli_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_direct_cli_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::WifiLanUsableChannels& wifi_lan_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_lan_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::WifiAwareUsableChannels& wifi_aware_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_aware_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::location::nearby::connections::WifiHotspotStaUsableChannels& wifi_hotspot_sta_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_hotspot_sta_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::location::nearby::connections::AvailableChannels&
MediumMetadata::_Internal::available_channels(const MediumMetadata* msg) {
  return *msg->available_channels_;
}
const ::location::nearby::connections::WifiDirectCliUsableChannels&
MediumMetadata::_Internal::wifi_direct_cli_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_direct_cli_usable_channels_;
}
const ::location::nearby::connections::WifiLanUsableChannels&
MediumMetadata::_Internal::wifi_lan_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_lan_usable_channels_;
}
const ::location::nearby::connections::WifiAwareUsableChannels&
MediumMetadata::_Internal::wifi_aware_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_aware_usable_channels_;
}
const ::location::nearby::connections::WifiHotspotStaUsableChannels&
MediumMetadata::_Internal::wifi_hotspot_sta_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_hotspot_sta_usable_channels_;
}
MediumMetadata::MediumMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.MediumMetadata)
}
MediumMetadata::MediumMetadata(const MediumMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  bssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bssid()) {
    bssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_bssid(), 
      GetArenaForAllocation());
  }
  ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_address(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_available_channels()) {
    available_channels_ = new ::location::nearby::connections::AvailableChannels(*from.available_channels_);
  } else {
    available_channels_ = nullptr;
  }
  if (from._internal_has_wifi_direct_cli_usable_channels()) {
    wifi_direct_cli_usable_channels_ = new ::location::nearby::connections::WifiDirectCliUsableChannels(*from.wifi_direct_cli_usable_channels_);
  } else {
    wifi_direct_cli_usable_channels_ = nullptr;
  }
  if (from._internal_has_wifi_lan_usable_channels()) {
    wifi_lan_usable_channels_ = new ::location::nearby::connections::WifiLanUsableChannels(*from.wifi_lan_usable_channels_);
  } else {
    wifi_lan_usable_channels_ = nullptr;
  }
  if (from._internal_has_wifi_aware_usable_channels()) {
    wifi_aware_usable_channels_ = new ::location::nearby::connections::WifiAwareUsableChannels(*from.wifi_aware_usable_channels_);
  } else {
    wifi_aware_usable_channels_ = nullptr;
  }
  if (from._internal_has_wifi_hotspot_sta_usable_channels()) {
    wifi_hotspot_sta_usable_channels_ = new ::location::nearby::connections::WifiHotspotStaUsableChannels(*from.wifi_hotspot_sta_usable_channels_);
  } else {
    wifi_hotspot_sta_usable_channels_ = nullptr;
  }
  ::memcpy(&supports_5_ghz_, &from.supports_5_ghz_,
    static_cast<size_t>(reinterpret_cast<char*>(&ap_frequency_) -
    reinterpret_cast<char*>(&supports_5_ghz_)) + sizeof(ap_frequency_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.MediumMetadata)
}

inline void MediumMetadata::SharedCtor() {
bssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&available_channels_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mobile_radio_) -
    reinterpret_cast<char*>(&available_channels_)) + sizeof(mobile_radio_));
ap_frequency_ = -1;
}

MediumMetadata::~MediumMetadata() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.MediumMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MediumMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  bssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ip_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete available_channels_;
  if (this != internal_default_instance()) delete wifi_direct_cli_usable_channels_;
  if (this != internal_default_instance()) delete wifi_lan_usable_channels_;
  if (this != internal_default_instance()) delete wifi_aware_usable_channels_;
  if (this != internal_default_instance()) delete wifi_hotspot_sta_usable_channels_;
}

void MediumMetadata::ArenaDtor(void* object) {
  MediumMetadata* _this = reinterpret_cast< MediumMetadata* >(object);
  (void)_this;
}
void MediumMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MediumMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MediumMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.MediumMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      bssid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ip_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(available_channels_ != nullptr);
      available_channels_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(wifi_direct_cli_usable_channels_ != nullptr);
      wifi_direct_cli_usable_channels_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(wifi_lan_usable_channels_ != nullptr);
      wifi_lan_usable_channels_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(wifi_aware_usable_channels_ != nullptr);
      wifi_aware_usable_channels_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(wifi_hotspot_sta_usable_channels_ != nullptr);
      wifi_hotspot_sta_usable_channels_->Clear();
    }
  }
  supports_5_ghz_ = false;
  ::memset(&supports_6_ghz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mobile_radio_) -
      reinterpret_cast<char*>(&supports_6_ghz_)) + sizeof(mobile_radio_));
  ap_frequency_ = -1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MediumMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool supports_5_ghz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_supports_5_ghz(&has_bits);
          supports_5_ghz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bssid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ip_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_6_ghz = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_supports_6_ghz(&has_bits);
          supports_6_ghz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mobile_radio = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mobile_radio(&has_bits);
          mobile_radio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ap_frequency = 6 [default = -1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ap_frequency(&has_bits);
          ap_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.AvailableChannels available_channels = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_available_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_direct_cli_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_lan_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_aware_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_hotspot_sta_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediumMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.MediumMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool supports_5_ghz = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_supports_5_ghz(), target);
  }

  // optional string bssid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bssid(), target);
  }

  // optional bytes ip_address = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ip_address(), target);
  }

  // optional bool supports_6_ghz = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_supports_6_ghz(), target);
  }

  // optional bool mobile_radio = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_mobile_radio(), target);
  }

  // optional int32 ap_frequency = 6 [default = -1];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_ap_frequency(), target);
  }

  // optional .location.nearby.connections.AvailableChannels available_channels = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::available_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::wifi_direct_cli_usable_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::wifi_lan_usable_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::wifi_aware_usable_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::wifi_hotspot_sta_usable_channels(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.MediumMetadata)
  return target;
}

size_t MediumMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.MediumMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string bssid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bssid());
    }

    // optional bytes ip_address = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip_address());
    }

    // optional .location.nearby.connections.AvailableChannels available_channels = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *available_channels_);
    }

    // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_direct_cli_usable_channels_);
    }

    // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_lan_usable_channels_);
    }

    // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_aware_usable_channels_);
    }

    // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_hotspot_sta_usable_channels_);
    }

    // optional bool supports_5_ghz = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool supports_6_ghz = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool mobile_radio = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional int32 ap_frequency = 6 [default = -1];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ap_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MediumMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MediumMetadata*>(
      &from));
}

void MediumMetadata::MergeFrom(const MediumMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.MediumMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_bssid(from._internal_bssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_available_channels()->::location::nearby::connections::AvailableChannels::MergeFrom(from._internal_available_channels());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_wifi_direct_cli_usable_channels()->::location::nearby::connections::WifiDirectCliUsableChannels::MergeFrom(from._internal_wifi_direct_cli_usable_channels());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_wifi_lan_usable_channels()->::location::nearby::connections::WifiLanUsableChannels::MergeFrom(from._internal_wifi_lan_usable_channels());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_wifi_aware_usable_channels()->::location::nearby::connections::WifiAwareUsableChannels::MergeFrom(from._internal_wifi_aware_usable_channels());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_wifi_hotspot_sta_usable_channels()->::location::nearby::connections::WifiHotspotStaUsableChannels::MergeFrom(from._internal_wifi_hotspot_sta_usable_channels());
    }
    if (cached_has_bits & 0x00000080u) {
      supports_5_ghz_ = from.supports_5_ghz_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      supports_6_ghz_ = from.supports_6_ghz_;
    }
    if (cached_has_bits & 0x00000200u) {
      mobile_radio_ = from.mobile_radio_;
    }
    if (cached_has_bits & 0x00000400u) {
      ap_frequency_ = from.ap_frequency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MediumMetadata::CopyFrom(const MediumMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.MediumMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediumMetadata::IsInitialized() const {
  return true;
}

void MediumMetadata::InternalSwap(MediumMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &bssid_, lhs_arena,
      &other->bssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_address_, lhs_arena,
      &other->ip_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediumMetadata, mobile_radio_)
      + sizeof(MediumMetadata::mobile_radio_)
      - PROTOBUF_FIELD_OFFSET(MediumMetadata, available_channels_)>(
          reinterpret_cast<char*>(&available_channels_),
          reinterpret_cast<char*>(&other->available_channels_));
  swap(ap_frequency_, other->ap_frequency_);
}

std::string MediumMetadata::GetTypeName() const {
  return "location.nearby.connections.MediumMetadata";
}


// ===================================================================

class AvailableChannels::_Internal {
 public:
};

AvailableChannels::AvailableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AvailableChannels)
}
AvailableChannels::AvailableChannels(const AvailableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AvailableChannels)
}

inline void AvailableChannels::SharedCtor() {
}

AvailableChannels::~AvailableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AvailableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AvailableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AvailableChannels::ArenaDtor(void* object) {
  AvailableChannels* _this = reinterpret_cast< AvailableChannels* >(object);
  (void)_this;
}
void AvailableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvailableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvailableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AvailableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AvailableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvailableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AvailableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AvailableChannels)
  return target;
}

size_t AvailableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AvailableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AvailableChannels*>(
      &from));
}

void AvailableChannels::MergeFrom(const AvailableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AvailableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvailableChannels::CopyFrom(const AvailableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AvailableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableChannels::IsInitialized() const {
  return true;
}

void AvailableChannels::InternalSwap(AvailableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string AvailableChannels::GetTypeName() const {
  return "location.nearby.connections.AvailableChannels";
}


// ===================================================================

class WifiDirectCliUsableChannels::_Internal {
 public:
};

WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiDirectCliUsableChannels)
}
WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(const WifiDirectCliUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiDirectCliUsableChannels)
}

inline void WifiDirectCliUsableChannels::SharedCtor() {
}

WifiDirectCliUsableChannels::~WifiDirectCliUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiDirectCliUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiDirectCliUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiDirectCliUsableChannels::ArenaDtor(void* object) {
  WifiDirectCliUsableChannels* _this = reinterpret_cast< WifiDirectCliUsableChannels* >(object);
  (void)_this;
}
void WifiDirectCliUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiDirectCliUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiDirectCliUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiDirectCliUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiDirectCliUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiDirectCliUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiDirectCliUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiDirectCliUsableChannels)
  return target;
}

size_t WifiDirectCliUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiDirectCliUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiDirectCliUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiDirectCliUsableChannels*>(
      &from));
}

void WifiDirectCliUsableChannels::MergeFrom(const WifiDirectCliUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiDirectCliUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiDirectCliUsableChannels::CopyFrom(const WifiDirectCliUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiDirectCliUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiDirectCliUsableChannels::IsInitialized() const {
  return true;
}

void WifiDirectCliUsableChannels::InternalSwap(WifiDirectCliUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiDirectCliUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiDirectCliUsableChannels";
}


// ===================================================================

class WifiLanUsableChannels::_Internal {
 public:
};

WifiLanUsableChannels::WifiLanUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiLanUsableChannels)
}
WifiLanUsableChannels::WifiLanUsableChannels(const WifiLanUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiLanUsableChannels)
}

inline void WifiLanUsableChannels::SharedCtor() {
}

WifiLanUsableChannels::~WifiLanUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiLanUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiLanUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiLanUsableChannels::ArenaDtor(void* object) {
  WifiLanUsableChannels* _this = reinterpret_cast< WifiLanUsableChannels* >(object);
  (void)_this;
}
void WifiLanUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiLanUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiLanUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiLanUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiLanUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiLanUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiLanUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiLanUsableChannels)
  return target;
}

size_t WifiLanUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiLanUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiLanUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiLanUsableChannels*>(
      &from));
}

void WifiLanUsableChannels::MergeFrom(const WifiLanUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiLanUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiLanUsableChannels::CopyFrom(const WifiLanUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiLanUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiLanUsableChannels::IsInitialized() const {
  return true;
}

void WifiLanUsableChannels::InternalSwap(WifiLanUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiLanUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiLanUsableChannels";
}


// ===================================================================

class WifiAwareUsableChannels::_Internal {
 public:
};

WifiAwareUsableChannels::WifiAwareUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiAwareUsableChannels)
}
WifiAwareUsableChannels::WifiAwareUsableChannels(const WifiAwareUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiAwareUsableChannels)
}

inline void WifiAwareUsableChannels::SharedCtor() {
}

WifiAwareUsableChannels::~WifiAwareUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiAwareUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiAwareUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiAwareUsableChannels::ArenaDtor(void* object) {
  WifiAwareUsableChannels* _this = reinterpret_cast< WifiAwareUsableChannels* >(object);
  (void)_this;
}
void WifiAwareUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiAwareUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiAwareUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiAwareUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiAwareUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiAwareUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiAwareUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiAwareUsableChannels)
  return target;
}

size_t WifiAwareUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiAwareUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiAwareUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiAwareUsableChannels*>(
      &from));
}

void WifiAwareUsableChannels::MergeFrom(const WifiAwareUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiAwareUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiAwareUsableChannels::CopyFrom(const WifiAwareUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiAwareUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiAwareUsableChannels::IsInitialized() const {
  return true;
}

void WifiAwareUsableChannels::InternalSwap(WifiAwareUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiAwareUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiAwareUsableChannels";
}


// ===================================================================

class WifiHotspotStaUsableChannels::_Internal {
 public:
};

WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiHotspotStaUsableChannels)
}
WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(const WifiHotspotStaUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiHotspotStaUsableChannels)
}

inline void WifiHotspotStaUsableChannels::SharedCtor() {
}

WifiHotspotStaUsableChannels::~WifiHotspotStaUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiHotspotStaUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiHotspotStaUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiHotspotStaUsableChannels::ArenaDtor(void* object) {
  WifiHotspotStaUsableChannels* _this = reinterpret_cast< WifiHotspotStaUsableChannels* >(object);
  (void)_this;
}
void WifiHotspotStaUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiHotspotStaUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiHotspotStaUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiHotspotStaUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiHotspotStaUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiHotspotStaUsableChannels)
  return target;
}

size_t WifiHotspotStaUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiHotspotStaUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiHotspotStaUsableChannels*>(
      &from));
}

void WifiHotspotStaUsableChannels::MergeFrom(const WifiHotspotStaUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiHotspotStaUsableChannels::CopyFrom(const WifiHotspotStaUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiHotspotStaUsableChannels::IsInitialized() const {
  return true;
}

void WifiHotspotStaUsableChannels::InternalSwap(WifiHotspotStaUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiHotspotStaUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiHotspotStaUsableChannels";
}


// ===================================================================

class LocationHint::_Internal {
 public:
  using HasBits = decltype(std::declval<LocationHint>()._has_bits_);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LocationHint::LocationHint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.LocationHint)
}
LocationHint::LocationHint(const LocationHint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_location()) {
    location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_location(), 
      GetArenaForAllocation());
  }
  format_ = from.format_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.LocationHint)
}

inline void LocationHint::SharedCtor() {
location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
format_ = 0;
}

LocationHint::~LocationHint() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.LocationHint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LocationHint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  location_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LocationHint::ArenaDtor(void* object) {
  LocationHint* _this = reinterpret_cast< LocationHint* >(object);
  (void)_this;
}
void LocationHint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LocationHint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocationHint::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.LocationHint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    location_.ClearNonDefaultToEmpty();
  }
  format_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LocationHint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_location();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.LocationStandard.Format format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::LocationStandard_Format_IsValid(val))) {
            _internal_set_format(static_cast<::location::nearby::connections::LocationStandard_Format>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocationHint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.LocationHint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string location = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_location(), target);
  }

  // optional .location.nearby.connections.LocationStandard.Format format = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.LocationHint)
  return target;
}

size_t LocationHint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.LocationHint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string location = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_location());
    }

    // optional .location.nearby.connections.LocationStandard.Format format = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_format());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocationHint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LocationHint*>(
      &from));
}

void LocationHint::MergeFrom(const LocationHint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.LocationHint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_location(from._internal_location());
    }
    if (cached_has_bits & 0x00000002u) {
      format_ = from.format_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocationHint::CopyFrom(const LocationHint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.LocationHint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocationHint::IsInitialized() const {
  return true;
}

void LocationHint::InternalSwap(LocationHint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &location_, lhs_arena,
      &other->location_, rhs_arena
  );
  swap(format_, other->format_);
}

std::string LocationHint::GetTypeName() const {
  return "location.nearby.connections.LocationHint";
}


// ===================================================================

class LocationStandard::_Internal {
 public:
};

LocationStandard::LocationStandard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.LocationStandard)
}
LocationStandard::LocationStandard(const LocationStandard& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.LocationStandard)
}

inline void LocationStandard::SharedCtor() {
}

LocationStandard::~LocationStandard() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.LocationStandard)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LocationStandard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LocationStandard::ArenaDtor(void* object) {
  LocationStandard* _this = reinterpret_cast< LocationStandard* >(object);
  (void)_this;
}
void LocationStandard::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LocationStandard::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocationStandard::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.LocationStandard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LocationStandard::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocationStandard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.LocationStandard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.LocationStandard)
  return target;
}

size_t LocationStandard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.LocationStandard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocationStandard::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LocationStandard*>(
      &from));
}

void LocationStandard::MergeFrom(const LocationStandard& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.LocationStandard)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocationStandard::CopyFrom(const LocationStandard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.LocationStandard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocationStandard::IsInitialized() const {
  return true;
}

void LocationStandard::InternalSwap(LocationStandard* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LocationStandard::GetTypeName() const {
  return "location.nearby.connections.LocationStandard";
}


// ===================================================================

class OsInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<OsInfo>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OsInfo::OsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.OsInfo)
}
OsInfo::OsInfo(const OsInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.OsInfo)
}

inline void OsInfo::SharedCtor() {
type_ = 0;
}

OsInfo::~OsInfo() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.OsInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void OsInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OsInfo::ArenaDtor(void* object) {
  OsInfo* _this = reinterpret_cast< OsInfo* >(object);
  (void)_this;
}
void OsInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OsInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.OsInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OsInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.OsInfo.OsType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::OsInfo_OsType_IsValid(val))) {
            _internal_set_type(static_cast<::location::nearby::connections::OsInfo_OsType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OsInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.OsInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.OsInfo.OsType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.OsInfo)
  return target;
}

size_t OsInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.OsInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .location.nearby.connections.OsInfo.OsType type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OsInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const OsInfo*>(
      &from));
}

void OsInfo::MergeFrom(const OsInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.OsInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OsInfo::CopyFrom(const OsInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.OsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OsInfo::IsInitialized() const {
  return true;
}

void OsInfo::InternalSwap(OsInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
}

std::string OsInfo::GetTypeName() const {
  return "location.nearby.connections.OsInfo";
}


// ===================================================================

class ConnectionsDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsDevice>()._has_bits_);
  static void set_has_endpoint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_endpoint_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_connectivity_info_list(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ConnectionsDevice::ConnectionsDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionsDevice)
}
ConnectionsDevice::ConnectionsDevice(const ConnectionsDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_id()) {
    endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_id(), 
      GetArenaForAllocation());
  }
  connectivity_info_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_connectivity_info_list()) {
    connectivity_info_list_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_connectivity_info_list(), 
      GetArenaForAllocation());
  }
  endpoint_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_info()) {
    endpoint_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_info(), 
      GetArenaForAllocation());
  }
  endpoint_type_ = from.endpoint_type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionsDevice)
}

inline void ConnectionsDevice::SharedCtor() {
endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
connectivity_info_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
endpoint_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
endpoint_type_ = 0;
}

ConnectionsDevice::~ConnectionsDevice() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionsDevice)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConnectionsDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  endpoint_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  connectivity_info_list_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ConnectionsDevice::ArenaDtor(void* object) {
  ConnectionsDevice* _this = reinterpret_cast< ConnectionsDevice* >(object);
  (void)_this;
}
void ConnectionsDevice::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConnectionsDevice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConnectionsDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionsDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      connectivity_info_list_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      endpoint_info_.ClearNonDefaultToEmpty();
    }
  }
  endpoint_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsDevice::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string endpoint_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.EndpointType endpoint_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::EndpointType_IsValid(val))) {
            _internal_set_endpoint_type(static_cast<::location::nearby::connections::EndpointType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes connectivity_info_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_connectivity_info_list();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes endpoint_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_endpoint_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionsDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionsDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string endpoint_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint_id(), target);
  }

  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_endpoint_type(), target);
  }

  // optional bytes connectivity_info_list = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_connectivity_info_list(), target);
  }

  // optional bytes endpoint_info = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_endpoint_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionsDevice)
  return target;
}

size_t ConnectionsDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionsDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string endpoint_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_id());
    }

    // optional bytes connectivity_info_list = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_connectivity_info_list());
    }

    // optional bytes endpoint_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_endpoint_info());
    }

    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_endpoint_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsDevice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConnectionsDevice*>(
      &from));
}

void ConnectionsDevice::MergeFrom(const ConnectionsDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionsDevice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_connectivity_info_list(from._internal_connectivity_info_list());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_endpoint_info(from._internal_endpoint_info());
    }
    if (cached_has_bits & 0x00000008u) {
      endpoint_type_ = from.endpoint_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsDevice::CopyFrom(const ConnectionsDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionsDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsDevice::IsInitialized() const {
  return true;
}

void ConnectionsDevice::InternalSwap(ConnectionsDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_id_, lhs_arena,
      &other->endpoint_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &connectivity_info_list_, lhs_arena,
      &other->connectivity_info_list_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_info_, lhs_arena,
      &other->endpoint_info_, rhs_arena
  );
  swap(endpoint_type_, other->endpoint_type_);
}

std::string ConnectionsDevice::GetTypeName() const {
  return "location.nearby.connections.ConnectionsDevice";
}


// ===================================================================

class PresenceDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<PresenceDevice>()._has_bits_);
  static void set_has_endpoint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_endpoint_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_connectivity_info_list(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_device_image_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

PresenceDevice::PresenceDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  discovery_medium_(arena),
  actions_(arena),
  identity_type_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PresenceDevice)
}
PresenceDevice::PresenceDevice(const PresenceDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      discovery_medium_(from.discovery_medium_),
      actions_(from.actions_),
      identity_type_(from.identity_type_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_id()) {
    endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_id(), 
      GetArenaForAllocation());
  }
  connectivity_info_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_connectivity_info_list()) {
    connectivity_info_list_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_connectivity_info_list(), 
      GetArenaForAllocation());
  }
  device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_name()) {
    device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_name(), 
      GetArenaForAllocation());
  }
  device_image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_image_url()) {
    device_image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_image_url(), 
      GetArenaForAllocation());
  }
  ::memcpy(&device_id_, &from.device_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_type_) -
    reinterpret_cast<char*>(&device_id_)) + sizeof(device_type_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PresenceDevice)
}

inline void PresenceDevice::SharedCtor() {
endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
connectivity_info_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  connectivity_info_list_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&device_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_type_) -
    reinterpret_cast<char*>(&device_id_)) + sizeof(device_type_));
}

PresenceDevice::~PresenceDevice() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PresenceDevice)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PresenceDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  endpoint_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  connectivity_info_list_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_image_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PresenceDevice::ArenaDtor(void* object) {
  PresenceDevice* _this = reinterpret_cast< PresenceDevice* >(object);
  (void)_this;
}
void PresenceDevice::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PresenceDevice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PresenceDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PresenceDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  discovery_medium_.Clear();
  actions_.Clear();
  identity_type_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      connectivity_info_list_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      device_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      device_image_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&device_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_type_) -
        reinterpret_cast<char*>(&device_id_)) + sizeof(device_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PresenceDevice::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string endpoint_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.EndpointType endpoint_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::EndpointType_IsValid(val))) {
            _internal_set_endpoint_type(static_cast<::location::nearby::connections::EndpointType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes connectivity_info_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_connectivity_info_list();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 device_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_device_id(&has_bits);
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_device_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::PresenceDevice_DeviceType_IsValid(val))) {
            _internal_set_device_type(static_cast<::location::nearby::connections::PresenceDevice_DeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string device_image_url = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_device_image_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_discovery_medium(), ptr, ctx, ::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid, &_internal_metadata_, 8);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(val))) {
            _internal_add_discovery_medium(static_cast<::location::nearby::connections::ConnectionRequestFrame_Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated int32 actions = 9 [packed = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_actions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 72) {
          _internal_add_actions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 identity_type = 10 [packed = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_identity_type(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 80) {
          _internal_add_identity_type(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PresenceDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PresenceDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string endpoint_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint_id(), target);
  }

  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_endpoint_type(), target);
  }

  // optional bytes connectivity_info_list = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_connectivity_info_list(), target);
  }

  // optional int64 device_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_device_id(), target);
  }

  // optional string device_name = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_device_name(), target);
  }

  // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_device_type(), target);
  }

  // optional string device_image_url = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_device_image_url(), target);
  }

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
  {
    int byte_size = _discovery_medium_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          8, discovery_medium_, byte_size, target);
    }
  }

  // repeated int32 actions = 9 [packed = true];
  {
    int byte_size = _actions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          9, _internal_actions(), byte_size, target);
    }
  }

  // repeated int64 identity_type = 10 [packed = true];
  {
    int byte_size = _identity_type_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          10, _internal_identity_type(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PresenceDevice)
  return target;
}

size_t PresenceDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PresenceDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_discovery_medium_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_discovery_medium(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _discovery_medium_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 actions = 9 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->actions_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _actions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 identity_type = 10 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->identity_type_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _identity_type_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string endpoint_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_id());
    }

    // optional bytes connectivity_info_list = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_connectivity_info_list());
    }

    // optional string device_name = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_name());
    }

    // optional string device_image_url = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_image_url());
    }

    // optional int64 device_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_device_id());
    }

    // optional .location.nearby.connections.EndpointType endpoint_type = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_endpoint_type());
    }

    // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_device_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PresenceDevice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PresenceDevice*>(
      &from));
}

void PresenceDevice::MergeFrom(const PresenceDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PresenceDevice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  discovery_medium_.MergeFrom(from.discovery_medium_);
  actions_.MergeFrom(from.actions_);
  identity_type_.MergeFrom(from.identity_type_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_connectivity_info_list(from._internal_connectivity_info_list());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_device_name(from._internal_device_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_device_image_url(from._internal_device_image_url());
    }
    if (cached_has_bits & 0x00000010u) {
      device_id_ = from.device_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      endpoint_type_ = from.endpoint_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      device_type_ = from.device_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PresenceDevice::CopyFrom(const PresenceDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PresenceDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PresenceDevice::IsInitialized() const {
  return true;
}

void PresenceDevice::InternalSwap(PresenceDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  discovery_medium_.InternalSwap(&other->discovery_medium_);
  actions_.InternalSwap(&other->actions_);
  identity_type_.InternalSwap(&other->identity_type_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_id_, lhs_arena,
      &other->endpoint_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &connectivity_info_list_, lhs_arena,
      &other->connectivity_info_list_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_name_, lhs_arena,
      &other->device_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_image_url_, lhs_arena,
      &other->device_image_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PresenceDevice, device_type_)
      + sizeof(PresenceDevice::device_type_)
      - PROTOBUF_FIELD_OFFSET(PresenceDevice, device_id_)>(
          reinterpret_cast<char*>(&device_id_),
          reinterpret_cast<char*>(&other->device_id_));
}

std::string PresenceDevice::GetTypeName() const {
  return "location.nearby.connections.PresenceDevice";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace connections
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::location::nearby::connections::OfflineFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::OfflineFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::OfflineFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::V1Frame* Arena::CreateMaybeMessage< ::location::nearby::connections::V1Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::V1Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::ConnectionRequestFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::ConnectionRequestFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::ConnectionRequestFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::ConnectionResponseFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::ConnectionResponseFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::ConnectionResponseFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame_PayloadHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame_PayloadHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame_PayloadChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame_PayloadChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame_ControlMessage* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame_ControlMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame_ControlMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_SafeToClosePriorChannel >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeRetryFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeRetryFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeRetryFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::KeepAliveFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::KeepAliveFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::KeepAliveFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::DisconnectionFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::DisconnectionFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::DisconnectionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PairedKeyEncryptionFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::PairedKeyEncryptionFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PairedKeyEncryptionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::AuthenticationMessageFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::AuthenticationMessageFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::AuthenticationMessageFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::AuthenticationResultFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::AuthenticationResultFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::AuthenticationResultFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::AutoResumeFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::AutoResumeFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::AutoResumeFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::AutoReconnectFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::AutoReconnectFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::AutoReconnectFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::MediumMetadata* Arena::CreateMaybeMessage< ::location::nearby::connections::MediumMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::MediumMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::AvailableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::AvailableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::AvailableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiDirectCliUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiDirectCliUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiDirectCliUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiLanUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiLanUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiLanUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiAwareUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiAwareUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiAwareUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiHotspotStaUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiHotspotStaUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiHotspotStaUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::LocationHint* Arena::CreateMaybeMessage< ::location::nearby::connections::LocationHint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::LocationHint >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::LocationStandard* Arena::CreateMaybeMessage< ::location::nearby::connections::LocationStandard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::LocationStandard >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::OsInfo* Arena::CreateMaybeMessage< ::location::nearby::connections::OsInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::OsInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::ConnectionsDevice* Arena::CreateMaybeMessage< ::location::nearby::connections::ConnectionsDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::ConnectionsDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PresenceDevice* Arena::CreateMaybeMessage< ::location::nearby::connections::PresenceDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PresenceDevice >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
