// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connections/implementation/proto/offline_wire_formats.proto

#include "connections/implementation/proto/offline_wire_formats.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace location {
namespace nearby {
namespace connections {
constexpr OfflineFrame::OfflineFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : v1_(nullptr)
  , version_(0)
{}
struct OfflineFrameDefaultTypeInternal {
  constexpr OfflineFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OfflineFrameDefaultTypeInternal() {}
  union {
    OfflineFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OfflineFrameDefaultTypeInternal _OfflineFrame_default_instance_;
constexpr V1Frame::V1Frame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : connection_request_(nullptr)
  , connection_response_(nullptr)
  , payload_transfer_(nullptr)
  , bandwidth_upgrade_negotiation_(nullptr)
  , keep_alive_(nullptr)
  , disconnection_(nullptr)
  , paired_key_encryption_(nullptr)
  , type_(0)
{}
struct V1FrameDefaultTypeInternal {
  constexpr V1FrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~V1FrameDefaultTypeInternal() {}
  union {
    V1Frame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT V1FrameDefaultTypeInternal _V1Frame_default_instance_;
constexpr ConnectionRequestFrame::ConnectionRequestFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mediums_()
  , endpoint_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , endpoint_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , handshake_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , endpoint_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , medium_metadata_(nullptr)
  , nonce_(0)
  , keep_alive_interval_millis_(0)
  , keep_alive_timeout_millis_(0)
  , device_type_(0){}
struct ConnectionRequestFrameDefaultTypeInternal {
  constexpr ConnectionRequestFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConnectionRequestFrameDefaultTypeInternal() {}
  union {
    ConnectionRequestFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConnectionRequestFrameDefaultTypeInternal _ConnectionRequestFrame_default_instance_;
constexpr ConnectionResponseFrame::ConnectionResponseFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : handshake_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , status_(0)
  , response_(0)
{}
struct ConnectionResponseFrameDefaultTypeInternal {
  constexpr ConnectionResponseFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConnectionResponseFrameDefaultTypeInternal() {}
  union {
    ConnectionResponseFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
constexpr PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : file_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , parent_folder_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(int64_t{0})
  , total_size_(int64_t{0})
  , type_(0)

  , is_sensitive_(false){}
struct PayloadTransferFrame_PayloadHeaderDefaultTypeInternal {
  constexpr PayloadTransferFrame_PayloadHeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrame_PayloadHeaderDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_PayloadHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrame_PayloadHeaderDefaultTypeInternal _PayloadTransferFrame_PayloadHeader_default_instance_;
constexpr PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : body_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , offset_(int64_t{0})
  , flags_(0){}
struct PayloadTransferFrame_PayloadChunkDefaultTypeInternal {
  constexpr PayloadTransferFrame_PayloadChunkDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrame_PayloadChunkDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_PayloadChunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrame_PayloadChunkDefaultTypeInternal _PayloadTransferFrame_PayloadChunk_default_instance_;
constexpr PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : offset_(int64_t{0})
  , event_(0)
{}
struct PayloadTransferFrame_ControlMessageDefaultTypeInternal {
  constexpr PayloadTransferFrame_ControlMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrame_ControlMessageDefaultTypeInternal() {}
  union {
    PayloadTransferFrame_ControlMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrame_ControlMessageDefaultTypeInternal _PayloadTransferFrame_ControlMessage_default_instance_;
constexpr PayloadTransferFrame::PayloadTransferFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : payload_header_(nullptr)
  , payload_chunk_(nullptr)
  , control_message_(nullptr)
  , packet_type_(0)
{}
struct PayloadTransferFrameDefaultTypeInternal {
  constexpr PayloadTransferFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadTransferFrameDefaultTypeInternal() {}
  union {
    PayloadTransferFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadTransferFrameDefaultTypeInternal _PayloadTransferFrame_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gateway_(nullptr)
  , port_(0)
  , frequency_(-1){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , wifi_port_(0){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : service_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , mac_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : service_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , service_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gateway_(nullptr)
  , port_(0)
  , frequency_(0){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : peer_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , location_hint_(nullptr){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : wifi_hotspot_credentials_(nullptr)
  , wifi_lan_socket_(nullptr)
  , bluetooth_credentials_(nullptr)
  , wifi_aware_credentials_(nullptr)
  , wifi_direct_credentials_(nullptr)
  , web_rtc_credentials_(nullptr)
  , medium_(0)

  , supports_disabling_encryption_(false)
  , supports_client_introduction_ack_(false){}
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpoint_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , supports_disabling_encryption_(false){}
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_ClientIntroduction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame_ClientIntroductionAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_;
constexpr BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : upgrade_path_info_(nullptr)
  , client_introduction_(nullptr)
  , client_introduction_ack_(nullptr)
  , event_type_(0)
{}
struct BandwidthUpgradeNegotiationFrameDefaultTypeInternal {
  constexpr BandwidthUpgradeNegotiationFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BandwidthUpgradeNegotiationFrameDefaultTypeInternal() {}
  union {
    BandwidthUpgradeNegotiationFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BandwidthUpgradeNegotiationFrameDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_default_instance_;
constexpr KeepAliveFrame::KeepAliveFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ack_(false){}
struct KeepAliveFrameDefaultTypeInternal {
  constexpr KeepAliveFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeepAliveFrameDefaultTypeInternal() {}
  union {
    KeepAliveFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeepAliveFrameDefaultTypeInternal _KeepAliveFrame_default_instance_;
constexpr DisconnectionFrame::DisconnectionFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct DisconnectionFrameDefaultTypeInternal {
  constexpr DisconnectionFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DisconnectionFrameDefaultTypeInternal() {}
  union {
    DisconnectionFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DisconnectionFrameDefaultTypeInternal _DisconnectionFrame_default_instance_;
constexpr PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signed_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct PairedKeyEncryptionFrameDefaultTypeInternal {
  constexpr PairedKeyEncryptionFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PairedKeyEncryptionFrameDefaultTypeInternal() {}
  union {
    PairedKeyEncryptionFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;
constexpr MediumMetadata::MediumMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ip_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , available_channels_(nullptr)
  , wifi_direct_cli_usable_channels_(nullptr)
  , wifi_lan_usable_channels_(nullptr)
  , wifi_aware_usable_channels_(nullptr)
  , wifi_hotspot_sta_usable_channels_(nullptr)
  , supports_5_ghz_(false)
  , supports_6_ghz_(false)
  , mobile_radio_(false)
  , ap_frequency_(-1){}
struct MediumMetadataDefaultTypeInternal {
  constexpr MediumMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MediumMetadataDefaultTypeInternal() {}
  union {
    MediumMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MediumMetadataDefaultTypeInternal _MediumMetadata_default_instance_;
constexpr AvailableChannels::AvailableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct AvailableChannelsDefaultTypeInternal {
  constexpr AvailableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvailableChannelsDefaultTypeInternal() {}
  union {
    AvailableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvailableChannelsDefaultTypeInternal _AvailableChannels_default_instance_;
constexpr WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiDirectCliUsableChannelsDefaultTypeInternal {
  constexpr WifiDirectCliUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiDirectCliUsableChannelsDefaultTypeInternal() {}
  union {
    WifiDirectCliUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiDirectCliUsableChannelsDefaultTypeInternal _WifiDirectCliUsableChannels_default_instance_;
constexpr WifiLanUsableChannels::WifiLanUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiLanUsableChannelsDefaultTypeInternal {
  constexpr WifiLanUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiLanUsableChannelsDefaultTypeInternal() {}
  union {
    WifiLanUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiLanUsableChannelsDefaultTypeInternal _WifiLanUsableChannels_default_instance_;
constexpr WifiAwareUsableChannels::WifiAwareUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiAwareUsableChannelsDefaultTypeInternal {
  constexpr WifiAwareUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiAwareUsableChannelsDefaultTypeInternal() {}
  union {
    WifiAwareUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiAwareUsableChannelsDefaultTypeInternal _WifiAwareUsableChannels_default_instance_;
constexpr WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channels_()
  , _channels_cached_byte_size_(0){}
struct WifiHotspotStaUsableChannelsDefaultTypeInternal {
  constexpr WifiHotspotStaUsableChannelsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WifiHotspotStaUsableChannelsDefaultTypeInternal() {}
  union {
    WifiHotspotStaUsableChannels _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WifiHotspotStaUsableChannelsDefaultTypeInternal _WifiHotspotStaUsableChannels_default_instance_;
constexpr LocationHint::LocationHint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : location_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , format_(0)
{}
struct LocationHintDefaultTypeInternal {
  constexpr LocationHintDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LocationHintDefaultTypeInternal() {}
  union {
    LocationHint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LocationHintDefaultTypeInternal _LocationHint_default_instance_;
constexpr LocationStandard::LocationStandard(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LocationStandardDefaultTypeInternal {
  constexpr LocationStandardDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LocationStandardDefaultTypeInternal() {}
  union {
    LocationStandard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LocationStandardDefaultTypeInternal _LocationStandard_default_instance_;
}  // namespace connections
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace connections {
bool OfflineFrame_Version_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OfflineFrame_Version_strings[2] = {};

static const char OfflineFrame_Version_names[] =
  "UNKNOWN_VERSION"
  "V1";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OfflineFrame_Version_entries[] = {
  { {OfflineFrame_Version_names + 0, 15}, 0 },
  { {OfflineFrame_Version_names + 15, 2}, 1 },
};

static const int OfflineFrame_Version_entries_by_number[] = {
  0, // 0 -> UNKNOWN_VERSION
  1, // 1 -> V1
};

const std::string& OfflineFrame_Version_Name(
    OfflineFrame_Version value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OfflineFrame_Version_entries,
          OfflineFrame_Version_entries_by_number,
          2, OfflineFrame_Version_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OfflineFrame_Version_entries,
      OfflineFrame_Version_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OfflineFrame_Version_strings[idx].get();
}
bool OfflineFrame_Version_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfflineFrame_Version* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OfflineFrame_Version_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<OfflineFrame_Version>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr OfflineFrame_Version OfflineFrame::UNKNOWN_VERSION;
constexpr OfflineFrame_Version OfflineFrame::V1;
constexpr OfflineFrame_Version OfflineFrame::Version_MIN;
constexpr OfflineFrame_Version OfflineFrame::Version_MAX;
constexpr int OfflineFrame::Version_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool V1Frame_FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> V1Frame_FrameType_strings[8] = {};

static const char V1Frame_FrameType_names[] =
  "BANDWIDTH_UPGRADE_NEGOTIATION"
  "CONNECTION_REQUEST"
  "CONNECTION_RESPONSE"
  "DISCONNECTION"
  "KEEP_ALIVE"
  "PAIRED_KEY_ENCRYPTION"
  "PAYLOAD_TRANSFER"
  "UNKNOWN_FRAME_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry V1Frame_FrameType_entries[] = {
  { {V1Frame_FrameType_names + 0, 29}, 4 },
  { {V1Frame_FrameType_names + 29, 18}, 1 },
  { {V1Frame_FrameType_names + 47, 19}, 2 },
  { {V1Frame_FrameType_names + 66, 13}, 6 },
  { {V1Frame_FrameType_names + 79, 10}, 5 },
  { {V1Frame_FrameType_names + 89, 21}, 7 },
  { {V1Frame_FrameType_names + 110, 16}, 3 },
  { {V1Frame_FrameType_names + 126, 18}, 0 },
};

static const int V1Frame_FrameType_entries_by_number[] = {
  7, // 0 -> UNKNOWN_FRAME_TYPE
  1, // 1 -> CONNECTION_REQUEST
  2, // 2 -> CONNECTION_RESPONSE
  6, // 3 -> PAYLOAD_TRANSFER
  0, // 4 -> BANDWIDTH_UPGRADE_NEGOTIATION
  4, // 5 -> KEEP_ALIVE
  3, // 6 -> DISCONNECTION
  5, // 7 -> PAIRED_KEY_ENCRYPTION
};

const std::string& V1Frame_FrameType_Name(
    V1Frame_FrameType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          V1Frame_FrameType_entries,
          V1Frame_FrameType_entries_by_number,
          8, V1Frame_FrameType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      V1Frame_FrameType_entries,
      V1Frame_FrameType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     V1Frame_FrameType_strings[idx].get();
}
bool V1Frame_FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V1Frame_FrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      V1Frame_FrameType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<V1Frame_FrameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr V1Frame_FrameType V1Frame::UNKNOWN_FRAME_TYPE;
constexpr V1Frame_FrameType V1Frame::CONNECTION_REQUEST;
constexpr V1Frame_FrameType V1Frame::CONNECTION_RESPONSE;
constexpr V1Frame_FrameType V1Frame::PAYLOAD_TRANSFER;
constexpr V1Frame_FrameType V1Frame::BANDWIDTH_UPGRADE_NEGOTIATION;
constexpr V1Frame_FrameType V1Frame::KEEP_ALIVE;
constexpr V1Frame_FrameType V1Frame::DISCONNECTION;
constexpr V1Frame_FrameType V1Frame::PAIRED_KEY_ENCRYPTION;
constexpr V1Frame_FrameType V1Frame::FrameType_MIN;
constexpr V1Frame_FrameType V1Frame::FrameType_MAX;
constexpr int V1Frame::FrameType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionRequestFrame_Medium_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionRequestFrame_Medium_strings[12] = {};

static const char ConnectionRequestFrame_Medium_names[] =
  "BLE"
  "BLE_L2CAP"
  "BLUETOOTH"
  "MDNS"
  "NFC"
  "UNKNOWN_MEDIUM"
  "USB"
  "WEB_RTC"
  "WIFI_AWARE"
  "WIFI_DIRECT"
  "WIFI_HOTSPOT"
  "WIFI_LAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionRequestFrame_Medium_entries[] = {
  { {ConnectionRequestFrame_Medium_names + 0, 3}, 4 },
  { {ConnectionRequestFrame_Medium_names + 3, 9}, 10 },
  { {ConnectionRequestFrame_Medium_names + 12, 9}, 2 },
  { {ConnectionRequestFrame_Medium_names + 21, 4}, 1 },
  { {ConnectionRequestFrame_Medium_names + 25, 3}, 7 },
  { {ConnectionRequestFrame_Medium_names + 28, 14}, 0 },
  { {ConnectionRequestFrame_Medium_names + 42, 3}, 11 },
  { {ConnectionRequestFrame_Medium_names + 45, 7}, 9 },
  { {ConnectionRequestFrame_Medium_names + 52, 10}, 6 },
  { {ConnectionRequestFrame_Medium_names + 62, 11}, 8 },
  { {ConnectionRequestFrame_Medium_names + 73, 12}, 3 },
  { {ConnectionRequestFrame_Medium_names + 85, 8}, 5 },
};

static const int ConnectionRequestFrame_Medium_entries_by_number[] = {
  5, // 0 -> UNKNOWN_MEDIUM
  3, // 1 -> MDNS
  2, // 2 -> BLUETOOTH
  10, // 3 -> WIFI_HOTSPOT
  0, // 4 -> BLE
  11, // 5 -> WIFI_LAN
  8, // 6 -> WIFI_AWARE
  4, // 7 -> NFC
  9, // 8 -> WIFI_DIRECT
  7, // 9 -> WEB_RTC
  1, // 10 -> BLE_L2CAP
  6, // 11 -> USB
};

const std::string& ConnectionRequestFrame_Medium_Name(
    ConnectionRequestFrame_Medium value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionRequestFrame_Medium_entries,
          ConnectionRequestFrame_Medium_entries_by_number,
          12, ConnectionRequestFrame_Medium_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionRequestFrame_Medium_entries,
      ConnectionRequestFrame_Medium_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionRequestFrame_Medium_strings[idx].get();
}
bool ConnectionRequestFrame_Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionRequestFrame_Medium* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionRequestFrame_Medium_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionRequestFrame_Medium>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::UNKNOWN_MEDIUM;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::MDNS;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::BLUETOOTH;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_HOTSPOT;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::BLE;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_LAN;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_AWARE;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::NFC;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WIFI_DIRECT;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::WEB_RTC;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::BLE_L2CAP;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::USB;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::Medium_MIN;
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame::Medium_MAX;
constexpr int ConnectionRequestFrame::Medium_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionResponseFrame_ResponseStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionResponseFrame_ResponseStatus_strings[3] = {};

static const char ConnectionResponseFrame_ResponseStatus_names[] =
  "ACCEPT"
  "REJECT"
  "UNKNOWN_RESPONSE_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionResponseFrame_ResponseStatus_entries[] = {
  { {ConnectionResponseFrame_ResponseStatus_names + 0, 6}, 1 },
  { {ConnectionResponseFrame_ResponseStatus_names + 6, 6}, 2 },
  { {ConnectionResponseFrame_ResponseStatus_names + 12, 23}, 0 },
};

static const int ConnectionResponseFrame_ResponseStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_RESPONSE_STATUS
  0, // 1 -> ACCEPT
  1, // 2 -> REJECT
};

const std::string& ConnectionResponseFrame_ResponseStatus_Name(
    ConnectionResponseFrame_ResponseStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionResponseFrame_ResponseStatus_entries,
          ConnectionResponseFrame_ResponseStatus_entries_by_number,
          3, ConnectionResponseFrame_ResponseStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionResponseFrame_ResponseStatus_entries,
      ConnectionResponseFrame_ResponseStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionResponseFrame_ResponseStatus_strings[idx].get();
}
bool ConnectionResponseFrame_ResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionResponseFrame_ResponseStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionResponseFrame_ResponseStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionResponseFrame_ResponseStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::UNKNOWN_RESPONSE_STATUS;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::ACCEPT;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::REJECT;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::ResponseStatus_MIN;
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::ResponseStatus_MAX;
constexpr int ConnectionResponseFrame::ResponseStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_PayloadHeader_PayloadType_strings[4] = {};

static const char PayloadTransferFrame_PayloadHeader_PayloadType_names[] =
  "BYTES"
  "FILE"
  "STREAM"
  "UNKNOWN_PAYLOAD_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_PayloadHeader_PayloadType_entries[] = {
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 0, 5}, 1 },
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 5, 4}, 2 },
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 9, 6}, 3 },
  { {PayloadTransferFrame_PayloadHeader_PayloadType_names + 15, 20}, 0 },
};

static const int PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_PAYLOAD_TYPE
  0, // 1 -> BYTES
  1, // 2 -> FILE
  2, // 3 -> STREAM
};

const std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(
    PayloadTransferFrame_PayloadHeader_PayloadType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_PayloadHeader_PayloadType_entries,
          PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number,
          4, PayloadTransferFrame_PayloadHeader_PayloadType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_PayloadHeader_PayloadType_entries,
      PayloadTransferFrame_PayloadHeader_PayloadType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_PayloadHeader_PayloadType_strings[idx].get();
}
bool PayloadTransferFrame_PayloadHeader_PayloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PayloadHeader_PayloadType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_PayloadHeader_PayloadType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PayloadHeader_PayloadType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::UNKNOWN_PAYLOAD_TYPE;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::BYTES;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::FILE;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::STREAM;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::PayloadType_MIN;
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::PayloadType_MAX;
constexpr int PayloadTransferFrame_PayloadHeader::PayloadType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_PayloadChunk_Flags_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_PayloadChunk_Flags_strings[1] = {};

static const char PayloadTransferFrame_PayloadChunk_Flags_names[] =
  "LAST_CHUNK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_PayloadChunk_Flags_entries[] = {
  { {PayloadTransferFrame_PayloadChunk_Flags_names + 0, 10}, 1 },
};

static const int PayloadTransferFrame_PayloadChunk_Flags_entries_by_number[] = {
  0, // 1 -> LAST_CHUNK
};

const std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(
    PayloadTransferFrame_PayloadChunk_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_PayloadChunk_Flags_entries,
          PayloadTransferFrame_PayloadChunk_Flags_entries_by_number,
          1, PayloadTransferFrame_PayloadChunk_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_PayloadChunk_Flags_entries,
      PayloadTransferFrame_PayloadChunk_Flags_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_PayloadChunk_Flags_strings[idx].get();
}
bool PayloadTransferFrame_PayloadChunk_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PayloadChunk_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_PayloadChunk_Flags_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PayloadChunk_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk::LAST_CHUNK;
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk::Flags_MIN;
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk::Flags_MAX;
constexpr int PayloadTransferFrame_PayloadChunk::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_ControlMessage_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_ControlMessage_EventType_strings[3] = {};

static const char PayloadTransferFrame_ControlMessage_EventType_names[] =
  "PAYLOAD_CANCELED"
  "PAYLOAD_ERROR"
  "UNKNOWN_EVENT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_ControlMessage_EventType_entries[] = {
  { {PayloadTransferFrame_ControlMessage_EventType_names + 0, 16}, 2 },
  { {PayloadTransferFrame_ControlMessage_EventType_names + 16, 13}, 1 },
  { {PayloadTransferFrame_ControlMessage_EventType_names + 29, 18}, 0 },
};

static const int PayloadTransferFrame_ControlMessage_EventType_entries_by_number[] = {
  2, // 0 -> UNKNOWN_EVENT_TYPE
  1, // 1 -> PAYLOAD_ERROR
  0, // 2 -> PAYLOAD_CANCELED
};

const std::string& PayloadTransferFrame_ControlMessage_EventType_Name(
    PayloadTransferFrame_ControlMessage_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_ControlMessage_EventType_entries,
          PayloadTransferFrame_ControlMessage_EventType_entries_by_number,
          3, PayloadTransferFrame_ControlMessage_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_ControlMessage_EventType_entries,
      PayloadTransferFrame_ControlMessage_EventType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_ControlMessage_EventType_strings[idx].get();
}
bool PayloadTransferFrame_ControlMessage_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_ControlMessage_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_ControlMessage_EventType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_ControlMessage_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::UNKNOWN_EVENT_TYPE;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::PAYLOAD_ERROR;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::PAYLOAD_CANCELED;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::EventType_MIN;
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::EventType_MAX;
constexpr int PayloadTransferFrame_ControlMessage::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PayloadTransferFrame_PacketType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadTransferFrame_PacketType_strings[3] = {};

static const char PayloadTransferFrame_PacketType_names[] =
  "CONTROL"
  "DATA"
  "UNKNOWN_PACKET_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadTransferFrame_PacketType_entries[] = {
  { {PayloadTransferFrame_PacketType_names + 0, 7}, 2 },
  { {PayloadTransferFrame_PacketType_names + 7, 4}, 1 },
  { {PayloadTransferFrame_PacketType_names + 11, 19}, 0 },
};

static const int PayloadTransferFrame_PacketType_entries_by_number[] = {
  2, // 0 -> UNKNOWN_PACKET_TYPE
  1, // 1 -> DATA
  0, // 2 -> CONTROL
};

const std::string& PayloadTransferFrame_PacketType_Name(
    PayloadTransferFrame_PacketType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadTransferFrame_PacketType_entries,
          PayloadTransferFrame_PacketType_entries_by_number,
          3, PayloadTransferFrame_PacketType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadTransferFrame_PacketType_entries,
      PayloadTransferFrame_PacketType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadTransferFrame_PacketType_strings[idx].get();
}
bool PayloadTransferFrame_PacketType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadTransferFrame_PacketType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadTransferFrame_PacketType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PayloadTransferFrame_PacketType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::UNKNOWN_PACKET_TYPE;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::DATA;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::CONTROL;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::PacketType_MIN;
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame::PacketType_MAX;
constexpr int PayloadTransferFrame::PacketType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings[11] = {};

static const char BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names[] =
  "BLE"
  "BLUETOOTH"
  "MDNS"
  "NFC"
  "UNKNOWN_MEDIUM"
  "USB"
  "WEB_RTC"
  "WIFI_AWARE"
  "WIFI_DIRECT"
  "WIFI_HOTSPOT"
  "WIFI_LAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries[] = {
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 0, 3}, 4 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 3, 9}, 2 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 12, 4}, 1 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 16, 3}, 7 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 19, 14}, 0 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 33, 3}, 11 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 36, 7}, 9 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 43, 10}, 6 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 53, 11}, 8 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 64, 12}, 3 },
  { {BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_names + 76, 8}, 5 },
};

static const int BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number[] = {
  4, // 0 -> UNKNOWN_MEDIUM
  2, // 1 -> MDNS
  1, // 2 -> BLUETOOTH
  9, // 3 -> WIFI_HOTSPOT
  0, // 4 -> BLE
  10, // 5 -> WIFI_LAN
  7, // 6 -> WIFI_AWARE
  3, // 7 -> NFC
  8, // 8 -> WIFI_DIRECT
  6, // 9 -> WEB_RTC
  5, // 11 -> USB
};

const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(
    BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries,
          BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number,
          11, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries,
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_strings[idx].get();
}
bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::UNKNOWN_MEDIUM;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MDNS;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BLUETOOTH;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_HOTSPOT;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BLE;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_LAN;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_AWARE;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::NFC;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WIFI_DIRECT;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::WEB_RTC;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::USB;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Medium_MIN;
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Medium_MAX;
constexpr int BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Medium_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BandwidthUpgradeNegotiationFrame_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BandwidthUpgradeNegotiationFrame_EventType_strings[7] = {};

static const char BandwidthUpgradeNegotiationFrame_EventType_names[] =
  "CLIENT_INTRODUCTION"
  "CLIENT_INTRODUCTION_ACK"
  "LAST_WRITE_TO_PRIOR_CHANNEL"
  "SAFE_TO_CLOSE_PRIOR_CHANNEL"
  "UNKNOWN_EVENT_TYPE"
  "UPGRADE_FAILURE"
  "UPGRADE_PATH_AVAILABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BandwidthUpgradeNegotiationFrame_EventType_entries[] = {
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 0, 19}, 4 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 19, 23}, 6 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 42, 27}, 2 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 69, 27}, 3 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 96, 18}, 0 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 114, 15}, 5 },
  { {BandwidthUpgradeNegotiationFrame_EventType_names + 129, 22}, 1 },
};

static const int BandwidthUpgradeNegotiationFrame_EventType_entries_by_number[] = {
  4, // 0 -> UNKNOWN_EVENT_TYPE
  6, // 1 -> UPGRADE_PATH_AVAILABLE
  2, // 2 -> LAST_WRITE_TO_PRIOR_CHANNEL
  3, // 3 -> SAFE_TO_CLOSE_PRIOR_CHANNEL
  0, // 4 -> CLIENT_INTRODUCTION
  5, // 5 -> UPGRADE_FAILURE
  1, // 6 -> CLIENT_INTRODUCTION_ACK
};

const std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(
    BandwidthUpgradeNegotiationFrame_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BandwidthUpgradeNegotiationFrame_EventType_entries,
          BandwidthUpgradeNegotiationFrame_EventType_entries_by_number,
          7, BandwidthUpgradeNegotiationFrame_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BandwidthUpgradeNegotiationFrame_EventType_entries,
      BandwidthUpgradeNegotiationFrame_EventType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BandwidthUpgradeNegotiationFrame_EventType_strings[idx].get();
}
bool BandwidthUpgradeNegotiationFrame_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeNegotiationFrame_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BandwidthUpgradeNegotiationFrame_EventType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeNegotiationFrame_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::UNKNOWN_EVENT_TYPE;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::UPGRADE_PATH_AVAILABLE;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::LAST_WRITE_TO_PRIOR_CHANNEL;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::SAFE_TO_CLOSE_PRIOR_CHANNEL;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::CLIENT_INTRODUCTION;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::UPGRADE_FAILURE;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::CLIENT_INTRODUCTION_ACK;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::EventType_MIN;
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::EventType_MAX;
constexpr int BandwidthUpgradeNegotiationFrame::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LocationStandard_Format_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LocationStandard_Format_strings[3] = {};

static const char LocationStandard_Format_names[] =
  "E164_CALLING"
  "ISO_3166_1_ALPHA_2"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LocationStandard_Format_entries[] = {
  { {LocationStandard_Format_names + 0, 12}, 1 },
  { {LocationStandard_Format_names + 12, 18}, 2 },
  { {LocationStandard_Format_names + 30, 7}, 0 },
};

static const int LocationStandard_Format_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> E164_CALLING
  1, // 2 -> ISO_3166_1_ALPHA_2
};

const std::string& LocationStandard_Format_Name(
    LocationStandard_Format value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LocationStandard_Format_entries,
          LocationStandard_Format_entries_by_number,
          3, LocationStandard_Format_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LocationStandard_Format_entries,
      LocationStandard_Format_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LocationStandard_Format_strings[idx].get();
}
bool LocationStandard_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocationStandard_Format* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LocationStandard_Format_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LocationStandard_Format>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LocationStandard_Format LocationStandard::UNKNOWN;
constexpr LocationStandard_Format LocationStandard::E164_CALLING;
constexpr LocationStandard_Format LocationStandard::ISO_3166_1_ALPHA_2;
constexpr LocationStandard_Format LocationStandard::Format_MIN;
constexpr LocationStandard_Format LocationStandard::Format_MAX;
constexpr int LocationStandard::Format_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class OfflineFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<OfflineFrame>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::V1Frame& v1(const OfflineFrame* msg);
  static void set_has_v1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::location::nearby::connections::V1Frame&
OfflineFrame::_Internal::v1(const OfflineFrame* msg) {
  return *msg->v1_;
}
OfflineFrame::OfflineFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.OfflineFrame)
}
OfflineFrame::OfflineFrame(const OfflineFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_v1()) {
    v1_ = new ::location::nearby::connections::V1Frame(*from.v1_);
  } else {
    v1_ = nullptr;
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.OfflineFrame)
}

inline void OfflineFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&v1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&v1_)) + sizeof(version_));
}

OfflineFrame::~OfflineFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.OfflineFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void OfflineFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete v1_;
}

void OfflineFrame::ArenaDtor(void* object) {
  OfflineFrame* _this = reinterpret_cast< OfflineFrame* >(object);
  (void)_this;
}
void OfflineFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OfflineFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OfflineFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.OfflineFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(v1_ != nullptr);
    v1_->Clear();
  }
  version_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OfflineFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.OfflineFrame.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::OfflineFrame_Version_IsValid(val))) {
            _internal_set_version(static_cast<::location::nearby::connections::OfflineFrame_Version>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.V1Frame v1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_v1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfflineFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.OfflineFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.OfflineFrame.Version version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_version(), target);
  }

  // optional .location.nearby.connections.V1Frame v1 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::v1(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.OfflineFrame)
  return target;
}

size_t OfflineFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.OfflineFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .location.nearby.connections.V1Frame v1 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *v1_);
    }

    // optional .location.nearby.connections.OfflineFrame.Version version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OfflineFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const OfflineFrame*>(
      &from));
}

void OfflineFrame::MergeFrom(const OfflineFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.OfflineFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_v1()->::location::nearby::connections::V1Frame::MergeFrom(from._internal_v1());
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OfflineFrame::CopyFrom(const OfflineFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.OfflineFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFrame::IsInitialized() const {
  return true;
}

void OfflineFrame::InternalSwap(OfflineFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfflineFrame, version_)
      + sizeof(OfflineFrame::version_)
      - PROTOBUF_FIELD_OFFSET(OfflineFrame, v1_)>(
          reinterpret_cast<char*>(&v1_),
          reinterpret_cast<char*>(&other->v1_));
}

std::string OfflineFrame::GetTypeName() const {
  return "location.nearby.connections.OfflineFrame";
}


// ===================================================================

class V1Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<V1Frame>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::location::nearby::connections::ConnectionRequestFrame& connection_request(const V1Frame* msg);
  static void set_has_connection_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::ConnectionResponseFrame& connection_response(const V1Frame* msg);
  static void set_has_connection_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame& payload_transfer(const V1Frame* msg);
  static void set_has_payload_transfer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& bandwidth_upgrade_negotiation(const V1Frame* msg);
  static void set_has_bandwidth_upgrade_negotiation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::KeepAliveFrame& keep_alive(const V1Frame* msg);
  static void set_has_keep_alive(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::DisconnectionFrame& disconnection(const V1Frame* msg);
  static void set_has_disconnection(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::location::nearby::connections::PairedKeyEncryptionFrame& paired_key_encryption(const V1Frame* msg);
  static void set_has_paired_key_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::location::nearby::connections::ConnectionRequestFrame&
V1Frame::_Internal::connection_request(const V1Frame* msg) {
  return *msg->connection_request_;
}
const ::location::nearby::connections::ConnectionResponseFrame&
V1Frame::_Internal::connection_response(const V1Frame* msg) {
  return *msg->connection_response_;
}
const ::location::nearby::connections::PayloadTransferFrame&
V1Frame::_Internal::payload_transfer(const V1Frame* msg) {
  return *msg->payload_transfer_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame&
V1Frame::_Internal::bandwidth_upgrade_negotiation(const V1Frame* msg) {
  return *msg->bandwidth_upgrade_negotiation_;
}
const ::location::nearby::connections::KeepAliveFrame&
V1Frame::_Internal::keep_alive(const V1Frame* msg) {
  return *msg->keep_alive_;
}
const ::location::nearby::connections::DisconnectionFrame&
V1Frame::_Internal::disconnection(const V1Frame* msg) {
  return *msg->disconnection_;
}
const ::location::nearby::connections::PairedKeyEncryptionFrame&
V1Frame::_Internal::paired_key_encryption(const V1Frame* msg) {
  return *msg->paired_key_encryption_;
}
V1Frame::V1Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.V1Frame)
}
V1Frame::V1Frame(const V1Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_connection_request()) {
    connection_request_ = new ::location::nearby::connections::ConnectionRequestFrame(*from.connection_request_);
  } else {
    connection_request_ = nullptr;
  }
  if (from._internal_has_connection_response()) {
    connection_response_ = new ::location::nearby::connections::ConnectionResponseFrame(*from.connection_response_);
  } else {
    connection_response_ = nullptr;
  }
  if (from._internal_has_payload_transfer()) {
    payload_transfer_ = new ::location::nearby::connections::PayloadTransferFrame(*from.payload_transfer_);
  } else {
    payload_transfer_ = nullptr;
  }
  if (from._internal_has_bandwidth_upgrade_negotiation()) {
    bandwidth_upgrade_negotiation_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame(*from.bandwidth_upgrade_negotiation_);
  } else {
    bandwidth_upgrade_negotiation_ = nullptr;
  }
  if (from._internal_has_keep_alive()) {
    keep_alive_ = new ::location::nearby::connections::KeepAliveFrame(*from.keep_alive_);
  } else {
    keep_alive_ = nullptr;
  }
  if (from._internal_has_disconnection()) {
    disconnection_ = new ::location::nearby::connections::DisconnectionFrame(*from.disconnection_);
  } else {
    disconnection_ = nullptr;
  }
  if (from._internal_has_paired_key_encryption()) {
    paired_key_encryption_ = new ::location::nearby::connections::PairedKeyEncryptionFrame(*from.paired_key_encryption_);
  } else {
    paired_key_encryption_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.V1Frame)
}

inline void V1Frame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&connection_request_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&connection_request_)) + sizeof(type_));
}

V1Frame::~V1Frame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.V1Frame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void V1Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete connection_request_;
  if (this != internal_default_instance()) delete connection_response_;
  if (this != internal_default_instance()) delete payload_transfer_;
  if (this != internal_default_instance()) delete bandwidth_upgrade_negotiation_;
  if (this != internal_default_instance()) delete keep_alive_;
  if (this != internal_default_instance()) delete disconnection_;
  if (this != internal_default_instance()) delete paired_key_encryption_;
}

void V1Frame::ArenaDtor(void* object) {
  V1Frame* _this = reinterpret_cast< V1Frame* >(object);
  (void)_this;
}
void V1Frame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void V1Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void V1Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.V1Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(connection_request_ != nullptr);
      connection_request_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(connection_response_ != nullptr);
      connection_response_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(payload_transfer_ != nullptr);
      payload_transfer_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(bandwidth_upgrade_negotiation_ != nullptr);
      bandwidth_upgrade_negotiation_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(keep_alive_ != nullptr);
      keep_alive_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(disconnection_ != nullptr);
      disconnection_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(paired_key_encryption_ != nullptr);
      paired_key_encryption_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V1Frame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.V1Frame.FrameType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::V1Frame_FrameType_IsValid(val))) {
            _internal_set_type(static_cast<::location::nearby::connections::V1Frame_FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_payload_transfer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_bandwidth_upgrade_negotiation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_keep_alive(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_disconnection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_paired_key_encryption(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V1Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.V1Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.V1Frame.FrameType type = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::connection_request(this), target, stream);
  }

  // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::connection_response(this), target, stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::payload_transfer(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::bandwidth_upgrade_negotiation(this), target, stream);
  }

  // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::keep_alive(this), target, stream);
  }

  // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::disconnection(this), target, stream);
  }

  // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::paired_key_encryption(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.V1Frame)
  return target;
}

size_t V1Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.V1Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connection_request_);
    }

    // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connection_response_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_transfer_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bandwidth_upgrade_negotiation_);
    }

    // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *keep_alive_);
    }

    // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *disconnection_);
    }

    // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *paired_key_encryption_);
    }

    // optional .location.nearby.connections.V1Frame.FrameType type = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V1Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const V1Frame*>(
      &from));
}

void V1Frame::MergeFrom(const V1Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.V1Frame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_connection_request()->::location::nearby::connections::ConnectionRequestFrame::MergeFrom(from._internal_connection_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_connection_response()->::location::nearby::connections::ConnectionResponseFrame::MergeFrom(from._internal_connection_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_payload_transfer()->::location::nearby::connections::PayloadTransferFrame::MergeFrom(from._internal_payload_transfer());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_bandwidth_upgrade_negotiation()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame::MergeFrom(from._internal_bandwidth_upgrade_negotiation());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_keep_alive()->::location::nearby::connections::KeepAliveFrame::MergeFrom(from._internal_keep_alive());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_disconnection()->::location::nearby::connections::DisconnectionFrame::MergeFrom(from._internal_disconnection());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_paired_key_encryption()->::location::nearby::connections::PairedKeyEncryptionFrame::MergeFrom(from._internal_paired_key_encryption());
    }
    if (cached_has_bits & 0x00000080u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V1Frame::CopyFrom(const V1Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.V1Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V1Frame::IsInitialized() const {
  return true;
}

void V1Frame::InternalSwap(V1Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V1Frame, type_)
      + sizeof(V1Frame::type_)
      - PROTOBUF_FIELD_OFFSET(V1Frame, connection_request_)>(
          reinterpret_cast<char*>(&connection_request_),
          reinterpret_cast<char*>(&other->connection_request_));
}

std::string V1Frame::GetTypeName() const {
  return "location.nearby.connections.V1Frame";
}


// ===================================================================

class ConnectionRequestFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionRequestFrame>()._has_bits_);
  static void set_has_endpoint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_endpoint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_handshake_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nonce(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_endpoint_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::MediumMetadata& medium_metadata(const ConnectionRequestFrame* msg);
  static void set_has_medium_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_keep_alive_interval_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_keep_alive_timeout_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_device_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::location::nearby::connections::MediumMetadata&
ConnectionRequestFrame::_Internal::medium_metadata(const ConnectionRequestFrame* msg) {
  return *msg->medium_metadata_;
}
ConnectionRequestFrame::ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  mediums_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionRequestFrame)
}
ConnectionRequestFrame::ConnectionRequestFrame(const ConnectionRequestFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      mediums_(from.mediums_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_id()) {
    endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_id(), 
      GetArenaForAllocation());
  }
  endpoint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_name()) {
    endpoint_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_name(), 
      GetArenaForAllocation());
  }
  handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_handshake_data()) {
    handshake_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_handshake_data(), 
      GetArenaForAllocation());
  }
  endpoint_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_info()) {
    endpoint_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_info(), 
      GetArenaForAllocation());
  }
  device_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_info()) {
    device_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_info(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_medium_metadata()) {
    medium_metadata_ = new ::location::nearby::connections::MediumMetadata(*from.medium_metadata_);
  } else {
    medium_metadata_ = nullptr;
  }
  ::memcpy(&nonce_, &from.nonce_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_type_) -
    reinterpret_cast<char*>(&nonce_)) + sizeof(device_type_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionRequestFrame)
}

inline void ConnectionRequestFrame::SharedCtor() {
endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
endpoint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
endpoint_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&medium_metadata_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_type_) -
    reinterpret_cast<char*>(&medium_metadata_)) + sizeof(device_type_));
}

ConnectionRequestFrame::~ConnectionRequestFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionRequestFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConnectionRequestFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  endpoint_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  handshake_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete medium_metadata_;
}

void ConnectionRequestFrame::ArenaDtor(void* object) {
  ConnectionRequestFrame* _this = reinterpret_cast< ConnectionRequestFrame* >(object);
  (void)_this;
}
void ConnectionRequestFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConnectionRequestFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConnectionRequestFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionRequestFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mediums_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      endpoint_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      endpoint_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      handshake_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      endpoint_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      device_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(medium_metadata_ != nullptr);
      medium_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&nonce_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&keep_alive_interval_millis_) -
        reinterpret_cast<char*>(&nonce_)) + sizeof(keep_alive_interval_millis_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&keep_alive_timeout_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_type_) -
        reinterpret_cast<char*>(&keep_alive_timeout_millis_)) + sizeof(device_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionRequestFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string endpoint_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string endpoint_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_endpoint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes handshake_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_handshake_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nonce = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_nonce(&has_bits);
          nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(val))) {
              _internal_add_mediums(static_cast<::location::nearby::connections::ConnectionRequestFrame_Medium>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_mediums(), ptr, ctx, ::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes endpoint_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_endpoint_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_medium_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 keep_alive_interval_millis = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_keep_alive_interval_millis(&has_bits);
          keep_alive_interval_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 keep_alive_timeout_millis = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_keep_alive_timeout_millis(&has_bits);
          keep_alive_timeout_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 device_type = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_device_type(&has_bits);
          device_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes device_info = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_device_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionRequestFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionRequestFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string endpoint_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint_id(), target);
  }

  // optional string endpoint_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_endpoint_name(), target);
  }

  // optional bytes handshake_data = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_handshake_data(), target);
  }

  // optional int32 nonce = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_nonce(), target);
  }

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
  for (int i = 0, n = this->_internal_mediums_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        5, this->_internal_mediums(i), target);
  }

  // optional bytes endpoint_info = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_endpoint_info(), target);
  }

  // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::medium_metadata(this), target, stream);
  }

  // optional int32 keep_alive_interval_millis = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_keep_alive_interval_millis(), target);
  }

  // optional int32 keep_alive_timeout_millis = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_keep_alive_timeout_millis(), target);
  }

  // optional int32 device_type = 10 [default = 0];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_device_type(), target);
  }

  // optional bytes device_info = 11;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_device_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionRequestFrame)
  return target;
}

size_t ConnectionRequestFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionRequestFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_mediums_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_mediums(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string endpoint_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_id());
    }

    // optional string endpoint_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_name());
    }

    // optional bytes handshake_data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_handshake_data());
    }

    // optional bytes endpoint_info = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_endpoint_info());
    }

    // optional bytes device_info = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_device_info());
    }

    // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *medium_metadata_);
    }

    // optional int32 nonce = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_nonce());
    }

    // optional int32 keep_alive_interval_millis = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_keep_alive_interval_millis());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 keep_alive_timeout_millis = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_keep_alive_timeout_millis());
    }

    // optional int32 device_type = 10 [default = 0];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_device_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionRequestFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConnectionRequestFrame*>(
      &from));
}

void ConnectionRequestFrame::MergeFrom(const ConnectionRequestFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionRequestFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mediums_.MergeFrom(from.mediums_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_endpoint_name(from._internal_endpoint_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_handshake_data(from._internal_handshake_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_endpoint_info(from._internal_endpoint_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_device_info(from._internal_device_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_medium_metadata()->::location::nearby::connections::MediumMetadata::MergeFrom(from._internal_medium_metadata());
    }
    if (cached_has_bits & 0x00000040u) {
      nonce_ = from.nonce_;
    }
    if (cached_has_bits & 0x00000080u) {
      keep_alive_interval_millis_ = from.keep_alive_interval_millis_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      keep_alive_timeout_millis_ = from.keep_alive_timeout_millis_;
    }
    if (cached_has_bits & 0x00000200u) {
      device_type_ = from.device_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionRequestFrame::CopyFrom(const ConnectionRequestFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionRequestFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionRequestFrame::IsInitialized() const {
  return true;
}

void ConnectionRequestFrame::InternalSwap(ConnectionRequestFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mediums_.InternalSwap(&other->mediums_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_id_, lhs_arena,
      &other->endpoint_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_name_, lhs_arena,
      &other->endpoint_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &handshake_data_, lhs_arena,
      &other->handshake_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_info_, lhs_arena,
      &other->endpoint_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_info_, lhs_arena,
      &other->device_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, device_type_)
      + sizeof(ConnectionRequestFrame::device_type_)
      - PROTOBUF_FIELD_OFFSET(ConnectionRequestFrame, medium_metadata_)>(
          reinterpret_cast<char*>(&medium_metadata_),
          reinterpret_cast<char*>(&other->medium_metadata_));
}

std::string ConnectionRequestFrame::GetTypeName() const {
  return "location.nearby.connections.ConnectionRequestFrame";
}


// ===================================================================

class ConnectionResponseFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionResponseFrame>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_handshake_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ConnectionResponseFrame::ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.ConnectionResponseFrame)
}
ConnectionResponseFrame::ConnectionResponseFrame(const ConnectionResponseFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_handshake_data()) {
    handshake_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_handshake_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&status_, &from.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&response_) -
    reinterpret_cast<char*>(&status_)) + sizeof(response_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.ConnectionResponseFrame)
}

inline void ConnectionResponseFrame::SharedCtor() {
handshake_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  handshake_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&response_) -
    reinterpret_cast<char*>(&status_)) + sizeof(response_));
}

ConnectionResponseFrame::~ConnectionResponseFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.ConnectionResponseFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConnectionResponseFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  handshake_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ConnectionResponseFrame::ArenaDtor(void* object) {
  ConnectionResponseFrame* _this = reinterpret_cast< ConnectionResponseFrame* >(object);
  (void)_this;
}
void ConnectionResponseFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConnectionResponseFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConnectionResponseFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.ConnectionResponseFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    handshake_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&response_) -
        reinterpret_cast<char*>(&status_)) + sizeof(response_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionResponseFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 status = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes handshake_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_handshake_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus_IsValid(val))) {
            _internal_set_response(static_cast<::location::nearby::connections::ConnectionResponseFrame_ResponseStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionResponseFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.ConnectionResponseFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 status = 1 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_status(), target);
  }

  // optional bytes handshake_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_handshake_data(), target);
  }

  // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.ConnectionResponseFrame)
  return target;
}

size_t ConnectionResponseFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.ConnectionResponseFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes handshake_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_handshake_data());
    }

    // optional int32 status = 1 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_status());
    }

    // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_response());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionResponseFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConnectionResponseFrame*>(
      &from));
}

void ConnectionResponseFrame::MergeFrom(const ConnectionResponseFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.ConnectionResponseFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_handshake_data(from._internal_handshake_data());
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000004u) {
      response_ = from.response_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionResponseFrame::CopyFrom(const ConnectionResponseFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.ConnectionResponseFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionResponseFrame::IsInitialized() const {
  return true;
}

void ConnectionResponseFrame::InternalSwap(ConnectionResponseFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &handshake_data_, lhs_arena,
      &other->handshake_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, response_)
      + sizeof(ConnectionResponseFrame::response_)
      - PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, status_)>(
          reinterpret_cast<char*>(&status_),
          reinterpret_cast<char*>(&other->status_));
}

std::string ConnectionResponseFrame::GetTypeName() const {
  return "location.nearby.connections.ConnectionResponseFrame";
}


// ===================================================================

class PayloadTransferFrame_PayloadHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame_PayloadHeader>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_total_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_sensitive(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_folder(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
}
PayloadTransferFrame_PayloadHeader::PayloadTransferFrame_PayloadHeader(const PayloadTransferFrame_PayloadHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_name()) {
    file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_name(), 
      GetArenaForAllocation());
  }
  parent_folder_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    parent_folder_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_parent_folder()) {
    parent_folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_parent_folder(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_sensitive_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_sensitive_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
}

inline void PayloadTransferFrame_PayloadHeader::SharedCtor() {
file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
parent_folder_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  parent_folder_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_sensitive_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_sensitive_));
}

PayloadTransferFrame_PayloadHeader::~PayloadTransferFrame_PayloadHeader() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame_PayloadHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  file_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  parent_folder_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PayloadTransferFrame_PayloadHeader::ArenaDtor(void* object) {
  PayloadTransferFrame_PayloadHeader* _this = reinterpret_cast< PayloadTransferFrame_PayloadHeader* >(object);
  (void)_this;
}
void PayloadTransferFrame_PayloadHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame_PayloadHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame_PayloadHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      file_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      parent_folder_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_sensitive_) -
        reinterpret_cast<char*>(&id_)) + sizeof(is_sensitive_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame_PayloadHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(val))) {
            _internal_set_type(static_cast<::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 total_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total_size(&has_bits);
          total_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_sensitive = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_sensitive(&has_bits);
          is_sensitive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string file_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_file_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string parent_folder = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_parent_folder();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame_PayloadHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_id(), target);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional int64 total_size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_total_size(), target);
  }

  // optional bool is_sensitive = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_sensitive(), target);
  }

  // optional string file_name = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_file_name(), target);
  }

  // optional string parent_folder = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_parent_folder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  return target;
}

size_t PayloadTransferFrame_PayloadHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string file_name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_name());
    }

    // optional string parent_folder = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parent_folder());
    }

    // optional int64 id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_id());
    }

    // optional int64 total_size = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_total_size());
    }

    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool is_sensitive = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame_PayloadHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame_PayloadHeader*>(
      &from));
}

void PayloadTransferFrame_PayloadHeader::MergeFrom(const PayloadTransferFrame_PayloadHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_file_name(from._internal_file_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_parent_folder(from._internal_parent_folder());
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      total_size_ = from.total_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_sensitive_ = from.is_sensitive_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame_PayloadHeader::CopyFrom(const PayloadTransferFrame_PayloadHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame_PayloadHeader::IsInitialized() const {
  return true;
}

void PayloadTransferFrame_PayloadHeader::InternalSwap(PayloadTransferFrame_PayloadHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_name_, lhs_arena,
      &other->file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &parent_folder_, lhs_arena,
      &other->parent_folder_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, is_sensitive_)
      + sizeof(PayloadTransferFrame_PayloadHeader::is_sensitive_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadHeader, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

std::string PayloadTransferFrame_PayloadHeader::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame.PayloadHeader";
}


// ===================================================================

class PayloadTransferFrame_PayloadChunk::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame_PayloadChunk>()._has_bits_);
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
}
PayloadTransferFrame_PayloadChunk::PayloadTransferFrame_PayloadChunk(const PayloadTransferFrame_PayloadChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  body_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_body(), 
      GetArenaForAllocation());
  }
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
}

inline void PayloadTransferFrame_PayloadChunk::SharedCtor() {
body_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&offset_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(flags_));
}

PayloadTransferFrame_PayloadChunk::~PayloadTransferFrame_PayloadChunk() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame_PayloadChunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  body_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PayloadTransferFrame_PayloadChunk::ArenaDtor(void* object) {
  PayloadTransferFrame_PayloadChunk* _this = reinterpret_cast< PayloadTransferFrame_PayloadChunk* >(object);
  (void)_this;
}
void PayloadTransferFrame_PayloadChunk::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame_PayloadChunk::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame_PayloadChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    body_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame_PayloadChunk::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_body();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame_PayloadChunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 flags = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_flags(), target);
  }

  // optional int64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_offset(), target);
  }

  // optional bytes body = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  return target;
}

size_t PayloadTransferFrame_PayloadChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes body = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_body());
    }

    // optional int64 offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int32 flags = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame_PayloadChunk::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame_PayloadChunk*>(
      &from));
}

void PayloadTransferFrame_PayloadChunk::MergeFrom(const PayloadTransferFrame_PayloadChunk& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame_PayloadChunk::CopyFrom(const PayloadTransferFrame_PayloadChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame_PayloadChunk::IsInitialized() const {
  return true;
}

void PayloadTransferFrame_PayloadChunk::InternalSwap(PayloadTransferFrame_PayloadChunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &body_, lhs_arena,
      &other->body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, flags_)
      + sizeof(PayloadTransferFrame_PayloadChunk::flags_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_PayloadChunk, offset_)>(
          reinterpret_cast<char*>(&offset_),
          reinterpret_cast<char*>(&other->offset_));
}

std::string PayloadTransferFrame_PayloadChunk::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame.PayloadChunk";
}


// ===================================================================

class PayloadTransferFrame_ControlMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame_ControlMessage>()._has_bits_);
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
}
PayloadTransferFrame_ControlMessage::PayloadTransferFrame_ControlMessage(const PayloadTransferFrame_ControlMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&event_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(event_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
}

inline void PayloadTransferFrame_ControlMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&offset_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&event_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(event_));
}

PayloadTransferFrame_ControlMessage::~PayloadTransferFrame_ControlMessage() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame_ControlMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PayloadTransferFrame_ControlMessage::ArenaDtor(void* object) {
  PayloadTransferFrame_ControlMessage* _this = reinterpret_cast< PayloadTransferFrame_ControlMessage* >(object);
  (void)_this;
}
void PayloadTransferFrame_ControlMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame_ControlMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame_ControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&event_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(event_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame_ControlMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType_IsValid(val))) {
            _internal_set_event(static_cast<::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame_ControlMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event(), target);
  }

  // optional int64 offset = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  return target;
}

size_t PayloadTransferFrame_ControlMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 offset = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame_ControlMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame_ControlMessage*>(
      &from));
}

void PayloadTransferFrame_ControlMessage::MergeFrom(const PayloadTransferFrame_ControlMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000002u) {
      event_ = from.event_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame_ControlMessage::CopyFrom(const PayloadTransferFrame_ControlMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame.ControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame_ControlMessage::IsInitialized() const {
  return true;
}

void PayloadTransferFrame_ControlMessage::InternalSwap(PayloadTransferFrame_ControlMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, event_)
      + sizeof(PayloadTransferFrame_ControlMessage::event_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame_ControlMessage, offset_)>(
          reinterpret_cast<char*>(&offset_),
          reinterpret_cast<char*>(&other->offset_));
}

std::string PayloadTransferFrame_ControlMessage::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame.ControlMessage";
}


// ===================================================================

class PayloadTransferFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadTransferFrame>()._has_bits_);
  static void set_has_packet_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& payload_header(const PayloadTransferFrame* msg);
  static void set_has_payload_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& payload_chunk(const PayloadTransferFrame* msg);
  static void set_has_payload_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& control_message(const PayloadTransferFrame* msg);
  static void set_has_control_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader&
PayloadTransferFrame::_Internal::payload_header(const PayloadTransferFrame* msg) {
  return *msg->payload_header_;
}
const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk&
PayloadTransferFrame::_Internal::payload_chunk(const PayloadTransferFrame* msg) {
  return *msg->payload_chunk_;
}
const ::location::nearby::connections::PayloadTransferFrame_ControlMessage&
PayloadTransferFrame::_Internal::control_message(const PayloadTransferFrame* msg) {
  return *msg->control_message_;
}
PayloadTransferFrame::PayloadTransferFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PayloadTransferFrame)
}
PayloadTransferFrame::PayloadTransferFrame(const PayloadTransferFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_payload_header()) {
    payload_header_ = new ::location::nearby::connections::PayloadTransferFrame_PayloadHeader(*from.payload_header_);
  } else {
    payload_header_ = nullptr;
  }
  if (from._internal_has_payload_chunk()) {
    payload_chunk_ = new ::location::nearby::connections::PayloadTransferFrame_PayloadChunk(*from.payload_chunk_);
  } else {
    payload_chunk_ = nullptr;
  }
  if (from._internal_has_control_message()) {
    control_message_ = new ::location::nearby::connections::PayloadTransferFrame_ControlMessage(*from.control_message_);
  } else {
    control_message_ = nullptr;
  }
  packet_type_ = from.packet_type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PayloadTransferFrame)
}

inline void PayloadTransferFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&payload_header_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&packet_type_) -
    reinterpret_cast<char*>(&payload_header_)) + sizeof(packet_type_));
}

PayloadTransferFrame::~PayloadTransferFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PayloadTransferFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PayloadTransferFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete payload_header_;
  if (this != internal_default_instance()) delete payload_chunk_;
  if (this != internal_default_instance()) delete control_message_;
}

void PayloadTransferFrame::ArenaDtor(void* object) {
  PayloadTransferFrame* _this = reinterpret_cast< PayloadTransferFrame* >(object);
  (void)_this;
}
void PayloadTransferFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PayloadTransferFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PayloadTransferFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PayloadTransferFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(payload_header_ != nullptr);
      payload_header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(payload_chunk_ != nullptr);
      payload_chunk_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(control_message_ != nullptr);
      control_message_->Clear();
    }
  }
  packet_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadTransferFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::PayloadTransferFrame_PacketType_IsValid(val))) {
            _internal_set_packet_type(static_cast<::location::nearby::connections::PayloadTransferFrame_PacketType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_payload_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_payload_chunk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_control_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PayloadTransferFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PayloadTransferFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_packet_type(), target);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::payload_header(this), target, stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::payload_chunk(this), target, stream);
  }

  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::control_message(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PayloadTransferFrame)
  return target;
}

size_t PayloadTransferFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PayloadTransferFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_header_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_chunk_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *control_message_);
    }

    // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_packet_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadTransferFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PayloadTransferFrame*>(
      &from));
}

void PayloadTransferFrame::MergeFrom(const PayloadTransferFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PayloadTransferFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_payload_header()->::location::nearby::connections::PayloadTransferFrame_PayloadHeader::MergeFrom(from._internal_payload_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_payload_chunk()->::location::nearby::connections::PayloadTransferFrame_PayloadChunk::MergeFrom(from._internal_payload_chunk());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_control_message()->::location::nearby::connections::PayloadTransferFrame_ControlMessage::MergeFrom(from._internal_control_message());
    }
    if (cached_has_bits & 0x00000008u) {
      packet_type_ = from.packet_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadTransferFrame::CopyFrom(const PayloadTransferFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PayloadTransferFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadTransferFrame::IsInitialized() const {
  return true;
}

void PayloadTransferFrame::InternalSwap(PayloadTransferFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, packet_type_)
      + sizeof(PayloadTransferFrame::packet_type_)
      - PROTOBUF_FIELD_OFFSET(PayloadTransferFrame, payload_header_)>(
          reinterpret_cast<char*>(&payload_header_),
          reinterpret_cast<char*>(&other->payload_header_));
}

std::string PayloadTransferFrame::GetTypeName() const {
  return "location.nearby.connections.PayloadTransferFrame";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>()._has_bits_);
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gateway(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::internal::LazyString BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_i_give_permission_to_break_this_code_default_gateway_{{{"0.0.0.0", 7}}, {nullptr}};
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssid()) {
    ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ssid(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  gateway_.UnsafeSetDefault(nullptr);
  if (from._internal_has_gateway()) {
    gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_gateway(), 
      GetArenaForAllocation());
  }
  ::memcpy(&port_, &from.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&frequency_) -
    reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SharedCtor() {
ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gateway_.UnsafeSetDefault(nullptr);
port_ = 0;
frequency_ = -1;
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  gateway_.DestroyNoArena(nullptr);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ssid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
       }
  }
  if (cached_has_bits & 0x00000018u) {
    port_ = 0;
    frequency_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ssid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gateway = 4 [default = "0.0.0.0"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_gateway();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 frequency = 5 [default = -1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_frequency(&has_bits);
          frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ssid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ssid(), target);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional int32 port = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  // optional string gateway = 4 [default = "0.0.0.0"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_gateway(), target);
  }

  // optional int32 frequency = 5 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_frequency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ssid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ssid());
    }

    // optional string password = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional string gateway = 4 [default = "0.0.0.0"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gateway());
    }

    // optional int32 port = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

    // optional int32 frequency = 5 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ssid(from._internal_ssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_gateway(from._internal_gateway());
    }
    if (cached_has_bits & 0x00000008u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00000010u) {
      frequency_ = from.frequency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ssid_, lhs_arena,
      &other->ssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      nullptr,
      &gateway_, lhs_arena,
      &other->gateway_, rhs_arena
  );
  swap(port_, other->port_);
  swap(frequency_, other->frequency_);
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>()._has_bits_);
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wifi_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_address(), 
      GetArenaForAllocation());
  }
  wifi_port_ = from.wifi_port_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SharedCtor() {
ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
wifi_port_ = 0;
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_address_.ClearNonDefaultToEmpty();
  }
  wifi_port_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wifi_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_wifi_port(&has_bits);
          wifi_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes ip_address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ip_address(), target);
  }

  // optional int32 wifi_port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_wifi_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes ip_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip_address());
    }

    // optional int32 wifi_port = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_wifi_port());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000002u) {
      wifi_port_ = from.wifi_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_address_, lhs_arena,
      &other->ip_address_, rhs_arena
  );
  swap(wifi_port_, other->wifi_port_);
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>()._has_bits_);
  static void set_has_service_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mac_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  service_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service_name()) {
    service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service_name(), 
      GetArenaForAllocation());
  }
  mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac_address()) {
    mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mac_address(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SharedCtor() {
service_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  service_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mac_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      service_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      mac_address_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string service_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mac_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string service_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service_name(), target);
  }

  // optional string mac_address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mac_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string service_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_service_name());
    }

    // optional string mac_address = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mac_address());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_service_name(from._internal_service_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_mac_address(from._internal_mac_address());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_name_, lhs_arena,
      &other->service_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mac_address_, lhs_arena,
      &other->mac_address_, rhs_arena
  );
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>()._has_bits_);
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_service_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  service_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service_id()) {
    service_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service_id(), 
      GetArenaForAllocation());
  }
  service_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service_info()) {
    service_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service_info(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SharedCtor() {
service_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
service_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  service_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  service_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      service_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      service_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      password_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string service_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes service_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_service_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string service_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service_id(), target);
  }

  // optional bytes service_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_service_info(), target);
  }

  // optional string password = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string service_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_service_id());
    }

    // optional bytes service_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_service_info());
    }

    // optional string password = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_service_id(from._internal_service_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_service_info(from._internal_service_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_password(from._internal_password());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_id_, lhs_arena,
      &other->service_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_info_, lhs_arena,
      &other->service_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>()._has_bits_);
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_gateway(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::internal::LazyString BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_i_give_permission_to_break_this_code_default_gateway_{{{"0.0.0.0", 7}}, {nullptr}};
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssid()) {
    ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ssid(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  gateway_.UnsafeSetDefault(nullptr);
  if (from._internal_has_gateway()) {
    gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_gateway(), 
      GetArenaForAllocation());
  }
  ::memcpy(&port_, &from.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&frequency_) -
    reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SharedCtor() {
ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gateway_.UnsafeSetDefault(nullptr);
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&port_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frequency_) -
    reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  gateway_.DestroyNoArena(nullptr);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ssid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
       }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&frequency_) -
        reinterpret_cast<char*>(&port_)) + sizeof(frequency_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ssid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 frequency = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_frequency(&has_bits);
          frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gateway = 5 [default = "0.0.0.0"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gateway();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ssid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ssid(), target);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional int32 port = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  // optional int32 frequency = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_frequency(), target);
  }

  // optional string gateway = 5 [default = "0.0.0.0"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_gateway(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ssid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ssid());
    }

    // optional string password = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional string gateway = 5 [default = "0.0.0.0"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gateway());
    }

    // optional int32 port = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

    // optional int32 frequency = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ssid(from._internal_ssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_gateway(from._internal_gateway());
    }
    if (cached_has_bits & 0x00000008u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00000010u) {
      frequency_ = from.frequency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ssid_, lhs_arena,
      &other->ssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      nullptr,
      &gateway_, lhs_arena,
      &other->gateway_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, frequency_)
      + sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::frequency_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials, port_)>(
          reinterpret_cast<char*>(&port_),
          reinterpret_cast<char*>(&other->port_));
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>()._has_bits_);
  static void set_has_peer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::LocationHint& location_hint(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* msg);
  static void set_has_location_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::location::nearby::connections::LocationHint&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_Internal::location_hint(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* msg) {
  return *msg->location_hint_;
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  peer_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    peer_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_peer_id()) {
    peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_peer_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_location_hint()) {
    location_hint_ = new ::location::nearby::connections::LocationHint(*from.location_hint_);
  } else {
    location_hint_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SharedCtor() {
peer_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  peer_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
location_hint_ = nullptr;
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  peer_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete location_hint_;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      peer_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(location_hint_ != nullptr);
      location_hint_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string peer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_peer_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.LocationHint location_hint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_location_hint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string peer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_peer_id(), target);
  }

  // optional .location.nearby.connections.LocationHint location_hint = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::location_hint(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string peer_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_peer_id());
    }

    // optional .location.nearby.connections.LocationHint location_hint = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *location_hint_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_peer_id(from._internal_peer_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_location_hint()->::location::nearby::connections::LocationHint::MergeFrom(from._internal_location_hint());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &peer_id_, lhs_arena,
      &other->peer_id_, rhs_arena
  );
  swap(location_hint_, other->location_hint_);
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_UpgradePathInfo>()._has_bits_);
  static void set_has_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& wifi_hotspot_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_hotspot_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& wifi_lan_socket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_lan_socket(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& bluetooth_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_bluetooth_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& wifi_aware_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_aware_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& wifi_direct_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_wifi_direct_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& web_rtc_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg);
  static void set_has_web_rtc_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_supports_disabling_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_supports_client_introduction_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_hotspot_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_hotspot_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_lan_socket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_lan_socket_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::bluetooth_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->bluetooth_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_aware_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_aware_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::wifi_direct_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->wifi_direct_credentials_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_Internal::web_rtc_credentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* msg) {
  return *msg->web_rtc_credentials_;
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
}
BandwidthUpgradeNegotiationFrame_UpgradePathInfo::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_wifi_hotspot_credentials()) {
    wifi_hotspot_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(*from.wifi_hotspot_credentials_);
  } else {
    wifi_hotspot_credentials_ = nullptr;
  }
  if (from._internal_has_wifi_lan_socket()) {
    wifi_lan_socket_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(*from.wifi_lan_socket_);
  } else {
    wifi_lan_socket_ = nullptr;
  }
  if (from._internal_has_bluetooth_credentials()) {
    bluetooth_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(*from.bluetooth_credentials_);
  } else {
    bluetooth_credentials_ = nullptr;
  }
  if (from._internal_has_wifi_aware_credentials()) {
    wifi_aware_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(*from.wifi_aware_credentials_);
  } else {
    wifi_aware_credentials_ = nullptr;
  }
  if (from._internal_has_wifi_direct_credentials()) {
    wifi_direct_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(*from.wifi_direct_credentials_);
  } else {
    wifi_direct_credentials_ = nullptr;
  }
  if (from._internal_has_web_rtc_credentials()) {
    web_rtc_credentials_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(*from.web_rtc_credentials_);
  } else {
    web_rtc_credentials_ = nullptr;
  }
  ::memcpy(&medium_, &from.medium_,
    static_cast<size_t>(reinterpret_cast<char*>(&supports_client_introduction_ack_) -
    reinterpret_cast<char*>(&medium_)) + sizeof(supports_client_introduction_ack_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&wifi_hotspot_credentials_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&supports_client_introduction_ack_) -
    reinterpret_cast<char*>(&wifi_hotspot_credentials_)) + sizeof(supports_client_introduction_ack_));
}

BandwidthUpgradeNegotiationFrame_UpgradePathInfo::~BandwidthUpgradeNegotiationFrame_UpgradePathInfo() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete wifi_hotspot_credentials_;
  if (this != internal_default_instance()) delete wifi_lan_socket_;
  if (this != internal_default_instance()) delete bluetooth_credentials_;
  if (this != internal_default_instance()) delete wifi_aware_credentials_;
  if (this != internal_default_instance()) delete wifi_direct_credentials_;
  if (this != internal_default_instance()) delete web_rtc_credentials_;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_UpgradePathInfo* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(wifi_hotspot_credentials_ != nullptr);
      wifi_hotspot_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(wifi_lan_socket_ != nullptr);
      wifi_lan_socket_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(bluetooth_credentials_ != nullptr);
      bluetooth_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(wifi_aware_credentials_ != nullptr);
      wifi_aware_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(wifi_direct_credentials_ != nullptr);
      wifi_direct_credentials_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(web_rtc_credentials_ != nullptr);
      web_rtc_credentials_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&medium_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&supports_disabling_encryption_) -
        reinterpret_cast<char*>(&medium_)) + sizeof(supports_disabling_encryption_));
  }
  supports_client_introduction_ack_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(val))) {
            _internal_set_medium(static_cast<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_hotspot_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_lan_socket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_bluetooth_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_aware_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_direct_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_disabling_encryption = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_supports_disabling_encryption(&has_bits);
          supports_disabling_encryption_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_web_rtc_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_client_introduction_ack = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_supports_client_introduction_ack(&has_bits);
          supports_client_introduction_ack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_medium(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::wifi_hotspot_credentials(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::wifi_lan_socket(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::bluetooth_credentials(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::wifi_aware_credentials(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::wifi_direct_credentials(this), target, stream);
  }

  // optional bool supports_disabling_encryption = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_supports_disabling_encryption(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::web_rtc_credentials(this), target, stream);
  }

  // optional bool supports_client_introduction_ack = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_supports_client_introduction_ack(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_hotspot_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_lan_socket_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bluetooth_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_aware_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_direct_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *web_rtc_credentials_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_medium());
    }

    // optional bool supports_disabling_encryption = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool supports_client_introduction_ack = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_wifi_hotspot_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::MergeFrom(from._internal_wifi_hotspot_credentials());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_wifi_lan_socket()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::MergeFrom(from._internal_wifi_lan_socket());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_bluetooth_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::MergeFrom(from._internal_bluetooth_credentials());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_wifi_aware_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::MergeFrom(from._internal_wifi_aware_credentials());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_wifi_direct_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::MergeFrom(from._internal_wifi_direct_credentials());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_web_rtc_credentials()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::MergeFrom(from._internal_web_rtc_credentials());
    }
    if (cached_has_bits & 0x00000040u) {
      medium_ = from.medium_;
    }
    if (cached_has_bits & 0x00000080u) {
      supports_disabling_encryption_ = from.supports_disabling_encryption_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_supports_client_introduction_ack(from._internal_supports_client_introduction_ack());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, supports_client_introduction_ack_)
      + sizeof(BandwidthUpgradeNegotiationFrame_UpgradePathInfo::supports_client_introduction_ack_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame_UpgradePathInfo, wifi_hotspot_credentials_)>(
          reinterpret_cast<char*>(&wifi_hotspot_credentials_),
          reinterpret_cast<char*>(&other->wifi_hotspot_credentials_));
}

std::string BandwidthUpgradeNegotiationFrame_UpgradePathInfo::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_ClientIntroduction::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame_ClientIntroduction>()._has_bits_);
  static void set_has_endpoint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_disabling_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
}
BandwidthUpgradeNegotiationFrame_ClientIntroduction::BandwidthUpgradeNegotiationFrame_ClientIntroduction(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint_id()) {
    endpoint_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_endpoint_id(), 
      GetArenaForAllocation());
  }
  supports_disabling_encryption_ = from.supports_disabling_encryption_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SharedCtor() {
endpoint_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  endpoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
supports_disabling_encryption_ = false;
}

BandwidthUpgradeNegotiationFrame_ClientIntroduction::~BandwidthUpgradeNegotiationFrame_ClientIntroduction() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  endpoint_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_ClientIntroduction* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_ClientIntroduction* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_ClientIntroduction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_ClientIntroduction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    endpoint_id_.ClearNonDefaultToEmpty();
  }
  supports_disabling_encryption_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_ClientIntroduction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string endpoint_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_disabling_encryption = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_supports_disabling_encryption(&has_bits);
          supports_disabling_encryption_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_ClientIntroduction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string endpoint_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint_id(), target);
  }

  // optional bool supports_disabling_encryption = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_supports_disabling_encryption(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_ClientIntroduction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string endpoint_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint_id());
    }

    // optional bool supports_disabling_encryption = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_ClientIntroduction*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint_id(from._internal_endpoint_id());
    }
    if (cached_has_bits & 0x00000002u) {
      supports_disabling_encryption_ = from.supports_disabling_encryption_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroduction::InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &endpoint_id_, lhs_arena,
      &other->endpoint_id_, rhs_arena
  );
  swap(supports_disabling_encryption_, other->supports_disabling_encryption_);
}

std::string BandwidthUpgradeNegotiationFrame_ClientIntroduction::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_Internal {
 public:
};

BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
}
BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SharedCtor() {
}

BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::~BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck";
}


// ===================================================================

class BandwidthUpgradeNegotiationFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<BandwidthUpgradeNegotiationFrame>()._has_bits_);
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& upgrade_path_info(const BandwidthUpgradeNegotiationFrame* msg);
  static void set_has_upgrade_path_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& client_introduction(const BandwidthUpgradeNegotiationFrame* msg);
  static void set_has_client_introduction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& client_introduction_ack(const BandwidthUpgradeNegotiationFrame* msg);
  static void set_has_client_introduction_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo&
BandwidthUpgradeNegotiationFrame::_Internal::upgrade_path_info(const BandwidthUpgradeNegotiationFrame* msg) {
  return *msg->upgrade_path_info_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction&
BandwidthUpgradeNegotiationFrame::_Internal::client_introduction(const BandwidthUpgradeNegotiationFrame* msg) {
  return *msg->client_introduction_;
}
const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&
BandwidthUpgradeNegotiationFrame::_Internal::client_introduction_ack(const BandwidthUpgradeNegotiationFrame* msg) {
  return *msg->client_introduction_ack_;
}
BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
}
BandwidthUpgradeNegotiationFrame::BandwidthUpgradeNegotiationFrame(const BandwidthUpgradeNegotiationFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_upgrade_path_info()) {
    upgrade_path_info_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo(*from.upgrade_path_info_);
  } else {
    upgrade_path_info_ = nullptr;
  }
  if (from._internal_has_client_introduction()) {
    client_introduction_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction(*from.client_introduction_);
  } else {
    client_introduction_ = nullptr;
  }
  if (from._internal_has_client_introduction_ack()) {
    client_introduction_ack_ = new ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(*from.client_introduction_ack_);
  } else {
    client_introduction_ack_ = nullptr;
  }
  event_type_ = from.event_type_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
}

inline void BandwidthUpgradeNegotiationFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&upgrade_path_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&event_type_) -
    reinterpret_cast<char*>(&upgrade_path_info_)) + sizeof(event_type_));
}

BandwidthUpgradeNegotiationFrame::~BandwidthUpgradeNegotiationFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BandwidthUpgradeNegotiationFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete upgrade_path_info_;
  if (this != internal_default_instance()) delete client_introduction_;
  if (this != internal_default_instance()) delete client_introduction_ack_;
}

void BandwidthUpgradeNegotiationFrame::ArenaDtor(void* object) {
  BandwidthUpgradeNegotiationFrame* _this = reinterpret_cast< BandwidthUpgradeNegotiationFrame* >(object);
  (void)_this;
}
void BandwidthUpgradeNegotiationFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BandwidthUpgradeNegotiationFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BandwidthUpgradeNegotiationFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(upgrade_path_info_ != nullptr);
      upgrade_path_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_introduction_ != nullptr);
      client_introduction_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(client_introduction_ack_ != nullptr);
      client_introduction_ack_->Clear();
    }
  }
  event_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BandwidthUpgradeNegotiationFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_upgrade_path_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_introduction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_introduction_ack(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BandwidthUpgradeNegotiationFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_type(), target);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::upgrade_path_info(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::client_introduction(this), target, stream);
  }

  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::client_introduction_ack(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  return target;
}

size_t BandwidthUpgradeNegotiationFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *upgrade_path_info_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_introduction_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_introduction_ack_);
    }

    // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BandwidthUpgradeNegotiationFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BandwidthUpgradeNegotiationFrame*>(
      &from));
}

void BandwidthUpgradeNegotiationFrame::MergeFrom(const BandwidthUpgradeNegotiationFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_upgrade_path_info()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo::MergeFrom(from._internal_upgrade_path_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_introduction()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction::MergeFrom(from._internal_client_introduction());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_client_introduction_ack()->::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck::MergeFrom(from._internal_client_introduction_ack());
    }
    if (cached_has_bits & 0x00000008u) {
      event_type_ = from.event_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthUpgradeNegotiationFrame::CopyFrom(const BandwidthUpgradeNegotiationFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandwidthUpgradeNegotiationFrame::IsInitialized() const {
  return true;
}

void BandwidthUpgradeNegotiationFrame::InternalSwap(BandwidthUpgradeNegotiationFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, event_type_)
      + sizeof(BandwidthUpgradeNegotiationFrame::event_type_)
      - PROTOBUF_FIELD_OFFSET(BandwidthUpgradeNegotiationFrame, upgrade_path_info_)>(
          reinterpret_cast<char*>(&upgrade_path_info_),
          reinterpret_cast<char*>(&other->upgrade_path_info_));
}

std::string BandwidthUpgradeNegotiationFrame::GetTypeName() const {
  return "location.nearby.connections.BandwidthUpgradeNegotiationFrame";
}


// ===================================================================

class KeepAliveFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<KeepAliveFrame>()._has_bits_);
  static void set_has_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KeepAliveFrame::KeepAliveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.KeepAliveFrame)
}
KeepAliveFrame::KeepAliveFrame(const KeepAliveFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ack_ = from.ack_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.KeepAliveFrame)
}

inline void KeepAliveFrame::SharedCtor() {
ack_ = false;
}

KeepAliveFrame::~KeepAliveFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.KeepAliveFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KeepAliveFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeepAliveFrame::ArenaDtor(void* object) {
  KeepAliveFrame* _this = reinterpret_cast< KeepAliveFrame* >(object);
  (void)_this;
}
void KeepAliveFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeepAliveFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeepAliveFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.KeepAliveFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ack_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeepAliveFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool ack = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ack(&has_bits);
          ack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeepAliveFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.KeepAliveFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool ack = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_ack(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.KeepAliveFrame)
  return target;
}

size_t KeepAliveFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.KeepAliveFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool ack = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeepAliveFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KeepAliveFrame*>(
      &from));
}

void KeepAliveFrame::MergeFrom(const KeepAliveFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.KeepAliveFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ack()) {
    _internal_set_ack(from._internal_ack());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeepAliveFrame::CopyFrom(const KeepAliveFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.KeepAliveFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeepAliveFrame::IsInitialized() const {
  return true;
}

void KeepAliveFrame::InternalSwap(KeepAliveFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(ack_, other->ack_);
}

std::string KeepAliveFrame::GetTypeName() const {
  return "location.nearby.connections.KeepAliveFrame";
}


// ===================================================================

class DisconnectionFrame::_Internal {
 public:
};

DisconnectionFrame::DisconnectionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.DisconnectionFrame)
}
DisconnectionFrame::DisconnectionFrame(const DisconnectionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.DisconnectionFrame)
}

inline void DisconnectionFrame::SharedCtor() {
}

DisconnectionFrame::~DisconnectionFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.DisconnectionFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DisconnectionFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DisconnectionFrame::ArenaDtor(void* object) {
  DisconnectionFrame* _this = reinterpret_cast< DisconnectionFrame* >(object);
  (void)_this;
}
void DisconnectionFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DisconnectionFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DisconnectionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.DisconnectionFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DisconnectionFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DisconnectionFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.DisconnectionFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.DisconnectionFrame)
  return target;
}

size_t DisconnectionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.DisconnectionFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DisconnectionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DisconnectionFrame*>(
      &from));
}

void DisconnectionFrame::MergeFrom(const DisconnectionFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.DisconnectionFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisconnectionFrame::CopyFrom(const DisconnectionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.DisconnectionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisconnectionFrame::IsInitialized() const {
  return true;
}

void DisconnectionFrame::InternalSwap(DisconnectionFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DisconnectionFrame::GetTypeName() const {
  return "location.nearby.connections.DisconnectionFrame";
}


// ===================================================================

class PairedKeyEncryptionFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PairedKeyEncryptionFrame>()._has_bits_);
  static void set_has_signed_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.PairedKeyEncryptionFrame)
}
PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  signed_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signed_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signed_data()) {
    signed_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signed_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.PairedKeyEncryptionFrame)
}

inline void PairedKeyEncryptionFrame::SharedCtor() {
signed_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signed_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PairedKeyEncryptionFrame::~PairedKeyEncryptionFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.PairedKeyEncryptionFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PairedKeyEncryptionFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signed_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PairedKeyEncryptionFrame::ArenaDtor(void* object) {
  PairedKeyEncryptionFrame* _this = reinterpret_cast< PairedKeyEncryptionFrame* >(object);
  (void)_this;
}
void PairedKeyEncryptionFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PairedKeyEncryptionFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PairedKeyEncryptionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.PairedKeyEncryptionFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    signed_data_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PairedKeyEncryptionFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes signed_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_signed_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PairedKeyEncryptionFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.PairedKeyEncryptionFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signed_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_signed_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.PairedKeyEncryptionFrame)
  return target;
}

size_t PairedKeyEncryptionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.PairedKeyEncryptionFrame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes signed_data = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signed_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairedKeyEncryptionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PairedKeyEncryptionFrame*>(
      &from));
}

void PairedKeyEncryptionFrame::MergeFrom(const PairedKeyEncryptionFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.PairedKeyEncryptionFrame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_signed_data()) {
    _internal_set_signed_data(from._internal_signed_data());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PairedKeyEncryptionFrame::CopyFrom(const PairedKeyEncryptionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.PairedKeyEncryptionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairedKeyEncryptionFrame::IsInitialized() const {
  return true;
}

void PairedKeyEncryptionFrame::InternalSwap(PairedKeyEncryptionFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signed_data_, lhs_arena,
      &other->signed_data_, rhs_arena
  );
}

std::string PairedKeyEncryptionFrame::GetTypeName() const {
  return "location.nearby.connections.PairedKeyEncryptionFrame";
}


// ===================================================================

class MediumMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<MediumMetadata>()._has_bits_);
  static void set_has_supports_5_ghz(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_supports_6_ghz(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mobile_radio(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ap_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::location::nearby::connections::AvailableChannels& available_channels(const MediumMetadata* msg);
  static void set_has_available_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::connections::WifiDirectCliUsableChannels& wifi_direct_cli_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_direct_cli_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::location::nearby::connections::WifiLanUsableChannels& wifi_lan_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_lan_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::connections::WifiAwareUsableChannels& wifi_aware_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_aware_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::location::nearby::connections::WifiHotspotStaUsableChannels& wifi_hotspot_sta_usable_channels(const MediumMetadata* msg);
  static void set_has_wifi_hotspot_sta_usable_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::location::nearby::connections::AvailableChannels&
MediumMetadata::_Internal::available_channels(const MediumMetadata* msg) {
  return *msg->available_channels_;
}
const ::location::nearby::connections::WifiDirectCliUsableChannels&
MediumMetadata::_Internal::wifi_direct_cli_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_direct_cli_usable_channels_;
}
const ::location::nearby::connections::WifiLanUsableChannels&
MediumMetadata::_Internal::wifi_lan_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_lan_usable_channels_;
}
const ::location::nearby::connections::WifiAwareUsableChannels&
MediumMetadata::_Internal::wifi_aware_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_aware_usable_channels_;
}
const ::location::nearby::connections::WifiHotspotStaUsableChannels&
MediumMetadata::_Internal::wifi_hotspot_sta_usable_channels(const MediumMetadata* msg) {
  return *msg->wifi_hotspot_sta_usable_channels_;
}
MediumMetadata::MediumMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.MediumMetadata)
}
MediumMetadata::MediumMetadata(const MediumMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  bssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bssid()) {
    bssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_bssid(), 
      GetArenaForAllocation());
  }
  ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_address(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_available_channels()) {
    available_channels_ = new ::location::nearby::connections::AvailableChannels(*from.available_channels_);
  } else {
    available_channels_ = nullptr;
  }
  if (from._internal_has_wifi_direct_cli_usable_channels()) {
    wifi_direct_cli_usable_channels_ = new ::location::nearby::connections::WifiDirectCliUsableChannels(*from.wifi_direct_cli_usable_channels_);
  } else {
    wifi_direct_cli_usable_channels_ = nullptr;
  }
  if (from._internal_has_wifi_lan_usable_channels()) {
    wifi_lan_usable_channels_ = new ::location::nearby::connections::WifiLanUsableChannels(*from.wifi_lan_usable_channels_);
  } else {
    wifi_lan_usable_channels_ = nullptr;
  }
  if (from._internal_has_wifi_aware_usable_channels()) {
    wifi_aware_usable_channels_ = new ::location::nearby::connections::WifiAwareUsableChannels(*from.wifi_aware_usable_channels_);
  } else {
    wifi_aware_usable_channels_ = nullptr;
  }
  if (from._internal_has_wifi_hotspot_sta_usable_channels()) {
    wifi_hotspot_sta_usable_channels_ = new ::location::nearby::connections::WifiHotspotStaUsableChannels(*from.wifi_hotspot_sta_usable_channels_);
  } else {
    wifi_hotspot_sta_usable_channels_ = nullptr;
  }
  ::memcpy(&supports_5_ghz_, &from.supports_5_ghz_,
    static_cast<size_t>(reinterpret_cast<char*>(&ap_frequency_) -
    reinterpret_cast<char*>(&supports_5_ghz_)) + sizeof(ap_frequency_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.MediumMetadata)
}

inline void MediumMetadata::SharedCtor() {
bssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&available_channels_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mobile_radio_) -
    reinterpret_cast<char*>(&available_channels_)) + sizeof(mobile_radio_));
ap_frequency_ = -1;
}

MediumMetadata::~MediumMetadata() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.MediumMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MediumMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  bssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ip_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete available_channels_;
  if (this != internal_default_instance()) delete wifi_direct_cli_usable_channels_;
  if (this != internal_default_instance()) delete wifi_lan_usable_channels_;
  if (this != internal_default_instance()) delete wifi_aware_usable_channels_;
  if (this != internal_default_instance()) delete wifi_hotspot_sta_usable_channels_;
}

void MediumMetadata::ArenaDtor(void* object) {
  MediumMetadata* _this = reinterpret_cast< MediumMetadata* >(object);
  (void)_this;
}
void MediumMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MediumMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MediumMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.MediumMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      bssid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ip_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(available_channels_ != nullptr);
      available_channels_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(wifi_direct_cli_usable_channels_ != nullptr);
      wifi_direct_cli_usable_channels_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(wifi_lan_usable_channels_ != nullptr);
      wifi_lan_usable_channels_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(wifi_aware_usable_channels_ != nullptr);
      wifi_aware_usable_channels_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(wifi_hotspot_sta_usable_channels_ != nullptr);
      wifi_hotspot_sta_usable_channels_->Clear();
    }
  }
  supports_5_ghz_ = false;
  ::memset(&supports_6_ghz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mobile_radio_) -
      reinterpret_cast<char*>(&supports_6_ghz_)) + sizeof(mobile_radio_));
  ap_frequency_ = -1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MediumMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool supports_5_ghz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_supports_5_ghz(&has_bits);
          supports_5_ghz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bssid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ip_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_6_ghz = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_supports_6_ghz(&has_bits);
          supports_6_ghz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mobile_radio = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mobile_radio(&has_bits);
          mobile_radio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ap_frequency = 6 [default = -1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ap_frequency(&has_bits);
          ap_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.AvailableChannels available_channels = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_available_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_direct_cli_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_lan_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_aware_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_wifi_hotspot_sta_usable_channels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediumMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.MediumMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool supports_5_ghz = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_supports_5_ghz(), target);
  }

  // optional string bssid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bssid(), target);
  }

  // optional bytes ip_address = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ip_address(), target);
  }

  // optional bool supports_6_ghz = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_supports_6_ghz(), target);
  }

  // optional bool mobile_radio = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_mobile_radio(), target);
  }

  // optional int32 ap_frequency = 6 [default = -1];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_ap_frequency(), target);
  }

  // optional .location.nearby.connections.AvailableChannels available_channels = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::available_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::wifi_direct_cli_usable_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::wifi_lan_usable_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::wifi_aware_usable_channels(this), target, stream);
  }

  // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::wifi_hotspot_sta_usable_channels(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.MediumMetadata)
  return target;
}

size_t MediumMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.MediumMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string bssid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bssid());
    }

    // optional bytes ip_address = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip_address());
    }

    // optional .location.nearby.connections.AvailableChannels available_channels = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *available_channels_);
    }

    // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_direct_cli_usable_channels_);
    }

    // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_lan_usable_channels_);
    }

    // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_aware_usable_channels_);
    }

    // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wifi_hotspot_sta_usable_channels_);
    }

    // optional bool supports_5_ghz = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool supports_6_ghz = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool mobile_radio = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional int32 ap_frequency = 6 [default = -1];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ap_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MediumMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MediumMetadata*>(
      &from));
}

void MediumMetadata::MergeFrom(const MediumMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.MediumMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_bssid(from._internal_bssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_available_channels()->::location::nearby::connections::AvailableChannels::MergeFrom(from._internal_available_channels());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_wifi_direct_cli_usable_channels()->::location::nearby::connections::WifiDirectCliUsableChannels::MergeFrom(from._internal_wifi_direct_cli_usable_channels());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_wifi_lan_usable_channels()->::location::nearby::connections::WifiLanUsableChannels::MergeFrom(from._internal_wifi_lan_usable_channels());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_wifi_aware_usable_channels()->::location::nearby::connections::WifiAwareUsableChannels::MergeFrom(from._internal_wifi_aware_usable_channels());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_wifi_hotspot_sta_usable_channels()->::location::nearby::connections::WifiHotspotStaUsableChannels::MergeFrom(from._internal_wifi_hotspot_sta_usable_channels());
    }
    if (cached_has_bits & 0x00000080u) {
      supports_5_ghz_ = from.supports_5_ghz_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      supports_6_ghz_ = from.supports_6_ghz_;
    }
    if (cached_has_bits & 0x00000200u) {
      mobile_radio_ = from.mobile_radio_;
    }
    if (cached_has_bits & 0x00000400u) {
      ap_frequency_ = from.ap_frequency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MediumMetadata::CopyFrom(const MediumMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.MediumMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediumMetadata::IsInitialized() const {
  return true;
}

void MediumMetadata::InternalSwap(MediumMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &bssid_, lhs_arena,
      &other->bssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_address_, lhs_arena,
      &other->ip_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediumMetadata, mobile_radio_)
      + sizeof(MediumMetadata::mobile_radio_)
      - PROTOBUF_FIELD_OFFSET(MediumMetadata, available_channels_)>(
          reinterpret_cast<char*>(&available_channels_),
          reinterpret_cast<char*>(&other->available_channels_));
  swap(ap_frequency_, other->ap_frequency_);
}

std::string MediumMetadata::GetTypeName() const {
  return "location.nearby.connections.MediumMetadata";
}


// ===================================================================

class AvailableChannels::_Internal {
 public:
};

AvailableChannels::AvailableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.AvailableChannels)
}
AvailableChannels::AvailableChannels(const AvailableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.AvailableChannels)
}

inline void AvailableChannels::SharedCtor() {
}

AvailableChannels::~AvailableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.AvailableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AvailableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AvailableChannels::ArenaDtor(void* object) {
  AvailableChannels* _this = reinterpret_cast< AvailableChannels* >(object);
  (void)_this;
}
void AvailableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvailableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvailableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.AvailableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AvailableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvailableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.AvailableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.AvailableChannels)
  return target;
}

size_t AvailableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.AvailableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AvailableChannels*>(
      &from));
}

void AvailableChannels::MergeFrom(const AvailableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.AvailableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvailableChannels::CopyFrom(const AvailableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.AvailableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableChannels::IsInitialized() const {
  return true;
}

void AvailableChannels::InternalSwap(AvailableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string AvailableChannels::GetTypeName() const {
  return "location.nearby.connections.AvailableChannels";
}


// ===================================================================

class WifiDirectCliUsableChannels::_Internal {
 public:
};

WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiDirectCliUsableChannels)
}
WifiDirectCliUsableChannels::WifiDirectCliUsableChannels(const WifiDirectCliUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiDirectCliUsableChannels)
}

inline void WifiDirectCliUsableChannels::SharedCtor() {
}

WifiDirectCliUsableChannels::~WifiDirectCliUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiDirectCliUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiDirectCliUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiDirectCliUsableChannels::ArenaDtor(void* object) {
  WifiDirectCliUsableChannels* _this = reinterpret_cast< WifiDirectCliUsableChannels* >(object);
  (void)_this;
}
void WifiDirectCliUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiDirectCliUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiDirectCliUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiDirectCliUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiDirectCliUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiDirectCliUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiDirectCliUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiDirectCliUsableChannels)
  return target;
}

size_t WifiDirectCliUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiDirectCliUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiDirectCliUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiDirectCliUsableChannels*>(
      &from));
}

void WifiDirectCliUsableChannels::MergeFrom(const WifiDirectCliUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiDirectCliUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiDirectCliUsableChannels::CopyFrom(const WifiDirectCliUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiDirectCliUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiDirectCliUsableChannels::IsInitialized() const {
  return true;
}

void WifiDirectCliUsableChannels::InternalSwap(WifiDirectCliUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiDirectCliUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiDirectCliUsableChannels";
}


// ===================================================================

class WifiLanUsableChannels::_Internal {
 public:
};

WifiLanUsableChannels::WifiLanUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiLanUsableChannels)
}
WifiLanUsableChannels::WifiLanUsableChannels(const WifiLanUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiLanUsableChannels)
}

inline void WifiLanUsableChannels::SharedCtor() {
}

WifiLanUsableChannels::~WifiLanUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiLanUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiLanUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiLanUsableChannels::ArenaDtor(void* object) {
  WifiLanUsableChannels* _this = reinterpret_cast< WifiLanUsableChannels* >(object);
  (void)_this;
}
void WifiLanUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiLanUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiLanUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiLanUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiLanUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiLanUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiLanUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiLanUsableChannels)
  return target;
}

size_t WifiLanUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiLanUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiLanUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiLanUsableChannels*>(
      &from));
}

void WifiLanUsableChannels::MergeFrom(const WifiLanUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiLanUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiLanUsableChannels::CopyFrom(const WifiLanUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiLanUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiLanUsableChannels::IsInitialized() const {
  return true;
}

void WifiLanUsableChannels::InternalSwap(WifiLanUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiLanUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiLanUsableChannels";
}


// ===================================================================

class WifiAwareUsableChannels::_Internal {
 public:
};

WifiAwareUsableChannels::WifiAwareUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiAwareUsableChannels)
}
WifiAwareUsableChannels::WifiAwareUsableChannels(const WifiAwareUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiAwareUsableChannels)
}

inline void WifiAwareUsableChannels::SharedCtor() {
}

WifiAwareUsableChannels::~WifiAwareUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiAwareUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiAwareUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiAwareUsableChannels::ArenaDtor(void* object) {
  WifiAwareUsableChannels* _this = reinterpret_cast< WifiAwareUsableChannels* >(object);
  (void)_this;
}
void WifiAwareUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiAwareUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiAwareUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiAwareUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiAwareUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiAwareUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiAwareUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiAwareUsableChannels)
  return target;
}

size_t WifiAwareUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiAwareUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiAwareUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiAwareUsableChannels*>(
      &from));
}

void WifiAwareUsableChannels::MergeFrom(const WifiAwareUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiAwareUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiAwareUsableChannels::CopyFrom(const WifiAwareUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiAwareUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiAwareUsableChannels::IsInitialized() const {
  return true;
}

void WifiAwareUsableChannels::InternalSwap(WifiAwareUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiAwareUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiAwareUsableChannels";
}


// ===================================================================

class WifiHotspotStaUsableChannels::_Internal {
 public:
};

WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.WifiHotspotStaUsableChannels)
}
WifiHotspotStaUsableChannels::WifiHotspotStaUsableChannels(const WifiHotspotStaUsableChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.WifiHotspotStaUsableChannels)
}

inline void WifiHotspotStaUsableChannels::SharedCtor() {
}

WifiHotspotStaUsableChannels::~WifiHotspotStaUsableChannels() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.WifiHotspotStaUsableChannels)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WifiHotspotStaUsableChannels::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WifiHotspotStaUsableChannels::ArenaDtor(void* object) {
  WifiHotspotStaUsableChannels* _this = reinterpret_cast< WifiHotspotStaUsableChannels* >(object);
  (void)_this;
}
void WifiHotspotStaUsableChannels::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WifiHotspotStaUsableChannels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WifiHotspotStaUsableChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiHotspotStaUsableChannels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 channels = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WifiHotspotStaUsableChannels::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    int byte_size = _channels_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_channels(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.WifiHotspotStaUsableChannels)
  return target;
}

size_t WifiHotspotStaUsableChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 channels = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->channels_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _channels_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiHotspotStaUsableChannels::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiHotspotStaUsableChannels*>(
      &from));
}

void WifiHotspotStaUsableChannels::MergeFrom(const WifiHotspotStaUsableChannels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiHotspotStaUsableChannels::CopyFrom(const WifiHotspotStaUsableChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.WifiHotspotStaUsableChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiHotspotStaUsableChannels::IsInitialized() const {
  return true;
}

void WifiHotspotStaUsableChannels::InternalSwap(WifiHotspotStaUsableChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  channels_.InternalSwap(&other->channels_);
}

std::string WifiHotspotStaUsableChannels::GetTypeName() const {
  return "location.nearby.connections.WifiHotspotStaUsableChannels";
}


// ===================================================================

class LocationHint::_Internal {
 public:
  using HasBits = decltype(std::declval<LocationHint>()._has_bits_);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LocationHint::LocationHint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.LocationHint)
}
LocationHint::LocationHint(const LocationHint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_location()) {
    location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_location(), 
      GetArenaForAllocation());
  }
  format_ = from.format_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.LocationHint)
}

inline void LocationHint::SharedCtor() {
location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
format_ = 0;
}

LocationHint::~LocationHint() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.LocationHint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LocationHint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  location_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LocationHint::ArenaDtor(void* object) {
  LocationHint* _this = reinterpret_cast< LocationHint* >(object);
  (void)_this;
}
void LocationHint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LocationHint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocationHint::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.LocationHint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    location_.ClearNonDefaultToEmpty();
  }
  format_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LocationHint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_location();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .location.nearby.connections.LocationStandard.Format format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::connections::LocationStandard_Format_IsValid(val))) {
            _internal_set_format(static_cast<::location::nearby::connections::LocationStandard_Format>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocationHint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.LocationHint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string location = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_location(), target);
  }

  // optional .location.nearby.connections.LocationStandard.Format format = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.LocationHint)
  return target;
}

size_t LocationHint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.LocationHint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string location = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_location());
    }

    // optional .location.nearby.connections.LocationStandard.Format format = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_format());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocationHint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LocationHint*>(
      &from));
}

void LocationHint::MergeFrom(const LocationHint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.LocationHint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_location(from._internal_location());
    }
    if (cached_has_bits & 0x00000002u) {
      format_ = from.format_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocationHint::CopyFrom(const LocationHint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.LocationHint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocationHint::IsInitialized() const {
  return true;
}

void LocationHint::InternalSwap(LocationHint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &location_, lhs_arena,
      &other->location_, rhs_arena
  );
  swap(format_, other->format_);
}

std::string LocationHint::GetTypeName() const {
  return "location.nearby.connections.LocationHint";
}


// ===================================================================

class LocationStandard::_Internal {
 public:
};

LocationStandard::LocationStandard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:location.nearby.connections.LocationStandard)
}
LocationStandard::LocationStandard(const LocationStandard& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.connections.LocationStandard)
}

inline void LocationStandard::SharedCtor() {
}

LocationStandard::~LocationStandard() {
  // @@protoc_insertion_point(destructor:location.nearby.connections.LocationStandard)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LocationStandard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LocationStandard::ArenaDtor(void* object) {
  LocationStandard* _this = reinterpret_cast< LocationStandard* >(object);
  (void)_this;
}
void LocationStandard::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LocationStandard::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocationStandard::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.connections.LocationStandard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LocationStandard::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocationStandard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.connections.LocationStandard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.connections.LocationStandard)
  return target;
}

size_t LocationStandard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.connections.LocationStandard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocationStandard::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LocationStandard*>(
      &from));
}

void LocationStandard::MergeFrom(const LocationStandard& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.connections.LocationStandard)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocationStandard::CopyFrom(const LocationStandard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.connections.LocationStandard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocationStandard::IsInitialized() const {
  return true;
}

void LocationStandard::InternalSwap(LocationStandard* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LocationStandard::GetTypeName() const {
  return "location.nearby.connections.LocationStandard";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace connections
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::location::nearby::connections::OfflineFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::OfflineFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::OfflineFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::V1Frame* Arena::CreateMaybeMessage< ::location::nearby::connections::V1Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::V1Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::ConnectionRequestFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::ConnectionRequestFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::ConnectionRequestFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::ConnectionResponseFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::ConnectionResponseFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::ConnectionResponseFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame_PayloadHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame_PayloadHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame_PayloadChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame_PayloadChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame_ControlMessage* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame_ControlMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame_ControlMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PayloadTransferFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::PayloadTransferFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PayloadTransferFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::BandwidthUpgradeNegotiationFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::KeepAliveFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::KeepAliveFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::KeepAliveFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::DisconnectionFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::DisconnectionFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::DisconnectionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::PairedKeyEncryptionFrame* Arena::CreateMaybeMessage< ::location::nearby::connections::PairedKeyEncryptionFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::PairedKeyEncryptionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::MediumMetadata* Arena::CreateMaybeMessage< ::location::nearby::connections::MediumMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::MediumMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::AvailableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::AvailableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::AvailableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiDirectCliUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiDirectCliUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiDirectCliUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiLanUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiLanUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiLanUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiAwareUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiAwareUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiAwareUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::WifiHotspotStaUsableChannels* Arena::CreateMaybeMessage< ::location::nearby::connections::WifiHotspotStaUsableChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::WifiHotspotStaUsableChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::LocationHint* Arena::CreateMaybeMessage< ::location::nearby::connections::LocationHint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::LocationHint >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::connections::LocationStandard* Arena::CreateMaybeMessage< ::location::nearby::connections::LocationStandard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::connections::LocationStandard >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
