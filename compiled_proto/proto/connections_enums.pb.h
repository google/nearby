// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/connections_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fconnections_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fconnections_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fconnections_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fconnections_5fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace location {
namespace nearby {
namespace proto {
namespace connections {

enum EventType : int {
  UNKNOWN_EVENT_TYPE = 0,
  CLIENT_SESSION = 1,
  START_CLIENT_SESSION = 2,
  STOP_CLIENT_SESSION = 3,
  START_STRATEGY_SESSION = 4,
  STOP_STRATEGY_SESSION = 5,
  ERROR_CODE = 6
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = UNKNOWN_EVENT_TYPE;
constexpr EventType EventType_MAX = ERROR_CODE;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const std::string& EventType_Name(EventType value);
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return EventType_Name(static_cast<EventType>(enum_t_value));
}
bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value);
enum ConnectionsStrategy : int {
  UNKNOWN_STRATEGY = 0,
  MDNS_LOCAL_WIFI PROTOBUF_DEPRECATED_ENUM = 1,
  RADIO_P2P PROTOBUF_DEPRECATED_ENUM = 2,
  P2P_CLUSTER = 3,
  P2P_STAR = 4,
  P2P_POINT_TO_POINT = 5
};
bool ConnectionsStrategy_IsValid(int value);
constexpr ConnectionsStrategy ConnectionsStrategy_MIN = UNKNOWN_STRATEGY;
constexpr ConnectionsStrategy ConnectionsStrategy_MAX = P2P_POINT_TO_POINT;
constexpr int ConnectionsStrategy_ARRAYSIZE = ConnectionsStrategy_MAX + 1;

const std::string& ConnectionsStrategy_Name(ConnectionsStrategy value);
template<typename T>
inline const std::string& ConnectionsStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionsStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionsStrategy_Name.");
  return ConnectionsStrategy_Name(static_cast<ConnectionsStrategy>(enum_t_value));
}
bool ConnectionsStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionsStrategy* value);
enum SessionRole : int {
  UNKNOWN_SESSION_ROLE = 0,
  ADVERTISER = 1,
  DISCOVERER = 2
};
bool SessionRole_IsValid(int value);
constexpr SessionRole SessionRole_MIN = UNKNOWN_SESSION_ROLE;
constexpr SessionRole SessionRole_MAX = DISCOVERER;
constexpr int SessionRole_ARRAYSIZE = SessionRole_MAX + 1;

const std::string& SessionRole_Name(SessionRole value);
template<typename T>
inline const std::string& SessionRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionRole_Name.");
  return SessionRole_Name(static_cast<SessionRole>(enum_t_value));
}
bool SessionRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionRole* value);
enum Medium : int {
  UNKNOWN_MEDIUM = 0,
  MDNS PROTOBUF_DEPRECATED_ENUM = 1,
  BLUETOOTH = 2,
  WIFI_HOTSPOT = 3,
  BLE = 4,
  WIFI_LAN = 5,
  WIFI_AWARE = 6,
  NFC = 7,
  WIFI_DIRECT = 8,
  WEB_RTC = 9,
  BLE_L2CAP = 10,
  USB = 11
};
bool Medium_IsValid(int value);
constexpr Medium Medium_MIN = UNKNOWN_MEDIUM;
constexpr Medium Medium_MAX = USB;
constexpr int Medium_ARRAYSIZE = Medium_MAX + 1;

const std::string& Medium_Name(Medium value);
template<typename T>
inline const std::string& Medium_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Medium>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Medium_Name.");
  return Medium_Name(static_cast<Medium>(enum_t_value));
}
bool Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Medium* value);
enum ConnectionTechnology : int {
  CONNECTION_TECHNOLOGY_UNKNOWN_TECHNOLOGY = 0,
  CONNECTION_TECHNOLOGY_BLE_GATT = 1,
  CONNECTION_TECHNOLOGY_BLE_L2CAP = 2,
  CONNECTION_TECHNOLOGY_HOTSPOT_DIRECT = 3,
  CONNECTION_TECHNOLOGY_HOTSPOT_LOCALONLY = 4,
  CONNECTION_TECHNOLOGY_HOTSPOT_SOFTAP = 5,
  CONNECTION_TECHNOLOGY_WEBRTC_WIFI = 6,
  CONNECTION_TECHNOLOGY_WEBRTC_MOBILE = 7,
  CONNECTION_TECHNOLOGY_WEBRTC_ETHERNET = 8,
  CONNECTION_TECHNOLOGY_WEBRTC_VPN = 9,
  CONNECTION_TECHNOLOGY_WEBRTC_LOOPBACK = 10,
  CONNECTION_TECHNOLOGY_WEBRTC_ADAPTER_TYPE_ANY = 11
};
bool ConnectionTechnology_IsValid(int value);
constexpr ConnectionTechnology ConnectionTechnology_MIN = CONNECTION_TECHNOLOGY_UNKNOWN_TECHNOLOGY;
constexpr ConnectionTechnology ConnectionTechnology_MAX = CONNECTION_TECHNOLOGY_WEBRTC_ADAPTER_TYPE_ANY;
constexpr int ConnectionTechnology_ARRAYSIZE = ConnectionTechnology_MAX + 1;

const std::string& ConnectionTechnology_Name(ConnectionTechnology value);
template<typename T>
inline const std::string& ConnectionTechnology_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionTechnology>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionTechnology_Name.");
  return ConnectionTechnology_Name(static_cast<ConnectionTechnology>(enum_t_value));
}
bool ConnectionTechnology_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionTechnology* value);
enum ConnectionBand : int {
  CONNECTION_BAND_UNKNOWN_BAND = 0,
  CONNECTION_BAND_WIFI_BAND_2GHZ = 1,
  CONNECTION_BAND_WIFI_BAND_5GHZ = 2,
  CONNECTION_BAND_WIFI_BAND_6GHZ = 3,
  CONNECTION_BAND_CELLULAR_BAND_2G = 4,
  CONNECTION_BAND_CELLULAR_BAND_3G = 5,
  CONNECTION_BAND_CELLULAR_BAND_4G = 6,
  CONNECTION_BAND_CELLULAR_BAND_5G = 7
};
bool ConnectionBand_IsValid(int value);
constexpr ConnectionBand ConnectionBand_MIN = CONNECTION_BAND_UNKNOWN_BAND;
constexpr ConnectionBand ConnectionBand_MAX = CONNECTION_BAND_CELLULAR_BAND_5G;
constexpr int ConnectionBand_ARRAYSIZE = ConnectionBand_MAX + 1;

const std::string& ConnectionBand_Name(ConnectionBand value);
template<typename T>
inline const std::string& ConnectionBand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionBand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionBand_Name.");
  return ConnectionBand_Name(static_cast<ConnectionBand>(enum_t_value));
}
bool ConnectionBand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionBand* value);
enum ConnectionRequestResponse : int {
  UNKNOWN_CONNECTION_REQUEST_RESPONSE = 0,
  ACCEPTED = 1,
  REJECTED = 2,
  IGNORED = 3,
  NOT_SENT = 4
};
bool ConnectionRequestResponse_IsValid(int value);
constexpr ConnectionRequestResponse ConnectionRequestResponse_MIN = UNKNOWN_CONNECTION_REQUEST_RESPONSE;
constexpr ConnectionRequestResponse ConnectionRequestResponse_MAX = NOT_SENT;
constexpr int ConnectionRequestResponse_ARRAYSIZE = ConnectionRequestResponse_MAX + 1;

const std::string& ConnectionRequestResponse_Name(ConnectionRequestResponse value);
template<typename T>
inline const std::string& ConnectionRequestResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionRequestResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionRequestResponse_Name.");
  return ConnectionRequestResponse_Name(static_cast<ConnectionRequestResponse>(enum_t_value));
}
bool ConnectionRequestResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionRequestResponse* value);
enum ConnectionAttemptResult : int {
  UNKNOWN_CONNECTION_ATTEMPT_RESULT = 0,
  RESULT_SUCCESS = 1,
  RESULT_ERROR = 2,
  RESULT_CANCELLED = 3
};
bool ConnectionAttemptResult_IsValid(int value);
constexpr ConnectionAttemptResult ConnectionAttemptResult_MIN = UNKNOWN_CONNECTION_ATTEMPT_RESULT;
constexpr ConnectionAttemptResult ConnectionAttemptResult_MAX = RESULT_CANCELLED;
constexpr int ConnectionAttemptResult_ARRAYSIZE = ConnectionAttemptResult_MAX + 1;

const std::string& ConnectionAttemptResult_Name(ConnectionAttemptResult value);
template<typename T>
inline const std::string& ConnectionAttemptResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionAttemptResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionAttemptResult_Name.");
  return ConnectionAttemptResult_Name(static_cast<ConnectionAttemptResult>(enum_t_value));
}
bool ConnectionAttemptResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionAttemptResult* value);
enum ConnectionAttemptDirection : int {
  UNKNOWN_CONNECTION_ATTEMPT_DIRECTION = 0,
  INCOMING = 1,
  OUTGOING = 2
};
bool ConnectionAttemptDirection_IsValid(int value);
constexpr ConnectionAttemptDirection ConnectionAttemptDirection_MIN = UNKNOWN_CONNECTION_ATTEMPT_DIRECTION;
constexpr ConnectionAttemptDirection ConnectionAttemptDirection_MAX = OUTGOING;
constexpr int ConnectionAttemptDirection_ARRAYSIZE = ConnectionAttemptDirection_MAX + 1;

const std::string& ConnectionAttemptDirection_Name(ConnectionAttemptDirection value);
template<typename T>
inline const std::string& ConnectionAttemptDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionAttemptDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionAttemptDirection_Name.");
  return ConnectionAttemptDirection_Name(static_cast<ConnectionAttemptDirection>(enum_t_value));
}
bool ConnectionAttemptDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionAttemptDirection* value);
enum ConnectionAttemptType : int {
  UNKNOWN_CONNECTION_ATTEMPT_TYPE = 0,
  INITIAL = 1,
  UPGRADE = 2,
  RECONNECT = 3
};
bool ConnectionAttemptType_IsValid(int value);
constexpr ConnectionAttemptType ConnectionAttemptType_MIN = UNKNOWN_CONNECTION_ATTEMPT_TYPE;
constexpr ConnectionAttemptType ConnectionAttemptType_MAX = RECONNECT;
constexpr int ConnectionAttemptType_ARRAYSIZE = ConnectionAttemptType_MAX + 1;

const std::string& ConnectionAttemptType_Name(ConnectionAttemptType value);
template<typename T>
inline const std::string& ConnectionAttemptType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionAttemptType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionAttemptType_Name.");
  return ConnectionAttemptType_Name(static_cast<ConnectionAttemptType>(enum_t_value));
}
bool ConnectionAttemptType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionAttemptType* value);
enum DisconnectionReason : int {
  UNKNOWN_DISCONNECTION_REASON = 0,
  LOCAL_DISCONNECTION = 1,
  REMOTE_DISCONNECTION = 2,
  IO_ERROR = 3,
  UPGRADED = 4,
  SHUTDOWN = 5,
  UNFINISHED = 6,
  PREV_CHANNEL_DISCONNECTION_IN_RECONNECT = 7
};
bool DisconnectionReason_IsValid(int value);
constexpr DisconnectionReason DisconnectionReason_MIN = UNKNOWN_DISCONNECTION_REASON;
constexpr DisconnectionReason DisconnectionReason_MAX = PREV_CHANNEL_DISCONNECTION_IN_RECONNECT;
constexpr int DisconnectionReason_ARRAYSIZE = DisconnectionReason_MAX + 1;

const std::string& DisconnectionReason_Name(DisconnectionReason value);
template<typename T>
inline const std::string& DisconnectionReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DisconnectionReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DisconnectionReason_Name.");
  return DisconnectionReason_Name(static_cast<DisconnectionReason>(enum_t_value));
}
bool DisconnectionReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisconnectionReason* value);
enum PayloadType : int {
  UNKNOWN_PAYLOAD_TYPE = 0,
  BYTES = 1,
  FILE = 2,
  STREAM = 3
};
bool PayloadType_IsValid(int value);
constexpr PayloadType PayloadType_MIN = UNKNOWN_PAYLOAD_TYPE;
constexpr PayloadType PayloadType_MAX = STREAM;
constexpr int PayloadType_ARRAYSIZE = PayloadType_MAX + 1;

const std::string& PayloadType_Name(PayloadType value);
template<typename T>
inline const std::string& PayloadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadType_Name.");
  return PayloadType_Name(static_cast<PayloadType>(enum_t_value));
}
bool PayloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadType* value);
enum PayloadStatus : int {
  UNKNOWN_PAYLOAD_STATUS = 0,
  SUCCESS = 1,
  LOCAL_ERROR = 2,
  REMOTE_ERROR = 3,
  ENDPOINT_IO_ERROR = 4,
  MOVED_TO_NEW_MEDIUM = 5,
  CONNECTION_CLOSED = 6,
  LOCAL_CANCELLATION = 7,
  REMOTE_CANCELLATION = 8,
  ENDPOINT_UNENCRYPTED = 9,
  LOCAL_CLIENT_DISCONNECTION = 10,
  REMOTE_CLIENT_DISCONNECTION = 11
};
bool PayloadStatus_IsValid(int value);
constexpr PayloadStatus PayloadStatus_MIN = UNKNOWN_PAYLOAD_STATUS;
constexpr PayloadStatus PayloadStatus_MAX = REMOTE_CLIENT_DISCONNECTION;
constexpr int PayloadStatus_ARRAYSIZE = PayloadStatus_MAX + 1;

const std::string& PayloadStatus_Name(PayloadStatus value);
template<typename T>
inline const std::string& PayloadStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadStatus_Name.");
  return PayloadStatus_Name(static_cast<PayloadStatus>(enum_t_value));
}
bool PayloadStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadStatus* value);
enum Bandwidth : int {
  BANDWIDTH_UNKNOWN = 0,
  BANDWIDTH_24_GHZ = 1,
  BANDWIDTH_5_GHZ = 2,
  BANDWIDTH_6_GHZ = 3
};
bool Bandwidth_IsValid(int value);
constexpr Bandwidth Bandwidth_MIN = BANDWIDTH_UNKNOWN;
constexpr Bandwidth Bandwidth_MAX = BANDWIDTH_6_GHZ;
constexpr int Bandwidth_ARRAYSIZE = Bandwidth_MAX + 1;

const std::string& Bandwidth_Name(Bandwidth value);
template<typename T>
inline const std::string& Bandwidth_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Bandwidth>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Bandwidth_Name.");
  return Bandwidth_Name(static_cast<Bandwidth>(enum_t_value));
}
bool Bandwidth_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Bandwidth* value);
enum BandwidthUpgradeResult : int {
  UNKNOWN_BANDWIDTH_UPGRADE_RESULT = 0,
  UPGRADE_RESULT_SUCCESS = 1,
  UPGRADE_RESULT_ERROR = 2,
  MEDIUM_ERROR = 3,
  PROTOCOL_ERROR = 4,
  RESULT_IO_ERROR = 5,
  CHANNEL_ERROR = 6,
  ALREADY_ON_MEDIUM_ERROR = 7,
  UNFINISHED_ERROR = 10,
  BLUETOOTH_MEDIUM_ERROR = 11,
  WIFI_AWARE_MEDIUM_ERROR = 12,
  WIFI_LAN_MEDIUM_ERROR = 13,
  WIFI_HOTSPOT_MEDIUM_ERROR = 14,
  WIFI_DIRECT_MEDIUM_ERROR = 15,
  WEB_RTC_MEDIUM_ERROR = 16,
  RESULT_REMOTE_ERROR = 17,
  ATTEMPT_SKIPPED = 18,
  REMOTE_CONNECTION_ERROR = 19
};
bool BandwidthUpgradeResult_IsValid(int value);
constexpr BandwidthUpgradeResult BandwidthUpgradeResult_MIN = UNKNOWN_BANDWIDTH_UPGRADE_RESULT;
constexpr BandwidthUpgradeResult BandwidthUpgradeResult_MAX = REMOTE_CONNECTION_ERROR;
constexpr int BandwidthUpgradeResult_ARRAYSIZE = BandwidthUpgradeResult_MAX + 1;

const std::string& BandwidthUpgradeResult_Name(BandwidthUpgradeResult value);
template<typename T>
inline const std::string& BandwidthUpgradeResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BandwidthUpgradeResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BandwidthUpgradeResult_Name.");
  return BandwidthUpgradeResult_Name(static_cast<BandwidthUpgradeResult>(enum_t_value));
}
bool BandwidthUpgradeResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeResult* value);
enum BandwidthUpgradeErrorStage : int {
  UNKNOWN_BANDWIDTH_UPGRADE_ERROR_STAGE = 0,
  CLIENT_INTRODUCTION = 1,
  NETWORK_AVAILABLE = 2,
  LAST_WRITE_TO_PRIOR_CHANNEL = 3,
  SAFE_TO_CLOSE_PRIOR_CHANNEL = 4,
  SOCKET_CREATION = 5,
  PRIOR_ENDPOINT_CHANNEL = 6,
  UPGRADE_UNFINISHED = 7,
  UPGRADE_SUCCESS = 8,
  UPGRADE_CANCEL = 9,
  WIFI_START_HOTSPOT = 10,
  WIFI_LISTEN_INCOMING = 11,
  WIFI_CONNECT_TO_HOTSPOT = 12,
  WIFI_HOTSPOT_SOCKET_CREATION = 28,
  WIFI_LAN_LISTEN_INCOMING = 13,
  WIFI_LAN_IP_ADDRESS = 14,
  WIFI_LAN_SOCKET_CREATION = 29,
  WIFI_LAN_SOCKET_CONNECTION = 15,
  BLUETOOTH_LISTEN_INCOMING = 16,
  BLUETOOTH_OBTAIN_MAC_ADDRESS = 17,
  BLUETOOTH_CONNECT_OUTGOING = 18,
  BLUETOOTH_PARSE_MAC_ADDRESS = 19,
  BLUETOOTH_SOCKET_CREATION = 30,
  WIFI_AWARE_LISTEN_INCOMING = 20,
  WIFI_AWARE_PUBLISH = 21,
  WIFI_AWARE_SUBSCRIBE = 22,
  WIFI_AWARE_CONNECT_TO_NETWORK = 23,
  WIFI_AWARE_SOCKET_CREATION = 31,
  WIFI_DIRECT_LISTEN_INCOMING = 24,
  WIFI_DIRECT_CREATE_GROUP = 25,
  WIFI_DIRECT_CONNECT_OUTGOING = 26,
  WIFI_DIRECT_PARSE_DEVICE_ADDRESS = 27,
  WIFI_DIRECT_SOCKET_CREATION = 32,
  WEB_RTC_SOCKET_CREATION = 33,
  WEB_RTC_LISTEN_INCOMING = 34
};
bool BandwidthUpgradeErrorStage_IsValid(int value);
constexpr BandwidthUpgradeErrorStage BandwidthUpgradeErrorStage_MIN = UNKNOWN_BANDWIDTH_UPGRADE_ERROR_STAGE;
constexpr BandwidthUpgradeErrorStage BandwidthUpgradeErrorStage_MAX = WEB_RTC_LISTEN_INCOMING;
constexpr int BandwidthUpgradeErrorStage_ARRAYSIZE = BandwidthUpgradeErrorStage_MAX + 1;

const std::string& BandwidthUpgradeErrorStage_Name(BandwidthUpgradeErrorStage value);
template<typename T>
inline const std::string& BandwidthUpgradeErrorStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BandwidthUpgradeErrorStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BandwidthUpgradeErrorStage_Name.");
  return BandwidthUpgradeErrorStage_Name(static_cast<BandwidthUpgradeErrorStage>(enum_t_value));
}
bool BandwidthUpgradeErrorStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeErrorStage* value);
enum LogSource : int {
  UNSPECIFIED_SOURCE = 0,
  LAB_DEVICES = 1,
  INTERNAL_DEVICES = 2,
  BETA_TESTER_DEVICES = 3,
  OEM_DEVICES = 4,
  DEBUG_DEVICES = 5
};
bool LogSource_IsValid(int value);
constexpr LogSource LogSource_MIN = UNSPECIFIED_SOURCE;
constexpr LogSource LogSource_MAX = DEBUG_DEVICES;
constexpr int LogSource_ARRAYSIZE = LogSource_MAX + 1;

const std::string& LogSource_Name(LogSource value);
template<typename T>
inline const std::string& LogSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogSource_Name.");
  return LogSource_Name(static_cast<LogSource>(enum_t_value));
}
bool LogSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogSource* value);
enum PowerLevel : int {
  ULTRA_LOW_POWER = -1,
  UNSPECIFIED = 0,
  LOW_POWER = 1,
  BALANCED_POWER = 2,
  HIGH_POWER = 3
};
bool PowerLevel_IsValid(int value);
constexpr PowerLevel PowerLevel_MIN = ULTRA_LOW_POWER;
constexpr PowerLevel PowerLevel_MAX = HIGH_POWER;
constexpr int PowerLevel_ARRAYSIZE = PowerLevel_MAX + 1;

const std::string& PowerLevel_Name(PowerLevel value);
template<typename T>
inline const std::string& PowerLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerLevel_Name.");
  return PowerLevel_Name(static_cast<PowerLevel>(enum_t_value));
}
bool PowerLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerLevel* value);
enum OperationResultCategory : int {
  CATEGORY_UNKNOWN = 0,
  CATEGORY_SUCCESS = 1,
  CATEGORY_CLIENT_CANCELLATION = 2,
  CATEGORY_MEDIUM_UNAVAILABLE = 3,
  CATEGORY_DEVICE_STATE_ERROR = 4,
  CATEGORY_CLIENT_ERROR = 5,
  CATEGORY_NEARBY_ERROR = 6,
  CATEGORY_CONNECTIVITY_ERROR = 7,
  CATEGORY_MISCELLANEOUS = 8,
  CATEGORY_IO_ERROR = 9
};
bool OperationResultCategory_IsValid(int value);
constexpr OperationResultCategory OperationResultCategory_MIN = CATEGORY_UNKNOWN;
constexpr OperationResultCategory OperationResultCategory_MAX = CATEGORY_IO_ERROR;
constexpr int OperationResultCategory_ARRAYSIZE = OperationResultCategory_MAX + 1;

const std::string& OperationResultCategory_Name(OperationResultCategory value);
template<typename T>
inline const std::string& OperationResultCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationResultCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationResultCategory_Name.");
  return OperationResultCategory_Name(static_cast<OperationResultCategory>(enum_t_value));
}
bool OperationResultCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationResultCategory* value);
enum OperationResultDetail : int {
  DETAIL_UNKNOWN = 0,
  DETAIL_SUCCESS = 1,
  CLIENT_CANCELLATION_REMOTE_IN_CANCELED_STATE = 500,
  CLIENT_CANCELLATION_LOCAL_CANCEL_PAYLOAD = 501,
  CLIENT_CANCELLATION_REMOTE_CANCEL_PAYLOAD = 502,
  CLIENT_CANCELLATION_UPGRADE_CANCELED_BY_REMOTE = 503,
  CLIENT_CANCELLATION_CANCEL_BLE_OUTGOING_CONNECTION = 504,
  CLIENT_CANCELLATION_CANCEL_BT_OUTGOING_CONNECTION = 505,
  CLIENT_CANCELLATION_CANCEL_L2CAP_OUTGOING_CONNECTION = 506,
  CLIENT_CANCELLATION_CANCEL_LAN_OUTGOING_CONNECTION = 507,
  CLIENT_CANCELLATION_CANCEL_NFC_OUTGOING_CONNECTION = 508,
  CLIENT_CANCELLATION_CANCEL_USB_OUTGOING_CONNECTION = 509,
  CLIENT_CANCELLATION_CANCEL_WIFI_AWARE_OUTGOING_CONNECTION = 510,
  CLIENT_CANCELLATION_CANCEL_WIFI_DIRECT_OUTGOING_CONNECTION = 511,
  CLIENT_CANCELLATION_CANCEL_WIFI_HOTSPOT_OUTGOING_CONNECTION = 512,
  CLIENT_CANCELLATION_CANCEL_WEB_RTC_OUTGOING_CONNECTION = 513,
  CLIENT_CANCELLATION_CANCEL_OUTGOING_CONNECTION = 514,
  CLIENT_CANCELLATION_CANCEL_INCOMING_CONNECTION = 515,
  CLIENT_CANCELLATION_WIFI_AWARE_SERVER_SOCKET_CREATION = 516,
  CLIENT_CANCELLATION_WIFI_DIRECT_SERVER_SOCKET_CREATION = 517,
  CLIENT_CANCELLATION_WIFI_HOTSPOT_SERVER_SOCKET_CREATION = 518,
  CLIENT_CANCELLATION_BT_SERVER_SOCKET_CREATION = 519,
  CLIENT_CANCELLATION_WEB_RTC_SERVER_SOCKET_CREATION = 520,
  CLIENT_CANCELLATION_WIFI_LAN_SERVER_SOCKET_CREATION = 521,
  CLIENT_CANCELLATION_LOCAL_DISCONNECT = 522,
  CLIENT_CANCELLATION_REMOTE_DISCONNECT = 523,
  DEVICE_STATE_ERROR_UNFINISHED_UPGRADE_ATTEMPTS = 1000,
  DEVICE_STATE_ERROR_USER_HOTSPOT_ENABLED = 1001,
  DEVICE_STATE_LOCATION_DISABLED = 1002,
  DEVICE_STATE_RADIO_DISABLING_FAILURE = 1003,
  DEVICE_STATE_RADIO_ENABLING_FAILURE = 1004,
  MEDIUM_UNAVAILABLE_WIFI_AWARE_RESOURCE_NOT_AVAILABLE = 1500,
  MEDIUM_UNAVAILABLE_DIRECT_HOTSPOT_NOT_SUPPORT = 1501,
  MEDIUM_UNAVAILABLE_SOFT_AP_NOT_SUPPORT = 1502,
  MEDIUM_UNAVAILABLE_LOCAL_ONLY_HOTSPOT_NOT_SUPPORT = 1503,
  MEDIUM_UNAVAILABLE_LOCAL_ONLY_HOTSPOT_NOT_SUPPORT_5G = 1504,
  MEDIUM_UNAVAILABLE_BLE_NOT_AVAILABLE = 1505,
  MEDIUM_UNAVAILABLE_L2CAP_NOT_AVAILABLE = 1506,
  MEDIUM_UNAVAILABLE_BLUETOOTH_NOT_AVAILABLE = 1507,
  MEDIUM_UNAVAILABLE_WEB_RTC_NOT_AVAILABLE = 1508,
  MEDIUM_UNAVAILABLE_WIFI_AWARE_NOT_AVAILABLE = 1509,
  MEDIUM_UNAVAILABLE_WIFI_HOTSPOT_NOT_AVAILABLE = 1510,
  MEDIUM_UNAVAILABLE_WIFI_DIRECT_NOT_AVAILABLE = 1511,
  MEDIUM_UNAVAILABLE_NFC_NOT_AVAILABLE = 1512,
  MEDIUM_UNAVAILABLE_LAN_NOT_AVAILABLE = 1513,
  MEDIUM_UNAVAILABLE_USB_NOT_AVAILABLE = 1514,
  MEDIUM_UNAVAILABLE_BLE_NC_LOGICAL_NOT_AVAILABLE = 1515,
  MEDIUM_UNAVAILABLE_BT_NC_LOGICAL_NOT_AVAILABLE = 1516,
  MEDIUM_UNAVAILABLE_LAN_NC_LOGICAL_NOT_AVAILABLE = 1517,
  MEDIUM_UNAVAILABLE_NFC_NC_LOGICAL_NOT_AVAILABLE = 1518,
  MEDIUM_UNAVAILABLE_USB_NC_LOGICAL_NOT_AVAILABLE = 1519,
  MEDIUM_UNAVAILABLE_WEB_RTC_NC_LOGICAL_NOT_AVAILABLE = 1520,
  MEDIUM_UNAVAILABLE_WIFI_AWARE_NC_LOGICAL_NOT_AVAILABLE = 1521,
  MEDIUM_UNAVAILABLE_WIFI_HOTSPOT_NC_LOGICAL_NOT_AVAILABLE = 1522,
  MEDIUM_UNAVAILABLE_WIFI_DIRECT_NC_LOGICAL_NOT_AVAILABLE = 1523,
  MEDIUM_UNAVAILABLE_WIFI_HOTSPOT_P2P_RESOURCE_NOT_AVAILABLE = 1524,
  MEDIUM_UNAVAILABLE_WIFI_DIRECT_P2P_RESOURCE_NOT_AVAILABLE = 1525,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_BLE_LOW_QUALITY_MEDIUMS = 1526,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_L2CAP_LOW_QUALITY_MEDIUMS = 1527,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_WEB_RTC_LOW_QUALITY_MEDIUMS = 1528,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_LAN_LOW_QUALITY_MEDIUMS = 1529,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_BT_LOW_QUALITY_MEDIUMS = 1530,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_USB_LOW_QUALITY_MEDIUMS = 1531,
  MEDIUM_UNAVAILABLE_LOCAL_ONLY_HOTSPOT_DISRUPTIVE_FALSE = 1532,
  MEDIUM_UNAVAILABLE_SOFT_AP_DISRUPTIVE_FALSE = 1533,
  MEDIUM_UNAVAILABLE_ALREADY_HAVE_A_WIFI_DIRECT_GROUP = 1534,
  MEDIUM_UNAVAILABLE_ALREADY_HOSTING_HOTSPOT_FOR_OTHER_CLIENTS = 1535,
  MEDIUM_UNAVAILABLE_REJECT_L2CAP_ON_GATT_MULTIPLEX_CONNECTION = 1536,
  MEDIUM_UNAVAILABLE_UPGRADE_ON_SAME_MEDIUM = 1537,
  MEDIUM_UNAVAILABLE_WEB_RTC_NO_INTERNET = 1538,
  CLIENT_WIFI_DIRECT_ALREADY_HOSTING_DIRECT_GROUP_FOR_THIS_CLIENT = 2000,
  CLIENT_WIFI_HOTSPOT_ALREADY_HOSTING_HOTSPOT_FOR_THIS_CLIENT = 2001,
  CLIENT_DUPLICATE_ACCEPTING_BLE_CONNECTION_REQUEST = 2002,
  CLIENT_DUPLICATE_ACCEPTING_L2CAP_CONNECTION_REQUEST = 2003,
  CLIENT_DUPLICATE_ACCEPTING_BT_CONNECTION_REQUEST = 2004,
  CLIENT_DUPLICATE_ACCEPTING_LAN_CONNECTION_REQUEST = 2005,
  CLIENT_DUPLICATE_ACCEPTING_NFC_CONNECTION_REQUEST = 2006,
  CLIENT_DUPLICATE_ACCEPTING_WEB_RTC_CONNECTION_REQUEST = 2007,
  CLIENT_DUPLICATE_ACCEPTING_WIFI_AWARE_CONNECTION_REQUEST = 2008,
  CLIENT_DUPLICATE_ACCEPTING_WIFI_HOTSPOT_CONNECTION_REQUEST = 2009,
  CLIENT_DUPLICATE_ACCEPTING_WIFI_DIRECT_CONNECTION_REQUEST = 2010,
  CLIENT_DUPLICATE_ACCEPTING_USB_CONNECTION_REQUEST = 2011,
  CLIENT_DUPLICATE_WIFI_AWARE_CONNECTION_REQUEST = 2012,
  CLIENT_DUPLICATE_WIFI_DIRECT_CONNECTION_REQUEST = 2013,
  CLIENT_DUPLICATE_WIFI_HOTSPOT_CONNECTION_REQUEST = 2014,
  CLIENT_DUPLICATE_WIFI_AWARE_SUBSCRIBING_REQUEST = 2015,
  CLIENT_UNSUPPORTED_USB_TO_BE_UPGRADE_MEDIUM = 2016,
  MISCELLEANEOUS_BLUETOOTH_MAC_ADDRESS_NULL = 2500,
  MISCELLEANEOUS_MOVE_TO_NEW_MEDIUM = 2501,
  MISCELLEANEOUS_WIFI_HOTSPOT_SOFT_AP_BLOCKED_BY_PROVISION = 2502,
  MISCELLEANEOUS_BLE_SYSTEM_SERVICE_NULL = 2503,
  MISCELLEANEOUS_L2CAP_SYSTEM_SERVICE_NULL = 2504,
  MISCELLEANEOUS_BT_SYSTEM_SERVICE_NULL = 2505,
  MISCELLEANEOUS_WIFI_AWARE_SYSTEM_SERVICE_NULL = 2506,
  MISCELLEANEOUS_WIFI_DIRECT_SYSTEM_SERVICE_NULL = 2507,
  MISCELLEANEOUS_WIFI_LAN_SYSTEM_SERVICE_NULL = 2508,
  MISCELLEANEOUS_WIFI_HOTSPOT_SYSTEM_SERVICE_NULL = 2509,
  MISCELLEANEOUS_BT_NOT_ACCEPTING_CONNECTION_FOR_WORK_PROFILE = 2510,
  MISCELLEANEOUS_WEB_RTC_GET_DROIDGUARD_RESULT_FAILURE = 2511,
  MISCELLEANEOUS_WEB_RTC_TACHYON_SIGNALING_MESSENGER_NULL = 2512,
  IO_FILE_OPENING_ERROR = 3000,
  IO_FILE_READING_ERROR = 3001,
  IO_FILE_WRITING_ERROR = 3002,
  IO_FOLDER_CREATION_ERROR = 3003,
  IO_STREAM_CREATE_PIPE_FAILURE = 3004,
  IO_ENDPOINT_IO_ERROR_ON_BLE = 3005,
  IO_ENDPOINT_IO_ERROR_ON_L2CAP = 3006,
  IO_ENDPOINT_IO_ERROR_ON_BT = 3007,
  IO_ENDPOINT_IO_ERROR_ON_WEB_RTC = 3008,
  IO_ENDPOINT_IO_ERROR_ON_LAN = 3009,
  IO_ENDPOINT_IO_ERROR_ON_WIFI_DIRECT = 3010,
  IO_ENDPOINT_IO_ERROR_ON_WIFI_HOTSPOT = 3011,
  IO_ENDPOINT_IO_ERROR_ON_WIFI_AWARE = 3012,
  IO_ENDPOINT_IO_ERROR_ON_NFC = 3013,
  IO_ENDPOINT_IO_ERROR_ON_USB = 3014,
  CONNECTIVITY_WIFI_AWARE_ATTACH_FAILURE = 3500,
  CONNECTIVITY_BLUETOOTH_DEVICE_OBTAIN_FAILURE = 3501,
  CONNECTIVITY_BLE_CLIENT_SOCKET_CREATION_FAILURE = 3502,
  CONNECTIVITY_L2CAP_CLIENT_SOCKET_CREATION_FAILURE = 3503,
  CONNECTIVITY_BT_CLIENT_SOCKET_CREATION_FAILURE = 3504,
  CONNECTIVITY_LAN_CLIENT_SOCKET_CREATION_FAILURE = 3505,
  CONNECTIVITY_NFC_CLIENT_SOCKET_CREATION_FAILURE = 3506,
  CONNECTIVITY_WEB_RTC_CLIENT_SOCKET_CREATION_FAILURE = 3507,
  CONNECTIVITY_WIFI_AWARE_CLIENT_SOCKET_CREATION_FAILURE = 3508,
  CONNECTIVITY_WIFI_HOTSPOT_CLIENT_SOCKET_CREATION_FAILURE = 3509,
  CONNECTIVITY_WIFI_DIRECT_CLIENT_SOCKET_CREATION_FAILURE = 3510,
  CONNECTIVITY_USB_CLIENT_SOCKET_CREATION_FAILURE = 3511,
  CONNECTIVITY_WEB_RTC_CONNECT_TO_TACHYON_FAILURE = 3512,
  CONNECTIVITY_BLE_CREATE_GATT_CONNECTION_FAILURE = 3513,
  CONNECTIVITY_WIFI_AWARE_GET_REMOTE_IP_FRAME_FAILURE = 3514,
  CONNECTIVITY_WIFI_AWARE_GET_REMOTE_IP_ADDRESS_FAILURE = 3515,
  CONNECTIVITY_WIFI_DIRECT_INCONSISTENT_HOSTED_WIFI_BAND = 3516,
  CONNECTIVITY_WIFI_HOTSPOT_INCONSISTENT_HOSTED_WIFI_BAND = 3517,
  CONNECTIVITY_BLUETOOTH_INVALID_CREDENTIAL = 3518,
  CONNECTIVITY_WIFI_LAN_INVALID_CREDENTIAL = 3519,
  CONNECTIVITY_WIFI_DIRECT_INVALID_CREDENTIAL = 3520,
  CONNECTIVITY_WIFI_HOTSPOT_INVALID_CREDENTIAL = 3521,
  CONNECTIVITY_WIFI_AWARE_INVALID_CREDENTIAL = 3522,
  CONNECTIVITY_WEB_RTC_INVALID_CREDENTIAL = 3523,
  CONNECTIVITY_WIFI_LAN_IP_ADDRESS_ERROR = 3524,
  CONNECTIVITY_L2CAP_CLIENT_OBTAIN_FAIURE = 3525,
  CONNECTIVITY_L2CAP_DATA_CONNECTION_FAILURE = 3526,
  CONNECTIVITY_WIFI_AWARE_L2MESSAGE_NETWORK_AVAILABLE_FRAME_NULL = 3527,
  CONNECTIVITY_WIFI_AWARE_L2MESSAGE_SEND_HOST_NETWORK_FRAME_FAILURE = 3528,
  CONNECTIVITY_LAN_UNREACHABLE = 3529,
  CONNECTIVITY_WIFI_HOTSPOT_LOHS_CREATION_FAILURE = 3530,
  CONNECTIVITY_LAN_GET_NETWORK_INTERFACES_FAILURE = 3531,
  CONNECTIVITY_WIFI_DIRECT_GET_NETWORK_INTERFACES_FAILURE = 3532,
  CONNECTIVITY_WIFI_HOTSPOT_GET_NETWORK_INTERFACES_FAILURE = 3533,
  CONNECTIVITY_WIFI_HOTSPOT_P2P_CHANNEL_INITIALIZE_FAILURE = 3534,
  CONNECTIVITY_WIFI_DIRECT_P2P_CHANNEL_INITIALIZE_FAILURE = 3535,
  CONNECTIVITY_WIFI_HOTSPOT_P2P_GROUP_CREATION_FAILURE = 3536,
  CONNECTIVITY_WIFI_DIRECT_P2P_GROUP_CREATION_FAILURE = 3537,
  CONNECTIVITY_GATT_SERVER_OPEN_FAILURE = 3538,
  CONNECTIVITY_BLE_SERVER_SOCKET_CREATION_FAILURE = 3539,
  CONNECTIVITY_L2CAP_SERVER_SOCKET_CREATION_FAILURE = 3540,
  CONNECTIVITY_BT_SERVER_SOCKET_CREATION_FAILURE = 3541,
  CONNECTIVITY_LAN_SERVER_SOCKET_CREATION_FAILURE = 3542,
  CONNECTIVITY_WEB_RTC_SERVER_SOCKET_CREATION_FAILURE = 3543,
  CONNECTIVITY_WIFI_AWARE_SERVER_SOCKET_CREATION_FAILURE = 3544,
  CONNECTIVITY_WIFI_HOTSPOT_SERVER_SOCKET_CREATION_FAILURE = 3545,
  CONNECTIVITY_WIFI_DIRECT_SERVER_SOCKET_CREATION_FAILURE = 3546,
  CONNECTIVITY_NFC_SERVER_SOCKET_CREATION_FAILURE = 3547,
  CONNECTIVITY_WIFI_HOTSPOT_SOFT_AP_CREATION_FAILURE = 3548,
  CONNECTIVITY_WIFI_AWARE_UPDATE_PUBLISH_FAILURE = 3549,
  CONNECTIVITY_GENERIC_WRITING_CHANNEL_IO_ERROR = 3550,
  CONNECTIVITY_GENERIC_WRITE_CLIENT_INTRODUCTION_ACK_IO_ERROR = 3551,
  CONNECTIVITY_WIFI_AWARE_DISCOVERED_PEER_NULL = 3552,
  CONNECTIVITY_GENERIC_PAYLOAD_SENT_ERROR = 3553,
  CONNECTIVITY_L2CAP_SERVER_SOCKET_CREATION_SECURITY_EXCEPTION_FAILURE = 3554,
  CONNECTIVITY_BT_SERVER_SOCKET_CREATION_SECURITY_EXCEPTION_FAILURE = 3555,
  NEARBY_BLE_ADVERTISEMENT_MAPPING_TO_MAC_ERROR = 4500,
  NEARBY_BLUETOOTH_MAC_ADDRESS_INVALID_FOR_CONNECT = 4501,
  NEARBY_WEB_RTC_CONNECTION_FLOW_NULL = 4502,
  NEARBY_GENERIC_CONNECTION_CLOSED = 4503,
  NEARBY_BLE_ENDPOINT_CHANNEL_CREATION_FAILURE = 4504,
  NEARBY_L2CAP_ENDPOINT_CHANNEL_CREATION_FAILURE = 4505,
  NEARBY_BT_ENDPOINT_CHANNEL_CREATION_FAILURE = 4506,
  NEARBY_LAN_ENDPOINT_CHANNEL_CREATION_FAILURE = 4507,
  NEARBY_NFC_ENDPOINT_CHANNEL_CREATION_FAILURE = 4508,
  NEARBY_WIFI_AWARE_ENDPOINT_CHANNEL_CREATION_FAILURE = 4509,
  NEARBY_WIFI_HOTSPOT_ENDPOINT_CHANNEL_CREATION_FAILURE = 4510,
  NEARBY_WIFI_DIRECT_ENDPOINT_CHANNEL_CREATION_FAILURE = 4511,
  NEARBY_WEB_RTC_ENDPOINT_CHANNEL_CREATION_FAILURE = 4512,
  NEARBY_USB_ENDPOINT_CHANNEL_CREATION_FAILURE = 4513,
  NEARBY_GENERIC_ENDPOINT_UNENCRYPTED = 4514,
  NEARBY_BLE_GATT_ADVERTISEMENT_NULL_FOR_CONNECTION = 4515,
  NEARBY_WIFI_DIRECT_HOST_ON_SRD_CHANNELS = 4516,
  NEARBY_WIFI_HOTSPOT_HOST_ON_SRD_CHANNELS = 4517,
  NEARBY_BLE_GATT_NULL_CALLBACK = 4518,
  NEARBY_L2CAP_NULL_CALLBACK = 4519,
  NEARBY_BT_NULL_CALLBACK = 4520,
  NEARBY_USB_NULL_CALLBACK = 4521,
  NEARBY_NFC_NULL_CALLBACK = 4522,
  NEARBY_WIFI_AWARE_NULL_CALLBACK = 4523,
  NEARBY_WEB_RTC_NULL_CALLBACK = 4524,
  NEARBY_LAN_NULL_CALLBACK = 4525,
  NEARBY_WIFI_HOTSPOT_NULL_CALLBACK = 4526,
  NEARBY_WIFI_DIRECT_NULL_CALLBACK = 4527,
  NEARBY_WIFI_DIRECT_NULL_SSID = 4528,
  NEARBY_WIFI_DIRECT_NULL_PASSWORD = 4529,
  NEARBY_BT_MULTIPLEX_SOCKET_DISABLED = 4530,
  NEARBY_LAN_MULTIPLEX_SOCKET_DISABLED = 4531,
  NEARBY_GENERIC_NEW_ENDPOINT_CHANNEL_NULL = 4532,
  NEARBY_WIFI_DIRECT_NO_GROUP_FOR_LISTENING = 4533,
  NEARBY_WIFI_HOTSPOT_NO_HOTSPOT_FOR_LISTENING = 4534,
  NEARBY_GENERIC_OLD_ENDPOINT_CHANNEL_NULL = 4535,
  NEARBY_BLE_OPERATION_REGISTERED_FAILED = 4536,
  NEARBY_L2CAP_OPERATION_REGISTERED_FAILED = 4537,
  NEARBY_BT_OPERATION_REGISTERED_FAILED = 4538,
  NEARBY_LAN_OPERATION_REGISTERED_FAILED = 4539,
  NEARBY_WEB_RTC_OPERATION_REGISTERED_FAILED = 4540,
  NEARBY_WIFI_AWARE_OPERATION_REGISTERED_FAILED = 4541,
  NEARBY_WIFI_HOTSPOT_DIRECT_OPERATION_REGISTERED_FAILED = 4542,
  NEARBY_WIFI_HOTSPOT_SOFT_AP_OPERATION_REGISTERED_FAILED = 4543,
  NEARBY_WIFI_HOTSPOT_LOHS_OPERATION_REGISTERED_FAILED = 4544,
  NEARBY_WIFI_HOTSPOT_CLIENT_OPERATION_REGISTERED_FAILED = 4545,
  NEARBY_WIFI_DIRECT_OPERATION_REGISTERED_FAILED = 4546,
  NEARBY_GENERIC_OUTGOING_PAYLOAD_CREATION_FAILURE = 4547,
  NEARBY_WIFI_HOTSPOT_P2P_NON_DBS_WANT_2G_BUT_AP_5G = 4548,
  NEARBY_WIFI_DIRECT_P2P_NON_DBS_WANT_2G_BUT_AP_5G = 4549,
  NEARBY_WIFI_HOTSPOT_P2P_NON_DBS_WANT_5G_BUT_AP_2G = 4550,
  NEARBY_WIFI_DIRECT_P2P_NON_DBS_WANT_5G_BUT_AP_2G = 4551,
  NEARBY_GENERIC_INCOMING_PAYLOAD_NOT_DATA_TYPE = 4552,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_EVENT_TYPE_ERROR = 4553,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_FRAME_TYPE_ERROR = 4554,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_FORMAT_ERROR = 4555,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_ACK_EVENT_TYPE_ERROR = 4556,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_ACK_FRAME_TYPE_ERROR = 4557,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_ACK_FORMAT_ERROR = 4558,
  NEARBY_GENERIC_REMOTE_ENDPOINT_STATUS_ERROR = 4559,
  NEARBY_GENERIC_REMOTE_REPORT_PAYLOADS_ERROR = 4560,
  NEARBY_GENERIC_REMOTE_UPGRADE_FAILURE = 4561,
  NEARBY_GENERIC_SEND_PAYLOAD_EXECUTOR_NULL = 4562,
  NEARBY_BT_VIRTUAL_SOCKET_CREATION_FAILURE = 4563,
  NEARBY_LAN_VIRTUAL_SOCKET_CREATION_FAILURE = 4564,
  NEARBY_WIFI_LAN_IP_ADDRESS_ERROR = 4565,
  NEARBY_L2CAP_PSM_NOT_POSITIVE = 4566
};
bool OperationResultDetail_IsValid(int value);
constexpr OperationResultDetail OperationResultDetail_MIN = DETAIL_UNKNOWN;
constexpr OperationResultDetail OperationResultDetail_MAX = NEARBY_L2CAP_PSM_NOT_POSITIVE;
constexpr int OperationResultDetail_ARRAYSIZE = OperationResultDetail_MAX + 1;

const std::string& OperationResultDetail_Name(OperationResultDetail value);
template<typename T>
inline const std::string& OperationResultDetail_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationResultDetail>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationResultDetail_Name.");
  return OperationResultDetail_Name(static_cast<OperationResultDetail>(enum_t_value));
}
bool OperationResultDetail_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationResultDetail* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace connections
}  // namespace proto
}  // namespace nearby
}  // namespace location

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::location::nearby::proto::connections::EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::ConnectionsStrategy> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::SessionRole> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::Medium> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::ConnectionTechnology> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::ConnectionBand> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::ConnectionRequestResponse> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::ConnectionAttemptResult> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::ConnectionAttemptDirection> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::ConnectionAttemptType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::DisconnectionReason> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::PayloadType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::PayloadStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::Bandwidth> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::BandwidthUpgradeResult> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::BandwidthUpgradeErrorStage> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::LogSource> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::PowerLevel> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::OperationResultCategory> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::proto::connections::OperationResultDetail> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fconnections_5fenums_2eproto
