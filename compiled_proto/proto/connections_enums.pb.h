// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: proto/connections_enums.proto
// Protobuf C++ Version: 6.33.3

#ifndef proto_2fconnections_5fenums_2eproto_2epb_2eh
#define proto_2fconnections_5fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fconnections_5fenums_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fconnections_5fenums_2eproto {
  static const ::uint32_t offsets[];
};
namespace location {
namespace nearby {
namespace proto {
namespace connections {
enum Bandwidth : int;
extern const uint32_t Bandwidth_internal_data_[];
enum BandwidthUpgradeErrorStage : int;
extern const uint32_t BandwidthUpgradeErrorStage_internal_data_[];
enum BandwidthUpgradeResult : int;
extern const uint32_t BandwidthUpgradeResult_internal_data_[];
enum ConnectionAttemptDirection : int;
extern const uint32_t ConnectionAttemptDirection_internal_data_[];
enum ConnectionAttemptResult : int;
extern const uint32_t ConnectionAttemptResult_internal_data_[];
enum ConnectionAttemptType : int;
extern const uint32_t ConnectionAttemptType_internal_data_[];
enum ConnectionBand : int;
extern const uint32_t ConnectionBand_internal_data_[];
enum ConnectionMode : int;
extern const uint32_t ConnectionMode_internal_data_[];
enum ConnectionRequestResponse : int;
extern const uint32_t ConnectionRequestResponse_internal_data_[];
enum ConnectionTechnology : int;
extern const uint32_t ConnectionTechnology_internal_data_[];
enum ConnectionsStrategy : int;
extern const uint32_t ConnectionsStrategy_internal_data_[];
enum DctPayloadType : int;
extern const uint32_t DctPayloadType_internal_data_[];
enum DeviceType : int;
extern const uint32_t DeviceType_internal_data_[];
enum DisconnectionReason : int;
extern const uint32_t DisconnectionReason_internal_data_[];
enum EventType : int;
extern const uint32_t EventType_internal_data_[];
enum InstantConnectionResult : int;
extern const uint32_t InstantConnectionResult_internal_data_[];
enum LogSource : int;
extern const uint32_t LogSource_internal_data_[];
enum Medium : int;
extern const uint32_t Medium_internal_data_[];
enum OperationResultCategory : int;
extern const uint32_t OperationResultCategory_internal_data_[];
enum OperationResultCode : int;
extern const uint32_t OperationResultCode_internal_data_[];
enum PayloadStatus : int;
extern const uint32_t PayloadStatus_internal_data_[];
enum PayloadType : int;
extern const uint32_t PayloadType_internal_data_[];
enum PowerLevel : int;
extern const uint32_t PowerLevel_internal_data_[];
enum SessionRole : int;
extern const uint32_t SessionRole_internal_data_[];
enum StopAdvertisingReason : int;
extern const uint32_t StopAdvertisingReason_internal_data_[];
enum StopDiscoveringReason : int;
extern const uint32_t StopDiscoveringReason_internal_data_[];
enum SupportedService : int;
extern const uint32_t SupportedService_internal_data_[];
enum WifiDirectAuthType : int;
extern const uint32_t WifiDirectAuthType_internal_data_[];
}  // namespace connections
}  // namespace proto
}  // namespace nearby
}  // namespace location
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::Bandwidth_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::Bandwidth>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::BandwidthUpgradeErrorStage_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::BandwidthUpgradeErrorStage>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::BandwidthUpgradeResult_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::BandwidthUpgradeResult>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionAttemptDirection_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionAttemptDirection>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionAttemptResult_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionAttemptResult>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionAttemptType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionAttemptType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionBand_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionBand>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionMode_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionMode>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionRequestResponse_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionRequestResponse>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionTechnology_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionTechnology>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::ConnectionsStrategy_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::ConnectionsStrategy>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::DctPayloadType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::DctPayloadType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::DeviceType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::DeviceType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::DisconnectionReason_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::DisconnectionReason>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::EventType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::EventType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::InstantConnectionResult_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::InstantConnectionResult>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::LogSource_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::LogSource>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::Medium_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::Medium>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::OperationResultCategory_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::OperationResultCategory>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::OperationResultCode_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::OperationResultCode>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::PayloadStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::PayloadStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::PayloadType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::PayloadType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::PowerLevel_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::PowerLevel>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::SessionRole_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::SessionRole>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::StopAdvertisingReason_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::StopAdvertisingReason>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::StopDiscoveringReason_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::StopDiscoveringReason>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::SupportedService_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::SupportedService>;
template <>
internal::EnumTraitsT<::location::nearby::proto::connections::WifiDirectAuthType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::connections::WifiDirectAuthType>;
}  // namespace protobuf
}  // namespace google

namespace location {
namespace nearby {
namespace proto {
namespace connections {
enum EventType : int {
  UNKNOWN_EVENT_TYPE = 0,
  CLIENT_SESSION = 1,
  START_CLIENT_SESSION = 2,
  STOP_CLIENT_SESSION = 3,
  START_STRATEGY_SESSION = 4,
  STOP_STRATEGY_SESSION = 5,
  ERROR_CODE = 6,
};

extern const uint32_t EventType_internal_data_[];
inline constexpr EventType EventType_MIN =
    static_cast<EventType>(0);
inline constexpr EventType EventType_MAX =
    static_cast<EventType>(6);
inline bool EventType_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int EventType_ARRAYSIZE = 6 + 1;
const ::std::string& EventType_Name(EventType value);
template <typename T>
const ::std::string& EventType_Name(T value) {
  static_assert(::std::is_same<T, EventType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
bool EventType_Parse(
    ::absl::string_view name, EventType* PROTOBUF_NONNULL value);
enum ConnectionsStrategy : int {
  UNKNOWN_STRATEGY = 0,
  MDNS_LOCAL_WIFI [[deprecated]] = 1,
  RADIO_P2P [[deprecated]] = 2,
  P2P_CLUSTER = 3,
  P2P_STAR = 4,
  P2P_POINT_TO_POINT = 5,
};

extern const uint32_t ConnectionsStrategy_internal_data_[];
inline constexpr ConnectionsStrategy ConnectionsStrategy_MIN =
    static_cast<ConnectionsStrategy>(0);
inline constexpr ConnectionsStrategy ConnectionsStrategy_MAX =
    static_cast<ConnectionsStrategy>(5);
inline bool ConnectionsStrategy_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int ConnectionsStrategy_ARRAYSIZE = 5 + 1;
const ::std::string& ConnectionsStrategy_Name(ConnectionsStrategy value);
template <typename T>
const ::std::string& ConnectionsStrategy_Name(T value) {
  static_assert(::std::is_same<T, ConnectionsStrategy>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionsStrategy_Name().");
  return ConnectionsStrategy_Name(static_cast<ConnectionsStrategy>(value));
}
bool ConnectionsStrategy_Parse(
    ::absl::string_view name, ConnectionsStrategy* PROTOBUF_NONNULL value);
enum SessionRole : int {
  UNKNOWN_SESSION_ROLE = 0,
  ADVERTISER = 1,
  DISCOVERER = 2,
};

extern const uint32_t SessionRole_internal_data_[];
inline constexpr SessionRole SessionRole_MIN =
    static_cast<SessionRole>(0);
inline constexpr SessionRole SessionRole_MAX =
    static_cast<SessionRole>(2);
inline bool SessionRole_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int SessionRole_ARRAYSIZE = 2 + 1;
const ::std::string& SessionRole_Name(SessionRole value);
template <typename T>
const ::std::string& SessionRole_Name(T value) {
  static_assert(::std::is_same<T, SessionRole>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SessionRole_Name().");
  return SessionRole_Name(static_cast<SessionRole>(value));
}
bool SessionRole_Parse(
    ::absl::string_view name, SessionRole* PROTOBUF_NONNULL value);
enum Medium : int {
  UNKNOWN_MEDIUM = 0,
  MDNS [[deprecated]] = 1,
  BLUETOOTH = 2,
  WIFI_HOTSPOT = 3,
  BLE = 4,
  WIFI_LAN = 5,
  WIFI_AWARE = 6,
  NFC = 7,
  WIFI_DIRECT = 8,
  WEB_RTC = 9,
  BLE_L2CAP = 10,
  USB = 11,
  WEB_RTC_NON_CELLULAR = 12,
  AWDL = 13,
};

extern const uint32_t Medium_internal_data_[];
inline constexpr Medium Medium_MIN =
    static_cast<Medium>(0);
inline constexpr Medium Medium_MAX =
    static_cast<Medium>(13);
inline bool Medium_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int Medium_ARRAYSIZE = 13 + 1;
const ::std::string& Medium_Name(Medium value);
template <typename T>
const ::std::string& Medium_Name(T value) {
  static_assert(::std::is_same<T, Medium>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Medium_Name().");
  return Medium_Name(static_cast<Medium>(value));
}
bool Medium_Parse(
    ::absl::string_view name, Medium* PROTOBUF_NONNULL value);
enum WifiDirectAuthType : int {
  WIFI_DIRECT_TYPE_UNKNOWN = 0,
  WIFI_DIRECT_WITH_PASSWORD = 1,
  WIFI_DIRECT_WITH_PIN = 2,
};

extern const uint32_t WifiDirectAuthType_internal_data_[];
inline constexpr WifiDirectAuthType WifiDirectAuthType_MIN =
    static_cast<WifiDirectAuthType>(0);
inline constexpr WifiDirectAuthType WifiDirectAuthType_MAX =
    static_cast<WifiDirectAuthType>(2);
inline bool WifiDirectAuthType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int WifiDirectAuthType_ARRAYSIZE = 2 + 1;
const ::std::string& WifiDirectAuthType_Name(WifiDirectAuthType value);
template <typename T>
const ::std::string& WifiDirectAuthType_Name(T value) {
  static_assert(::std::is_same<T, WifiDirectAuthType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WifiDirectAuthType_Name().");
  return WifiDirectAuthType_Name(static_cast<WifiDirectAuthType>(value));
}
bool WifiDirectAuthType_Parse(
    ::absl::string_view name, WifiDirectAuthType* PROTOBUF_NONNULL value);
enum ConnectionTechnology : int {
  CONNECTION_TECHNOLOGY_UNKNOWN_TECHNOLOGY = 0,
  CONNECTION_TECHNOLOGY_BLE_GATT = 1,
  CONNECTION_TECHNOLOGY_BLE_L2CAP = 2,
  CONNECTION_TECHNOLOGY_HOTSPOT_DIRECT = 3,
  CONNECTION_TECHNOLOGY_HOTSPOT_LOCALONLY = 4,
  CONNECTION_TECHNOLOGY_HOTSPOT_SOFTAP = 5,
  CONNECTION_TECHNOLOGY_WEBRTC_WIFI = 6,
  CONNECTION_TECHNOLOGY_WEBRTC_MOBILE = 7,
  CONNECTION_TECHNOLOGY_WEBRTC_ETHERNET = 8,
  CONNECTION_TECHNOLOGY_WEBRTC_VPN = 9,
  CONNECTION_TECHNOLOGY_WEBRTC_LOOPBACK = 10,
  CONNECTION_TECHNOLOGY_WEBRTC_ADAPTER_TYPE_ANY = 11,
};

extern const uint32_t ConnectionTechnology_internal_data_[];
inline constexpr ConnectionTechnology ConnectionTechnology_MIN =
    static_cast<ConnectionTechnology>(0);
inline constexpr ConnectionTechnology ConnectionTechnology_MAX =
    static_cast<ConnectionTechnology>(11);
inline bool ConnectionTechnology_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int ConnectionTechnology_ARRAYSIZE = 11 + 1;
const ::std::string& ConnectionTechnology_Name(ConnectionTechnology value);
template <typename T>
const ::std::string& ConnectionTechnology_Name(T value) {
  static_assert(::std::is_same<T, ConnectionTechnology>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionTechnology_Name().");
  return ConnectionTechnology_Name(static_cast<ConnectionTechnology>(value));
}
bool ConnectionTechnology_Parse(
    ::absl::string_view name, ConnectionTechnology* PROTOBUF_NONNULL value);
enum ConnectionBand : int {
  CONNECTION_BAND_UNKNOWN_BAND = 0,
  CONNECTION_BAND_WIFI_BAND_2GHZ = 1,
  CONNECTION_BAND_WIFI_BAND_5GHZ = 2,
  CONNECTION_BAND_WIFI_BAND_6GHZ = 3,
  CONNECTION_BAND_CELLULAR_BAND_2G = 4,
  CONNECTION_BAND_CELLULAR_BAND_3G = 5,
  CONNECTION_BAND_CELLULAR_BAND_4G = 6,
  CONNECTION_BAND_CELLULAR_BAND_5G = 7,
};

extern const uint32_t ConnectionBand_internal_data_[];
inline constexpr ConnectionBand ConnectionBand_MIN =
    static_cast<ConnectionBand>(0);
inline constexpr ConnectionBand ConnectionBand_MAX =
    static_cast<ConnectionBand>(7);
inline bool ConnectionBand_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int ConnectionBand_ARRAYSIZE = 7 + 1;
const ::std::string& ConnectionBand_Name(ConnectionBand value);
template <typename T>
const ::std::string& ConnectionBand_Name(T value) {
  static_assert(::std::is_same<T, ConnectionBand>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionBand_Name().");
  return ConnectionBand_Name(static_cast<ConnectionBand>(value));
}
bool ConnectionBand_Parse(
    ::absl::string_view name, ConnectionBand* PROTOBUF_NONNULL value);
enum ConnectionMode : int {
  LEGACY = 0,
  INSTANT = 1,
};

extern const uint32_t ConnectionMode_internal_data_[];
inline constexpr ConnectionMode ConnectionMode_MIN =
    static_cast<ConnectionMode>(0);
inline constexpr ConnectionMode ConnectionMode_MAX =
    static_cast<ConnectionMode>(1);
inline bool ConnectionMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ConnectionMode_ARRAYSIZE = 1 + 1;
const ::std::string& ConnectionMode_Name(ConnectionMode value);
template <typename T>
const ::std::string& ConnectionMode_Name(T value) {
  static_assert(::std::is_same<T, ConnectionMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionMode_Name().");
  return ConnectionMode_Name(static_cast<ConnectionMode>(value));
}
bool ConnectionMode_Parse(
    ::absl::string_view name, ConnectionMode* PROTOBUF_NONNULL value);
enum InstantConnectionResult : int {
  UNKNOWN_INSTANT_CONNECTION_RESULT = 0,
  INSTANT_CONNECTION_SUCCESS = 1,
  INSTANT_CONNECTION_FAILURE = 2,
  INSTANT_CONNECTION_TIMEOUT = 3,
};

extern const uint32_t InstantConnectionResult_internal_data_[];
inline constexpr InstantConnectionResult InstantConnectionResult_MIN =
    static_cast<InstantConnectionResult>(0);
inline constexpr InstantConnectionResult InstantConnectionResult_MAX =
    static_cast<InstantConnectionResult>(3);
inline bool InstantConnectionResult_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int InstantConnectionResult_ARRAYSIZE = 3 + 1;
const ::std::string& InstantConnectionResult_Name(InstantConnectionResult value);
template <typename T>
const ::std::string& InstantConnectionResult_Name(T value) {
  static_assert(::std::is_same<T, InstantConnectionResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InstantConnectionResult_Name().");
  return InstantConnectionResult_Name(static_cast<InstantConnectionResult>(value));
}
bool InstantConnectionResult_Parse(
    ::absl::string_view name, InstantConnectionResult* PROTOBUF_NONNULL value);
enum ConnectionRequestResponse : int {
  UNKNOWN_CONNECTION_REQUEST_RESPONSE = 0,
  ACCEPTED = 1,
  REJECTED = 2,
  IGNORED = 3,
  NOT_SENT = 4,
};

extern const uint32_t ConnectionRequestResponse_internal_data_[];
inline constexpr ConnectionRequestResponse ConnectionRequestResponse_MIN =
    static_cast<ConnectionRequestResponse>(0);
inline constexpr ConnectionRequestResponse ConnectionRequestResponse_MAX =
    static_cast<ConnectionRequestResponse>(4);
inline bool ConnectionRequestResponse_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ConnectionRequestResponse_ARRAYSIZE = 4 + 1;
const ::std::string& ConnectionRequestResponse_Name(ConnectionRequestResponse value);
template <typename T>
const ::std::string& ConnectionRequestResponse_Name(T value) {
  static_assert(::std::is_same<T, ConnectionRequestResponse>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionRequestResponse_Name().");
  return ConnectionRequestResponse_Name(static_cast<ConnectionRequestResponse>(value));
}
bool ConnectionRequestResponse_Parse(
    ::absl::string_view name, ConnectionRequestResponse* PROTOBUF_NONNULL value);
enum ConnectionAttemptResult : int {
  UNKNOWN_CONNECTION_ATTEMPT_RESULT = 0,
  RESULT_SUCCESS = 1,
  RESULT_ERROR = 2,
  RESULT_CANCELLED = 3,
};

extern const uint32_t ConnectionAttemptResult_internal_data_[];
inline constexpr ConnectionAttemptResult ConnectionAttemptResult_MIN =
    static_cast<ConnectionAttemptResult>(0);
inline constexpr ConnectionAttemptResult ConnectionAttemptResult_MAX =
    static_cast<ConnectionAttemptResult>(3);
inline bool ConnectionAttemptResult_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ConnectionAttemptResult_ARRAYSIZE = 3 + 1;
const ::std::string& ConnectionAttemptResult_Name(ConnectionAttemptResult value);
template <typename T>
const ::std::string& ConnectionAttemptResult_Name(T value) {
  static_assert(::std::is_same<T, ConnectionAttemptResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionAttemptResult_Name().");
  return ConnectionAttemptResult_Name(static_cast<ConnectionAttemptResult>(value));
}
bool ConnectionAttemptResult_Parse(
    ::absl::string_view name, ConnectionAttemptResult* PROTOBUF_NONNULL value);
enum ConnectionAttemptDirection : int {
  UNKNOWN_CONNECTION_ATTEMPT_DIRECTION = 0,
  INCOMING = 1,
  OUTGOING = 2,
};

extern const uint32_t ConnectionAttemptDirection_internal_data_[];
inline constexpr ConnectionAttemptDirection ConnectionAttemptDirection_MIN =
    static_cast<ConnectionAttemptDirection>(0);
inline constexpr ConnectionAttemptDirection ConnectionAttemptDirection_MAX =
    static_cast<ConnectionAttemptDirection>(2);
inline bool ConnectionAttemptDirection_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ConnectionAttemptDirection_ARRAYSIZE = 2 + 1;
const ::std::string& ConnectionAttemptDirection_Name(ConnectionAttemptDirection value);
template <typename T>
const ::std::string& ConnectionAttemptDirection_Name(T value) {
  static_assert(::std::is_same<T, ConnectionAttemptDirection>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionAttemptDirection_Name().");
  return ConnectionAttemptDirection_Name(static_cast<ConnectionAttemptDirection>(value));
}
bool ConnectionAttemptDirection_Parse(
    ::absl::string_view name, ConnectionAttemptDirection* PROTOBUF_NONNULL value);
enum ConnectionAttemptType : int {
  UNKNOWN_CONNECTION_ATTEMPT_TYPE = 0,
  INITIAL = 1,
  UPGRADE = 2,
  RECONNECT = 3,
};

extern const uint32_t ConnectionAttemptType_internal_data_[];
inline constexpr ConnectionAttemptType ConnectionAttemptType_MIN =
    static_cast<ConnectionAttemptType>(0);
inline constexpr ConnectionAttemptType ConnectionAttemptType_MAX =
    static_cast<ConnectionAttemptType>(3);
inline bool ConnectionAttemptType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ConnectionAttemptType_ARRAYSIZE = 3 + 1;
const ::std::string& ConnectionAttemptType_Name(ConnectionAttemptType value);
template <typename T>
const ::std::string& ConnectionAttemptType_Name(T value) {
  static_assert(::std::is_same<T, ConnectionAttemptType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionAttemptType_Name().");
  return ConnectionAttemptType_Name(static_cast<ConnectionAttemptType>(value));
}
bool ConnectionAttemptType_Parse(
    ::absl::string_view name, ConnectionAttemptType* PROTOBUF_NONNULL value);
enum DisconnectionReason : int {
  UNKNOWN_DISCONNECTION_REASON = 0,
  LOCAL_DISCONNECTION = 1,
  REMOTE_DISCONNECTION = 2,
  IO_ERROR = 3,
  UPGRADED = 4,
  SHUTDOWN = 5,
  UNFINISHED = 6,
  PREV_CHANNEL_DISCONNECTION_IN_RECONNECT = 7,
  AUTHENTICATION_FAILURE = 8,
};

extern const uint32_t DisconnectionReason_internal_data_[];
inline constexpr DisconnectionReason DisconnectionReason_MIN =
    static_cast<DisconnectionReason>(0);
inline constexpr DisconnectionReason DisconnectionReason_MAX =
    static_cast<DisconnectionReason>(8);
inline bool DisconnectionReason_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int DisconnectionReason_ARRAYSIZE = 8 + 1;
const ::std::string& DisconnectionReason_Name(DisconnectionReason value);
template <typename T>
const ::std::string& DisconnectionReason_Name(T value) {
  static_assert(::std::is_same<T, DisconnectionReason>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisconnectionReason_Name().");
  return DisconnectionReason_Name(static_cast<DisconnectionReason>(value));
}
bool DisconnectionReason_Parse(
    ::absl::string_view name, DisconnectionReason* PROTOBUF_NONNULL value);
enum PayloadType : int {
  UNKNOWN_PAYLOAD_TYPE = 0,
  BYTES = 1,
  FILE = 2,
  STREAM = 3,
};

extern const uint32_t PayloadType_internal_data_[];
inline constexpr PayloadType PayloadType_MIN =
    static_cast<PayloadType>(0);
inline constexpr PayloadType PayloadType_MAX =
    static_cast<PayloadType>(3);
inline bool PayloadType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int PayloadType_ARRAYSIZE = 3 + 1;
const ::std::string& PayloadType_Name(PayloadType value);
template <typename T>
const ::std::string& PayloadType_Name(T value) {
  static_assert(::std::is_same<T, PayloadType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PayloadType_Name().");
  return PayloadType_Name(static_cast<PayloadType>(value));
}
bool PayloadType_Parse(
    ::absl::string_view name, PayloadType* PROTOBUF_NONNULL value);
enum PayloadStatus : int {
  UNKNOWN_PAYLOAD_STATUS = 0,
  SUCCESS = 1,
  LOCAL_ERROR = 2,
  REMOTE_ERROR = 3,
  ENDPOINT_IO_ERROR = 4,
  MOVED_TO_NEW_MEDIUM = 5,
  CONNECTION_CLOSED = 6,
  LOCAL_CANCELLATION = 7,
  REMOTE_CANCELLATION = 8,
  ENDPOINT_UNENCRYPTED = 9,
  LOCAL_CLIENT_DISCONNECTION = 10,
  REMOTE_CLIENT_DISCONNECTION = 11,
};

extern const uint32_t PayloadStatus_internal_data_[];
inline constexpr PayloadStatus PayloadStatus_MIN =
    static_cast<PayloadStatus>(0);
inline constexpr PayloadStatus PayloadStatus_MAX =
    static_cast<PayloadStatus>(11);
inline bool PayloadStatus_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int PayloadStatus_ARRAYSIZE = 11 + 1;
const ::std::string& PayloadStatus_Name(PayloadStatus value);
template <typename T>
const ::std::string& PayloadStatus_Name(T value) {
  static_assert(::std::is_same<T, PayloadStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PayloadStatus_Name().");
  return PayloadStatus_Name(static_cast<PayloadStatus>(value));
}
bool PayloadStatus_Parse(
    ::absl::string_view name, PayloadStatus* PROTOBUF_NONNULL value);
enum Bandwidth : int {
  BANDWIDTH_UNKNOWN = 0,
  BANDWIDTH_24_GHZ = 1,
  BANDWIDTH_5_GHZ = 2,
  BANDWIDTH_6_GHZ = 3,
};

extern const uint32_t Bandwidth_internal_data_[];
inline constexpr Bandwidth Bandwidth_MIN =
    static_cast<Bandwidth>(0);
inline constexpr Bandwidth Bandwidth_MAX =
    static_cast<Bandwidth>(3);
inline bool Bandwidth_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int Bandwidth_ARRAYSIZE = 3 + 1;
const ::std::string& Bandwidth_Name(Bandwidth value);
template <typename T>
const ::std::string& Bandwidth_Name(T value) {
  static_assert(::std::is_same<T, Bandwidth>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Bandwidth_Name().");
  return Bandwidth_Name(static_cast<Bandwidth>(value));
}
bool Bandwidth_Parse(
    ::absl::string_view name, Bandwidth* PROTOBUF_NONNULL value);
enum BandwidthUpgradeResult : int {
  UNKNOWN_BANDWIDTH_UPGRADE_RESULT = 0,
  UPGRADE_RESULT_SUCCESS = 1,
  UPGRADE_RESULT_ERROR = 2,
  MEDIUM_ERROR = 3,
  PROTOCOL_ERROR = 4,
  RESULT_IO_ERROR = 5,
  CHANNEL_ERROR = 6,
  ALREADY_ON_MEDIUM_ERROR = 7,
  UNFINISHED_ERROR = 10,
  BLUETOOTH_MEDIUM_ERROR = 11,
  WIFI_AWARE_MEDIUM_ERROR = 12,
  WIFI_LAN_MEDIUM_ERROR = 13,
  WIFI_HOTSPOT_MEDIUM_ERROR = 14,
  WIFI_DIRECT_MEDIUM_ERROR = 15,
  WEB_RTC_MEDIUM_ERROR = 16,
  RESULT_REMOTE_ERROR = 17,
  ATTEMPT_SKIPPED = 18,
  REMOTE_CONNECTION_ERROR = 19,
};

extern const uint32_t BandwidthUpgradeResult_internal_data_[];
inline constexpr BandwidthUpgradeResult BandwidthUpgradeResult_MIN =
    static_cast<BandwidthUpgradeResult>(0);
inline constexpr BandwidthUpgradeResult BandwidthUpgradeResult_MAX =
    static_cast<BandwidthUpgradeResult>(19);
inline bool BandwidthUpgradeResult_IsValid(int value) {
  return 0 <= value && value <= 19 && ((1047807u >> value) & 1) != 0;
}
inline constexpr int BandwidthUpgradeResult_ARRAYSIZE = 19 + 1;
const ::std::string& BandwidthUpgradeResult_Name(BandwidthUpgradeResult value);
template <typename T>
const ::std::string& BandwidthUpgradeResult_Name(T value) {
  static_assert(::std::is_same<T, BandwidthUpgradeResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BandwidthUpgradeResult_Name().");
  return BandwidthUpgradeResult_Name(static_cast<BandwidthUpgradeResult>(value));
}
bool BandwidthUpgradeResult_Parse(
    ::absl::string_view name, BandwidthUpgradeResult* PROTOBUF_NONNULL value);
enum BandwidthUpgradeErrorStage : int {
  UNKNOWN_BANDWIDTH_UPGRADE_ERROR_STAGE = 0,
  CLIENT_INTRODUCTION = 1,
  NETWORK_AVAILABLE = 2,
  LAST_WRITE_TO_PRIOR_CHANNEL = 3,
  SAFE_TO_CLOSE_PRIOR_CHANNEL = 4,
  SOCKET_CREATION = 5,
  PRIOR_ENDPOINT_CHANNEL = 6,
  UPGRADE_UNFINISHED = 7,
  UPGRADE_SUCCESS = 8,
  UPGRADE_CANCEL = 9,
  WIFI_START_HOTSPOT = 10,
  WIFI_LISTEN_INCOMING = 11,
  WIFI_CONNECT_TO_HOTSPOT = 12,
  WIFI_HOTSPOT_SOCKET_CREATION = 28,
  WIFI_LAN_LISTEN_INCOMING = 13,
  WIFI_LAN_IP_ADDRESS = 14,
  WIFI_LAN_SOCKET_CREATION = 29,
  WIFI_LAN_SOCKET_CONNECTION = 15,
  BLUETOOTH_LISTEN_INCOMING = 16,
  BLUETOOTH_OBTAIN_MAC_ADDRESS = 17,
  BLUETOOTH_CONNECT_OUTGOING = 18,
  BLUETOOTH_PARSE_MAC_ADDRESS = 19,
  BLUETOOTH_SOCKET_CREATION = 30,
  WIFI_AWARE_LISTEN_INCOMING = 20,
  WIFI_AWARE_PUBLISH = 21,
  WIFI_AWARE_SUBSCRIBE = 22,
  WIFI_AWARE_CONNECT_TO_NETWORK = 23,
  WIFI_AWARE_SOCKET_CREATION = 31,
  WIFI_DIRECT_LISTEN_INCOMING = 24,
  WIFI_DIRECT_CREATE_GROUP = 25,
  WIFI_DIRECT_CONNECT_OUTGOING = 26,
  WIFI_DIRECT_PARSE_DEVICE_ADDRESS = 27,
  WIFI_DIRECT_SOCKET_CREATION = 32,
  WEB_RTC_SOCKET_CREATION = 33,
  WEB_RTC_LISTEN_INCOMING = 34,
};

extern const uint32_t BandwidthUpgradeErrorStage_internal_data_[];
inline constexpr BandwidthUpgradeErrorStage BandwidthUpgradeErrorStage_MIN =
    static_cast<BandwidthUpgradeErrorStage>(0);
inline constexpr BandwidthUpgradeErrorStage BandwidthUpgradeErrorStage_MAX =
    static_cast<BandwidthUpgradeErrorStage>(34);
inline bool BandwidthUpgradeErrorStage_IsValid(int value) {
  return 0 <= value && value <= 34;
}
inline constexpr int BandwidthUpgradeErrorStage_ARRAYSIZE = 34 + 1;
const ::std::string& BandwidthUpgradeErrorStage_Name(BandwidthUpgradeErrorStage value);
template <typename T>
const ::std::string& BandwidthUpgradeErrorStage_Name(T value) {
  static_assert(::std::is_same<T, BandwidthUpgradeErrorStage>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BandwidthUpgradeErrorStage_Name().");
  return BandwidthUpgradeErrorStage_Name(static_cast<BandwidthUpgradeErrorStage>(value));
}
bool BandwidthUpgradeErrorStage_Parse(
    ::absl::string_view name, BandwidthUpgradeErrorStage* PROTOBUF_NONNULL value);
enum LogSource : int {
  UNSPECIFIED_SOURCE = 0,
  LAB_DEVICES = 1,
  INTERNAL_DEVICES = 2,
  BETA_TESTER_DEVICES = 3,
  OEM_DEVICES = 4,
  DEBUG_DEVICES = 5,
  NEARBY_MODULE_FOOD_DEVICES = 6,
  BETO_DOGFOOD_DEVICES = 7,
  NEARBY_DOGFOOD_DEVICES = 8,
  NEARBY_TEAMFOOD_DEVICES = 9,
};

extern const uint32_t LogSource_internal_data_[];
inline constexpr LogSource LogSource_MIN =
    static_cast<LogSource>(0);
inline constexpr LogSource LogSource_MAX =
    static_cast<LogSource>(9);
inline bool LogSource_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int LogSource_ARRAYSIZE = 9 + 1;
const ::std::string& LogSource_Name(LogSource value);
template <typename T>
const ::std::string& LogSource_Name(T value) {
  static_assert(::std::is_same<T, LogSource>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LogSource_Name().");
  return LogSource_Name(static_cast<LogSource>(value));
}
bool LogSource_Parse(
    ::absl::string_view name, LogSource* PROTOBUF_NONNULL value);
enum PowerLevel : int {
  ULTRA_LOW_POWER = -1,
  UNSPECIFIED = 0,
  LOW_POWER = 1,
  BALANCED_POWER = 2,
  HIGH_POWER = 3,
};

extern const uint32_t PowerLevel_internal_data_[];
inline constexpr PowerLevel PowerLevel_MIN =
    static_cast<PowerLevel>(-1);
inline constexpr PowerLevel PowerLevel_MAX =
    static_cast<PowerLevel>(3);
inline bool PowerLevel_IsValid(int value) {
  return -1 <= value && value <= 3;
}
inline constexpr int PowerLevel_ARRAYSIZE = 3 + 1;
const ::std::string& PowerLevel_Name(PowerLevel value);
template <typename T>
const ::std::string& PowerLevel_Name(T value) {
  static_assert(::std::is_same<T, PowerLevel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PowerLevel_Name().");
  return PowerLevel_Name(static_cast<PowerLevel>(value));
}
bool PowerLevel_Parse(
    ::absl::string_view name, PowerLevel* PROTOBUF_NONNULL value);
enum OperationResultCategory : int {
  CATEGORY_UNKNOWN = 0,
  CATEGORY_SUCCESS = 1,
  CATEGORY_CLIENT_CANCELLATION = 2,
  CATEGORY_MEDIUM_UNAVAILABLE = 3,
  CATEGORY_DEVICE_STATE_ERROR = 4,
  CATEGORY_CLIENT_ERROR = 5,
  CATEGORY_NEARBY_ERROR = 6,
  CATEGORY_CONNECTIVITY_ERROR = 7,
  CATEGORY_MISCELLANEOUS = 8,
  CATEGORY_IO_ERROR = 9,
  CATEGORY_DCT_ERROR = 10,
};

extern const uint32_t OperationResultCategory_internal_data_[];
inline constexpr OperationResultCategory OperationResultCategory_MIN =
    static_cast<OperationResultCategory>(0);
inline constexpr OperationResultCategory OperationResultCategory_MAX =
    static_cast<OperationResultCategory>(10);
inline bool OperationResultCategory_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int OperationResultCategory_ARRAYSIZE = 10 + 1;
const ::std::string& OperationResultCategory_Name(OperationResultCategory value);
template <typename T>
const ::std::string& OperationResultCategory_Name(T value) {
  static_assert(::std::is_same<T, OperationResultCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to OperationResultCategory_Name().");
  return OperationResultCategory_Name(static_cast<OperationResultCategory>(value));
}
bool OperationResultCategory_Parse(
    ::absl::string_view name, OperationResultCategory* PROTOBUF_NONNULL value);
enum OperationResultCode : int {
  DETAIL_UNKNOWN = 0,
  DETAIL_SUCCESS = 1,
  CLIENT_CANCELLATION_REMOTE_IN_CANCELED_STATE = 500,
  CLIENT_CANCELLATION_LOCAL_CANCEL_PAYLOAD = 501,
  CLIENT_CANCELLATION_REMOTE_CANCEL_PAYLOAD = 502,
  CLIENT_CANCELLATION_UPGRADE_CANCELED_BY_REMOTE = 503,
  CLIENT_CANCELLATION_CANCEL_BLE_OUTGOING_CONNECTION = 504,
  CLIENT_CANCELLATION_CANCEL_BT_OUTGOING_CONNECTION = 505,
  CLIENT_CANCELLATION_CANCEL_L2CAP_OUTGOING_CONNECTION = 506,
  CLIENT_CANCELLATION_CANCEL_LAN_OUTGOING_CONNECTION = 507,
  CLIENT_CANCELLATION_CANCEL_NFC_OUTGOING_CONNECTION = 508,
  CLIENT_CANCELLATION_CANCEL_USB_OUTGOING_CONNECTION = 509,
  CLIENT_CANCELLATION_CANCEL_WIFI_AWARE_OUTGOING_CONNECTION = 510,
  CLIENT_CANCELLATION_CANCEL_WIFI_DIRECT_OUTGOING_CONNECTION = 511,
  CLIENT_CANCELLATION_CANCEL_WIFI_HOTSPOT_OUTGOING_CONNECTION = 512,
  CLIENT_CANCELLATION_CANCEL_WEB_RTC_OUTGOING_CONNECTION = 513,
  CLIENT_CANCELLATION_CANCEL_OUTGOING_CONNECTION = 514,
  CLIENT_CANCELLATION_CANCEL_INCOMING_CONNECTION = 515,
  CLIENT_CANCELLATION_WIFI_AWARE_SERVER_SOCKET_CREATION = 516,
  CLIENT_CANCELLATION_WIFI_DIRECT_SERVER_SOCKET_CREATION = 517,
  CLIENT_CANCELLATION_WIFI_HOTSPOT_SERVER_SOCKET_CREATION = 518,
  CLIENT_CANCELLATION_BT_SERVER_SOCKET_CREATION = 519,
  CLIENT_CANCELLATION_WEB_RTC_SERVER_SOCKET_CREATION = 520,
  CLIENT_CANCELLATION_WIFI_LAN_SERVER_SOCKET_CREATION = 521,
  CLIENT_CANCELLATION_LOCAL_DISCONNECT = 522,
  CLIENT_CANCELLATION_REMOTE_DISCONNECT = 523,
  CLIENT_CANCELLATION_AWDL_SERVER_SOCKET_CREATION = 524,
  CLIENT_CANCELLATION_CANCEL_AWDL_OUTGOING_CONNECTION = 525,
  DEVICE_STATE_ERROR_UNFINISHED_UPGRADE_ATTEMPTS = 1000,
  DEVICE_STATE_ERROR_USER_HOTSPOT_ENABLED = 1001,
  DEVICE_STATE_LOCATION_DISABLED = 1002,
  DEVICE_STATE_RADIO_DISABLING_FAILURE = 1003,
  DEVICE_STATE_RADIO_ENABLING_FAILURE = 1004,
  MEDIUM_UNAVAILABLE_WIFI_AWARE_RESOURCE_NOT_AVAILABLE = 1500,
  MEDIUM_UNAVAILABLE_DIRECT_HOTSPOT_NOT_SUPPORT = 1501,
  MEDIUM_UNAVAILABLE_SOFT_AP_NOT_SUPPORT = 1502,
  MEDIUM_UNAVAILABLE_LOCAL_ONLY_HOTSPOT_NOT_SUPPORT = 1503,
  MEDIUM_UNAVAILABLE_LOCAL_ONLY_HOTSPOT_NOT_SUPPORT_5G = 1504,
  MEDIUM_UNAVAILABLE_BLE_NOT_AVAILABLE = 1505,
  MEDIUM_UNAVAILABLE_L2CAP_NOT_AVAILABLE = 1506,
  MEDIUM_UNAVAILABLE_BLUETOOTH_NOT_AVAILABLE = 1507,
  MEDIUM_UNAVAILABLE_WEB_RTC_NOT_AVAILABLE = 1508,
  MEDIUM_UNAVAILABLE_WIFI_AWARE_NOT_AVAILABLE = 1509,
  MEDIUM_UNAVAILABLE_WIFI_HOTSPOT_NOT_AVAILABLE = 1510,
  MEDIUM_UNAVAILABLE_WIFI_DIRECT_NOT_AVAILABLE = 1511,
  MEDIUM_UNAVAILABLE_NFC_NOT_AVAILABLE = 1512,
  MEDIUM_UNAVAILABLE_LAN_NOT_AVAILABLE = 1513,
  MEDIUM_UNAVAILABLE_USB_NOT_AVAILABLE = 1514,
  MEDIUM_UNAVAILABLE_BLE_NC_LOGICAL_NOT_AVAILABLE = 1515,
  MEDIUM_UNAVAILABLE_BT_NC_LOGICAL_NOT_AVAILABLE = 1516,
  MEDIUM_UNAVAILABLE_LAN_NC_LOGICAL_NOT_AVAILABLE = 1517,
  MEDIUM_UNAVAILABLE_NFC_NC_LOGICAL_NOT_AVAILABLE = 1518,
  MEDIUM_UNAVAILABLE_USB_NC_LOGICAL_NOT_AVAILABLE = 1519,
  MEDIUM_UNAVAILABLE_WEB_RTC_NC_LOGICAL_NOT_AVAILABLE = 1520,
  MEDIUM_UNAVAILABLE_WIFI_AWARE_NC_LOGICAL_NOT_AVAILABLE = 1521,
  MEDIUM_UNAVAILABLE_WIFI_HOTSPOT_NC_LOGICAL_NOT_AVAILABLE = 1522,
  MEDIUM_UNAVAILABLE_WIFI_DIRECT_NC_LOGICAL_NOT_AVAILABLE = 1523,
  MEDIUM_UNAVAILABLE_WIFI_HOTSPOT_P2P_RESOURCE_NOT_AVAILABLE = 1524,
  MEDIUM_UNAVAILABLE_WIFI_DIRECT_P2P_RESOURCE_NOT_AVAILABLE = 1525,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_BLE_LOW_QUALITY_MEDIUMS = 1526,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_L2CAP_LOW_QUALITY_MEDIUMS = 1527,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_WEB_RTC_LOW_QUALITY_MEDIUMS = 1528,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_LAN_LOW_QUALITY_MEDIUMS = 1529,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_BT_LOW_QUALITY_MEDIUMS = 1530,
  MEDIUM_UNAVAILABLE_UPGRADE_SKIP_USB_LOW_QUALITY_MEDIUMS = 1531,
  MEDIUM_UNAVAILABLE_LOCAL_ONLY_HOTSPOT_DISRUPTIVE_FALSE = 1532,
  MEDIUM_UNAVAILABLE_SOFT_AP_DISRUPTIVE_FALSE = 1533,
  MEDIUM_UNAVAILABLE_ALREADY_HAVE_A_WIFI_DIRECT_GROUP = 1534,
  MEDIUM_UNAVAILABLE_ALREADY_HOSTING_HOTSPOT_FOR_OTHER_CLIENTS = 1535,
  MEDIUM_UNAVAILABLE_REJECT_L2CAP_ON_GATT_MULTIPLEX_CONNECTION = 1536,
  MEDIUM_UNAVAILABLE_UPGRADE_ON_SAME_MEDIUM = 1537,
  MEDIUM_UNAVAILABLE_WEB_RTC_NO_INTERNET = 1538,
  MEDIUM_UNAVAILABLE_STA_DISRUPTIVE_FALSE = 1539,
  MEDIUM_UNAVAILABLE_STA_USER_NOT_ALLOW = 1540,
  MEDIUM_UNAVAILABLE_DUPLICATE_FAST_ADVERTISING = 1541,
  MEDIUM_UNAVAILABLE_NSD_NOT_AVAILABLE = 1542,
  MEDIUM_UNAVAILABLE_MDNS_NOT_AVAILABLE = 1543,
  MEDIUM_UNAVAILABLE_LAN_BLOCKED = 1544,
  MEDIUM_UNAVAILABLE_POOR_SIGNAL = 1545,
  MEDIUM_UNAVAILABLE_BT_MULTIPLEX_DISABLED = 1546,
  MEDIUM_UNAVAILABLE_AWDL_NOT_AVAILABLE = 1547,
  CLIENT_WIFI_DIRECT_ALREADY_HOSTING_DIRECT_GROUP_FOR_THIS_CLIENT = 2000,
  CLIENT_WIFI_HOTSPOT_ALREADY_HOSTING_HOTSPOT_FOR_THIS_CLIENT = 2001,
  CLIENT_DUPLICATE_ACCEPTING_BLE_CONNECTION_REQUEST = 2002,
  CLIENT_DUPLICATE_ACCEPTING_L2CAP_CONNECTION_REQUEST = 2003,
  CLIENT_DUPLICATE_ACCEPTING_BT_CONNECTION_REQUEST = 2004,
  CLIENT_DUPLICATE_ACCEPTING_LAN_CONNECTION_REQUEST = 2005,
  CLIENT_DUPLICATE_ACCEPTING_NFC_CONNECTION_REQUEST = 2006,
  CLIENT_DUPLICATE_ACCEPTING_WEB_RTC_CONNECTION_REQUEST = 2007,
  CLIENT_DUPLICATE_ACCEPTING_WIFI_AWARE_CONNECTION_REQUEST = 2008,
  CLIENT_DUPLICATE_ACCEPTING_WIFI_HOTSPOT_CONNECTION_REQUEST = 2009,
  CLIENT_DUPLICATE_ACCEPTING_WIFI_DIRECT_CONNECTION_REQUEST = 2010,
  CLIENT_DUPLICATE_ACCEPTING_USB_CONNECTION_REQUEST = 2011,
  CLIENT_DUPLICATE_WIFI_AWARE_CONNECTION_REQUEST = 2012,
  CLIENT_DUPLICATE_WIFI_DIRECT_CONNECTION_REQUEST = 2013,
  CLIENT_DUPLICATE_WIFI_HOTSPOT_CONNECTION_REQUEST = 2014,
  CLIENT_DUPLICATE_WIFI_AWARE_SUBSCRIBING_REQUEST = 2015,
  CLIENT_UNSUPPORTED_USB_TO_BE_UPGRADE_MEDIUM = 2016,
  CLIENT_PROCESS_TIE_BREAK_LOSS = 2017,
  CLIENT_BLE_DUPLICATE_ADVERTISING = 2018,
  CLIENT_BLUETOOTH_DUPLICATE_ADVERTISING = 2019,
  CLIENT_NFC_DUPLICATE_ADVERTISING = 2020,
  CLIENT_WIFI_LAN_DUPLICATE_ADVERTISING = 2021,
  CLIENT_USB_DUPLICATE_ADVERTISING = 2022,
  CLIENT_BLE_DUPLICATE_DISCOVERING = 2023,
  CLIENT_BLUETOOTH_DUPLICATE_DISCOVERING = 2024,
  CLIENT_NFC_DUPLICATE_DISCOVERING = 2025,
  CLIENT_WIFI_LAN_DUPLICATE_DISCOVERING = 2026,
  CLIENT_USB_DUPLICATE_DISCOVERING = 2027,
  CLIENT_PERMISSION_FAILURE = 2028,
  CLIENT_BLE_NO_LISTENING = 2029,
  CLIENT_ALREADY_CONNECTED_TO_TARGET = 2030,
  CLIENT_FAILED_INCOMING_CONNECTION_DUE_TO_TOPOLOGICAL_LIMIT = 2031,
  CLIENT_OUT_OF_ORDER_API_CALL = 2032,
  CLIENT_WRONG_CONNECTING_PERMISSIONS = 2033,
  CLIENT_ALREADY_CONNECTED_TO_ENDPOINT = 2034,
  CLIENT_CONNECT_TO_UNKNOWN_ENDPOINT = 2035,
  CLIENT_AWDL_DUPLICATE_ADVERTISING = 2036,
  CLIENT_AWDL_DUPLICATE_DISCOVERING = 2037,
  CLIENT_DUPLICATE_ACCEPTING_AWDL_CONNECTION_REQUEST = 2038,
  MISCELLEANEOUS_BLUETOOTH_MAC_ADDRESS_NULL = 2500,
  MISCELLEANEOUS_MOVE_TO_NEW_MEDIUM = 2501,
  MISCELLEANEOUS_WIFI_HOTSPOT_SOFT_AP_BLOCKED_BY_PROVISION = 2502,
  MISCELLEANEOUS_BLE_SYSTEM_SERVICE_NULL = 2503,
  MISCELLEANEOUS_L2CAP_SYSTEM_SERVICE_NULL = 2504,
  MISCELLEANEOUS_BT_SYSTEM_SERVICE_NULL = 2505,
  MISCELLEANEOUS_WIFI_AWARE_SYSTEM_SERVICE_NULL = 2506,
  MISCELLEANEOUS_WIFI_DIRECT_SYSTEM_SERVICE_NULL = 2507,
  MISCELLEANEOUS_WIFI_LAN_SYSTEM_SERVICE_NULL = 2508,
  MISCELLEANEOUS_WIFI_HOTSPOT_SYSTEM_SERVICE_NULL = 2509,
  MISCELLEANEOUS_BT_NOT_ACCEPTING_CONNECTION_FOR_WORK_PROFILE = 2510,
  MISCELLEANEOUS_WEB_RTC_GET_DROIDGUARD_RESULT_FAILURE = 2511,
  MISCELLEANEOUS_WEB_RTC_TACHYON_SIGNALING_MESSENGER_NULL = 2512,
  MISCELLEANEOUS_WEB_RTC_FAILED_TO_RECEIVE_MESSAGE = 2513,
  MISCELLEANEOUS_BLUETOOTH_CHANGE_DEVICE_NAME_FAILURE = 2514,
  MISCELLEANEOUS_WEB_RTC_ICE_SERVER_NULL = 2515,
  MISCELLEANEOUS_WORK_SOURCE_NULL = 2516,
  IO_FILE_OPENING_ERROR = 3000,
  IO_FILE_READING_ERROR = 3001,
  IO_FILE_WRITING_ERROR = 3002,
  IO_FOLDER_CREATION_ERROR = 3003,
  IO_STREAM_CREATE_PIPE_FAILURE = 3004,
  IO_ENDPOINT_IO_ERROR_ON_BLE [[deprecated]] = 3005,
  IO_ENDPOINT_IO_ERROR_ON_BLE_L2CAP [[deprecated]] = 3006,
  IO_ENDPOINT_IO_ERROR_ON_BT [[deprecated]] = 3007,
  IO_ENDPOINT_IO_ERROR_ON_WEB_RTC [[deprecated]] = 3008,
  IO_ENDPOINT_IO_ERROR_ON_LAN [[deprecated]] = 3009,
  IO_ENDPOINT_IO_ERROR_ON_WIFI_DIRECT [[deprecated]] = 3010,
  IO_ENDPOINT_IO_ERROR_ON_WIFI_HOTSPOT [[deprecated]] = 3011,
  IO_ENDPOINT_IO_ERROR_ON_WIFI_AWARE [[deprecated]] = 3012,
  IO_ENDPOINT_IO_ERROR_ON_NFC [[deprecated]] = 3013,
  IO_ENDPOINT_IO_ERROR_ON_USB [[deprecated]] = 3014,
  CONNECTIVITY_WIFI_AWARE_ATTACH_FAILURE = 3500,
  CONNECTIVITY_BLUETOOTH_DEVICE_OBTAIN_FAILURE = 3501,
  CONNECTIVITY_BLE_CLIENT_SOCKET_CREATION_FAILURE = 3502,
  CONNECTIVITY_L2CAP_CLIENT_SOCKET_CREATION_FAILURE = 3503,
  CONNECTIVITY_BT_CLIENT_SOCKET_CREATION_FAILURE = 3504,
  CONNECTIVITY_LAN_CLIENT_SOCKET_CREATION_FAILURE = 3505,
  CONNECTIVITY_NFC_CLIENT_SOCKET_CREATION_FAILURE = 3506,
  CONNECTIVITY_WEB_RTC_CLIENT_SOCKET_CREATION_FAILURE = 3507,
  CONNECTIVITY_WIFI_AWARE_CLIENT_SOCKET_CREATION_FAILURE = 3508,
  CONNECTIVITY_WIFI_HOTSPOT_CLIENT_SOCKET_CREATION_FAILURE = 3509,
  CONNECTIVITY_WIFI_DIRECT_CLIENT_SOCKET_CREATION_FAILURE = 3510,
  CONNECTIVITY_USB_CLIENT_SOCKET_CREATION_FAILURE = 3511,
  CONNECTIVITY_WEB_RTC_CONNECT_TO_TACHYON_FAILURE = 3512,
  CONNECTIVITY_BLE_CREATE_GATT_CONNECTION_FAILURE = 3513,
  CONNECTIVITY_WIFI_AWARE_GET_REMOTE_IP_FRAME_FAILURE = 3514,
  CONNECTIVITY_WIFI_AWARE_GET_REMOTE_IP_ADDRESS_FAILURE = 3515,
  CONNECTIVITY_WIFI_DIRECT_INCONSISTENT_HOSTED_WIFI_BAND = 3516,
  CONNECTIVITY_WIFI_HOTSPOT_INCONSISTENT_HOSTED_WIFI_BAND = 3517,
  CONNECTIVITY_BLUETOOTH_INVALID_CREDENTIAL = 3518,
  CONNECTIVITY_WIFI_LAN_INVALID_CREDENTIAL = 3519,
  CONNECTIVITY_WIFI_DIRECT_INVALID_CREDENTIAL = 3520,
  CONNECTIVITY_WIFI_HOTSPOT_INVALID_CREDENTIAL = 3521,
  CONNECTIVITY_WIFI_AWARE_INVALID_CREDENTIAL = 3522,
  CONNECTIVITY_WEB_RTC_INVALID_CREDENTIAL = 3523,
  CONNECTIVITY_WIFI_LAN_IP_ADDRESS_ERROR = 3524,
  CONNECTIVITY_L2CAP_CLIENT_OBTAIN_FAIURE = 3525,
  CONNECTIVITY_L2CAP_DATA_CONNECTION_FAILURE = 3526,
  CONNECTIVITY_WIFI_AWARE_L2MESSAGE_NETWORK_AVAILABLE_FRAME_NULL = 3527,
  CONNECTIVITY_WIFI_AWARE_L2MESSAGE_SEND_HOST_NETWORK_FRAME_FAILURE = 3528,
  CONNECTIVITY_LAN_UNREACHABLE = 3529,
  CONNECTIVITY_WIFI_HOTSPOT_LOHS_CREATION_FAILURE = 3530,
  CONNECTIVITY_LAN_GET_NETWORK_INTERFACES_FAILURE = 3531,
  CONNECTIVITY_WIFI_DIRECT_GET_NETWORK_INTERFACES_FAILURE = 3532,
  CONNECTIVITY_WIFI_HOTSPOT_GET_NETWORK_INTERFACES_FAILURE = 3533,
  CONNECTIVITY_WIFI_HOTSPOT_P2P_CHANNEL_INITIALIZE_FAILURE = 3534,
  CONNECTIVITY_WIFI_DIRECT_P2P_CHANNEL_INITIALIZE_FAILURE = 3535,
  CONNECTIVITY_WIFI_HOTSPOT_P2P_GROUP_CREATION_FAILURE = 3536,
  CONNECTIVITY_WIFI_DIRECT_P2P_GROUP_CREATION_FAILURE = 3537,
  CONNECTIVITY_GATT_SERVER_OPEN_FAILURE = 3538,
  CONNECTIVITY_BLE_SERVER_SOCKET_CREATION_FAILURE = 3539,
  CONNECTIVITY_L2CAP_SERVER_SOCKET_CREATION_FAILURE = 3540,
  CONNECTIVITY_BT_SERVER_SOCKET_CREATION_FAILURE = 3541,
  CONNECTIVITY_LAN_SERVER_SOCKET_CREATION_FAILURE = 3542,
  CONNECTIVITY_WEB_RTC_SERVER_SOCKET_CREATION_FAILURE = 3543,
  CONNECTIVITY_WIFI_AWARE_SERVER_SOCKET_CREATION_FAILURE = 3544,
  CONNECTIVITY_WIFI_HOTSPOT_SERVER_SOCKET_CREATION_FAILURE = 3545,
  CONNECTIVITY_WIFI_DIRECT_SERVER_SOCKET_CREATION_FAILURE = 3546,
  CONNECTIVITY_NFC_SERVER_SOCKET_CREATION_FAILURE = 3547,
  CONNECTIVITY_WIFI_HOTSPOT_SOFT_AP_CREATION_FAILURE = 3548,
  CONNECTIVITY_WIFI_AWARE_UPDATE_PUBLISH_FAILURE = 3549,
  CONNECTIVITY_GENERIC_WRITING_CHANNEL_IO_ERROR = 3550,
  CONNECTIVITY_GENERIC_WRITE_CLIENT_INTRODUCTION_ACK_IO_ERROR = 3551,
  CONNECTIVITY_WIFI_AWARE_DISCOVERED_PEER_NULL = 3552,
  CONNECTIVITY_GENERIC_PAYLOAD_SENT_ERROR = 3553,
  CONNECTIVITY_L2CAP_SERVER_SOCKET_CREATION_SECURITY_EXCEPTION_FAILURE = 3554,
  CONNECTIVITY_BT_SERVER_SOCKET_CREATION_SECURITY_EXCEPTION_FAILURE = 3555,
  CONNECTIVITY_L2CAP_CLIENT_SOCKET_CREATION_TIMEOUT_FAILURE = 3556,
  CONNECTIVITY_WEB_RTC_UNSATISFIED_LINK_ERROR = 3557,
  CONNECTIVITY_DIRECT_GROUP_MCC_FAILURE = 3558,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_BLE = 3559,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_BLE_L2CAP = 3560,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_BT = 3561,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_WEB_RTC = 3562,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_LAN = 3563,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_WIFI_DIRECT = 3564,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_WIFI_HOTSPOT = 3565,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_WIFI_AWARE = 3566,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_NFC = 3567,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_USB = 3568,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_UNKNOWN_MEDIUM = 3569,
  CONNECTIVITY_BT_SOCKET_CREATION_IO_EXCEPTION = 3570,
  CONNECTIVITY_BT_SOCKET_CONNECT_IO_EXCEPTION = 3571,
  CONNECTIVITY_BT_CONNECTION_INTERRUPTED_EXCEPTION = 3572,
  CONNECTIVITY_BT_CONNECTION_EXECUTION_EXCEPTION = 3573,
  CONNECTIVITY_BT_CONNECTION_TIMEOUT_EXCEPTION = 3574,
  CONNECTIVITY_WIFI_DIRECT_P2P_CONNECTION_FAILURE = 3575,
  CONNECTIVITY_WFD_CONNECTION_INTERRUPTED_EXCEPTION = 3576,
  CONNECTIVITY_WFD_CONNECTION_EXECUTION_EXCEPTION = 3577,
  CONNECTIVITY_WFD_CONNECTION_TIMEOUT_EXCEPTION = 3578,
  CONNECTIVITY_WFD_CONNECTION_HOSTED_ADDRESS_NULL = 3579,
  CONNECTIVITY_WIFI_HOTSPOT_SPECIFIER_FAILURE = 3580,
  CONNECTIVITY_WIFI_HOTSPOT_LEGACY_STA_CONNECTION_FAILURE = 3581,
  CONNECTIVITY_WIFI_LAN_SOCKET_CONNECT_TIMEOUT = 3582,
  CONNECTIVITY_WIFI_LAN_SOCKET_CONNECT_IO_EXCEPTION = 3583,
  CONNECTIVITY_BLE_START_GATT_SERVER_FAILURE = 3584,
  CONNECTIVITY_BLE_ADD_GATT_ADVERTISEMENT_FAILURE = 3585,
  CONNECTIVITY_BLE_START_ADVERTISING_FAILURE = 3586,
  CONNECTIVITY_BLUETOOTH_START_ADVERTISING_FAILURE = 3587,
  CONNECTIVITY_WIFI_LAN_START_ADVERTISING_FAILURE = 3588,
  CONNECTIVITY_WIFI_AWARE_START_ADVERTISING_FAILURE = 3589,
  CONNECTIVITY_BLUETOOTH_SCAN_FAILURE = 3590,
  CONNECTIVITY_BLE_SCAN_FAILURE = 3591,
  CONNECTIVITY_MDNS_SCAN_FAILURE = 3592,
  CONNECTIVITY_NFC_START_DISCOVERY_FAILURE = 3593,
  CONNECTIVITY_WIFI_LAN_START_DISCOVERY_FAILURE = 3594,
  CONNECTIVITY_WIFI_AWARE_START_DISCOVERY_FAILURE = 3595,
  CONNECTIVITY_UWB_START_DISCOVERY_FAILURE = 3596,
  CONNECTIVITY_LAN_MDNS_REGISTER_FAILURE = 3597,
  CONNECTIVITY_BLUETOOTH_CHANGE_SCAN_MODE_FAILURE = 3598,
  CONNECTIVITY_AUTO_RESUME_FAILURE = 3599,
  CONNECTIVITY_INSTANT_CONNECTION_LISTENING_TIMEOUT = 3600,
  CONNECTIVITY_MEDIUM_INVALID_CREDENTIAL = 3601,
  CONNECTIVITY_AWDL_START_ADVERTISING_FAILURE = 3602,
  CONNECTIVITY_AWDL_START_DISCOVERY_FAILURE = 3603,
  CONNECTIVITY_AWDL_INVALID_CREDENTIAL = 3604,
  CONNECTIVITY_AWDL_CLIENT_SOCKET_CREATION_FAILURE = 3605,
  CONNECTIVITY_CHANNEL_IO_ERROR_ON_AWDL = 3606,
  CONNECTIVITY_WIFI_AWARE_DO_UNAVAILABLE = 3607,
  CONNECTIVITY_WIFI_AWARE_DISCOVER_PEER_NULL_SCREEN_OFF = 3608,
  CONNECTIVITY_WIFI_AWARE_DISCOVER_PEER_NULL_TIMEOUT = 3609,
  CONNECTIVITY_WIFI_AWARE_JOIN_NETWORK_FAILED = 3610,
  NEARBY_BLE_ADVERTISEMENT_MAPPING_TO_MAC_ERROR = 4500,
  NEARBY_BLUETOOTH_MAC_ADDRESS_INVALID_FOR_CONNECT = 4501,
  NEARBY_WEB_RTC_CONNECTION_FLOW_NULL = 4502,
  NEARBY_GENERIC_CONNECTION_CLOSED = 4503,
  NEARBY_BLE_ENDPOINT_CHANNEL_CREATION_FAILURE = 4504,
  NEARBY_L2CAP_ENDPOINT_CHANNEL_CREATION_FAILURE = 4505,
  NEARBY_BT_ENDPOINT_CHANNEL_CREATION_FAILURE = 4506,
  NEARBY_LAN_ENDPOINT_CHANNEL_CREATION_FAILURE = 4507,
  NEARBY_NFC_ENDPOINT_CHANNEL_CREATION_FAILURE = 4508,
  NEARBY_WIFI_AWARE_ENDPOINT_CHANNEL_CREATION_FAILURE = 4509,
  NEARBY_WIFI_HOTSPOT_ENDPOINT_CHANNEL_CREATION_FAILURE = 4510,
  NEARBY_WIFI_DIRECT_ENDPOINT_CHANNEL_CREATION_FAILURE = 4511,
  NEARBY_WEB_RTC_ENDPOINT_CHANNEL_CREATION_FAILURE = 4512,
  NEARBY_USB_ENDPOINT_CHANNEL_CREATION_FAILURE = 4513,
  NEARBY_GENERIC_ENDPOINT_UNENCRYPTED = 4514,
  NEARBY_BLE_GATT_ADVERTISEMENT_NULL_FOR_CONNECTION = 4515,
  NEARBY_WIFI_DIRECT_HOST_ON_SRD_CHANNELS = 4516,
  NEARBY_WIFI_HOTSPOT_HOST_ON_SRD_CHANNELS = 4517,
  NEARBY_BLE_GATT_NULL_CALLBACK = 4518,
  NEARBY_L2CAP_NULL_CALLBACK = 4519,
  NEARBY_BT_NULL_CALLBACK = 4520,
  NEARBY_USB_NULL_CALLBACK = 4521,
  NEARBY_NFC_NULL_CALLBACK = 4522,
  NEARBY_WIFI_AWARE_NULL_CALLBACK = 4523,
  NEARBY_WEB_RTC_NULL_CALLBACK = 4524,
  NEARBY_LAN_NULL_CALLBACK = 4525,
  NEARBY_WIFI_HOTSPOT_NULL_CALLBACK = 4526,
  NEARBY_WIFI_DIRECT_NULL_CALLBACK = 4527,
  NEARBY_WIFI_DIRECT_NULL_SSID = 4528,
  NEARBY_WIFI_DIRECT_NULL_PASSWORD = 4529,
  NEARBY_BT_MULTIPLEX_SOCKET_DISABLED [[deprecated]] = 4530,
  NEARBY_LAN_MULTIPLEX_SOCKET_DISABLED = 4531,
  NEARBY_GENERIC_NEW_ENDPOINT_CHANNEL_NULL = 4532,
  NEARBY_WIFI_DIRECT_NO_GROUP_FOR_LISTENING = 4533,
  NEARBY_WIFI_HOTSPOT_NO_HOTSPOT_FOR_LISTENING = 4534,
  NEARBY_GENERIC_OLD_ENDPOINT_CHANNEL_NULL = 4535,
  NEARBY_BLE_OPERATION_REGISTERED_FAILED = 4536,
  NEARBY_L2CAP_OPERATION_REGISTERED_FAILED = 4537,
  NEARBY_BT_OPERATION_REGISTERED_FAILED = 4538,
  NEARBY_LAN_OPERATION_REGISTERED_FAILED = 4539,
  NEARBY_WEB_RTC_OPERATION_REGISTERED_FAILED = 4540,
  NEARBY_WIFI_AWARE_OPERATION_REGISTERED_FAILED = 4541,
  NEARBY_WIFI_HOTSPOT_DIRECT_OPERATION_REGISTERED_FAILED = 4542,
  NEARBY_WIFI_HOTSPOT_SOFT_AP_OPERATION_REGISTERED_FAILED = 4543,
  NEARBY_WIFI_HOTSPOT_LOHS_OPERATION_REGISTERED_FAILED = 4544,
  NEARBY_WIFI_HOTSPOT_CLIENT_OPERATION_REGISTERED_FAILED = 4545,
  NEARBY_WIFI_DIRECT_OPERATION_REGISTERED_FAILED = 4546,
  NEARBY_GENERIC_OUTGOING_PAYLOAD_CREATION_FAILURE = 4547,
  NEARBY_WIFI_HOTSPOT_P2P_NON_DBS_WANT_2G_BUT_AP_5G = 4548,
  NEARBY_WIFI_DIRECT_P2P_NON_DBS_WANT_2G_BUT_AP_5G = 4549,
  NEARBY_WIFI_HOTSPOT_P2P_NON_DBS_WANT_5G_BUT_AP_2G = 4550,
  NEARBY_WIFI_DIRECT_P2P_NON_DBS_WANT_5G_BUT_AP_2G = 4551,
  NEARBY_GENERIC_INCOMING_PAYLOAD_NOT_DATA_TYPE = 4552,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_EVENT_TYPE_ERROR = 4553,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_FRAME_TYPE_ERROR = 4554,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_FORMAT_ERROR = 4555,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_ACK_EVENT_TYPE_ERROR = 4556,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_ACK_FRAME_TYPE_ERROR = 4557,
  NEARBY_GENERIC_READ_CLIENT_INTRODUCTION_ACK_FORMAT_ERROR = 4558,
  NEARBY_GENERIC_REMOTE_ENDPOINT_STATUS_ERROR = 4559,
  NEARBY_GENERIC_REMOTE_REPORT_PAYLOADS_ERROR = 4560,
  NEARBY_GENERIC_REMOTE_UPGRADE_FAILURE = 4561,
  NEARBY_GENERIC_SEND_PAYLOAD_EXECUTOR_NULL = 4562,
  NEARBY_BT_VIRTUAL_SOCKET_CREATION_FAILURE = 4563,
  NEARBY_LAN_VIRTUAL_SOCKET_CREATION_FAILURE = 4564,
  NEARBY_WIFI_LAN_IP_ADDRESS_ERROR = 4565,
  NEARBY_L2CAP_PSM_NOT_POSITIVE = 4566,
  NEARBY_ENCRYPTION_FAILURE = 4567,
  NEARBY_AUTHENTICATION_FAILURE = 4568,
  NEARBY_LAN_VIRTUAL_SOCKET_NULL = 4569,
  NEARBY_BLUETOOTH_ADVERTISE_TO_BYTES_FAILURE = 4570,
  NEARBY_BLE_ADVERTISE_TO_BYTES_FAILURE = 4571,
  NEARBY_BLE_FAST_ADVERTISE_TO_BYTES_FAILURE = 4572,
  NEARBY_NFC_ADVERTISE_TO_BYTES_FAILURE = 4573,
  NEARBY_WIFI_LAN_ADVERTISE_TO_BYTES_FAILURE = 4574,
  NEARBY_WIFI_AWARE_ADVERTISE_TO_BYTES_FAILURE = 4575,
  NEARBY_USB_ADVERTISE_TO_BYTES_FAILURE = 4576,
  NEARBY_NFC_INVALID_PCP_OPTIONS = 4577,
  NEARBY_BLUETOOTH_INVALID_PCP_OPTIONS = 4578,
  NEARBY_BLE_INVALID_PCP_OPTIONS = 4579,
  NEARBY_WIFI_LAN_INVALID_PCP_OPTIONS = 4580,
  NEARBY_WIFI_AWARE_INVALID_PCP_OPTIONS = 4581,
  NEARBY_USB_INVALID_PCP_OPTIONS = 4582,
  NEARBY_UWB_INVALID_PCP_OPTIONS = 4583,
  NEARBY_WEB_RTC_INVALID_PCP_OPTIONS = 4584,
  NEARBY_BLUETOOTH_NO_CLIENT_REGISTER_FOR_SCAN = 4585,
  NEARBY_INSTANT_CONNECTION_WRONG_CONNECTIVITY_INFO = 4586,
  NEARBY_NEED_METHOD_OVERRIDE = 4587,
  NEARBY_GENERIC_INCOMING_PAYLOAD_CREATION_FAILURE = 4588,
  NEARBY_WEB_RTC_NO_LISTENING_PEER_FOUND = 4589,
  NEARBY_UPGRADE_PATH_ON_WRONG_MEDIUM = 4590,
  NEARBY_CONNECT_TO_ALL_MEDIUMS_FAILURE = 4591,
  NEARBY_BLUETOOTH_RECONNECT_MAC_NULL = 4592,
  NEARBY_LAN_RECONNECT_CONNECTION_INFO_NULL = 4593,
  NEARBY_LAN_RECONNECT_IP_NULL = 4594,
  NEARBY_WIFI_DIRECT_RECONNECT_META_DATA_NULL = 4595,
  NEARBY_WIFI_DIRECT_RECONNECT_CONNECT_META_DATA_NULL = 4596,
  NEARBY_WIFI_HOTSPOT_RECONNECT_META_DATA_NULL = 4597,
  NEARBY_WIFI_HOTSPOT_RECONNECT_CONNECT_META_DATA_NULL = 4598,
  NEARBY_WEB_RTC_RECONNECT_PEER_ID_NULL = 4599,
  NEARBY_WIFI_AWARE_RECONNECT_META_DATA_NULL = 4600,
  NEARBY_NOT_ADVERTISING_OR_LISTENING = 4601,
  NEARBY_CAN_NOT_OBTAIN_DEVICE_PROVIDER = 4602,
  NEARBY_SETUP_STRATEGY_FAILURE = 4603,
  NEARBY_TX_ADVERTISEMENT_NULL = 4604,
  NEARBY_ENDPOINT_ID_MISMATCH = 4605,
  NEARBY_CONNECTIVITY_INFO_NULL_OR_WRONG = 4606,
  NEARBY_LOCAL_CLIENT_STATE_WRONG = 4607,
  NEARBY_REMOTE_EXCEPTION_WHEN_PROCESSING_RECEIVED_PAYLOAD = 4608,
  NEARBY_BAD_FILE_DESCRIPTION_WHEN_PROCESSING_RECEIVED_PAYLOAD = 4609,
  NEARBY_CONNECTION_LISTENER_NULL = 4610,
  NEARBY_AWDL_ADVERTISE_TO_BYTES_FAILURE = 4611,
  NEARBY_AWDL_ENDPOINT_CHANNEL_CREATION_FAILURE = 4612,
  DCT_ERROR_BLE_DISABLED = 5000,
  DCT_ERROR_BLE_ADV_FAILED = 5001,
  DCT_ERROR_BLE_SCAN_FAILED = 5002,
  DCT_ERROR_L2CAP_SERVER_FAILED = 5003,
  DCT_ERROR_L2CAP_CLIENT_FAILED = 5004,
  DCT_ERROR_MDNS_DISCOVERY_TIMEOUT = 5005,
  DCT_ERROR_MDNS_REGISTER_SERVICE = 5006,
  DCT_ERROR_INITIAL_TLS_SPAKE = 5007,
  DCT_ERROR_SUBSEQUENT_TLS_SPAKE = 5008,
  DCT_ERROR_REQUEST_FAILED = 5009,
  DCT_ERROR_RESPONSE_FAILED = 5010,
  DCT_ERROR_CONTROL_MESSAGE_EXCHANGE = 5011,
  DCT_ERROR_CAPABILITY_MISMATCH = 5012,
  DCT_ERROR_HIGH_SPEED_MEDIUM_UNAVAILABLE = 5013,
  DCT_ERROR_WIFI_DISABLED = 5014,
  DCT_ERROR_WIFI_DISCONNECTED = 5015,
  DCT_ERROR_WIFI_CREDENTIAL_TRANSFER = 5016,
  DCT_ERROR_WIFI_INTERNET_CONNECTION = 5017,
  DCT_ERROR_UPGRADE_HIGH_SPEED_MEDIUM_FAILED = 5018,
  DCT_ERROR_KEEPALIVE_TIMEOUT = 5019,
  DCT_ERROR_ESTABLISHED_CONNECTION_LOST = 5020,
  DCT_ERROR_USER_CANCELLED = 5021,
  DCT_ERROR_SERVICE_CANCELLED = 5022,
  DCT_ERROR_UNVERIFIED_INTEGRITY = 5023,
  DCT_ERROR_HTTP_SERVER_CLOSED = 5024,
  DCT_ERROR_CHECKIN_FAILURE = 5025,
  DCT_ERROR_REMOTE_ATTESTATION_TIMEOUT = 5026,
  DCT_ERROR_REMOTE_ATTESTATION_NULL_PACKET = 5027,
  DCT_ERROR_REMOTE_ATTESTATION_STATUS_NOT_AVAILABLE = 5028,
  DCT_ERROR_REMOTE_ATTESTATION_HASH_TOO_SHORT = 5029,
  DCT_ERROR_REMOTE_ATTESTATION_APPLE_INTEGRITY_UNAVAILABLE = 5030,
  DCT_ERROR_LOCAL_ATTESTATION_PLAY_INTEGRITY_UNAVAILABLE = 5031,
  DCT_ERROR_LOCAL_ATTESTATION_TIMEOUT = 5032,
  DCT_ERROR_PARALLEL_ATTESTATION_TIMEOUT = 5033,
};

extern const uint32_t OperationResultCode_internal_data_[];
inline constexpr OperationResultCode OperationResultCode_MIN =
    static_cast<OperationResultCode>(0);
inline constexpr OperationResultCode OperationResultCode_MAX =
    static_cast<OperationResultCode>(5033);
inline bool OperationResultCode_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, OperationResultCode_internal_data_);
}
inline constexpr int OperationResultCode_ARRAYSIZE = 5033 + 1;
const ::std::string& OperationResultCode_Name(OperationResultCode value);
template <typename T>
const ::std::string& OperationResultCode_Name(T value) {
  static_assert(::std::is_same<T, OperationResultCode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to OperationResultCode_Name().");
  return OperationResultCode_Name(static_cast<OperationResultCode>(value));
}
bool OperationResultCode_Parse(
    ::absl::string_view name, OperationResultCode* PROTOBUF_NONNULL value);
enum StopAdvertisingReason : int {
  STOP_ADVERTISING_REASON_UNKNOWN = 0,
  CLIENT_STOP_ADVERTISING = 1,
  FINISH_SESSION_STOP_ADVERTISING = 2,
};

extern const uint32_t StopAdvertisingReason_internal_data_[];
inline constexpr StopAdvertisingReason StopAdvertisingReason_MIN =
    static_cast<StopAdvertisingReason>(0);
inline constexpr StopAdvertisingReason StopAdvertisingReason_MAX =
    static_cast<StopAdvertisingReason>(2);
inline bool StopAdvertisingReason_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int StopAdvertisingReason_ARRAYSIZE = 2 + 1;
const ::std::string& StopAdvertisingReason_Name(StopAdvertisingReason value);
template <typename T>
const ::std::string& StopAdvertisingReason_Name(T value) {
  static_assert(::std::is_same<T, StopAdvertisingReason>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to StopAdvertisingReason_Name().");
  return StopAdvertisingReason_Name(static_cast<StopAdvertisingReason>(value));
}
bool StopAdvertisingReason_Parse(
    ::absl::string_view name, StopAdvertisingReason* PROTOBUF_NONNULL value);
enum StopDiscoveringReason : int {
  STOP_DISCOVERING_REASON_UNKNOWN = 0,
  CLIENT_STOP_DISCOVERING = 1,
  FINISH_SESSION_STOP_DISCOVERING = 2,
};

extern const uint32_t StopDiscoveringReason_internal_data_[];
inline constexpr StopDiscoveringReason StopDiscoveringReason_MIN =
    static_cast<StopDiscoveringReason>(0);
inline constexpr StopDiscoveringReason StopDiscoveringReason_MAX =
    static_cast<StopDiscoveringReason>(2);
inline bool StopDiscoveringReason_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int StopDiscoveringReason_ARRAYSIZE = 2 + 1;
const ::std::string& StopDiscoveringReason_Name(StopDiscoveringReason value);
template <typename T>
const ::std::string& StopDiscoveringReason_Name(T value) {
  static_assert(::std::is_same<T, StopDiscoveringReason>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to StopDiscoveringReason_Name().");
  return StopDiscoveringReason_Name(static_cast<StopDiscoveringReason>(value));
}
bool StopDiscoveringReason_Parse(
    ::absl::string_view name, StopDiscoveringReason* PROTOBUF_NONNULL value);
enum DeviceType : int {
  UNKNOWN_TYPE = 0,
  NEARBY_CONNECTION = 1,
  NEARBY_PRESENCE = 2,
  DCT = 3,
};

extern const uint32_t DeviceType_internal_data_[];
inline constexpr DeviceType DeviceType_MIN =
    static_cast<DeviceType>(0);
inline constexpr DeviceType DeviceType_MAX =
    static_cast<DeviceType>(3);
inline bool DeviceType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DeviceType_ARRAYSIZE = 3 + 1;
const ::std::string& DeviceType_Name(DeviceType value);
template <typename T>
const ::std::string& DeviceType_Name(T value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DeviceType_Name().");
  return DeviceType_Name(static_cast<DeviceType>(value));
}
bool DeviceType_Parse(
    ::absl::string_view name, DeviceType* PROTOBUF_NONNULL value);
enum SupportedService : int {
  SUPPORTED_SERVICE_UNSPECIFIED = 0,
  SUPPORTED_SERVICE_SETTINGS_ESIM = 1,
  SUPPORTED_SERVICE_DATA_MIGRATION = 2,
  SUPPORTED_SERVICE_DATA_TRANSFER = 3,
};

extern const uint32_t SupportedService_internal_data_[];
inline constexpr SupportedService SupportedService_MIN =
    static_cast<SupportedService>(0);
inline constexpr SupportedService SupportedService_MAX =
    static_cast<SupportedService>(3);
inline bool SupportedService_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int SupportedService_ARRAYSIZE = 3 + 1;
const ::std::string& SupportedService_Name(SupportedService value);
template <typename T>
const ::std::string& SupportedService_Name(T value) {
  static_assert(::std::is_same<T, SupportedService>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SupportedService_Name().");
  return SupportedService_Name(static_cast<SupportedService>(value));
}
bool SupportedService_Parse(
    ::absl::string_view name, SupportedService* PROTOBUF_NONNULL value);
enum DctPayloadType : int {
  DCT_PAYLOAD_TYPE_UNSPECIFIED = 0,
  DCT_PAYLOAD_TYPE_REQUEST = 1,
  DCT_PAYLOAD_TYPE_BYTES_RESPONSE = 2,
  DCT_PAYLOAD_TYPE_FILES_RESPONSE = 3,
  DCT_PAYLOAD_TYPE_ONE_WAY_MESSAGE = 4,
};

extern const uint32_t DctPayloadType_internal_data_[];
inline constexpr DctPayloadType DctPayloadType_MIN =
    static_cast<DctPayloadType>(0);
inline constexpr DctPayloadType DctPayloadType_MAX =
    static_cast<DctPayloadType>(4);
inline bool DctPayloadType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int DctPayloadType_ARRAYSIZE = 4 + 1;
const ::std::string& DctPayloadType_Name(DctPayloadType value);
template <typename T>
const ::std::string& DctPayloadType_Name(T value) {
  static_assert(::std::is_same<T, DctPayloadType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DctPayloadType_Name().");
  return DctPayloadType_Name(static_cast<DctPayloadType>(value));
}
bool DctPayloadType_Parse(
    ::absl::string_view name, DctPayloadType* PROTOBUF_NONNULL value);

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace connections
}  // namespace proto
}  // namespace nearby
}  // namespace location


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::location::nearby::proto::connections::EventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionsStrategy> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::SessionRole> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::Medium> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::WifiDirectAuthType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionTechnology> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionBand> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionMode> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::InstantConnectionResult> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionRequestResponse> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionAttemptResult> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionAttemptDirection> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::ConnectionAttemptType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::DisconnectionReason> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::PayloadType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::PayloadStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::Bandwidth> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::BandwidthUpgradeResult> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::BandwidthUpgradeErrorStage> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::LogSource> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::PowerLevel> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::OperationResultCategory> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::OperationResultCode> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::StopAdvertisingReason> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::StopDiscoveringReason> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::DeviceType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::SupportedService> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::connections::DctPayloadType> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // proto_2fconnections_5fenums_2eproto_2epb_2eh
