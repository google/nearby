// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/fast_pair_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2ffast_5fpair_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2ffast_5fpair_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2ffast_5fpair_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2ffast_5fpair_5fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace nearby {
namespace proto {
namespace fastpair {
class FastPairEvent;
struct FastPairEventDefaultTypeInternal;
extern FastPairEventDefaultTypeInternal _FastPairEvent_default_instance_;
}  // namespace fastpair
}  // namespace proto
}  // namespace nearby
PROTOBUF_NAMESPACE_OPEN
template<> ::nearby::proto::fastpair::FastPairEvent* Arena::CreateMaybeMessage<::nearby::proto::fastpair::FastPairEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace nearby {
namespace proto {
namespace fastpair {

enum FastPairEvent_BondState : int {
  FastPairEvent_BondState_UNKNOWN_BOND_STATE = 0,
  FastPairEvent_BondState_NONE = 10,
  FastPairEvent_BondState_BONDING = 11,
  FastPairEvent_BondState_BONDED = 12
};
bool FastPairEvent_BondState_IsValid(int value);
constexpr FastPairEvent_BondState FastPairEvent_BondState_BondState_MIN = FastPairEvent_BondState_UNKNOWN_BOND_STATE;
constexpr FastPairEvent_BondState FastPairEvent_BondState_BondState_MAX = FastPairEvent_BondState_BONDED;
constexpr int FastPairEvent_BondState_BondState_ARRAYSIZE = FastPairEvent_BondState_BondState_MAX + 1;

const std::string& FastPairEvent_BondState_Name(FastPairEvent_BondState value);
template<typename T>
inline const std::string& FastPairEvent_BondState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FastPairEvent_BondState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FastPairEvent_BondState_Name.");
  return FastPairEvent_BondState_Name(static_cast<FastPairEvent_BondState>(enum_t_value));
}
bool FastPairEvent_BondState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FastPairEvent_BondState* value);
enum FastPairEvent_ErrorCode : int {
  FastPairEvent_ErrorCode_UNKNOWN_ERROR_CODE = 0,
  FastPairEvent_ErrorCode_OTHER_ERROR = 1,
  FastPairEvent_ErrorCode_TIMEOUT = 2,
  FastPairEvent_ErrorCode_INTERRUPTED = 3,
  FastPairEvent_ErrorCode_REFLECTIVE_OPERATION_EXCEPTION = 4,
  FastPairEvent_ErrorCode_EXECUTION_EXCEPTION = 5,
  FastPairEvent_ErrorCode_PARSE_EXCEPTION = 6,
  FastPairEvent_ErrorCode_MDH_REMOTE_EXCEPTION = 7,
  FastPairEvent_ErrorCode_SUCCESS_RETRY_GATT_ERROR = 8,
  FastPairEvent_ErrorCode_SUCCESS_RETRY_GATT_TIMEOUT = 9,
  FastPairEvent_ErrorCode_SUCCESS_RETRY_SECRET_HANDSHAKE_ERROR = 10,
  FastPairEvent_ErrorCode_SUCCESS_RETRY_SECRET_HANDSHAKE_TIMEOUT = 11,
  FastPairEvent_ErrorCode_SUCCESS_SECRET_HANDSHAKE_RECONNECT = 12,
  FastPairEvent_ErrorCode_SUCCESS_ADDRESS_ROTATE = 13,
  FastPairEvent_ErrorCode_SUCCESS_SIGNAL_LOST = 14,
  FastPairEvent_ErrorCode_DEVICE_NOT_IN_PAIRED_HISTORY_EXCEPTION = 15,
  FastPairEvent_ErrorCode_DEVICE_NOT_BONDED_DURING_RETROACTIVE_PAIR = 16
};
bool FastPairEvent_ErrorCode_IsValid(int value);
constexpr FastPairEvent_ErrorCode FastPairEvent_ErrorCode_ErrorCode_MIN = FastPairEvent_ErrorCode_UNKNOWN_ERROR_CODE;
constexpr FastPairEvent_ErrorCode FastPairEvent_ErrorCode_ErrorCode_MAX = FastPairEvent_ErrorCode_DEVICE_NOT_BONDED_DURING_RETROACTIVE_PAIR;
constexpr int FastPairEvent_ErrorCode_ErrorCode_ARRAYSIZE = FastPairEvent_ErrorCode_ErrorCode_MAX + 1;

const std::string& FastPairEvent_ErrorCode_Name(FastPairEvent_ErrorCode value);
template<typename T>
inline const std::string& FastPairEvent_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FastPairEvent_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FastPairEvent_ErrorCode_Name.");
  return FastPairEvent_ErrorCode_Name(static_cast<FastPairEvent_ErrorCode>(enum_t_value));
}
bool FastPairEvent_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FastPairEvent_ErrorCode* value);
enum FastPairEvent_BrEdrHandoverErrorCode : int {
  FastPairEvent_BrEdrHandoverErrorCode_UNKNOWN_BR_EDR_HANDOVER_ERROR_CODE = 0,
  FastPairEvent_BrEdrHandoverErrorCode_CONTROL_POINT_RESULT_CODE_NOT_SUCCESS = 1,
  FastPairEvent_BrEdrHandoverErrorCode_BLUETOOTH_MAC_INVALID = 2,
  FastPairEvent_BrEdrHandoverErrorCode_TRANSPORT_BLOCK_INVALID = 3
};
bool FastPairEvent_BrEdrHandoverErrorCode_IsValid(int value);
constexpr FastPairEvent_BrEdrHandoverErrorCode FastPairEvent_BrEdrHandoverErrorCode_BrEdrHandoverErrorCode_MIN = FastPairEvent_BrEdrHandoverErrorCode_UNKNOWN_BR_EDR_HANDOVER_ERROR_CODE;
constexpr FastPairEvent_BrEdrHandoverErrorCode FastPairEvent_BrEdrHandoverErrorCode_BrEdrHandoverErrorCode_MAX = FastPairEvent_BrEdrHandoverErrorCode_TRANSPORT_BLOCK_INVALID;
constexpr int FastPairEvent_BrEdrHandoverErrorCode_BrEdrHandoverErrorCode_ARRAYSIZE = FastPairEvent_BrEdrHandoverErrorCode_BrEdrHandoverErrorCode_MAX + 1;

const std::string& FastPairEvent_BrEdrHandoverErrorCode_Name(FastPairEvent_BrEdrHandoverErrorCode value);
template<typename T>
inline const std::string& FastPairEvent_BrEdrHandoverErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FastPairEvent_BrEdrHandoverErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FastPairEvent_BrEdrHandoverErrorCode_Name.");
  return FastPairEvent_BrEdrHandoverErrorCode_Name(static_cast<FastPairEvent_BrEdrHandoverErrorCode>(enum_t_value));
}
bool FastPairEvent_BrEdrHandoverErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FastPairEvent_BrEdrHandoverErrorCode* value);
enum FastPairEvent_CreateBondErrorCode : int {
  FastPairEvent_CreateBondErrorCode_UNKNOWN_BOND_ERROR_CODE = 0,
  FastPairEvent_CreateBondErrorCode_BOND_BROKEN = 1,
  FastPairEvent_CreateBondErrorCode_POSSIBLE_MITM = 2,
  FastPairEvent_CreateBondErrorCode_NO_PERMISSION = 3,
  FastPairEvent_CreateBondErrorCode_INCORRECT_VARIANT = 4,
  FastPairEvent_CreateBondErrorCode_FAILED_BUT_ALREADY_RECEIVE_PASS_KEY = 5
};
bool FastPairEvent_CreateBondErrorCode_IsValid(int value);
constexpr FastPairEvent_CreateBondErrorCode FastPairEvent_CreateBondErrorCode_CreateBondErrorCode_MIN = FastPairEvent_CreateBondErrorCode_UNKNOWN_BOND_ERROR_CODE;
constexpr FastPairEvent_CreateBondErrorCode FastPairEvent_CreateBondErrorCode_CreateBondErrorCode_MAX = FastPairEvent_CreateBondErrorCode_FAILED_BUT_ALREADY_RECEIVE_PASS_KEY;
constexpr int FastPairEvent_CreateBondErrorCode_CreateBondErrorCode_ARRAYSIZE = FastPairEvent_CreateBondErrorCode_CreateBondErrorCode_MAX + 1;

const std::string& FastPairEvent_CreateBondErrorCode_Name(FastPairEvent_CreateBondErrorCode value);
template<typename T>
inline const std::string& FastPairEvent_CreateBondErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FastPairEvent_CreateBondErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FastPairEvent_CreateBondErrorCode_Name.");
  return FastPairEvent_CreateBondErrorCode_Name(static_cast<FastPairEvent_CreateBondErrorCode>(enum_t_value));
}
bool FastPairEvent_CreateBondErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FastPairEvent_CreateBondErrorCode* value);
enum FastPairEvent_ConnectErrorCode : int {
  FastPairEvent_ConnectErrorCode_UNKNOWN_CONNECT_ERROR_CODE = 0,
  FastPairEvent_ConnectErrorCode_UNSUPPORTED_PROFILE = 1,
  FastPairEvent_ConnectErrorCode_GET_PROFILE_PROXY_FAILED = 2,
  FastPairEvent_ConnectErrorCode_DISCONNECTED = 3,
  FastPairEvent_ConnectErrorCode_LINK_KEY_CLEARED = 4,
  FastPairEvent_ConnectErrorCode_FAIL_TO_DISCOVERY = 5,
  FastPairEvent_ConnectErrorCode_DISCOVERY_NOT_FINISHED = 6
};
bool FastPairEvent_ConnectErrorCode_IsValid(int value);
constexpr FastPairEvent_ConnectErrorCode FastPairEvent_ConnectErrorCode_ConnectErrorCode_MIN = FastPairEvent_ConnectErrorCode_UNKNOWN_CONNECT_ERROR_CODE;
constexpr FastPairEvent_ConnectErrorCode FastPairEvent_ConnectErrorCode_ConnectErrorCode_MAX = FastPairEvent_ConnectErrorCode_DISCOVERY_NOT_FINISHED;
constexpr int FastPairEvent_ConnectErrorCode_ConnectErrorCode_ARRAYSIZE = FastPairEvent_ConnectErrorCode_ConnectErrorCode_MAX + 1;

const std::string& FastPairEvent_ConnectErrorCode_Name(FastPairEvent_ConnectErrorCode value);
template<typename T>
inline const std::string& FastPairEvent_ConnectErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FastPairEvent_ConnectErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FastPairEvent_ConnectErrorCode_Name.");
  return FastPairEvent_ConnectErrorCode_Name(static_cast<FastPairEvent_ConnectErrorCode>(enum_t_value));
}
bool FastPairEvent_ConnectErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FastPairEvent_ConnectErrorCode* value);
enum DeviceType : int {
  UNKNOWN_DEVICE_TYPE = 0,
  PHONE = 1,
  WEARABLE = 2,
  AUTO = 3,
  PC = 4,
  TV = 5,
  TABLET = 6
};
bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = UNKNOWN_DEVICE_TYPE;
constexpr DeviceType DeviceType_MAX = TABLET;
constexpr int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const std::string& DeviceType_Name(DeviceType value);
template<typename T>
inline const std::string& DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceType_Name.");
  return DeviceType_Name(static_cast<DeviceType>(enum_t_value));
}
bool DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value);
enum OsType : int {
  UNKNOWN_OS_TYPE = 0,
  ANDROID = 1,
  CHROME_OS = 2
};
bool OsType_IsValid(int value);
constexpr OsType OsType_MIN = UNKNOWN_OS_TYPE;
constexpr OsType OsType_MAX = CHROME_OS;
constexpr int OsType_ARRAYSIZE = OsType_MAX + 1;

const std::string& OsType_Name(OsType value);
template<typename T>
inline const std::string& OsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OsType_Name.");
  return OsType_Name(static_cast<OsType>(enum_t_value));
}
bool OsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OsType* value);
// ===================================================================

class FastPairEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.proto.fastpair.FastPairEvent) */ {
 public:
  inline FastPairEvent() : FastPairEvent(nullptr) {}
  ~FastPairEvent() override;
  explicit constexpr FastPairEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastPairEvent(const FastPairEvent& from);
  FastPairEvent(FastPairEvent&& from) noexcept
    : FastPairEvent() {
    *this = ::std::move(from);
  }

  inline FastPairEvent& operator=(const FastPairEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastPairEvent& operator=(FastPairEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FastPairEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastPairEvent* internal_default_instance() {
    return reinterpret_cast<const FastPairEvent*>(
               &_FastPairEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FastPairEvent& a, FastPairEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FastPairEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastPairEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastPairEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastPairEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FastPairEvent& from);
  void MergeFrom(const FastPairEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FastPairEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nearby.proto.fastpair.FastPairEvent";
  }
  protected:
  explicit FastPairEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FastPairEvent_BondState BondState;
  static constexpr BondState UNKNOWN_BOND_STATE =
    FastPairEvent_BondState_UNKNOWN_BOND_STATE;
  static constexpr BondState NONE =
    FastPairEvent_BondState_NONE;
  static constexpr BondState BONDING =
    FastPairEvent_BondState_BONDING;
  static constexpr BondState BONDED =
    FastPairEvent_BondState_BONDED;
  static inline bool BondState_IsValid(int value) {
    return FastPairEvent_BondState_IsValid(value);
  }
  static constexpr BondState BondState_MIN =
    FastPairEvent_BondState_BondState_MIN;
  static constexpr BondState BondState_MAX =
    FastPairEvent_BondState_BondState_MAX;
  static constexpr int BondState_ARRAYSIZE =
    FastPairEvent_BondState_BondState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BondState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BondState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BondState_Name.");
    return FastPairEvent_BondState_Name(enum_t_value);
  }
  static inline bool BondState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BondState* value) {
    return FastPairEvent_BondState_Parse(name, value);
  }

  typedef FastPairEvent_ErrorCode ErrorCode;
  static constexpr ErrorCode UNKNOWN_ERROR_CODE =
    FastPairEvent_ErrorCode_UNKNOWN_ERROR_CODE;
  static constexpr ErrorCode OTHER_ERROR =
    FastPairEvent_ErrorCode_OTHER_ERROR;
  static constexpr ErrorCode TIMEOUT =
    FastPairEvent_ErrorCode_TIMEOUT;
  static constexpr ErrorCode INTERRUPTED =
    FastPairEvent_ErrorCode_INTERRUPTED;
  static constexpr ErrorCode REFLECTIVE_OPERATION_EXCEPTION =
    FastPairEvent_ErrorCode_REFLECTIVE_OPERATION_EXCEPTION;
  static constexpr ErrorCode EXECUTION_EXCEPTION =
    FastPairEvent_ErrorCode_EXECUTION_EXCEPTION;
  static constexpr ErrorCode PARSE_EXCEPTION =
    FastPairEvent_ErrorCode_PARSE_EXCEPTION;
  static constexpr ErrorCode MDH_REMOTE_EXCEPTION =
    FastPairEvent_ErrorCode_MDH_REMOTE_EXCEPTION;
  static constexpr ErrorCode SUCCESS_RETRY_GATT_ERROR =
    FastPairEvent_ErrorCode_SUCCESS_RETRY_GATT_ERROR;
  static constexpr ErrorCode SUCCESS_RETRY_GATT_TIMEOUT =
    FastPairEvent_ErrorCode_SUCCESS_RETRY_GATT_TIMEOUT;
  static constexpr ErrorCode SUCCESS_RETRY_SECRET_HANDSHAKE_ERROR =
    FastPairEvent_ErrorCode_SUCCESS_RETRY_SECRET_HANDSHAKE_ERROR;
  static constexpr ErrorCode SUCCESS_RETRY_SECRET_HANDSHAKE_TIMEOUT =
    FastPairEvent_ErrorCode_SUCCESS_RETRY_SECRET_HANDSHAKE_TIMEOUT;
  static constexpr ErrorCode SUCCESS_SECRET_HANDSHAKE_RECONNECT =
    FastPairEvent_ErrorCode_SUCCESS_SECRET_HANDSHAKE_RECONNECT;
  static constexpr ErrorCode SUCCESS_ADDRESS_ROTATE =
    FastPairEvent_ErrorCode_SUCCESS_ADDRESS_ROTATE;
  static constexpr ErrorCode SUCCESS_SIGNAL_LOST =
    FastPairEvent_ErrorCode_SUCCESS_SIGNAL_LOST;
  static constexpr ErrorCode DEVICE_NOT_IN_PAIRED_HISTORY_EXCEPTION =
    FastPairEvent_ErrorCode_DEVICE_NOT_IN_PAIRED_HISTORY_EXCEPTION;
  static constexpr ErrorCode DEVICE_NOT_BONDED_DURING_RETROACTIVE_PAIR =
    FastPairEvent_ErrorCode_DEVICE_NOT_BONDED_DURING_RETROACTIVE_PAIR;
  static inline bool ErrorCode_IsValid(int value) {
    return FastPairEvent_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    FastPairEvent_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    FastPairEvent_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    FastPairEvent_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return FastPairEvent_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return FastPairEvent_ErrorCode_Parse(name, value);
  }

  typedef FastPairEvent_BrEdrHandoverErrorCode BrEdrHandoverErrorCode;
  static constexpr BrEdrHandoverErrorCode UNKNOWN_BR_EDR_HANDOVER_ERROR_CODE =
    FastPairEvent_BrEdrHandoverErrorCode_UNKNOWN_BR_EDR_HANDOVER_ERROR_CODE;
  static constexpr BrEdrHandoverErrorCode CONTROL_POINT_RESULT_CODE_NOT_SUCCESS =
    FastPairEvent_BrEdrHandoverErrorCode_CONTROL_POINT_RESULT_CODE_NOT_SUCCESS;
  static constexpr BrEdrHandoverErrorCode BLUETOOTH_MAC_INVALID =
    FastPairEvent_BrEdrHandoverErrorCode_BLUETOOTH_MAC_INVALID;
  static constexpr BrEdrHandoverErrorCode TRANSPORT_BLOCK_INVALID =
    FastPairEvent_BrEdrHandoverErrorCode_TRANSPORT_BLOCK_INVALID;
  static inline bool BrEdrHandoverErrorCode_IsValid(int value) {
    return FastPairEvent_BrEdrHandoverErrorCode_IsValid(value);
  }
  static constexpr BrEdrHandoverErrorCode BrEdrHandoverErrorCode_MIN =
    FastPairEvent_BrEdrHandoverErrorCode_BrEdrHandoverErrorCode_MIN;
  static constexpr BrEdrHandoverErrorCode BrEdrHandoverErrorCode_MAX =
    FastPairEvent_BrEdrHandoverErrorCode_BrEdrHandoverErrorCode_MAX;
  static constexpr int BrEdrHandoverErrorCode_ARRAYSIZE =
    FastPairEvent_BrEdrHandoverErrorCode_BrEdrHandoverErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BrEdrHandoverErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BrEdrHandoverErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BrEdrHandoverErrorCode_Name.");
    return FastPairEvent_BrEdrHandoverErrorCode_Name(enum_t_value);
  }
  static inline bool BrEdrHandoverErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BrEdrHandoverErrorCode* value) {
    return FastPairEvent_BrEdrHandoverErrorCode_Parse(name, value);
  }

  typedef FastPairEvent_CreateBondErrorCode CreateBondErrorCode;
  static constexpr CreateBondErrorCode UNKNOWN_BOND_ERROR_CODE =
    FastPairEvent_CreateBondErrorCode_UNKNOWN_BOND_ERROR_CODE;
  static constexpr CreateBondErrorCode BOND_BROKEN =
    FastPairEvent_CreateBondErrorCode_BOND_BROKEN;
  static constexpr CreateBondErrorCode POSSIBLE_MITM =
    FastPairEvent_CreateBondErrorCode_POSSIBLE_MITM;
  static constexpr CreateBondErrorCode NO_PERMISSION =
    FastPairEvent_CreateBondErrorCode_NO_PERMISSION;
  static constexpr CreateBondErrorCode INCORRECT_VARIANT =
    FastPairEvent_CreateBondErrorCode_INCORRECT_VARIANT;
  static constexpr CreateBondErrorCode FAILED_BUT_ALREADY_RECEIVE_PASS_KEY =
    FastPairEvent_CreateBondErrorCode_FAILED_BUT_ALREADY_RECEIVE_PASS_KEY;
  static inline bool CreateBondErrorCode_IsValid(int value) {
    return FastPairEvent_CreateBondErrorCode_IsValid(value);
  }
  static constexpr CreateBondErrorCode CreateBondErrorCode_MIN =
    FastPairEvent_CreateBondErrorCode_CreateBondErrorCode_MIN;
  static constexpr CreateBondErrorCode CreateBondErrorCode_MAX =
    FastPairEvent_CreateBondErrorCode_CreateBondErrorCode_MAX;
  static constexpr int CreateBondErrorCode_ARRAYSIZE =
    FastPairEvent_CreateBondErrorCode_CreateBondErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CreateBondErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CreateBondErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CreateBondErrorCode_Name.");
    return FastPairEvent_CreateBondErrorCode_Name(enum_t_value);
  }
  static inline bool CreateBondErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CreateBondErrorCode* value) {
    return FastPairEvent_CreateBondErrorCode_Parse(name, value);
  }

  typedef FastPairEvent_ConnectErrorCode ConnectErrorCode;
  static constexpr ConnectErrorCode UNKNOWN_CONNECT_ERROR_CODE =
    FastPairEvent_ConnectErrorCode_UNKNOWN_CONNECT_ERROR_CODE;
  static constexpr ConnectErrorCode UNSUPPORTED_PROFILE =
    FastPairEvent_ConnectErrorCode_UNSUPPORTED_PROFILE;
  static constexpr ConnectErrorCode GET_PROFILE_PROXY_FAILED =
    FastPairEvent_ConnectErrorCode_GET_PROFILE_PROXY_FAILED;
  static constexpr ConnectErrorCode DISCONNECTED =
    FastPairEvent_ConnectErrorCode_DISCONNECTED;
  static constexpr ConnectErrorCode LINK_KEY_CLEARED =
    FastPairEvent_ConnectErrorCode_LINK_KEY_CLEARED;
  static constexpr ConnectErrorCode FAIL_TO_DISCOVERY =
    FastPairEvent_ConnectErrorCode_FAIL_TO_DISCOVERY;
  static constexpr ConnectErrorCode DISCOVERY_NOT_FINISHED =
    FastPairEvent_ConnectErrorCode_DISCOVERY_NOT_FINISHED;
  static inline bool ConnectErrorCode_IsValid(int value) {
    return FastPairEvent_ConnectErrorCode_IsValid(value);
  }
  static constexpr ConnectErrorCode ConnectErrorCode_MIN =
    FastPairEvent_ConnectErrorCode_ConnectErrorCode_MIN;
  static constexpr ConnectErrorCode ConnectErrorCode_MAX =
    FastPairEvent_ConnectErrorCode_ConnectErrorCode_MAX;
  static constexpr int ConnectErrorCode_ARRAYSIZE =
    FastPairEvent_ConnectErrorCode_ConnectErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectErrorCode_Name.");
    return FastPairEvent_ConnectErrorCode_Name(enum_t_value);
  }
  static inline bool ConnectErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectErrorCode* value) {
    return FastPairEvent_ConnectErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:nearby.proto.fastpair.FastPairEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ffast_5fpair_5fenums_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FastPairEvent

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace fastpair
}  // namespace proto
}  // namespace nearby

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::nearby::proto::fastpair::FastPairEvent_BondState> : ::std::true_type {};
template <> struct is_proto_enum< ::nearby::proto::fastpair::FastPairEvent_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::nearby::proto::fastpair::FastPairEvent_BrEdrHandoverErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::nearby::proto::fastpair::FastPairEvent_CreateBondErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::nearby::proto::fastpair::FastPairEvent_ConnectErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::nearby::proto::fastpair::DeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::nearby::proto::fastpair::OsType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2ffast_5fpair_5fenums_2eproto
