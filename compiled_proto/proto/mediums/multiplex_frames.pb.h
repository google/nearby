// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/mediums/multiplex_frames.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fmediums_2fmultiplex_5fframes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fmediums_2fmultiplex_5fframes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fmediums_2fmultiplex_5fframes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace location {
namespace nearby {
namespace mediums {
class ConnectionRequestFrame;
struct ConnectionRequestFrameDefaultTypeInternal;
extern ConnectionRequestFrameDefaultTypeInternal _ConnectionRequestFrame_default_instance_;
class ConnectionResponseFrame;
struct ConnectionResponseFrameDefaultTypeInternal;
extern ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
class DisconnectFrame;
struct DisconnectFrameDefaultTypeInternal;
extern DisconnectFrameDefaultTypeInternal _DisconnectFrame_default_instance_;
class MultiplexControlFrame;
struct MultiplexControlFrameDefaultTypeInternal;
extern MultiplexControlFrameDefaultTypeInternal _MultiplexControlFrame_default_instance_;
class MultiplexDataFrame;
struct MultiplexDataFrameDefaultTypeInternal;
extern MultiplexDataFrameDefaultTypeInternal _MultiplexDataFrame_default_instance_;
class MultiplexFrame;
struct MultiplexFrameDefaultTypeInternal;
extern MultiplexFrameDefaultTypeInternal _MultiplexFrame_default_instance_;
class MultiplexFrameHeader;
struct MultiplexFrameHeaderDefaultTypeInternal;
extern MultiplexFrameHeaderDefaultTypeInternal _MultiplexFrameHeader_default_instance_;
}  // namespace mediums
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template<> ::location::nearby::mediums::ConnectionRequestFrame* Arena::CreateMaybeMessage<::location::nearby::mediums::ConnectionRequestFrame>(Arena*);
template<> ::location::nearby::mediums::ConnectionResponseFrame* Arena::CreateMaybeMessage<::location::nearby::mediums::ConnectionResponseFrame>(Arena*);
template<> ::location::nearby::mediums::DisconnectFrame* Arena::CreateMaybeMessage<::location::nearby::mediums::DisconnectFrame>(Arena*);
template<> ::location::nearby::mediums::MultiplexControlFrame* Arena::CreateMaybeMessage<::location::nearby::mediums::MultiplexControlFrame>(Arena*);
template<> ::location::nearby::mediums::MultiplexDataFrame* Arena::CreateMaybeMessage<::location::nearby::mediums::MultiplexDataFrame>(Arena*);
template<> ::location::nearby::mediums::MultiplexFrame* Arena::CreateMaybeMessage<::location::nearby::mediums::MultiplexFrame>(Arena*);
template<> ::location::nearby::mediums::MultiplexFrameHeader* Arena::CreateMaybeMessage<::location::nearby::mediums::MultiplexFrameHeader>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace location {
namespace nearby {
namespace mediums {

enum MultiplexFrame_MultiplexFrameType : int {
  MultiplexFrame_MultiplexFrameType_UNKNOWN_FRAME_TYPE = 0,
  MultiplexFrame_MultiplexFrameType_CONTROL_FRAME = 1,
  MultiplexFrame_MultiplexFrameType_DATA_FRAME = 2
};
bool MultiplexFrame_MultiplexFrameType_IsValid(int value);
constexpr MultiplexFrame_MultiplexFrameType MultiplexFrame_MultiplexFrameType_MultiplexFrameType_MIN = MultiplexFrame_MultiplexFrameType_UNKNOWN_FRAME_TYPE;
constexpr MultiplexFrame_MultiplexFrameType MultiplexFrame_MultiplexFrameType_MultiplexFrameType_MAX = MultiplexFrame_MultiplexFrameType_DATA_FRAME;
constexpr int MultiplexFrame_MultiplexFrameType_MultiplexFrameType_ARRAYSIZE = MultiplexFrame_MultiplexFrameType_MultiplexFrameType_MAX + 1;

const std::string& MultiplexFrame_MultiplexFrameType_Name(MultiplexFrame_MultiplexFrameType value);
template<typename T>
inline const std::string& MultiplexFrame_MultiplexFrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MultiplexFrame_MultiplexFrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MultiplexFrame_MultiplexFrameType_Name.");
  return MultiplexFrame_MultiplexFrameType_Name(static_cast<MultiplexFrame_MultiplexFrameType>(enum_t_value));
}
bool MultiplexFrame_MultiplexFrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MultiplexFrame_MultiplexFrameType* value);
enum MultiplexControlFrame_MultiplexControlFrameType : int {
  MultiplexControlFrame_MultiplexControlFrameType_UNKNOWN_CONTROL_FRAME_TYPE = 0,
  MultiplexControlFrame_MultiplexControlFrameType_CONNECTION_REQUEST = 1,
  MultiplexControlFrame_MultiplexControlFrameType_CONNECTION_RESPONSE = 2,
  MultiplexControlFrame_MultiplexControlFrameType_DISCONNECTION = 3
};
bool MultiplexControlFrame_MultiplexControlFrameType_IsValid(int value);
constexpr MultiplexControlFrame_MultiplexControlFrameType MultiplexControlFrame_MultiplexControlFrameType_MultiplexControlFrameType_MIN = MultiplexControlFrame_MultiplexControlFrameType_UNKNOWN_CONTROL_FRAME_TYPE;
constexpr MultiplexControlFrame_MultiplexControlFrameType MultiplexControlFrame_MultiplexControlFrameType_MultiplexControlFrameType_MAX = MultiplexControlFrame_MultiplexControlFrameType_DISCONNECTION;
constexpr int MultiplexControlFrame_MultiplexControlFrameType_MultiplexControlFrameType_ARRAYSIZE = MultiplexControlFrame_MultiplexControlFrameType_MultiplexControlFrameType_MAX + 1;

const std::string& MultiplexControlFrame_MultiplexControlFrameType_Name(MultiplexControlFrame_MultiplexControlFrameType value);
template<typename T>
inline const std::string& MultiplexControlFrame_MultiplexControlFrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MultiplexControlFrame_MultiplexControlFrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MultiplexControlFrame_MultiplexControlFrameType_Name.");
  return MultiplexControlFrame_MultiplexControlFrameType_Name(static_cast<MultiplexControlFrame_MultiplexControlFrameType>(enum_t_value));
}
bool MultiplexControlFrame_MultiplexControlFrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MultiplexControlFrame_MultiplexControlFrameType* value);
enum ConnectionResponseFrame_ConnectionResponseCode : int {
  ConnectionResponseFrame_ConnectionResponseCode_UNKNOWN_RESPONSE_CODE = 0,
  ConnectionResponseFrame_ConnectionResponseCode_CONNECTION_ACCEPTED = 1,
  ConnectionResponseFrame_ConnectionResponseCode_NOT_LISTENING = 2
};
bool ConnectionResponseFrame_ConnectionResponseCode_IsValid(int value);
constexpr ConnectionResponseFrame_ConnectionResponseCode ConnectionResponseFrame_ConnectionResponseCode_ConnectionResponseCode_MIN = ConnectionResponseFrame_ConnectionResponseCode_UNKNOWN_RESPONSE_CODE;
constexpr ConnectionResponseFrame_ConnectionResponseCode ConnectionResponseFrame_ConnectionResponseCode_ConnectionResponseCode_MAX = ConnectionResponseFrame_ConnectionResponseCode_NOT_LISTENING;
constexpr int ConnectionResponseFrame_ConnectionResponseCode_ConnectionResponseCode_ARRAYSIZE = ConnectionResponseFrame_ConnectionResponseCode_ConnectionResponseCode_MAX + 1;

const std::string& ConnectionResponseFrame_ConnectionResponseCode_Name(ConnectionResponseFrame_ConnectionResponseCode value);
template<typename T>
inline const std::string& ConnectionResponseFrame_ConnectionResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionResponseFrame_ConnectionResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionResponseFrame_ConnectionResponseCode_Name.");
  return ConnectionResponseFrame_ConnectionResponseCode_Name(static_cast<ConnectionResponseFrame_ConnectionResponseCode>(enum_t_value));
}
bool ConnectionResponseFrame_ConnectionResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionResponseFrame_ConnectionResponseCode* value);
// ===================================================================

class MultiplexFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.MultiplexFrame) */ {
 public:
  inline MultiplexFrame() : MultiplexFrame(nullptr) {}
  ~MultiplexFrame() override;
  explicit constexpr MultiplexFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiplexFrame(const MultiplexFrame& from);
  MultiplexFrame(MultiplexFrame&& from) noexcept
    : MultiplexFrame() {
    *this = ::std::move(from);
  }

  inline MultiplexFrame& operator=(const MultiplexFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplexFrame& operator=(MultiplexFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MultiplexFrame& default_instance() {
    return *internal_default_instance();
  }
  enum FrameCase {
    kControlFrame = 3,
    kDataFrame = 4,
    FRAME_NOT_SET = 0,
  };

  static inline const MultiplexFrame* internal_default_instance() {
    return reinterpret_cast<const MultiplexFrame*>(
               &_MultiplexFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MultiplexFrame& a, MultiplexFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplexFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplexFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiplexFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiplexFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MultiplexFrame& from);
  void MergeFrom(const MultiplexFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultiplexFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.MultiplexFrame";
  }
  protected:
  explicit MultiplexFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef MultiplexFrame_MultiplexFrameType MultiplexFrameType;
  static constexpr MultiplexFrameType UNKNOWN_FRAME_TYPE =
    MultiplexFrame_MultiplexFrameType_UNKNOWN_FRAME_TYPE;
  static constexpr MultiplexFrameType CONTROL_FRAME =
    MultiplexFrame_MultiplexFrameType_CONTROL_FRAME;
  static constexpr MultiplexFrameType DATA_FRAME =
    MultiplexFrame_MultiplexFrameType_DATA_FRAME;
  static inline bool MultiplexFrameType_IsValid(int value) {
    return MultiplexFrame_MultiplexFrameType_IsValid(value);
  }
  static constexpr MultiplexFrameType MultiplexFrameType_MIN =
    MultiplexFrame_MultiplexFrameType_MultiplexFrameType_MIN;
  static constexpr MultiplexFrameType MultiplexFrameType_MAX =
    MultiplexFrame_MultiplexFrameType_MultiplexFrameType_MAX;
  static constexpr int MultiplexFrameType_ARRAYSIZE =
    MultiplexFrame_MultiplexFrameType_MultiplexFrameType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MultiplexFrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MultiplexFrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MultiplexFrameType_Name.");
    return MultiplexFrame_MultiplexFrameType_Name(enum_t_value);
  }
  static inline bool MultiplexFrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MultiplexFrameType* value) {
    return MultiplexFrame_MultiplexFrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFrameTypeFieldNumber = 2,
    kControlFrameFieldNumber = 3,
    kDataFrameFieldNumber = 4,
  };
  // optional .location.nearby.mediums.MultiplexFrameHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::location::nearby::mediums::MultiplexFrameHeader& header() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::MultiplexFrameHeader* release_header();
  ::location::nearby::mediums::MultiplexFrameHeader* mutable_header();
  void set_allocated_header(::location::nearby::mediums::MultiplexFrameHeader* header);
  private:
  const ::location::nearby::mediums::MultiplexFrameHeader& _internal_header() const;
  ::location::nearby::mediums::MultiplexFrameHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::location::nearby::mediums::MultiplexFrameHeader* header);
  ::location::nearby::mediums::MultiplexFrameHeader* unsafe_arena_release_header();

  // optional .location.nearby.mediums.MultiplexFrame.MultiplexFrameType frame_type = 2;
  bool has_frame_type() const;
  private:
  bool _internal_has_frame_type() const;
  public:
  void clear_frame_type();
  ::location::nearby::mediums::MultiplexFrame_MultiplexFrameType frame_type() const;
  void set_frame_type(::location::nearby::mediums::MultiplexFrame_MultiplexFrameType value);
  private:
  ::location::nearby::mediums::MultiplexFrame_MultiplexFrameType _internal_frame_type() const;
  void _internal_set_frame_type(::location::nearby::mediums::MultiplexFrame_MultiplexFrameType value);
  public:

  // .location.nearby.mediums.MultiplexControlFrame control_frame = 3;
  bool has_control_frame() const;
  private:
  bool _internal_has_control_frame() const;
  public:
  void clear_control_frame();
  const ::location::nearby::mediums::MultiplexControlFrame& control_frame() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::MultiplexControlFrame* release_control_frame();
  ::location::nearby::mediums::MultiplexControlFrame* mutable_control_frame();
  void set_allocated_control_frame(::location::nearby::mediums::MultiplexControlFrame* control_frame);
  private:
  const ::location::nearby::mediums::MultiplexControlFrame& _internal_control_frame() const;
  ::location::nearby::mediums::MultiplexControlFrame* _internal_mutable_control_frame();
  public:
  void unsafe_arena_set_allocated_control_frame(
      ::location::nearby::mediums::MultiplexControlFrame* control_frame);
  ::location::nearby::mediums::MultiplexControlFrame* unsafe_arena_release_control_frame();

  // .location.nearby.mediums.MultiplexDataFrame data_frame = 4;
  bool has_data_frame() const;
  private:
  bool _internal_has_data_frame() const;
  public:
  void clear_data_frame();
  const ::location::nearby::mediums::MultiplexDataFrame& data_frame() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::MultiplexDataFrame* release_data_frame();
  ::location::nearby::mediums::MultiplexDataFrame* mutable_data_frame();
  void set_allocated_data_frame(::location::nearby::mediums::MultiplexDataFrame* data_frame);
  private:
  const ::location::nearby::mediums::MultiplexDataFrame& _internal_data_frame() const;
  ::location::nearby::mediums::MultiplexDataFrame* _internal_mutable_data_frame();
  public:
  void unsafe_arena_set_allocated_data_frame(
      ::location::nearby::mediums::MultiplexDataFrame* data_frame);
  ::location::nearby::mediums::MultiplexDataFrame* unsafe_arena_release_data_frame();

  void clear_Frame();
  FrameCase Frame_case() const;
  // @@protoc_insertion_point(class_scope:location.nearby.mediums.MultiplexFrame)
 private:
  class _Internal;
  void set_has_control_frame();
  void set_has_data_frame();

  inline bool has_Frame() const;
  inline void clear_has_Frame();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::mediums::MultiplexFrameHeader* header_;
  int frame_type_;
  union FrameUnion {
    constexpr FrameUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::location::nearby::mediums::MultiplexControlFrame* control_frame_;
    ::location::nearby::mediums::MultiplexDataFrame* data_frame_;
  } Frame_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto;
};
// -------------------------------------------------------------------

class MultiplexFrameHeader final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.MultiplexFrameHeader) */ {
 public:
  inline MultiplexFrameHeader() : MultiplexFrameHeader(nullptr) {}
  ~MultiplexFrameHeader() override;
  explicit constexpr MultiplexFrameHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiplexFrameHeader(const MultiplexFrameHeader& from);
  MultiplexFrameHeader(MultiplexFrameHeader&& from) noexcept
    : MultiplexFrameHeader() {
    *this = ::std::move(from);
  }

  inline MultiplexFrameHeader& operator=(const MultiplexFrameHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplexFrameHeader& operator=(MultiplexFrameHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MultiplexFrameHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiplexFrameHeader* internal_default_instance() {
    return reinterpret_cast<const MultiplexFrameHeader*>(
               &_MultiplexFrameHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MultiplexFrameHeader& a, MultiplexFrameHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplexFrameHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplexFrameHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiplexFrameHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiplexFrameHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MultiplexFrameHeader& from);
  void MergeFrom(const MultiplexFrameHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultiplexFrameHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.MultiplexFrameHeader";
  }
  protected:
  explicit MultiplexFrameHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaltedServiceIdHashFieldNumber = 1,
    kServiceIdHashSaltFieldNumber = 2,
  };
  // optional bytes salted_service_id_hash = 1;
  bool has_salted_service_id_hash() const;
  private:
  bool _internal_has_salted_service_id_hash() const;
  public:
  void clear_salted_service_id_hash();
  const std::string& salted_service_id_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salted_service_id_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salted_service_id_hash();
  PROTOBUF_NODISCARD std::string* release_salted_service_id_hash();
  void set_allocated_salted_service_id_hash(std::string* salted_service_id_hash);
  private:
  const std::string& _internal_salted_service_id_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salted_service_id_hash(const std::string& value);
  std::string* _internal_mutable_salted_service_id_hash();
  public:

  // optional string service_id_hash_salt = 2;
  bool has_service_id_hash_salt() const;
  private:
  bool _internal_has_service_id_hash_salt() const;
  public:
  void clear_service_id_hash_salt();
  const std::string& service_id_hash_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_id_hash_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_id_hash_salt();
  PROTOBUF_NODISCARD std::string* release_service_id_hash_salt();
  void set_allocated_service_id_hash_salt(std::string* service_id_hash_salt);
  private:
  const std::string& _internal_service_id_hash_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_id_hash_salt(const std::string& value);
  std::string* _internal_mutable_service_id_hash_salt();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.MultiplexFrameHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salted_service_id_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_id_hash_salt_;
  friend struct ::TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto;
};
// -------------------------------------------------------------------

class MultiplexControlFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.MultiplexControlFrame) */ {
 public:
  inline MultiplexControlFrame() : MultiplexControlFrame(nullptr) {}
  ~MultiplexControlFrame() override;
  explicit constexpr MultiplexControlFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiplexControlFrame(const MultiplexControlFrame& from);
  MultiplexControlFrame(MultiplexControlFrame&& from) noexcept
    : MultiplexControlFrame() {
    *this = ::std::move(from);
  }

  inline MultiplexControlFrame& operator=(const MultiplexControlFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplexControlFrame& operator=(MultiplexControlFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MultiplexControlFrame& default_instance() {
    return *internal_default_instance();
  }
  enum FrameCase {
    kConnectionRequestFrame = 2,
    kConnectionResponseFrame = 3,
    kDisconnectFrame = 4,
    FRAME_NOT_SET = 0,
  };

  static inline const MultiplexControlFrame* internal_default_instance() {
    return reinterpret_cast<const MultiplexControlFrame*>(
               &_MultiplexControlFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MultiplexControlFrame& a, MultiplexControlFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplexControlFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplexControlFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiplexControlFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiplexControlFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MultiplexControlFrame& from);
  void MergeFrom(const MultiplexControlFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultiplexControlFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.MultiplexControlFrame";
  }
  protected:
  explicit MultiplexControlFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef MultiplexControlFrame_MultiplexControlFrameType MultiplexControlFrameType;
  static constexpr MultiplexControlFrameType UNKNOWN_CONTROL_FRAME_TYPE =
    MultiplexControlFrame_MultiplexControlFrameType_UNKNOWN_CONTROL_FRAME_TYPE;
  static constexpr MultiplexControlFrameType CONNECTION_REQUEST =
    MultiplexControlFrame_MultiplexControlFrameType_CONNECTION_REQUEST;
  static constexpr MultiplexControlFrameType CONNECTION_RESPONSE =
    MultiplexControlFrame_MultiplexControlFrameType_CONNECTION_RESPONSE;
  static constexpr MultiplexControlFrameType DISCONNECTION =
    MultiplexControlFrame_MultiplexControlFrameType_DISCONNECTION;
  static inline bool MultiplexControlFrameType_IsValid(int value) {
    return MultiplexControlFrame_MultiplexControlFrameType_IsValid(value);
  }
  static constexpr MultiplexControlFrameType MultiplexControlFrameType_MIN =
    MultiplexControlFrame_MultiplexControlFrameType_MultiplexControlFrameType_MIN;
  static constexpr MultiplexControlFrameType MultiplexControlFrameType_MAX =
    MultiplexControlFrame_MultiplexControlFrameType_MultiplexControlFrameType_MAX;
  static constexpr int MultiplexControlFrameType_ARRAYSIZE =
    MultiplexControlFrame_MultiplexControlFrameType_MultiplexControlFrameType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MultiplexControlFrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MultiplexControlFrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MultiplexControlFrameType_Name.");
    return MultiplexControlFrame_MultiplexControlFrameType_Name(enum_t_value);
  }
  static inline bool MultiplexControlFrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MultiplexControlFrameType* value) {
    return MultiplexControlFrame_MultiplexControlFrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kControlFrameTypeFieldNumber = 1,
    kConnectionRequestFrameFieldNumber = 2,
    kConnectionResponseFrameFieldNumber = 3,
    kDisconnectFrameFieldNumber = 4,
  };
  // optional .location.nearby.mediums.MultiplexControlFrame.MultiplexControlFrameType control_frame_type = 1;
  bool has_control_frame_type() const;
  private:
  bool _internal_has_control_frame_type() const;
  public:
  void clear_control_frame_type();
  ::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType control_frame_type() const;
  void set_control_frame_type(::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType value);
  private:
  ::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType _internal_control_frame_type() const;
  void _internal_set_control_frame_type(::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType value);
  public:

  // .location.nearby.mediums.ConnectionRequestFrame connection_request_frame = 2;
  bool has_connection_request_frame() const;
  private:
  bool _internal_has_connection_request_frame() const;
  public:
  void clear_connection_request_frame();
  const ::location::nearby::mediums::ConnectionRequestFrame& connection_request_frame() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::ConnectionRequestFrame* release_connection_request_frame();
  ::location::nearby::mediums::ConnectionRequestFrame* mutable_connection_request_frame();
  void set_allocated_connection_request_frame(::location::nearby::mediums::ConnectionRequestFrame* connection_request_frame);
  private:
  const ::location::nearby::mediums::ConnectionRequestFrame& _internal_connection_request_frame() const;
  ::location::nearby::mediums::ConnectionRequestFrame* _internal_mutable_connection_request_frame();
  public:
  void unsafe_arena_set_allocated_connection_request_frame(
      ::location::nearby::mediums::ConnectionRequestFrame* connection_request_frame);
  ::location::nearby::mediums::ConnectionRequestFrame* unsafe_arena_release_connection_request_frame();

  // .location.nearby.mediums.ConnectionResponseFrame connection_response_frame = 3;
  bool has_connection_response_frame() const;
  private:
  bool _internal_has_connection_response_frame() const;
  public:
  void clear_connection_response_frame();
  const ::location::nearby::mediums::ConnectionResponseFrame& connection_response_frame() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::ConnectionResponseFrame* release_connection_response_frame();
  ::location::nearby::mediums::ConnectionResponseFrame* mutable_connection_response_frame();
  void set_allocated_connection_response_frame(::location::nearby::mediums::ConnectionResponseFrame* connection_response_frame);
  private:
  const ::location::nearby::mediums::ConnectionResponseFrame& _internal_connection_response_frame() const;
  ::location::nearby::mediums::ConnectionResponseFrame* _internal_mutable_connection_response_frame();
  public:
  void unsafe_arena_set_allocated_connection_response_frame(
      ::location::nearby::mediums::ConnectionResponseFrame* connection_response_frame);
  ::location::nearby::mediums::ConnectionResponseFrame* unsafe_arena_release_connection_response_frame();

  // .location.nearby.mediums.DisconnectFrame disconnect_frame = 4;
  bool has_disconnect_frame() const;
  private:
  bool _internal_has_disconnect_frame() const;
  public:
  void clear_disconnect_frame();
  const ::location::nearby::mediums::DisconnectFrame& disconnect_frame() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::DisconnectFrame* release_disconnect_frame();
  ::location::nearby::mediums::DisconnectFrame* mutable_disconnect_frame();
  void set_allocated_disconnect_frame(::location::nearby::mediums::DisconnectFrame* disconnect_frame);
  private:
  const ::location::nearby::mediums::DisconnectFrame& _internal_disconnect_frame() const;
  ::location::nearby::mediums::DisconnectFrame* _internal_mutable_disconnect_frame();
  public:
  void unsafe_arena_set_allocated_disconnect_frame(
      ::location::nearby::mediums::DisconnectFrame* disconnect_frame);
  ::location::nearby::mediums::DisconnectFrame* unsafe_arena_release_disconnect_frame();

  void clear_Frame();
  FrameCase Frame_case() const;
  // @@protoc_insertion_point(class_scope:location.nearby.mediums.MultiplexControlFrame)
 private:
  class _Internal;
  void set_has_connection_request_frame();
  void set_has_connection_response_frame();
  void set_has_disconnect_frame();

  inline bool has_Frame() const;
  inline void clear_has_Frame();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int control_frame_type_;
  union FrameUnion {
    constexpr FrameUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::location::nearby::mediums::ConnectionRequestFrame* connection_request_frame_;
    ::location::nearby::mediums::ConnectionResponseFrame* connection_response_frame_;
    ::location::nearby::mediums::DisconnectFrame* disconnect_frame_;
  } Frame_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto;
};
// -------------------------------------------------------------------

class ConnectionRequestFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.ConnectionRequestFrame) */ {
 public:
  inline ConnectionRequestFrame() : ConnectionRequestFrame(nullptr) {}
  ~ConnectionRequestFrame() override;
  explicit constexpr ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionRequestFrame(const ConnectionRequestFrame& from);
  ConnectionRequestFrame(ConnectionRequestFrame&& from) noexcept
    : ConnectionRequestFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionRequestFrame& operator=(const ConnectionRequestFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionRequestFrame& operator=(ConnectionRequestFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionRequestFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionRequestFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionRequestFrame*>(
               &_ConnectionRequestFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConnectionRequestFrame& a, ConnectionRequestFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionRequestFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionRequestFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionRequestFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionRequestFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionRequestFrame& from);
  void MergeFrom(const ConnectionRequestFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionRequestFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.ConnectionRequestFrame";
  }
  protected:
  explicit ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.ConnectionRequestFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto;
};
// -------------------------------------------------------------------

class ConnectionResponseFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.ConnectionResponseFrame) */ {
 public:
  inline ConnectionResponseFrame() : ConnectionResponseFrame(nullptr) {}
  ~ConnectionResponseFrame() override;
  explicit constexpr ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionResponseFrame(const ConnectionResponseFrame& from);
  ConnectionResponseFrame(ConnectionResponseFrame&& from) noexcept
    : ConnectionResponseFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionResponseFrame& operator=(const ConnectionResponseFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionResponseFrame& operator=(ConnectionResponseFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionResponseFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionResponseFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionResponseFrame*>(
               &_ConnectionResponseFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnectionResponseFrame& a, ConnectionResponseFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionResponseFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionResponseFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionResponseFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionResponseFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionResponseFrame& from);
  void MergeFrom(const ConnectionResponseFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionResponseFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.ConnectionResponseFrame";
  }
  protected:
  explicit ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionResponseFrame_ConnectionResponseCode ConnectionResponseCode;
  static constexpr ConnectionResponseCode UNKNOWN_RESPONSE_CODE =
    ConnectionResponseFrame_ConnectionResponseCode_UNKNOWN_RESPONSE_CODE;
  static constexpr ConnectionResponseCode CONNECTION_ACCEPTED =
    ConnectionResponseFrame_ConnectionResponseCode_CONNECTION_ACCEPTED;
  static constexpr ConnectionResponseCode NOT_LISTENING =
    ConnectionResponseFrame_ConnectionResponseCode_NOT_LISTENING;
  static inline bool ConnectionResponseCode_IsValid(int value) {
    return ConnectionResponseFrame_ConnectionResponseCode_IsValid(value);
  }
  static constexpr ConnectionResponseCode ConnectionResponseCode_MIN =
    ConnectionResponseFrame_ConnectionResponseCode_ConnectionResponseCode_MIN;
  static constexpr ConnectionResponseCode ConnectionResponseCode_MAX =
    ConnectionResponseFrame_ConnectionResponseCode_ConnectionResponseCode_MAX;
  static constexpr int ConnectionResponseCode_ARRAYSIZE =
    ConnectionResponseFrame_ConnectionResponseCode_ConnectionResponseCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectionResponseCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionResponseCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionResponseCode_Name.");
    return ConnectionResponseFrame_ConnectionResponseCode_Name(enum_t_value);
  }
  static inline bool ConnectionResponseCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionResponseCode* value) {
    return ConnectionResponseFrame_ConnectionResponseCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionResponseCodeFieldNumber = 1,
  };
  // optional .location.nearby.mediums.ConnectionResponseFrame.ConnectionResponseCode connection_response_code = 1;
  bool has_connection_response_code() const;
  private:
  bool _internal_has_connection_response_code() const;
  public:
  void clear_connection_response_code();
  ::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode connection_response_code() const;
  void set_connection_response_code(::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode value);
  private:
  ::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode _internal_connection_response_code() const;
  void _internal_set_connection_response_code(::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.ConnectionResponseFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int connection_response_code_;
  friend struct ::TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto;
};
// -------------------------------------------------------------------

class DisconnectFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.DisconnectFrame) */ {
 public:
  inline DisconnectFrame() : DisconnectFrame(nullptr) {}
  ~DisconnectFrame() override;
  explicit constexpr DisconnectFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectFrame(const DisconnectFrame& from);
  DisconnectFrame(DisconnectFrame&& from) noexcept
    : DisconnectFrame() {
    *this = ::std::move(from);
  }

  inline DisconnectFrame& operator=(const DisconnectFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectFrame& operator=(DisconnectFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisconnectFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectFrame* internal_default_instance() {
    return reinterpret_cast<const DisconnectFrame*>(
               &_DisconnectFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DisconnectFrame& a, DisconnectFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisconnectFrame& from);
  void MergeFrom(const DisconnectFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisconnectFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.DisconnectFrame";
  }
  protected:
  explicit DisconnectFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.DisconnectFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto;
};
// -------------------------------------------------------------------

class MultiplexDataFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.MultiplexDataFrame) */ {
 public:
  inline MultiplexDataFrame() : MultiplexDataFrame(nullptr) {}
  ~MultiplexDataFrame() override;
  explicit constexpr MultiplexDataFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiplexDataFrame(const MultiplexDataFrame& from);
  MultiplexDataFrame(MultiplexDataFrame&& from) noexcept
    : MultiplexDataFrame() {
    *this = ::std::move(from);
  }

  inline MultiplexDataFrame& operator=(const MultiplexDataFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplexDataFrame& operator=(MultiplexDataFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MultiplexDataFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiplexDataFrame* internal_default_instance() {
    return reinterpret_cast<const MultiplexDataFrame*>(
               &_MultiplexDataFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MultiplexDataFrame& a, MultiplexDataFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplexDataFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplexDataFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiplexDataFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiplexDataFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MultiplexDataFrame& from);
  void MergeFrom(const MultiplexDataFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultiplexDataFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.MultiplexDataFrame";
  }
  protected:
  explicit MultiplexDataFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // optional bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.MultiplexDataFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  friend struct ::TableStruct_proto_2fmediums_2fmultiplex_5fframes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MultiplexFrame

// optional .location.nearby.mediums.MultiplexFrameHeader header = 1;
inline bool MultiplexFrame::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool MultiplexFrame::has_header() const {
  return _internal_has_header();
}
inline void MultiplexFrame::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::mediums::MultiplexFrameHeader& MultiplexFrame::_internal_header() const {
  const ::location::nearby::mediums::MultiplexFrameHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::mediums::MultiplexFrameHeader&>(
      ::location::nearby::mediums::_MultiplexFrameHeader_default_instance_);
}
inline const ::location::nearby::mediums::MultiplexFrameHeader& MultiplexFrame::header() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexFrame.header)
  return _internal_header();
}
inline void MultiplexFrame::unsafe_arena_set_allocated_header(
    ::location::nearby::mediums::MultiplexFrameHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.MultiplexFrame.header)
}
inline ::location::nearby::mediums::MultiplexFrameHeader* MultiplexFrame::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::MultiplexFrameHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::mediums::MultiplexFrameHeader* MultiplexFrame::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexFrame.header)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::MultiplexFrameHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::location::nearby::mediums::MultiplexFrameHeader* MultiplexFrame::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::mediums::MultiplexFrameHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::location::nearby::mediums::MultiplexFrameHeader* MultiplexFrame::mutable_header() {
  ::location::nearby::mediums::MultiplexFrameHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexFrame.header)
  return _msg;
}
inline void MultiplexFrame::set_allocated_header(::location::nearby::mediums::MultiplexFrameHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::mediums::MultiplexFrameHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.MultiplexFrame.header)
}

// optional .location.nearby.mediums.MultiplexFrame.MultiplexFrameType frame_type = 2;
inline bool MultiplexFrame::_internal_has_frame_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MultiplexFrame::has_frame_type() const {
  return _internal_has_frame_type();
}
inline void MultiplexFrame::clear_frame_type() {
  frame_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::mediums::MultiplexFrame_MultiplexFrameType MultiplexFrame::_internal_frame_type() const {
  return static_cast< ::location::nearby::mediums::MultiplexFrame_MultiplexFrameType >(frame_type_);
}
inline ::location::nearby::mediums::MultiplexFrame_MultiplexFrameType MultiplexFrame::frame_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexFrame.frame_type)
  return _internal_frame_type();
}
inline void MultiplexFrame::_internal_set_frame_type(::location::nearby::mediums::MultiplexFrame_MultiplexFrameType value) {
  assert(::location::nearby::mediums::MultiplexFrame_MultiplexFrameType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  frame_type_ = value;
}
inline void MultiplexFrame::set_frame_type(::location::nearby::mediums::MultiplexFrame_MultiplexFrameType value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.mediums.MultiplexFrame.frame_type)
}

// .location.nearby.mediums.MultiplexControlFrame control_frame = 3;
inline bool MultiplexFrame::_internal_has_control_frame() const {
  return Frame_case() == kControlFrame;
}
inline bool MultiplexFrame::has_control_frame() const {
  return _internal_has_control_frame();
}
inline void MultiplexFrame::set_has_control_frame() {
  _oneof_case_[0] = kControlFrame;
}
inline void MultiplexFrame::clear_control_frame() {
  if (_internal_has_control_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.control_frame_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::MultiplexControlFrame* MultiplexFrame::release_control_frame() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexFrame.control_frame)
  if (_internal_has_control_frame()) {
    clear_has_Frame();
      ::location::nearby::mediums::MultiplexControlFrame* temp = Frame_.control_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.control_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::MultiplexControlFrame& MultiplexFrame::_internal_control_frame() const {
  return _internal_has_control_frame()
      ? *Frame_.control_frame_
      : reinterpret_cast< ::location::nearby::mediums::MultiplexControlFrame&>(::location::nearby::mediums::_MultiplexControlFrame_default_instance_);
}
inline const ::location::nearby::mediums::MultiplexControlFrame& MultiplexFrame::control_frame() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexFrame.control_frame)
  return _internal_control_frame();
}
inline ::location::nearby::mediums::MultiplexControlFrame* MultiplexFrame::unsafe_arena_release_control_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.MultiplexFrame.control_frame)
  if (_internal_has_control_frame()) {
    clear_has_Frame();
    ::location::nearby::mediums::MultiplexControlFrame* temp = Frame_.control_frame_;
    Frame_.control_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiplexFrame::unsafe_arena_set_allocated_control_frame(::location::nearby::mediums::MultiplexControlFrame* control_frame) {
  clear_Frame();
  if (control_frame) {
    set_has_control_frame();
    Frame_.control_frame_ = control_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.MultiplexFrame.control_frame)
}
inline ::location::nearby::mediums::MultiplexControlFrame* MultiplexFrame::_internal_mutable_control_frame() {
  if (!_internal_has_control_frame()) {
    clear_Frame();
    set_has_control_frame();
    Frame_.control_frame_ = CreateMaybeMessage< ::location::nearby::mediums::MultiplexControlFrame >(GetArenaForAllocation());
  }
  return Frame_.control_frame_;
}
inline ::location::nearby::mediums::MultiplexControlFrame* MultiplexFrame::mutable_control_frame() {
  ::location::nearby::mediums::MultiplexControlFrame* _msg = _internal_mutable_control_frame();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexFrame.control_frame)
  return _msg;
}

// .location.nearby.mediums.MultiplexDataFrame data_frame = 4;
inline bool MultiplexFrame::_internal_has_data_frame() const {
  return Frame_case() == kDataFrame;
}
inline bool MultiplexFrame::has_data_frame() const {
  return _internal_has_data_frame();
}
inline void MultiplexFrame::set_has_data_frame() {
  _oneof_case_[0] = kDataFrame;
}
inline void MultiplexFrame::clear_data_frame() {
  if (_internal_has_data_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.data_frame_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::MultiplexDataFrame* MultiplexFrame::release_data_frame() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexFrame.data_frame)
  if (_internal_has_data_frame()) {
    clear_has_Frame();
      ::location::nearby::mediums::MultiplexDataFrame* temp = Frame_.data_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.data_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::MultiplexDataFrame& MultiplexFrame::_internal_data_frame() const {
  return _internal_has_data_frame()
      ? *Frame_.data_frame_
      : reinterpret_cast< ::location::nearby::mediums::MultiplexDataFrame&>(::location::nearby::mediums::_MultiplexDataFrame_default_instance_);
}
inline const ::location::nearby::mediums::MultiplexDataFrame& MultiplexFrame::data_frame() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexFrame.data_frame)
  return _internal_data_frame();
}
inline ::location::nearby::mediums::MultiplexDataFrame* MultiplexFrame::unsafe_arena_release_data_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.MultiplexFrame.data_frame)
  if (_internal_has_data_frame()) {
    clear_has_Frame();
    ::location::nearby::mediums::MultiplexDataFrame* temp = Frame_.data_frame_;
    Frame_.data_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiplexFrame::unsafe_arena_set_allocated_data_frame(::location::nearby::mediums::MultiplexDataFrame* data_frame) {
  clear_Frame();
  if (data_frame) {
    set_has_data_frame();
    Frame_.data_frame_ = data_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.MultiplexFrame.data_frame)
}
inline ::location::nearby::mediums::MultiplexDataFrame* MultiplexFrame::_internal_mutable_data_frame() {
  if (!_internal_has_data_frame()) {
    clear_Frame();
    set_has_data_frame();
    Frame_.data_frame_ = CreateMaybeMessage< ::location::nearby::mediums::MultiplexDataFrame >(GetArenaForAllocation());
  }
  return Frame_.data_frame_;
}
inline ::location::nearby::mediums::MultiplexDataFrame* MultiplexFrame::mutable_data_frame() {
  ::location::nearby::mediums::MultiplexDataFrame* _msg = _internal_mutable_data_frame();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexFrame.data_frame)
  return _msg;
}

inline bool MultiplexFrame::has_Frame() const {
  return Frame_case() != FRAME_NOT_SET;
}
inline void MultiplexFrame::clear_has_Frame() {
  _oneof_case_[0] = FRAME_NOT_SET;
}
inline MultiplexFrame::FrameCase MultiplexFrame::Frame_case() const {
  return MultiplexFrame::FrameCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MultiplexFrameHeader

// optional bytes salted_service_id_hash = 1;
inline bool MultiplexFrameHeader::_internal_has_salted_service_id_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MultiplexFrameHeader::has_salted_service_id_hash() const {
  return _internal_has_salted_service_id_hash();
}
inline void MultiplexFrameHeader::clear_salted_service_id_hash() {
  salted_service_id_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MultiplexFrameHeader::salted_service_id_hash() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexFrameHeader.salted_service_id_hash)
  return _internal_salted_service_id_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiplexFrameHeader::set_salted_service_id_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 salted_service_id_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.mediums.MultiplexFrameHeader.salted_service_id_hash)
}
inline std::string* MultiplexFrameHeader::mutable_salted_service_id_hash() {
  std::string* _s = _internal_mutable_salted_service_id_hash();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexFrameHeader.salted_service_id_hash)
  return _s;
}
inline const std::string& MultiplexFrameHeader::_internal_salted_service_id_hash() const {
  return salted_service_id_hash_.Get();
}
inline void MultiplexFrameHeader::_internal_set_salted_service_id_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  salted_service_id_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiplexFrameHeader::_internal_mutable_salted_service_id_hash() {
  _has_bits_[0] |= 0x00000001u;
  return salted_service_id_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiplexFrameHeader::release_salted_service_id_hash() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexFrameHeader.salted_service_id_hash)
  if (!_internal_has_salted_service_id_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = salted_service_id_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (salted_service_id_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    salted_service_id_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MultiplexFrameHeader::set_allocated_salted_service_id_hash(std::string* salted_service_id_hash) {
  if (salted_service_id_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  salted_service_id_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), salted_service_id_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (salted_service_id_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    salted_service_id_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.MultiplexFrameHeader.salted_service_id_hash)
}

// optional string service_id_hash_salt = 2;
inline bool MultiplexFrameHeader::_internal_has_service_id_hash_salt() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MultiplexFrameHeader::has_service_id_hash_salt() const {
  return _internal_has_service_id_hash_salt();
}
inline void MultiplexFrameHeader::clear_service_id_hash_salt() {
  service_id_hash_salt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MultiplexFrameHeader::service_id_hash_salt() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexFrameHeader.service_id_hash_salt)
  return _internal_service_id_hash_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiplexFrameHeader::set_service_id_hash_salt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 service_id_hash_salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.mediums.MultiplexFrameHeader.service_id_hash_salt)
}
inline std::string* MultiplexFrameHeader::mutable_service_id_hash_salt() {
  std::string* _s = _internal_mutable_service_id_hash_salt();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexFrameHeader.service_id_hash_salt)
  return _s;
}
inline const std::string& MultiplexFrameHeader::_internal_service_id_hash_salt() const {
  return service_id_hash_salt_.Get();
}
inline void MultiplexFrameHeader::_internal_set_service_id_hash_salt(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  service_id_hash_salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiplexFrameHeader::_internal_mutable_service_id_hash_salt() {
  _has_bits_[0] |= 0x00000002u;
  return service_id_hash_salt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiplexFrameHeader::release_service_id_hash_salt() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexFrameHeader.service_id_hash_salt)
  if (!_internal_has_service_id_hash_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = service_id_hash_salt_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_id_hash_salt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_id_hash_salt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MultiplexFrameHeader::set_allocated_service_id_hash_salt(std::string* service_id_hash_salt) {
  if (service_id_hash_salt != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  service_id_hash_salt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_id_hash_salt,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_id_hash_salt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_id_hash_salt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.MultiplexFrameHeader.service_id_hash_salt)
}

// -------------------------------------------------------------------

// MultiplexControlFrame

// optional .location.nearby.mediums.MultiplexControlFrame.MultiplexControlFrameType control_frame_type = 1;
inline bool MultiplexControlFrame::_internal_has_control_frame_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MultiplexControlFrame::has_control_frame_type() const {
  return _internal_has_control_frame_type();
}
inline void MultiplexControlFrame::clear_control_frame_type() {
  control_frame_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType MultiplexControlFrame::_internal_control_frame_type() const {
  return static_cast< ::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType >(control_frame_type_);
}
inline ::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType MultiplexControlFrame::control_frame_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexControlFrame.control_frame_type)
  return _internal_control_frame_type();
}
inline void MultiplexControlFrame::_internal_set_control_frame_type(::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType value) {
  assert(::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  control_frame_type_ = value;
}
inline void MultiplexControlFrame::set_control_frame_type(::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType value) {
  _internal_set_control_frame_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.mediums.MultiplexControlFrame.control_frame_type)
}

// .location.nearby.mediums.ConnectionRequestFrame connection_request_frame = 2;
inline bool MultiplexControlFrame::_internal_has_connection_request_frame() const {
  return Frame_case() == kConnectionRequestFrame;
}
inline bool MultiplexControlFrame::has_connection_request_frame() const {
  return _internal_has_connection_request_frame();
}
inline void MultiplexControlFrame::set_has_connection_request_frame() {
  _oneof_case_[0] = kConnectionRequestFrame;
}
inline void MultiplexControlFrame::clear_connection_request_frame() {
  if (_internal_has_connection_request_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.connection_request_frame_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::ConnectionRequestFrame* MultiplexControlFrame::release_connection_request_frame() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexControlFrame.connection_request_frame)
  if (_internal_has_connection_request_frame()) {
    clear_has_Frame();
      ::location::nearby::mediums::ConnectionRequestFrame* temp = Frame_.connection_request_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.connection_request_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::ConnectionRequestFrame& MultiplexControlFrame::_internal_connection_request_frame() const {
  return _internal_has_connection_request_frame()
      ? *Frame_.connection_request_frame_
      : reinterpret_cast< ::location::nearby::mediums::ConnectionRequestFrame&>(::location::nearby::mediums::_ConnectionRequestFrame_default_instance_);
}
inline const ::location::nearby::mediums::ConnectionRequestFrame& MultiplexControlFrame::connection_request_frame() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexControlFrame.connection_request_frame)
  return _internal_connection_request_frame();
}
inline ::location::nearby::mediums::ConnectionRequestFrame* MultiplexControlFrame::unsafe_arena_release_connection_request_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.MultiplexControlFrame.connection_request_frame)
  if (_internal_has_connection_request_frame()) {
    clear_has_Frame();
    ::location::nearby::mediums::ConnectionRequestFrame* temp = Frame_.connection_request_frame_;
    Frame_.connection_request_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiplexControlFrame::unsafe_arena_set_allocated_connection_request_frame(::location::nearby::mediums::ConnectionRequestFrame* connection_request_frame) {
  clear_Frame();
  if (connection_request_frame) {
    set_has_connection_request_frame();
    Frame_.connection_request_frame_ = connection_request_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.MultiplexControlFrame.connection_request_frame)
}
inline ::location::nearby::mediums::ConnectionRequestFrame* MultiplexControlFrame::_internal_mutable_connection_request_frame() {
  if (!_internal_has_connection_request_frame()) {
    clear_Frame();
    set_has_connection_request_frame();
    Frame_.connection_request_frame_ = CreateMaybeMessage< ::location::nearby::mediums::ConnectionRequestFrame >(GetArenaForAllocation());
  }
  return Frame_.connection_request_frame_;
}
inline ::location::nearby::mediums::ConnectionRequestFrame* MultiplexControlFrame::mutable_connection_request_frame() {
  ::location::nearby::mediums::ConnectionRequestFrame* _msg = _internal_mutable_connection_request_frame();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexControlFrame.connection_request_frame)
  return _msg;
}

// .location.nearby.mediums.ConnectionResponseFrame connection_response_frame = 3;
inline bool MultiplexControlFrame::_internal_has_connection_response_frame() const {
  return Frame_case() == kConnectionResponseFrame;
}
inline bool MultiplexControlFrame::has_connection_response_frame() const {
  return _internal_has_connection_response_frame();
}
inline void MultiplexControlFrame::set_has_connection_response_frame() {
  _oneof_case_[0] = kConnectionResponseFrame;
}
inline void MultiplexControlFrame::clear_connection_response_frame() {
  if (_internal_has_connection_response_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.connection_response_frame_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::ConnectionResponseFrame* MultiplexControlFrame::release_connection_response_frame() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexControlFrame.connection_response_frame)
  if (_internal_has_connection_response_frame()) {
    clear_has_Frame();
      ::location::nearby::mediums::ConnectionResponseFrame* temp = Frame_.connection_response_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.connection_response_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::ConnectionResponseFrame& MultiplexControlFrame::_internal_connection_response_frame() const {
  return _internal_has_connection_response_frame()
      ? *Frame_.connection_response_frame_
      : reinterpret_cast< ::location::nearby::mediums::ConnectionResponseFrame&>(::location::nearby::mediums::_ConnectionResponseFrame_default_instance_);
}
inline const ::location::nearby::mediums::ConnectionResponseFrame& MultiplexControlFrame::connection_response_frame() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexControlFrame.connection_response_frame)
  return _internal_connection_response_frame();
}
inline ::location::nearby::mediums::ConnectionResponseFrame* MultiplexControlFrame::unsafe_arena_release_connection_response_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.MultiplexControlFrame.connection_response_frame)
  if (_internal_has_connection_response_frame()) {
    clear_has_Frame();
    ::location::nearby::mediums::ConnectionResponseFrame* temp = Frame_.connection_response_frame_;
    Frame_.connection_response_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiplexControlFrame::unsafe_arena_set_allocated_connection_response_frame(::location::nearby::mediums::ConnectionResponseFrame* connection_response_frame) {
  clear_Frame();
  if (connection_response_frame) {
    set_has_connection_response_frame();
    Frame_.connection_response_frame_ = connection_response_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.MultiplexControlFrame.connection_response_frame)
}
inline ::location::nearby::mediums::ConnectionResponseFrame* MultiplexControlFrame::_internal_mutable_connection_response_frame() {
  if (!_internal_has_connection_response_frame()) {
    clear_Frame();
    set_has_connection_response_frame();
    Frame_.connection_response_frame_ = CreateMaybeMessage< ::location::nearby::mediums::ConnectionResponseFrame >(GetArenaForAllocation());
  }
  return Frame_.connection_response_frame_;
}
inline ::location::nearby::mediums::ConnectionResponseFrame* MultiplexControlFrame::mutable_connection_response_frame() {
  ::location::nearby::mediums::ConnectionResponseFrame* _msg = _internal_mutable_connection_response_frame();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexControlFrame.connection_response_frame)
  return _msg;
}

// .location.nearby.mediums.DisconnectFrame disconnect_frame = 4;
inline bool MultiplexControlFrame::_internal_has_disconnect_frame() const {
  return Frame_case() == kDisconnectFrame;
}
inline bool MultiplexControlFrame::has_disconnect_frame() const {
  return _internal_has_disconnect_frame();
}
inline void MultiplexControlFrame::set_has_disconnect_frame() {
  _oneof_case_[0] = kDisconnectFrame;
}
inline void MultiplexControlFrame::clear_disconnect_frame() {
  if (_internal_has_disconnect_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.disconnect_frame_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::DisconnectFrame* MultiplexControlFrame::release_disconnect_frame() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexControlFrame.disconnect_frame)
  if (_internal_has_disconnect_frame()) {
    clear_has_Frame();
      ::location::nearby::mediums::DisconnectFrame* temp = Frame_.disconnect_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.disconnect_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::DisconnectFrame& MultiplexControlFrame::_internal_disconnect_frame() const {
  return _internal_has_disconnect_frame()
      ? *Frame_.disconnect_frame_
      : reinterpret_cast< ::location::nearby::mediums::DisconnectFrame&>(::location::nearby::mediums::_DisconnectFrame_default_instance_);
}
inline const ::location::nearby::mediums::DisconnectFrame& MultiplexControlFrame::disconnect_frame() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexControlFrame.disconnect_frame)
  return _internal_disconnect_frame();
}
inline ::location::nearby::mediums::DisconnectFrame* MultiplexControlFrame::unsafe_arena_release_disconnect_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.MultiplexControlFrame.disconnect_frame)
  if (_internal_has_disconnect_frame()) {
    clear_has_Frame();
    ::location::nearby::mediums::DisconnectFrame* temp = Frame_.disconnect_frame_;
    Frame_.disconnect_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiplexControlFrame::unsafe_arena_set_allocated_disconnect_frame(::location::nearby::mediums::DisconnectFrame* disconnect_frame) {
  clear_Frame();
  if (disconnect_frame) {
    set_has_disconnect_frame();
    Frame_.disconnect_frame_ = disconnect_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.MultiplexControlFrame.disconnect_frame)
}
inline ::location::nearby::mediums::DisconnectFrame* MultiplexControlFrame::_internal_mutable_disconnect_frame() {
  if (!_internal_has_disconnect_frame()) {
    clear_Frame();
    set_has_disconnect_frame();
    Frame_.disconnect_frame_ = CreateMaybeMessage< ::location::nearby::mediums::DisconnectFrame >(GetArenaForAllocation());
  }
  return Frame_.disconnect_frame_;
}
inline ::location::nearby::mediums::DisconnectFrame* MultiplexControlFrame::mutable_disconnect_frame() {
  ::location::nearby::mediums::DisconnectFrame* _msg = _internal_mutable_disconnect_frame();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexControlFrame.disconnect_frame)
  return _msg;
}

inline bool MultiplexControlFrame::has_Frame() const {
  return Frame_case() != FRAME_NOT_SET;
}
inline void MultiplexControlFrame::clear_has_Frame() {
  _oneof_case_[0] = FRAME_NOT_SET;
}
inline MultiplexControlFrame::FrameCase MultiplexControlFrame::Frame_case() const {
  return MultiplexControlFrame::FrameCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConnectionRequestFrame

// -------------------------------------------------------------------

// ConnectionResponseFrame

// optional .location.nearby.mediums.ConnectionResponseFrame.ConnectionResponseCode connection_response_code = 1;
inline bool ConnectionResponseFrame::_internal_has_connection_response_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectionResponseFrame::has_connection_response_code() const {
  return _internal_has_connection_response_code();
}
inline void ConnectionResponseFrame::clear_connection_response_code() {
  connection_response_code_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode ConnectionResponseFrame::_internal_connection_response_code() const {
  return static_cast< ::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode >(connection_response_code_);
}
inline ::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode ConnectionResponseFrame::connection_response_code() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.ConnectionResponseFrame.connection_response_code)
  return _internal_connection_response_code();
}
inline void ConnectionResponseFrame::_internal_set_connection_response_code(::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode value) {
  assert(::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  connection_response_code_ = value;
}
inline void ConnectionResponseFrame::set_connection_response_code(::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode value) {
  _internal_set_connection_response_code(value);
  // @@protoc_insertion_point(field_set:location.nearby.mediums.ConnectionResponseFrame.connection_response_code)
}

// -------------------------------------------------------------------

// DisconnectFrame

// -------------------------------------------------------------------

// MultiplexDataFrame

// optional bytes data = 1;
inline bool MultiplexDataFrame::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MultiplexDataFrame::has_data() const {
  return _internal_has_data();
}
inline void MultiplexDataFrame::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MultiplexDataFrame::data() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.MultiplexDataFrame.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiplexDataFrame::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.mediums.MultiplexDataFrame.data)
}
inline std::string* MultiplexDataFrame::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.MultiplexDataFrame.data)
  return _s;
}
inline const std::string& MultiplexDataFrame::_internal_data() const {
  return data_.Get();
}
inline void MultiplexDataFrame::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiplexDataFrame::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiplexDataFrame::release_data() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.MultiplexDataFrame.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MultiplexDataFrame::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.MultiplexDataFrame.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mediums
}  // namespace nearby
}  // namespace location

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::location::nearby::mediums::MultiplexFrame_MultiplexFrameType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::mediums::MultiplexControlFrame_MultiplexControlFrameType> : ::std::true_type {};
template <> struct is_proto_enum< ::location::nearby::mediums::ConnectionResponseFrame_ConnectionResponseCode> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fmediums_2fmultiplex_5fframes_2eproto
