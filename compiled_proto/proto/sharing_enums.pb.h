// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: proto/sharing_enums.proto
// Protobuf C++ Version: 6.33.3

#ifndef proto_2fsharing_5fenums_2eproto_2epb_2eh
#define proto_2fsharing_5fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fsharing_5fenums_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fsharing_5fenums_2eproto {
  static const ::uint32_t offsets[];
};
namespace location {
namespace nearby {
namespace proto {
namespace sharing {
enum ActivityName : int;
extern const uint32_t ActivityName_internal_data_[];
enum AdvertisingMode : int;
extern const uint32_t AdvertisingMode_internal_data_[];
enum ApkSource : int;
extern const uint32_t ApkSource_internal_data_[];
enum AppCrashReason : int;
extern const uint32_t AppCrashReason_internal_data_[];
enum AttachmentSourceType : int;
extern const uint32_t AttachmentSourceType_internal_data_[];
enum AttachmentTransmissionStatus : int;
extern const uint32_t AttachmentTransmissionStatus_internal_data_[];
enum ButtonStatus : int;
extern const uint32_t ButtonStatus_internal_data_[];
enum ClientRole : int;
extern const uint32_t ClientRole_internal_data_[];
enum CloudActionType : int;
extern const uint32_t CloudActionType_internal_data_[];
enum CloudCreateSharingResult : int;
extern const uint32_t CloudCreateSharingResult_internal_data_[];
enum CloudRegisterReceiverResult : int;
extern const uint32_t CloudRegisterReceiverResult_internal_data_[];
enum ConnectionLayerStatus : int;
extern const uint32_t ConnectionLayerStatus_internal_data_[];
enum ConsentAcceptanceStatus : int;
extern const uint32_t ConsentAcceptanceStatus_internal_data_[];
enum ConsentType : int;
extern const uint32_t ConsentType_internal_data_[];
enum ContactAccess : int;
extern const uint32_t ContactAccess_internal_data_[];
enum DataUsage : int;
extern const uint32_t DataUsage_internal_data_[];
enum DecryptCertificateFailureStatus : int;
extern const uint32_t DecryptCertificateFailureStatus_internal_data_[];
enum DesktopNotification : int;
extern const uint32_t DesktopNotification_internal_data_[];
enum DesktopTransferEventType : int;
extern const uint32_t DesktopTransferEventType_internal_data_[];
enum DeviceRelationship : int;
extern const uint32_t DeviceRelationship_internal_data_[];
enum DeviceType : int;
extern const uint32_t DeviceType_internal_data_[];
enum DiscoveryMode : int;
extern const uint32_t DiscoveryMode_internal_data_[];
enum EstablishConnectionStatus : int;
extern const uint32_t EstablishConnectionStatus_internal_data_[];
enum EventCategory : int;
extern const uint32_t EventCategory_internal_data_[];
enum EventType : int;
extern const uint32_t EventType_internal_data_[];
enum FastInitState : int;
extern const uint32_t FastInitState_internal_data_[];
enum FastInitType : int;
extern const uint32_t FastInitType_internal_data_[];
enum IdentityVerification : int;
extern const uint32_t IdentityVerification_internal_data_[];
enum InstallAPKStatus : int;
extern const uint32_t InstallAPKStatus_internal_data_[];
enum LogSource : int;
extern const uint32_t LogSource_internal_data_[];
enum NearbySharingStatus : int;
extern const uint32_t NearbySharingStatus_internal_data_[];
enum OSType : int;
extern const uint32_t OSType_internal_data_[];
enum ParsingFailedType : int;
extern const uint32_t ParsingFailedType_internal_data_[];
enum PermissionRequestResult : int;
extern const uint32_t PermissionRequestResult_internal_data_[];
enum PermissionRequestType : int;
extern const uint32_t PermissionRequestType_internal_data_[];
enum PreferencesAction : int;
extern const uint32_t PreferencesAction_internal_data_[];
enum PreferencesActionStatus : int;
extern const uint32_t PreferencesActionStatus_internal_data_[];
enum ProcessReceivedAttachmentsStatus : int;
extern const uint32_t ProcessReceivedAttachmentsStatus_internal_data_[];
enum ResponseToIntroduction : int;
extern const uint32_t ResponseToIntroduction_internal_data_[];
enum ScanType : int;
extern const uint32_t ScanType_internal_data_[];
enum ServerActionName : int;
extern const uint32_t ServerActionName_internal_data_[];
enum ServerResponseState : int;
extern const uint32_t ServerResponseState_internal_data_[];
enum SessionStatus : int;
extern const uint32_t SessionStatus_internal_data_[];
enum SharingUseCase : int;
extern const uint32_t SharingUseCase_internal_data_[];
enum ShowNotificationStatus : int;
extern const uint32_t ShowNotificationStatus_internal_data_[];
enum SyncPurpose : int;
extern const uint32_t SyncPurpose_internal_data_[];
enum VerifyAPKStatus : int;
extern const uint32_t VerifyAPKStatus_internal_data_[];
enum Visibility : int;
extern const uint32_t Visibility_internal_data_[];
}  // namespace sharing
}  // namespace proto
}  // namespace nearby
}  // namespace location
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ActivityName_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ActivityName>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::AdvertisingMode_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::AdvertisingMode>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ApkSource_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ApkSource>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::AppCrashReason_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::AppCrashReason>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::AttachmentSourceType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::AttachmentSourceType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::AttachmentTransmissionStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::AttachmentTransmissionStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ButtonStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ButtonStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ClientRole_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ClientRole>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::CloudActionType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::CloudActionType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::CloudCreateSharingResult_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::CloudCreateSharingResult>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::CloudRegisterReceiverResult_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::CloudRegisterReceiverResult>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ConnectionLayerStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ConnectionLayerStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ConsentAcceptanceStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ConsentAcceptanceStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ConsentType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ConsentType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ContactAccess_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ContactAccess>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::DataUsage_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::DataUsage>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::DecryptCertificateFailureStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::DecryptCertificateFailureStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::DesktopNotification_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::DesktopNotification>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::DesktopTransferEventType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::DesktopTransferEventType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::DeviceRelationship_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::DeviceRelationship>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::DeviceType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::DeviceType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::DiscoveryMode_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::DiscoveryMode>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::EstablishConnectionStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::EstablishConnectionStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::EventCategory_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::EventCategory>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::EventType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::EventType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::FastInitState_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::FastInitState>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::FastInitType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::FastInitType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::IdentityVerification_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::IdentityVerification>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::InstallAPKStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::InstallAPKStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::LogSource_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::LogSource>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::NearbySharingStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::NearbySharingStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::OSType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::OSType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ParsingFailedType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ParsingFailedType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::PermissionRequestResult_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::PermissionRequestResult>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::PermissionRequestType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::PermissionRequestType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::PreferencesAction_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::PreferencesAction>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::PreferencesActionStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::PreferencesActionStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ProcessReceivedAttachmentsStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ProcessReceivedAttachmentsStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ResponseToIntroduction_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ResponseToIntroduction>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ScanType_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ScanType>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ServerActionName_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ServerActionName>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ServerResponseState_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ServerResponseState>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::SessionStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::SessionStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::SharingUseCase_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::SharingUseCase>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::ShowNotificationStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::ShowNotificationStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::SyncPurpose_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::SyncPurpose>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::VerifyAPKStatus_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::VerifyAPKStatus>;
template <>
internal::EnumTraitsT<::location::nearby::proto::sharing::Visibility_internal_data_>
    internal::EnumTraitsImpl::value<::location::nearby::proto::sharing::Visibility>;
}  // namespace protobuf
}  // namespace google

namespace location {
namespace nearby {
namespace proto {
namespace sharing {
enum EventType : int {
  UNKNOWN_EVENT_TYPE = 0,
  ACCEPT_AGREEMENTS = 1,
  ENABLE_NEARBY_SHARING = 2,
  SET_VISIBILITY = 3,
  DESCRIBE_ATTACHMENTS = 4,
  SCAN_FOR_SHARE_TARGETS_START = 5,
  SCAN_FOR_SHARE_TARGETS_END = 6,
  ADVERTISE_DEVICE_PRESENCE_START = 7,
  ADVERTISE_DEVICE_PRESENCE_END = 8,
  SEND_FAST_INITIALIZATION = 9,
  RECEIVE_FAST_INITIALIZATION = 10,
  DISCOVER_SHARE_TARGET = 11,
  SEND_INTRODUCTION = 12,
  RECEIVE_INTRODUCTION = 13,
  RESPOND_TO_INTRODUCTION = 14,
  SEND_ATTACHMENTS_START = 15,
  SEND_ATTACHMENTS_END = 16,
  RECEIVE_ATTACHMENTS_START = 17,
  RECEIVE_ATTACHMENTS_END = 18,
  CANCEL_SENDING_ATTACHMENTS = 19,
  CANCEL_RECEIVING_ATTACHMENTS = 20,
  OPEN_RECEIVED_ATTACHMENTS = 21,
  LAUNCH_SETUP_ACTIVITY [[deprecated]] = 22,
  ADD_CONTACT = 23,
  REMOVE_CONTACT = 24,
  FAST_SHARE_SERVER_RESPONSE = 25,
  SEND_START = 26,
  ACCEPT_FAST_INITIALIZATION = 27,
  SET_DATA_USAGE = 28,
  DISMISS_FAST_INITIALIZATION = 29,
  CANCEL_CONNECTION = 30,
  LAUNCH_ACTIVITY = 31,
  DISMISS_PRIVACY_NOTIFICATION = 32,
  TAP_PRIVACY_NOTIFICATION = 33,
  TAP_HELP = 34,
  TAP_FEEDBACK = 35,
  ADD_QUICK_SETTINGS_TILE = 36,
  REMOVE_QUICK_SETTINGS_TILE = 37,
  LAUNCH_PHONE_CONSENT = 38,
  DISPLAY_PHONE_CONSENT = 54,
  TAP_QUICK_SETTINGS_TILE = 39,
  INSTALL_APK = 40,
  VERIFY_APK = 41,
  LAUNCH_CONSENT = 42,
  PROCESS_RECEIVED_ATTACHMENTS_END = 43,
  TOGGLE_SHOW_NOTIFICATION = 44,
  SET_DEVICE_NAME = 45,
  DECLINE_AGREEMENTS = 46,
  REQUEST_SETTING_PERMISSIONS = 47,
  ESTABLISH_CONNECTION = 48,
  DEVICE_SETTINGS = 49,
  AUTO_DISMISS_FAST_INITIALIZATION = 50,
  APP_CRASH = 51,
  TAP_QUICK_SETTINGS_FILE_SHARE = 52,
  DISPLAY_PRIVACY_NOTIFICATION = 53,
  PREFERENCES_USAGE = 55,
  DEFAULT_OPT_IN = 56,
  SETUP_WIZARD = 57,
  TAP_QR_CODE = 58,
  QR_CODE_LINK_SHOWN = 59,
  PARSING_FAILED_ENDPOINT_ID = 60,
  FAST_INIT_DISCOVER_DEVICE = 61,
  SEND_DESKTOP_NOTIFICATION = 62,
  SET_ACCOUNT = 63,
  DECRYPT_CERTIFICATE_FAILURE = 64,
  SHOW_ALLOW_PERMISSION_AUTO_ACCESS = 65,
  SEND_DESKTOP_TRANSFER_EVENT = 66,
  WAITING_FOR_ACCEPT = 67,
  HIGH_QUALITY_MEDIUM_SETUP = 68,
  RPC_CALL_STATUS = 69,
  START_QR_CODE_SESSION = 70,
  QR_CODE_OPENED_IN_WEB_CLIENT = 71,
  HATS_JOINT_EVENT = 72,
  RECEIVE_PREVIEWS = 73,
  CLOUD_CREATE_SHARING_REQUEST = 74,
  CLOUD_REGISTER_RECEIVER = 75,
  CLOUD_UPLOAD_START = 76,
  CLOUD_UPLOAD_END = 77,
  CLOUD_DOWNLOAD_START = 78,
  CLOUD_DOWNLOAD_END = 79,
  CLOUD_SHARING_RPC_RESULT = 80,
};

extern const uint32_t EventType_internal_data_[];
inline constexpr EventType EventType_MIN =
    static_cast<EventType>(0);
inline constexpr EventType EventType_MAX =
    static_cast<EventType>(80);
inline bool EventType_IsValid(int value) {
  return 0 <= value && value <= 80;
}
inline constexpr int EventType_ARRAYSIZE = 80 + 1;
const ::std::string& EventType_Name(EventType value);
template <typename T>
const ::std::string& EventType_Name(T value) {
  static_assert(::std::is_same<T, EventType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
bool EventType_Parse(
    ::absl::string_view name, EventType* PROTOBUF_NONNULL value);
enum EventCategory : int {
  UNKNOWN_EVENT_CATEGORY = 0,
  SENDING_EVENT = 1,
  RECEIVING_EVENT = 2,
  SETTINGS_EVENT = 3,
  RPC_EVENT = 4,
};

extern const uint32_t EventCategory_internal_data_[];
inline constexpr EventCategory EventCategory_MIN =
    static_cast<EventCategory>(0);
inline constexpr EventCategory EventCategory_MAX =
    static_cast<EventCategory>(4);
inline bool EventCategory_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int EventCategory_ARRAYSIZE = 4 + 1;
const ::std::string& EventCategory_Name(EventCategory value);
template <typename T>
const ::std::string& EventCategory_Name(T value) {
  static_assert(::std::is_same<T, EventCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EventCategory_Name().");
  return EventCategory_Name(static_cast<EventCategory>(value));
}
bool EventCategory_Parse(
    ::absl::string_view name, EventCategory* PROTOBUF_NONNULL value);
enum NearbySharingStatus : int {
  UNKNOWN_NEARBY_SHARING_STATUS = 0,
  ON = 1,
  OFF = 2,
};

extern const uint32_t NearbySharingStatus_internal_data_[];
inline constexpr NearbySharingStatus NearbySharingStatus_MIN =
    static_cast<NearbySharingStatus>(0);
inline constexpr NearbySharingStatus NearbySharingStatus_MAX =
    static_cast<NearbySharingStatus>(2);
inline bool NearbySharingStatus_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int NearbySharingStatus_ARRAYSIZE = 2 + 1;
const ::std::string& NearbySharingStatus_Name(NearbySharingStatus value);
template <typename T>
const ::std::string& NearbySharingStatus_Name(T value) {
  static_assert(::std::is_same<T, NearbySharingStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to NearbySharingStatus_Name().");
  return NearbySharingStatus_Name(static_cast<NearbySharingStatus>(value));
}
bool NearbySharingStatus_Parse(
    ::absl::string_view name, NearbySharingStatus* PROTOBUF_NONNULL value);
enum Visibility : int {
  UNKNOWN_VISIBILITY = 0,
  CONTACTS_ONLY = 1,
  EVERYONE = 2,
  SELECTED_CONTACTS_ONLY [[deprecated]] = 3,
  HIDDEN = 4,
  SELF_SHARE = 5,
};

extern const uint32_t Visibility_internal_data_[];
inline constexpr Visibility Visibility_MIN =
    static_cast<Visibility>(0);
inline constexpr Visibility Visibility_MAX =
    static_cast<Visibility>(5);
inline bool Visibility_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int Visibility_ARRAYSIZE = 5 + 1;
const ::std::string& Visibility_Name(Visibility value);
template <typename T>
const ::std::string& Visibility_Name(T value) {
  static_assert(::std::is_same<T, Visibility>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Visibility_Name().");
  return Visibility_Name(static_cast<Visibility>(value));
}
bool Visibility_Parse(
    ::absl::string_view name, Visibility* PROTOBUF_NONNULL value);
enum DataUsage : int {
  UNKNOWN_DATA_USAGE = 0,
  ONLINE = 1,
  WIFI_ONLY = 2,
  OFFLINE = 3,
};

extern const uint32_t DataUsage_internal_data_[];
inline constexpr DataUsage DataUsage_MIN =
    static_cast<DataUsage>(0);
inline constexpr DataUsage DataUsage_MAX =
    static_cast<DataUsage>(3);
inline bool DataUsage_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DataUsage_ARRAYSIZE = 3 + 1;
const ::std::string& DataUsage_Name(DataUsage value);
template <typename T>
const ::std::string& DataUsage_Name(T value) {
  static_assert(::std::is_same<T, DataUsage>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DataUsage_Name().");
  return DataUsage_Name(static_cast<DataUsage>(value));
}
bool DataUsage_Parse(
    ::absl::string_view name, DataUsage* PROTOBUF_NONNULL value);
enum EstablishConnectionStatus : int {
  CONNECTION_STATUS_UNKNOWN = 0,
  CONNECTION_STATUS_SUCCESS = 1,
  CONNECTION_STATUS_FAILURE = 2,
  CONNECTION_STATUS_CANCELLATION = 3,
  CONNECTION_STATUS_MEDIA_UNAVAILABLE_ATTACHMENT = 4,
  CONNECTION_STATUS_FAILED_PAIRED_KEYHANDSHAKE = 5,
  CONNECTION_STATUS_FAILED_WRITE_INTRODUCTION = 6,
  CONNECTION_STATUS_FAILED_NULL_CONNECTION = 7,
  CONNECTION_STATUS_FAILED_NO_TRANSFER_UPDATE_CALLBACK = 8,
  CONNECTION_STATUS_LOST_CONNECTIVITY = 9,
  CONNECTION_STATUS_INVALID_ADVERTISEMENT = 10,
};

extern const uint32_t EstablishConnectionStatus_internal_data_[];
inline constexpr EstablishConnectionStatus EstablishConnectionStatus_MIN =
    static_cast<EstablishConnectionStatus>(0);
inline constexpr EstablishConnectionStatus EstablishConnectionStatus_MAX =
    static_cast<EstablishConnectionStatus>(10);
inline bool EstablishConnectionStatus_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int EstablishConnectionStatus_ARRAYSIZE = 10 + 1;
const ::std::string& EstablishConnectionStatus_Name(EstablishConnectionStatus value);
template <typename T>
const ::std::string& EstablishConnectionStatus_Name(T value) {
  static_assert(::std::is_same<T, EstablishConnectionStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EstablishConnectionStatus_Name().");
  return EstablishConnectionStatus_Name(static_cast<EstablishConnectionStatus>(value));
}
bool EstablishConnectionStatus_Parse(
    ::absl::string_view name, EstablishConnectionStatus* PROTOBUF_NONNULL value);
enum AttachmentTransmissionStatus : int {
  UNKNOWN_ATTACHMENT_TRANSMISSION_STATUS = 0,
  COMPLETE_ATTACHMENT_TRANSMISSION_STATUS = 1,
  CANCELED_ATTACHMENT_TRANSMISSION_STATUS = 2,
  FAILED_ATTACHMENT_TRANSMISSION_STATUS = 3,
  REJECTED_ATTACHMENT [[deprecated]] = 4,
  TIMED_OUT_ATTACHMENT [[deprecated]] = 5,
  AWAITING_REMOTE_ACCEPTANCE_FAILED_ATTACHMENT [[deprecated]] = 6,
  NOT_ENOUGH_SPACE_ATTACHMENT [[deprecated]] = 7,
  FAILED_NO_TRANSFER_UPDATE_CALLBACK [[deprecated]] = 8,
  MEDIA_UNAVAILABLE_ATTACHMENT [[deprecated]] = 9,
  UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT [[deprecated]] = 10,
  NO_ATTACHMENT_FOUND [[deprecated]] = 11,
  FAILED_NO_SHARE_TARGET_ENDPOINT [[deprecated]] = 12,
  FAILED_PAIRED_KEYHANDSHAKE [[deprecated]] = 13,
  FAILED_NULL_CONNECTION [[deprecated]] = 14,
  FAILED_NO_PAYLOAD [[deprecated]] = 15,
  FAILED_WRITE_INTRODUCTION [[deprecated]] = 16,
  FAILED_UNKNOWN_REMOTE_RESPONSE [[deprecated]] = 17,
  FAILED_NULL_CONNECTION_INIT_OUTGOING = 18,
  FAILED_NULL_CONNECTION_DISCONNECTED = 19,
  FAILED_NULL_CONNECTION_LOST_CONNECTIVITY [[deprecated]] = 20,
  FAILED_NULL_CONNECTION_FAILURE [[deprecated]] = 21,
  REJECTED_ATTACHMENT_TRANSMISSION_STATUS = 22,
  TIMED_OUT_ATTACHMENT_TRANSMISSION_STATUS = 23,
  NOT_ENOUGH_SPACE_ATTACHMENT_TRANSMISSION_STATUS = 24,
  UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT_TRANSMISSION_STATUS = 25,
  FAILED_UNKNOWN_REMOTE_RESPONSE_TRANSMISSION_STATUS = 26,
  NO_RESPONSE_FRAME_CONNECTION_CLOSED_LOST_CONNECTIVITY_TRANSMISSION_STATUS [[deprecated]] = 27,
  NO_RESPONSE_FRAME_CONNECTION_CLOSED_TRANSMISSION_STATUS = 28,
  LOST_CONNECTIVITY_TRANSMISSION_STATUS = 29,
  FAILED_DISALLOWED_MEDIUM = 30,
};

extern const uint32_t AttachmentTransmissionStatus_internal_data_[];
inline constexpr AttachmentTransmissionStatus AttachmentTransmissionStatus_MIN =
    static_cast<AttachmentTransmissionStatus>(0);
inline constexpr AttachmentTransmissionStatus AttachmentTransmissionStatus_MAX =
    static_cast<AttachmentTransmissionStatus>(30);
inline bool AttachmentTransmissionStatus_IsValid(int value) {
  return 0 <= value && value <= 30;
}
inline constexpr int AttachmentTransmissionStatus_ARRAYSIZE = 30 + 1;
const ::std::string& AttachmentTransmissionStatus_Name(AttachmentTransmissionStatus value);
template <typename T>
const ::std::string& AttachmentTransmissionStatus_Name(T value) {
  static_assert(::std::is_same<T, AttachmentTransmissionStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AttachmentTransmissionStatus_Name().");
  return AttachmentTransmissionStatus_Name(static_cast<AttachmentTransmissionStatus>(value));
}
bool AttachmentTransmissionStatus_Parse(
    ::absl::string_view name, AttachmentTransmissionStatus* PROTOBUF_NONNULL value);
enum ConnectionLayerStatus : int {
  CONNECTION_LAYER_STATUS_UNKNOWN = 0,
  CONNECTION_LAYER_STATUS_SUCCESS = 1,
  CONNECTION_LAYER_STATUS_ERROR = 2,
  CONNECTION_LAYER_STATUS_OUT_OF_ORDER_API_CALL = 3,
  CONNECTION_LAYER_STATUS_ALREADY_HAVE_ACTIVE_STRATEGY = 4,
  CONNECTION_LAYER_STATUS_ALREADY_ADVERTISING = 5,
  CONNECTION_LAYER_STATUS_ALREADY_DISCOVERING = 6,
  CONNECTION_LAYER_STATUS_ALREADY_LISTENING = 7,
  CONNECTION_LAYER_STATUS_END_POINT_IO_ERROR = 8,
  CONNECTION_LAYER_STATUS_END_POINT_UNKNOWN = 9,
  CONNECTION_LAYER_STATUS_CONNECTION_REJECTED = 10,
  CONNECTION_LAYER_STATUS_ALREADY_CONNECTED_TO_END_POINT = 11,
  CONNECTION_LAYER_STATUS_NOT_CONNECTED_TO_END_POINT = 12,
  CONNECTION_LAYER_STATUS_BLUETOOTH_ERROR = 13,
  CONNECTION_LAYER_STATUS_BLE_ERROR = 14,
  CONNECTION_LAYER_STATUS_WIFI_LAN_ERROR = 15,
  CONNECTION_LAYER_STATUS_PAYLOAD_UNKNOWN = 16,
  CONNECTION_LAYER_STATUS_RESET = 17,
  CONNECTION_LAYER_STATUS_TIMEOUT = 18,
};

extern const uint32_t ConnectionLayerStatus_internal_data_[];
inline constexpr ConnectionLayerStatus ConnectionLayerStatus_MIN =
    static_cast<ConnectionLayerStatus>(0);
inline constexpr ConnectionLayerStatus ConnectionLayerStatus_MAX =
    static_cast<ConnectionLayerStatus>(18);
inline bool ConnectionLayerStatus_IsValid(int value) {
  return 0 <= value && value <= 18;
}
inline constexpr int ConnectionLayerStatus_ARRAYSIZE = 18 + 1;
const ::std::string& ConnectionLayerStatus_Name(ConnectionLayerStatus value);
template <typename T>
const ::std::string& ConnectionLayerStatus_Name(T value) {
  static_assert(::std::is_same<T, ConnectionLayerStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConnectionLayerStatus_Name().");
  return ConnectionLayerStatus_Name(static_cast<ConnectionLayerStatus>(value));
}
bool ConnectionLayerStatus_Parse(
    ::absl::string_view name, ConnectionLayerStatus* PROTOBUF_NONNULL value);
enum ProcessReceivedAttachmentsStatus : int {
  PROCESSING_STATUS_UNKNOWN = 0,
  PROCESSING_STATUS_COMPLETE_PROCESSING_ATTACHMENTS = 1,
  PROCESSING_STATUS_FAILED_MOVING_FILES = 2,
  PROCESSING_STATUS_FAILED_RECEIVING_APK = 3,
  PROCESSING_STATUS_FAILED_RECEIVING_TEXT = 4,
  PROCESSING_STATUS_FAILED_RECEIVING_WIFI_CREDENTIALS = 5,
};

extern const uint32_t ProcessReceivedAttachmentsStatus_internal_data_[];
inline constexpr ProcessReceivedAttachmentsStatus ProcessReceivedAttachmentsStatus_MIN =
    static_cast<ProcessReceivedAttachmentsStatus>(0);
inline constexpr ProcessReceivedAttachmentsStatus ProcessReceivedAttachmentsStatus_MAX =
    static_cast<ProcessReceivedAttachmentsStatus>(5);
inline bool ProcessReceivedAttachmentsStatus_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int ProcessReceivedAttachmentsStatus_ARRAYSIZE = 5 + 1;
const ::std::string& ProcessReceivedAttachmentsStatus_Name(ProcessReceivedAttachmentsStatus value);
template <typename T>
const ::std::string& ProcessReceivedAttachmentsStatus_Name(T value) {
  static_assert(::std::is_same<T, ProcessReceivedAttachmentsStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ProcessReceivedAttachmentsStatus_Name().");
  return ProcessReceivedAttachmentsStatus_Name(static_cast<ProcessReceivedAttachmentsStatus>(value));
}
bool ProcessReceivedAttachmentsStatus_Parse(
    ::absl::string_view name, ProcessReceivedAttachmentsStatus* PROTOBUF_NONNULL value);
enum SessionStatus : int {
  UNKNOWN_SESSION_STATUS = 0,
  SUCCEEDED_SESSION_STATUS = 1,
  FAILED_SESSION_STATUS = 2,
};

extern const uint32_t SessionStatus_internal_data_[];
inline constexpr SessionStatus SessionStatus_MIN =
    static_cast<SessionStatus>(0);
inline constexpr SessionStatus SessionStatus_MAX =
    static_cast<SessionStatus>(2);
inline bool SessionStatus_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int SessionStatus_ARRAYSIZE = 2 + 1;
const ::std::string& SessionStatus_Name(SessionStatus value);
template <typename T>
const ::std::string& SessionStatus_Name(T value) {
  static_assert(::std::is_same<T, SessionStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SessionStatus_Name().");
  return SessionStatus_Name(static_cast<SessionStatus>(value));
}
bool SessionStatus_Parse(
    ::absl::string_view name, SessionStatus* PROTOBUF_NONNULL value);
enum ResponseToIntroduction : int {
  UNKNOWN_RESPONSE_TO_INTRODUCTION = 0,
  ACCEPT_INTRODUCTION = 1,
  REJECT_INTRODUCTION = 2,
  FAIL_INTRODUCTION = 3,
};

extern const uint32_t ResponseToIntroduction_internal_data_[];
inline constexpr ResponseToIntroduction ResponseToIntroduction_MIN =
    static_cast<ResponseToIntroduction>(0);
inline constexpr ResponseToIntroduction ResponseToIntroduction_MAX =
    static_cast<ResponseToIntroduction>(3);
inline bool ResponseToIntroduction_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ResponseToIntroduction_ARRAYSIZE = 3 + 1;
const ::std::string& ResponseToIntroduction_Name(ResponseToIntroduction value);
template <typename T>
const ::std::string& ResponseToIntroduction_Name(T value) {
  static_assert(::std::is_same<T, ResponseToIntroduction>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ResponseToIntroduction_Name().");
  return ResponseToIntroduction_Name(static_cast<ResponseToIntroduction>(value));
}
bool ResponseToIntroduction_Parse(
    ::absl::string_view name, ResponseToIntroduction* PROTOBUF_NONNULL value);
enum DeviceType : int {
  UNKNOWN_DEVICE_TYPE = 0,
  PHONE = 1,
  TABLET = 2,
  LAPTOP = 3,
  CAR = 4,
  FOLDABLE = 5,
  XR = 6,
};

extern const uint32_t DeviceType_internal_data_[];
inline constexpr DeviceType DeviceType_MIN =
    static_cast<DeviceType>(0);
inline constexpr DeviceType DeviceType_MAX =
    static_cast<DeviceType>(6);
inline bool DeviceType_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int DeviceType_ARRAYSIZE = 6 + 1;
const ::std::string& DeviceType_Name(DeviceType value);
template <typename T>
const ::std::string& DeviceType_Name(T value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DeviceType_Name().");
  return DeviceType_Name(static_cast<DeviceType>(value));
}
bool DeviceType_Parse(
    ::absl::string_view name, DeviceType* PROTOBUF_NONNULL value);
enum OSType : int {
  UNKNOWN_OS_TYPE = 0,
  ANDROID = 1,
  CHROME_OS = 2,
  IOS = 3,
  WINDOWS = 4,
  MACOS = 5,
};

extern const uint32_t OSType_internal_data_[];
inline constexpr OSType OSType_MIN =
    static_cast<OSType>(0);
inline constexpr OSType OSType_MAX =
    static_cast<OSType>(5);
inline bool OSType_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int OSType_ARRAYSIZE = 5 + 1;
const ::std::string& OSType_Name(OSType value);
template <typename T>
const ::std::string& OSType_Name(T value) {
  static_assert(::std::is_same<T, OSType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to OSType_Name().");
  return OSType_Name(static_cast<OSType>(value));
}
bool OSType_Parse(
    ::absl::string_view name, OSType* PROTOBUF_NONNULL value);
enum DeviceRelationship : int {
  UNKNOWN_DEVICE_RELATIONSHIP = 0,
  IS_SELF = 1,
  IS_CONTACT = 2,
  IS_STRANGER = 3,
};

extern const uint32_t DeviceRelationship_internal_data_[];
inline constexpr DeviceRelationship DeviceRelationship_MIN =
    static_cast<DeviceRelationship>(0);
inline constexpr DeviceRelationship DeviceRelationship_MAX =
    static_cast<DeviceRelationship>(3);
inline bool DeviceRelationship_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DeviceRelationship_ARRAYSIZE = 3 + 1;
const ::std::string& DeviceRelationship_Name(DeviceRelationship value);
template <typename T>
const ::std::string& DeviceRelationship_Name(T value) {
  static_assert(::std::is_same<T, DeviceRelationship>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DeviceRelationship_Name().");
  return DeviceRelationship_Name(static_cast<DeviceRelationship>(value));
}
bool DeviceRelationship_Parse(
    ::absl::string_view name, DeviceRelationship* PROTOBUF_NONNULL value);
enum LogSource : int {
  UNSPECIFIED_SOURCE = 0,
  LAB_DEVICES = 1,
  INTERNAL_DEVICES = 2,
  BETA_TESTER_DEVICES = 3,
  OEM_DEVICES = 4,
  DEBUG_DEVICES = 5,
  NEARBY_MODULE_FOOD_DEVICES = 6,
  BETO_DOGFOOD_DEVICES = 7,
  NEARBY_DOGFOOD_DEVICES = 8,
  NEARBY_TEAMFOOD_DEVICES = 9,
};

extern const uint32_t LogSource_internal_data_[];
inline constexpr LogSource LogSource_MIN =
    static_cast<LogSource>(0);
inline constexpr LogSource LogSource_MAX =
    static_cast<LogSource>(9);
inline bool LogSource_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int LogSource_ARRAYSIZE = 9 + 1;
const ::std::string& LogSource_Name(LogSource value);
template <typename T>
const ::std::string& LogSource_Name(T value) {
  static_assert(::std::is_same<T, LogSource>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LogSource_Name().");
  return LogSource_Name(static_cast<LogSource>(value));
}
bool LogSource_Parse(
    ::absl::string_view name, LogSource* PROTOBUF_NONNULL value);
enum ServerActionName : int {
  UNKNOWN_SERVER_ACTION = 0,
  UPLOAD_CERTIFICATES = 1,
  DOWNLOAD_CERTIFICATES = 2,
  CHECK_REACHABILITY = 3,
  UPLOAD_CONTACTS = 4,
  UPDATE_DEVICE_NAME = 5,
  UPLOAD_SENDER_CERTIFICATES = 6,
  DOWNLOAD_SENDER_CERTIFICATES = 7,
  UPLOAD_CONTACTS_AND_CERTIFICATES = 8,
  LIST_REACHABLE_PHONE_NUMBERS = 9,
  LIST_MY_DEVICES = 10,
  LIST_CONTACT_PEOPLE = 11,
  DOWNLOAD_CERTIFICATES_INFO = 12,
};

extern const uint32_t ServerActionName_internal_data_[];
inline constexpr ServerActionName ServerActionName_MIN =
    static_cast<ServerActionName>(0);
inline constexpr ServerActionName ServerActionName_MAX =
    static_cast<ServerActionName>(12);
inline bool ServerActionName_IsValid(int value) {
  return 0 <= value && value <= 12;
}
inline constexpr int ServerActionName_ARRAYSIZE = 12 + 1;
const ::std::string& ServerActionName_Name(ServerActionName value);
template <typename T>
const ::std::string& ServerActionName_Name(T value) {
  static_assert(::std::is_same<T, ServerActionName>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ServerActionName_Name().");
  return ServerActionName_Name(static_cast<ServerActionName>(value));
}
bool ServerActionName_Parse(
    ::absl::string_view name, ServerActionName* PROTOBUF_NONNULL value);
enum ServerResponseState : int {
  UNKNOWN_SERVER_RESPONSE_STATE = 0,
  SERVER_RESPONSE_SUCCESS = 1,
  SERVER_RESPONSE_UNKNOWN_FAILURE = 2,
  SERVER_RESPONSE_STATUS_OTHER_FAILURE = 3,
  SERVER_RESPONSE_STATUS_DEADLINE_EXCEEDED = 4,
  SERVER_RESPONSE_STATUS_PERMISSION_DENIED = 5,
  SERVER_RESPONSE_STATUS_UNAVAILABLE = 6,
  SERVER_RESPONSE_STATUS_UNAUTHENTICATED = 7,
  SERVER_RESPONSE_STATUS_INVALID_ARGUMENT = 9,
  SERVER_RESPONSE_GOOGLE_AUTH_FAILURE = 8,
  SERVER_RESPONSE_NOT_CONNECTED_TO_INTERNET = 10,
};

extern const uint32_t ServerResponseState_internal_data_[];
inline constexpr ServerResponseState ServerResponseState_MIN =
    static_cast<ServerResponseState>(0);
inline constexpr ServerResponseState ServerResponseState_MAX =
    static_cast<ServerResponseState>(10);
inline bool ServerResponseState_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int ServerResponseState_ARRAYSIZE = 10 + 1;
const ::std::string& ServerResponseState_Name(ServerResponseState value);
template <typename T>
const ::std::string& ServerResponseState_Name(T value) {
  static_assert(::std::is_same<T, ServerResponseState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ServerResponseState_Name().");
  return ServerResponseState_Name(static_cast<ServerResponseState>(value));
}
bool ServerResponseState_Parse(
    ::absl::string_view name, ServerResponseState* PROTOBUF_NONNULL value);
enum SyncPurpose : int {
  SYNC_PURPOSE_UNKNOWN = 0,
  SYNC_PURPOSE_ON_DEMAND_SYNC = 1,
  SYNC_PURPOSE_CHIME_NOTIFICATION = 2,
  SYNC_PURPOSE_DAILY_SYNC = 3,
  SYNC_PURPOSE_OPT_IN_FIRST_SYNC = 4,
  SYNC_PURPOSE_CHECK_DEFAULT_OPT_IN = 5,
  SYNC_PURPOSE_NEARBY_SHARE_ENABLED = 6,
  SYNC_PURPOSE_SYNC_AT_FAST_INIT = 7,
  SYNC_PURPOSE_SYNC_AT_DISCOVERY = 8,
  SYNC_PURPOSE_SYNC_AT_LOAD_PRIVATE_CERTIFICATE = 9,
  SYNC_PURPOSE_SYNC_AT_ADVERTISEMENT = 10,
  SYNC_PURPOSE_CONTACT_LIST_CHANGE = 11,
  SYNC_PURPOSE_SHOW_C11N_VIEW = 12,
  SYNC_PURPOSE_REGULAR_CHECK_CONTACT_REACHABILITY = 13,
  SYNC_PURPOSE_VISIBILITY_SELECTED_CONTACT_CHANGE = 14,
  SYNC_PURPOSE_ACCOUNT_CHANGE = 15,
  SYNC_PURPOSE_REGENERATE_CERTIFICATES = 16,
  SYNC_PURPOSE_DEVICE_CONTACTS_CONSENT_CHANGE = 17,
  SYNC_EXHAUST_SALT = 18,
  SYNC_QUICKSHARE_IDENTITY_PROVIDER_QUERY = 19,
};

extern const uint32_t SyncPurpose_internal_data_[];
inline constexpr SyncPurpose SyncPurpose_MIN =
    static_cast<SyncPurpose>(0);
inline constexpr SyncPurpose SyncPurpose_MAX =
    static_cast<SyncPurpose>(19);
inline bool SyncPurpose_IsValid(int value) {
  return 0 <= value && value <= 19;
}
inline constexpr int SyncPurpose_ARRAYSIZE = 19 + 1;
const ::std::string& SyncPurpose_Name(SyncPurpose value);
template <typename T>
const ::std::string& SyncPurpose_Name(T value) {
  static_assert(::std::is_same<T, SyncPurpose>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SyncPurpose_Name().");
  return SyncPurpose_Name(static_cast<SyncPurpose>(value));
}
bool SyncPurpose_Parse(
    ::absl::string_view name, SyncPurpose* PROTOBUF_NONNULL value);
enum ClientRole : int {
  CLIENT_ROLE_UNKNOWN = 0,
  CLIENT_ROLE_SENDER = 1,
  CLIENT_ROLE_RECEIVER = 2,
};

extern const uint32_t ClientRole_internal_data_[];
inline constexpr ClientRole ClientRole_MIN =
    static_cast<ClientRole>(0);
inline constexpr ClientRole ClientRole_MAX =
    static_cast<ClientRole>(2);
inline bool ClientRole_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ClientRole_ARRAYSIZE = 2 + 1;
const ::std::string& ClientRole_Name(ClientRole value);
template <typename T>
const ::std::string& ClientRole_Name(T value) {
  static_assert(::std::is_same<T, ClientRole>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ClientRole_Name().");
  return ClientRole_Name(static_cast<ClientRole>(value));
}
bool ClientRole_Parse(
    ::absl::string_view name, ClientRole* PROTOBUF_NONNULL value);
enum ScanType : int {
  UNKNOWN_SCAN_TYPE = 0,
  FOREGROUND_SCAN = 1,
  FOREGROUND_RETRY_SCAN [[deprecated]] = 2,
  DIRECT_SHARE_SCAN = 3,
  BACKGROUND_SCAN = 4,
};

extern const uint32_t ScanType_internal_data_[];
inline constexpr ScanType ScanType_MIN =
    static_cast<ScanType>(0);
inline constexpr ScanType ScanType_MAX =
    static_cast<ScanType>(4);
inline bool ScanType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ScanType_ARRAYSIZE = 4 + 1;
const ::std::string& ScanType_Name(ScanType value);
template <typename T>
const ::std::string& ScanType_Name(T value) {
  static_assert(::std::is_same<T, ScanType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScanType_Name().");
  return ScanType_Name(static_cast<ScanType>(value));
}
bool ScanType_Parse(
    ::absl::string_view name, ScanType* PROTOBUF_NONNULL value);
enum ParsingFailedType : int {
  FAILED_UNKNOWN_TYPE = 0,
  FAILED_PARSE_ADVERTISEMENT = 1,
  FAILED_CONVERT_SHARE_TARGET = 2,
};

extern const uint32_t ParsingFailedType_internal_data_[];
inline constexpr ParsingFailedType ParsingFailedType_MIN =
    static_cast<ParsingFailedType>(0);
inline constexpr ParsingFailedType ParsingFailedType_MAX =
    static_cast<ParsingFailedType>(2);
inline bool ParsingFailedType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ParsingFailedType_ARRAYSIZE = 2 + 1;
const ::std::string& ParsingFailedType_Name(ParsingFailedType value);
template <typename T>
const ::std::string& ParsingFailedType_Name(T value) {
  static_assert(::std::is_same<T, ParsingFailedType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ParsingFailedType_Name().");
  return ParsingFailedType_Name(static_cast<ParsingFailedType>(value));
}
bool ParsingFailedType_Parse(
    ::absl::string_view name, ParsingFailedType* PROTOBUF_NONNULL value);
enum AdvertisingMode : int {
  UNKNOWN_ADVERTISING_MODE = 0,
  SCREEN_OFF_ADVERTISING_MODE = 1,
  BACKGROUND_ADVERTISING_MODE = 2,
  MIDGROUND_ADVERTISING_MODE = 3,
  FOREGROUND_ADVERTISING_MODE = 4,
  SUSPENDED_ADVERTISING_MODE = 5,
};

extern const uint32_t AdvertisingMode_internal_data_[];
inline constexpr AdvertisingMode AdvertisingMode_MIN =
    static_cast<AdvertisingMode>(0);
inline constexpr AdvertisingMode AdvertisingMode_MAX =
    static_cast<AdvertisingMode>(5);
inline bool AdvertisingMode_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int AdvertisingMode_ARRAYSIZE = 5 + 1;
const ::std::string& AdvertisingMode_Name(AdvertisingMode value);
template <typename T>
const ::std::string& AdvertisingMode_Name(T value) {
  static_assert(::std::is_same<T, AdvertisingMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AdvertisingMode_Name().");
  return AdvertisingMode_Name(static_cast<AdvertisingMode>(value));
}
bool AdvertisingMode_Parse(
    ::absl::string_view name, AdvertisingMode* PROTOBUF_NONNULL value);
enum DiscoveryMode : int {
  UNKNOWN_DISCOVERY_MODE = 0,
  SCREEN_OFF_DISCOVERY_MODE = 1,
  BACKGROUND_DISCOVERY_MODE = 2,
  MIDGROUND_DISCOVERY_MODE = 3,
  FOREGROUND_DISCOVERY_MODE = 4,
  SUSPENDED_DISCOVERY_MODE = 5,
};

extern const uint32_t DiscoveryMode_internal_data_[];
inline constexpr DiscoveryMode DiscoveryMode_MIN =
    static_cast<DiscoveryMode>(0);
inline constexpr DiscoveryMode DiscoveryMode_MAX =
    static_cast<DiscoveryMode>(5);
inline bool DiscoveryMode_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int DiscoveryMode_ARRAYSIZE = 5 + 1;
const ::std::string& DiscoveryMode_Name(DiscoveryMode value);
template <typename T>
const ::std::string& DiscoveryMode_Name(T value) {
  static_assert(::std::is_same<T, DiscoveryMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DiscoveryMode_Name().");
  return DiscoveryMode_Name(static_cast<DiscoveryMode>(value));
}
bool DiscoveryMode_Parse(
    ::absl::string_view name, DiscoveryMode* PROTOBUF_NONNULL value);
enum ActivityName : int {
  UNKNOWN_ACTIVITY = 0,
  SHARE_SHEET_ACTIVITY = 1,
  SETTINGS_ACTIVITY = 2,
  RECEIVE_SURFACE_ACTIVITY = 3,
  SETUP_ACTIVITY = 4,
  DEVICE_VISIBILITY_ACTIVITY = 5,
  CONSENTS_ACTIVITY = 6,
  SET_DEVICE_NAME_DIALOG = 7,
  SET_DATA_USAGE_DIALOG = 8,
  QUICK_SETTINGS_ACTIVITY = 9,
  REMOTE_COPY_SHARE_SHEET_ACTIVITY = 10,
  SETUP_WIZARD_ACTIVITY = 11,
  SETTINGS_REVIEW_ACTIVITY = 12,
};

extern const uint32_t ActivityName_internal_data_[];
inline constexpr ActivityName ActivityName_MIN =
    static_cast<ActivityName>(0);
inline constexpr ActivityName ActivityName_MAX =
    static_cast<ActivityName>(12);
inline bool ActivityName_IsValid(int value) {
  return 0 <= value && value <= 12;
}
inline constexpr int ActivityName_ARRAYSIZE = 12 + 1;
const ::std::string& ActivityName_Name(ActivityName value);
template <typename T>
const ::std::string& ActivityName_Name(T value) {
  static_assert(::std::is_same<T, ActivityName>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ActivityName_Name().");
  return ActivityName_Name(static_cast<ActivityName>(value));
}
bool ActivityName_Parse(
    ::absl::string_view name, ActivityName* PROTOBUF_NONNULL value);
enum ConsentType : int {
  CONSENT_TYPE_UNKNOWN = 0,
  CONSENT_TYPE_C11N = 1,
  CONSENT_TYPE_DEVICE_CONTACT = 2,
};

extern const uint32_t ConsentType_internal_data_[];
inline constexpr ConsentType ConsentType_MIN =
    static_cast<ConsentType>(0);
inline constexpr ConsentType ConsentType_MAX =
    static_cast<ConsentType>(2);
inline bool ConsentType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ConsentType_ARRAYSIZE = 2 + 1;
const ::std::string& ConsentType_Name(ConsentType value);
template <typename T>
const ::std::string& ConsentType_Name(T value) {
  static_assert(::std::is_same<T, ConsentType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConsentType_Name().");
  return ConsentType_Name(static_cast<ConsentType>(value));
}
bool ConsentType_Parse(
    ::absl::string_view name, ConsentType* PROTOBUF_NONNULL value);
enum ConsentAcceptanceStatus : int {
  CONSENT_UNKNOWN_ACCEPT_STATUS = 0,
  CONSENT_ACCEPTED = 1,
  CONSENT_DECLINED = 2,
  CONSENT_UNABLE_TO_ENABLE = 3,
};

extern const uint32_t ConsentAcceptanceStatus_internal_data_[];
inline constexpr ConsentAcceptanceStatus ConsentAcceptanceStatus_MIN =
    static_cast<ConsentAcceptanceStatus>(0);
inline constexpr ConsentAcceptanceStatus ConsentAcceptanceStatus_MAX =
    static_cast<ConsentAcceptanceStatus>(3);
inline bool ConsentAcceptanceStatus_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ConsentAcceptanceStatus_ARRAYSIZE = 3 + 1;
const ::std::string& ConsentAcceptanceStatus_Name(ConsentAcceptanceStatus value);
template <typename T>
const ::std::string& ConsentAcceptanceStatus_Name(T value) {
  static_assert(::std::is_same<T, ConsentAcceptanceStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConsentAcceptanceStatus_Name().");
  return ConsentAcceptanceStatus_Name(static_cast<ConsentAcceptanceStatus>(value));
}
bool ConsentAcceptanceStatus_Parse(
    ::absl::string_view name, ConsentAcceptanceStatus* PROTOBUF_NONNULL value);
enum ApkSource : int {
  UNKNOWN_APK_SOURCE = 0,
  APK_FROM_SD_CARD = 1,
  INSTALLED_APP = 2,
};

extern const uint32_t ApkSource_internal_data_[];
inline constexpr ApkSource ApkSource_MIN =
    static_cast<ApkSource>(0);
inline constexpr ApkSource ApkSource_MAX =
    static_cast<ApkSource>(2);
inline bool ApkSource_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ApkSource_ARRAYSIZE = 2 + 1;
const ::std::string& ApkSource_Name(ApkSource value);
template <typename T>
const ::std::string& ApkSource_Name(T value) {
  static_assert(::std::is_same<T, ApkSource>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ApkSource_Name().");
  return ApkSource_Name(static_cast<ApkSource>(value));
}
bool ApkSource_Parse(
    ::absl::string_view name, ApkSource* PROTOBUF_NONNULL value);
enum InstallAPKStatus : int {
  UNKNOWN_INSTALL_APK_STATUS = 0,
  FAIL_INSTALLATION = 1,
  SUCCESS_INSTALLATION = 2,
};

extern const uint32_t InstallAPKStatus_internal_data_[];
inline constexpr InstallAPKStatus InstallAPKStatus_MIN =
    static_cast<InstallAPKStatus>(0);
inline constexpr InstallAPKStatus InstallAPKStatus_MAX =
    static_cast<InstallAPKStatus>(2);
inline bool InstallAPKStatus_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int InstallAPKStatus_ARRAYSIZE = 2 + 1;
const ::std::string& InstallAPKStatus_Name(InstallAPKStatus value);
template <typename T>
const ::std::string& InstallAPKStatus_Name(T value) {
  static_assert(::std::is_same<T, InstallAPKStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InstallAPKStatus_Name().");
  return InstallAPKStatus_Name(static_cast<InstallAPKStatus>(value));
}
bool InstallAPKStatus_Parse(
    ::absl::string_view name, InstallAPKStatus* PROTOBUF_NONNULL value);
enum VerifyAPKStatus : int {
  UNKNOWN_VERIFY_APK_STATUS = 0,
  NOT_INSTALLABLE = 1,
  INSTALLABLE = 2,
  ALREADY_INSTALLED = 3,
};

extern const uint32_t VerifyAPKStatus_internal_data_[];
inline constexpr VerifyAPKStatus VerifyAPKStatus_MIN =
    static_cast<VerifyAPKStatus>(0);
inline constexpr VerifyAPKStatus VerifyAPKStatus_MAX =
    static_cast<VerifyAPKStatus>(3);
inline bool VerifyAPKStatus_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int VerifyAPKStatus_ARRAYSIZE = 3 + 1;
const ::std::string& VerifyAPKStatus_Name(VerifyAPKStatus value);
template <typename T>
const ::std::string& VerifyAPKStatus_Name(T value) {
  static_assert(::std::is_same<T, VerifyAPKStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VerifyAPKStatus_Name().");
  return VerifyAPKStatus_Name(static_cast<VerifyAPKStatus>(value));
}
bool VerifyAPKStatus_Parse(
    ::absl::string_view name, VerifyAPKStatus* PROTOBUF_NONNULL value);
enum ShowNotificationStatus : int {
  UNKNOWN_SHOW_NOTIFICATION_STATUS = 0,
  SHOW = 1,
  NOT_SHOW = 2,
};

extern const uint32_t ShowNotificationStatus_internal_data_[];
inline constexpr ShowNotificationStatus ShowNotificationStatus_MIN =
    static_cast<ShowNotificationStatus>(0);
inline constexpr ShowNotificationStatus ShowNotificationStatus_MAX =
    static_cast<ShowNotificationStatus>(2);
inline bool ShowNotificationStatus_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ShowNotificationStatus_ARRAYSIZE = 2 + 1;
const ::std::string& ShowNotificationStatus_Name(ShowNotificationStatus value);
template <typename T>
const ::std::string& ShowNotificationStatus_Name(T value) {
  static_assert(::std::is_same<T, ShowNotificationStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ShowNotificationStatus_Name().");
  return ShowNotificationStatus_Name(static_cast<ShowNotificationStatus>(value));
}
bool ShowNotificationStatus_Parse(
    ::absl::string_view name, ShowNotificationStatus* PROTOBUF_NONNULL value);
enum PermissionRequestResult : int {
  PERMISSION_UNKNOWN_REQUEST_RESULT = 0,
  PERMISSION_GRANTED = 1,
  PERMISSION_REJECTED = 2,
  PERMISSION_UNABLE_TO_GRANT = 3,
};

extern const uint32_t PermissionRequestResult_internal_data_[];
inline constexpr PermissionRequestResult PermissionRequestResult_MIN =
    static_cast<PermissionRequestResult>(0);
inline constexpr PermissionRequestResult PermissionRequestResult_MAX =
    static_cast<PermissionRequestResult>(3);
inline bool PermissionRequestResult_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int PermissionRequestResult_ARRAYSIZE = 3 + 1;
const ::std::string& PermissionRequestResult_Name(PermissionRequestResult value);
template <typename T>
const ::std::string& PermissionRequestResult_Name(T value) {
  static_assert(::std::is_same<T, PermissionRequestResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PermissionRequestResult_Name().");
  return PermissionRequestResult_Name(static_cast<PermissionRequestResult>(value));
}
bool PermissionRequestResult_Parse(
    ::absl::string_view name, PermissionRequestResult* PROTOBUF_NONNULL value);
enum PermissionRequestType : int {
  PERMISSION_UNKNOWN_TYPE = 0,
  PERMISSION_AIRPLANE_MODE_OFF = 1,
  PERMISSION_WIFI = 2,
  PERMISSION_BLUETOOTH = 3,
  PERMISSION_LOCATION = 4,
  PERMISSION_WIFI_HOTSPOT = 5,
};

extern const uint32_t PermissionRequestType_internal_data_[];
inline constexpr PermissionRequestType PermissionRequestType_MIN =
    static_cast<PermissionRequestType>(0);
inline constexpr PermissionRequestType PermissionRequestType_MAX =
    static_cast<PermissionRequestType>(5);
inline bool PermissionRequestType_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int PermissionRequestType_ARRAYSIZE = 5 + 1;
const ::std::string& PermissionRequestType_Name(PermissionRequestType value);
template <typename T>
const ::std::string& PermissionRequestType_Name(T value) {
  static_assert(::std::is_same<T, PermissionRequestType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PermissionRequestType_Name().");
  return PermissionRequestType_Name(static_cast<PermissionRequestType>(value));
}
bool PermissionRequestType_Parse(
    ::absl::string_view name, PermissionRequestType* PROTOBUF_NONNULL value);
enum SharingUseCase : int {
  USE_CASE_UNKNOWN = 0,
  USE_CASE_NEARBY_SHARE = 1,
  USE_CASE_REMOTE_COPY_PASTE = 2,
  USE_CASE_WIFI_CREDENTIAL = 3,
  USE_CASE_APP_SHARE = 4,
  USE_CASE_QUICK_SETTING_FILE_SHARE = 5,
  USE_CASE_SETUP_WIZARD = 6,
  USE_CASE_NEARBY_SHARE_WITH_QR_CODE [[deprecated]] = 7,
  USE_CASE_REDIRECTED_FROM_BLUETOOTH_SHARE = 8,
};

extern const uint32_t SharingUseCase_internal_data_[];
inline constexpr SharingUseCase SharingUseCase_MIN =
    static_cast<SharingUseCase>(0);
inline constexpr SharingUseCase SharingUseCase_MAX =
    static_cast<SharingUseCase>(8);
inline bool SharingUseCase_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int SharingUseCase_ARRAYSIZE = 8 + 1;
const ::std::string& SharingUseCase_Name(SharingUseCase value);
template <typename T>
const ::std::string& SharingUseCase_Name(T value) {
  static_assert(::std::is_same<T, SharingUseCase>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SharingUseCase_Name().");
  return SharingUseCase_Name(static_cast<SharingUseCase>(value));
}
bool SharingUseCase_Parse(
    ::absl::string_view name, SharingUseCase* PROTOBUF_NONNULL value);
enum AppCrashReason : int {
  APP_CRASH_REASON_UNKNOWN = 0,
};

extern const uint32_t AppCrashReason_internal_data_[];
inline constexpr AppCrashReason AppCrashReason_MIN =
    static_cast<AppCrashReason>(0);
inline constexpr AppCrashReason AppCrashReason_MAX =
    static_cast<AppCrashReason>(0);
inline bool AppCrashReason_IsValid(int value) {
  return 0 <= value && value <= 0;
}
inline constexpr int AppCrashReason_ARRAYSIZE = 0 + 1;
const ::std::string& AppCrashReason_Name(AppCrashReason value);
template <typename T>
const ::std::string& AppCrashReason_Name(T value) {
  static_assert(::std::is_same<T, AppCrashReason>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AppCrashReason_Name().");
  return AppCrashReason_Name(static_cast<AppCrashReason>(value));
}
bool AppCrashReason_Parse(
    ::absl::string_view name, AppCrashReason* PROTOBUF_NONNULL value);
enum AttachmentSourceType : int {
  ATTACHMENT_SOURCE_UNKNOWN = 0,
  ATTACHMENT_SOURCE_CONTEXT_MENU = 1,
  ATTACHMENT_SOURCE_DRAG_AND_DROP = 2,
  ATTACHMENT_SOURCE_SELECT_FILES_BUTTON = 3,
  ATTACHMENT_SOURCE_PASTE = 4,
  ATTACHMENT_SOURCE_SELECT_FOLDERS_BUTTON = 5,
  ATTACHMENT_SOURCE_SHARE_ACTIVATION = 6,
};

extern const uint32_t AttachmentSourceType_internal_data_[];
inline constexpr AttachmentSourceType AttachmentSourceType_MIN =
    static_cast<AttachmentSourceType>(0);
inline constexpr AttachmentSourceType AttachmentSourceType_MAX =
    static_cast<AttachmentSourceType>(6);
inline bool AttachmentSourceType_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int AttachmentSourceType_ARRAYSIZE = 6 + 1;
const ::std::string& AttachmentSourceType_Name(AttachmentSourceType value);
template <typename T>
const ::std::string& AttachmentSourceType_Name(T value) {
  static_assert(::std::is_same<T, AttachmentSourceType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AttachmentSourceType_Name().");
  return AttachmentSourceType_Name(static_cast<AttachmentSourceType>(value));
}
bool AttachmentSourceType_Parse(
    ::absl::string_view name, AttachmentSourceType* PROTOBUF_NONNULL value);
enum PreferencesAction : int {
  PREFERENCES_ACTION_UNKNOWN = 0,
  PREFERENCES_ACTION_NO_ACTION = 1,
  PREFERENCES_ACTION_LOAD_PREFERENCES = 2,
  PREFERENCES_ACTION_SAVE_PREFERENCESS = 3,
  PREFERENCES_ACTION_ATTEMPT_LOAD = 4,
  PREFERENCES_ACTION_RESTORE_FROM_BACKUP = 5,
  PREFERENCES_ACTION_CREATE_PREFERENCES_PATH = 6,
  PREFERENCES_ACTION_MAKE_PREFERENCES_BACKUP_FILE = 7,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_PATH_EXISTS = 8,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_INPUT_STREAM_STATUS = 9,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_FILE_IS_CORRUPTED = 10,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_BACKUP_FILE_EXISTS = 11,
};

extern const uint32_t PreferencesAction_internal_data_[];
inline constexpr PreferencesAction PreferencesAction_MIN =
    static_cast<PreferencesAction>(0);
inline constexpr PreferencesAction PreferencesAction_MAX =
    static_cast<PreferencesAction>(11);
inline bool PreferencesAction_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int PreferencesAction_ARRAYSIZE = 11 + 1;
const ::std::string& PreferencesAction_Name(PreferencesAction value);
template <typename T>
const ::std::string& PreferencesAction_Name(T value) {
  static_assert(::std::is_same<T, PreferencesAction>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PreferencesAction_Name().");
  return PreferencesAction_Name(static_cast<PreferencesAction>(value));
}
bool PreferencesAction_Parse(
    ::absl::string_view name, PreferencesAction* PROTOBUF_NONNULL value);
enum PreferencesActionStatus : int {
  PREFERENCES_ACTION_STATUS_UNKNOWN = 0,
  PREFERENCES_ACTION_STATUS_SUCCESS = 1,
  PREFERENCES_ACTION_STATUS_FAIL = 2,
};

extern const uint32_t PreferencesActionStatus_internal_data_[];
inline constexpr PreferencesActionStatus PreferencesActionStatus_MIN =
    static_cast<PreferencesActionStatus>(0);
inline constexpr PreferencesActionStatus PreferencesActionStatus_MAX =
    static_cast<PreferencesActionStatus>(2);
inline bool PreferencesActionStatus_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int PreferencesActionStatus_ARRAYSIZE = 2 + 1;
const ::std::string& PreferencesActionStatus_Name(PreferencesActionStatus value);
template <typename T>
const ::std::string& PreferencesActionStatus_Name(T value) {
  static_assert(::std::is_same<T, PreferencesActionStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PreferencesActionStatus_Name().");
  return PreferencesActionStatus_Name(static_cast<PreferencesActionStatus>(value));
}
bool PreferencesActionStatus_Parse(
    ::absl::string_view name, PreferencesActionStatus* PROTOBUF_NONNULL value);
enum FastInitState : int {
  FAST_INIT_UNKNOWN_STATE = 0,
  FAST_INIT_CLOSE_STATE = 1,
  FAST_INIT_FAR_STATE = 2,
  FAST_INIT_LOST_STATE = 3,
};

extern const uint32_t FastInitState_internal_data_[];
inline constexpr FastInitState FastInitState_MIN =
    static_cast<FastInitState>(0);
inline constexpr FastInitState FastInitState_MAX =
    static_cast<FastInitState>(3);
inline bool FastInitState_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int FastInitState_ARRAYSIZE = 3 + 1;
const ::std::string& FastInitState_Name(FastInitState value);
template <typename T>
const ::std::string& FastInitState_Name(T value) {
  static_assert(::std::is_same<T, FastInitState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FastInitState_Name().");
  return FastInitState_Name(static_cast<FastInitState>(value));
}
bool FastInitState_Parse(
    ::absl::string_view name, FastInitState* PROTOBUF_NONNULL value);
enum FastInitType : int {
  FAST_INIT_UNKNOWN_TYPE = 0,
  FAST_INIT_NOTIFY_TYPE = 1,
  FAST_INIT_SILENT_TYPE = 2,
};

extern const uint32_t FastInitType_internal_data_[];
inline constexpr FastInitType FastInitType_MIN =
    static_cast<FastInitType>(0);
inline constexpr FastInitType FastInitType_MAX =
    static_cast<FastInitType>(2);
inline bool FastInitType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int FastInitType_ARRAYSIZE = 2 + 1;
const ::std::string& FastInitType_Name(FastInitType value);
template <typename T>
const ::std::string& FastInitType_Name(T value) {
  static_assert(::std::is_same<T, FastInitType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FastInitType_Name().");
  return FastInitType_Name(static_cast<FastInitType>(value));
}
bool FastInitType_Parse(
    ::absl::string_view name, FastInitType* PROTOBUF_NONNULL value);
enum DesktopNotification : int {
  DESKTOP_NOTIFICATION_UNKNOWN = 0,
  DESKTOP_NOTIFICATION_CONNECTING = 1,
  DESKTOP_NOTIFICATION_PROGRESS = 2,
  DESKTOP_NOTIFICATION_ACCEPT = 3,
  DESKTOP_NOTIFICATION_RECEIVED = 4,
  DESKTOP_NOTIFICATION_ERROR = 5,
};

extern const uint32_t DesktopNotification_internal_data_[];
inline constexpr DesktopNotification DesktopNotification_MIN =
    static_cast<DesktopNotification>(0);
inline constexpr DesktopNotification DesktopNotification_MAX =
    static_cast<DesktopNotification>(5);
inline bool DesktopNotification_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int DesktopNotification_ARRAYSIZE = 5 + 1;
const ::std::string& DesktopNotification_Name(DesktopNotification value);
template <typename T>
const ::std::string& DesktopNotification_Name(T value) {
  static_assert(::std::is_same<T, DesktopNotification>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DesktopNotification_Name().");
  return DesktopNotification_Name(static_cast<DesktopNotification>(value));
}
bool DesktopNotification_Parse(
    ::absl::string_view name, DesktopNotification* PROTOBUF_NONNULL value);
enum DesktopTransferEventType : int {
  DESKTOP_TRANSFER_EVENT_TYPE_UNKNOWN = 0,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_ACCEPT = 1,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_PROGRESS = 2,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_RECEIVED = 3,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_ERROR = 4,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_START = 5,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_SELECT_A_DEVICE = 6,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_PROGRESS = 7,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_SENT = 8,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_ERROR = 9,
};

extern const uint32_t DesktopTransferEventType_internal_data_[];
inline constexpr DesktopTransferEventType DesktopTransferEventType_MIN =
    static_cast<DesktopTransferEventType>(0);
inline constexpr DesktopTransferEventType DesktopTransferEventType_MAX =
    static_cast<DesktopTransferEventType>(9);
inline bool DesktopTransferEventType_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int DesktopTransferEventType_ARRAYSIZE = 9 + 1;
const ::std::string& DesktopTransferEventType_Name(DesktopTransferEventType value);
template <typename T>
const ::std::string& DesktopTransferEventType_Name(T value) {
  static_assert(::std::is_same<T, DesktopTransferEventType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DesktopTransferEventType_Name().");
  return DesktopTransferEventType_Name(static_cast<DesktopTransferEventType>(value));
}
bool DesktopTransferEventType_Parse(
    ::absl::string_view name, DesktopTransferEventType* PROTOBUF_NONNULL value);
enum DecryptCertificateFailureStatus : int {
  DECRYPT_CERT_UNKNOWN_FAILURE = 0,
  DECRYPT_CERT_NO_SUCH_ALGORITHM_FAILURE = 1,
  DECRYPT_CERT_NO_SUCH_PADDING_FAILURE = 2,
  DECRYPT_CERT_INVALID_KEY_FAILURE = 3,
  DECRYPT_CERT_INVALID_ALGORITHM_PARAMETER_FAILURE = 4,
  DECRYPT_CERT_ILLEGAL_BLOCK_SIZE_FAILURE = 5,
  DECRYPT_CERT_BAD_PADDING_FAILURE = 6,
};

extern const uint32_t DecryptCertificateFailureStatus_internal_data_[];
inline constexpr DecryptCertificateFailureStatus DecryptCertificateFailureStatus_MIN =
    static_cast<DecryptCertificateFailureStatus>(0);
inline constexpr DecryptCertificateFailureStatus DecryptCertificateFailureStatus_MAX =
    static_cast<DecryptCertificateFailureStatus>(6);
inline bool DecryptCertificateFailureStatus_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int DecryptCertificateFailureStatus_ARRAYSIZE = 6 + 1;
const ::std::string& DecryptCertificateFailureStatus_Name(DecryptCertificateFailureStatus value);
template <typename T>
const ::std::string& DecryptCertificateFailureStatus_Name(T value) {
  static_assert(::std::is_same<T, DecryptCertificateFailureStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DecryptCertificateFailureStatus_Name().");
  return DecryptCertificateFailureStatus_Name(static_cast<DecryptCertificateFailureStatus>(value));
}
bool DecryptCertificateFailureStatus_Parse(
    ::absl::string_view name, DecryptCertificateFailureStatus* PROTOBUF_NONNULL value);
enum ContactAccess : int {
  CONTACT_ACCESS_UNKNOWN = 0,
  CONTACT_ACCESS_NO_CONTACT_UPLOADED = 1,
  CONTACT_ACCESS_ONLY_UPLOAD_GOOGLE_CONTACT = 2,
  CONTACT_ACCESS_UPLOAD_CONTACT_FOR_DEVICE_CONTACT_CONSENT = 3,
  CONTACT_ACCESS_UPLOAD_CONTACT_FOR_QUICK_SHARE_CONSENT = 4,
};

extern const uint32_t ContactAccess_internal_data_[];
inline constexpr ContactAccess ContactAccess_MIN =
    static_cast<ContactAccess>(0);
inline constexpr ContactAccess ContactAccess_MAX =
    static_cast<ContactAccess>(4);
inline bool ContactAccess_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ContactAccess_ARRAYSIZE = 4 + 1;
const ::std::string& ContactAccess_Name(ContactAccess value);
template <typename T>
const ::std::string& ContactAccess_Name(T value) {
  static_assert(::std::is_same<T, ContactAccess>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ContactAccess_Name().");
  return ContactAccess_Name(static_cast<ContactAccess>(value));
}
bool ContactAccess_Parse(
    ::absl::string_view name, ContactAccess* PROTOBUF_NONNULL value);
enum IdentityVerification : int {
  IDENTITY_VERIFICATION_UNKNOWN = 0,
  IDENTITY_VERIFICATION_NO_PHONE_NUMBER_VERIFIED = 1,
  IDENTITY_VERIFICATION_PHONE_NUMBER_VERIFIED_NOT_LINKED_TO_GAIA = 2,
  IDENTITY_VERIFICATION_PHONE_NUMBER_VERIFIED_LINKED_TO_QS_GAIA = 3,
};

extern const uint32_t IdentityVerification_internal_data_[];
inline constexpr IdentityVerification IdentityVerification_MIN =
    static_cast<IdentityVerification>(0);
inline constexpr IdentityVerification IdentityVerification_MAX =
    static_cast<IdentityVerification>(3);
inline bool IdentityVerification_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int IdentityVerification_ARRAYSIZE = 3 + 1;
const ::std::string& IdentityVerification_Name(IdentityVerification value);
template <typename T>
const ::std::string& IdentityVerification_Name(T value) {
  static_assert(::std::is_same<T, IdentityVerification>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to IdentityVerification_Name().");
  return IdentityVerification_Name(static_cast<IdentityVerification>(value));
}
bool IdentityVerification_Parse(
    ::absl::string_view name, IdentityVerification* PROTOBUF_NONNULL value);
enum ButtonStatus : int {
  BUTTON_STATUS_UNKNOWN = 0,
  BUTTON_STATUS_CLICK_ACCEPT = 1,
  BUTTON_STATUS_CLICK_REJECT = 2,
  BUTTON_STATUS_IGNORE = 3,
};

extern const uint32_t ButtonStatus_internal_data_[];
inline constexpr ButtonStatus ButtonStatus_MIN =
    static_cast<ButtonStatus>(0);
inline constexpr ButtonStatus ButtonStatus_MAX =
    static_cast<ButtonStatus>(3);
inline bool ButtonStatus_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ButtonStatus_ARRAYSIZE = 3 + 1;
const ::std::string& ButtonStatus_Name(ButtonStatus value);
template <typename T>
const ::std::string& ButtonStatus_Name(T value) {
  static_assert(::std::is_same<T, ButtonStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ButtonStatus_Name().");
  return ButtonStatus_Name(static_cast<ButtonStatus>(value));
}
bool ButtonStatus_Parse(
    ::absl::string_view name, ButtonStatus* PROTOBUF_NONNULL value);
enum CloudCreateSharingResult : int {
  CLOUD_CREATE_SHARING_RESULT_UNKNOWN = 0,
  CLOUD_CREATE_SHARING_RESULT_SUCCESS = 1,
  CLOUD_CREATE_SHARING_RESULT_SIGN_IN_REQUIRE = 2,
  CLOUD_CREATE_SHARING_RESULT_ALREADY_EXIST = 3,
  CLOUD_CREATE_SHARING_RESULT_ALREADY_STARTED = 4,
  CLOUD_CREATE_SHARING_RESULT_NETWORK_ERROR = 5,
  CLOUD_CREATE_SHARING_RESULT_INVALID_ARGUMENT = 6,
  CLOUD_CREATE_SHARING_RESULT_REMOTE_ERROR = 7,
  CLOUD_CREATE_SHARING_RESULT_FILE_LIMIT_EXCEED_COUNT = 8,
  CLOUD_CREATE_SHARING_RESULT_FILE_LIMIT_EXCEED_SIZE = 9,
  CLOUD_CREATE_SHARING_RESULT_SUCCESS_NO_NOTIFICATION = 10,
};

extern const uint32_t CloudCreateSharingResult_internal_data_[];
inline constexpr CloudCreateSharingResult CloudCreateSharingResult_MIN =
    static_cast<CloudCreateSharingResult>(0);
inline constexpr CloudCreateSharingResult CloudCreateSharingResult_MAX =
    static_cast<CloudCreateSharingResult>(10);
inline bool CloudCreateSharingResult_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int CloudCreateSharingResult_ARRAYSIZE = 10 + 1;
const ::std::string& CloudCreateSharingResult_Name(CloudCreateSharingResult value);
template <typename T>
const ::std::string& CloudCreateSharingResult_Name(T value) {
  static_assert(::std::is_same<T, CloudCreateSharingResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CloudCreateSharingResult_Name().");
  return CloudCreateSharingResult_Name(static_cast<CloudCreateSharingResult>(value));
}
bool CloudCreateSharingResult_Parse(
    ::absl::string_view name, CloudCreateSharingResult* PROTOBUF_NONNULL value);
enum CloudRegisterReceiverResult : int {
  CLOUD_REGISTER_RECEIVER_RESULT_UNKNOWN = 0,
  CLOUD_REGISTER_RECEIVER_RESULT_SUCCESS = 1,
  CLOUD_REGISTER_RECEIVER_RESULT_INVALID_ARGUMENT = 2,
  CLOUD_REGISTER_RECEIVER_RESULT_DEADLINE_EXCEEDED = 3,
  CLOUD_REGISTER_RECEIVER_RESULT_INTERNAL = 4,
  CLOUD_REGISTER_RECEIVER_RESULT_RESOURCE_EXHAUSTED = 5,
  CLOUD_REGISTER_RECEIVER_RESULT_UNAVAILABLE = 6,
  CLOUD_REGISTER_RECEIVER_RESULT_PERMISSION_DENIED = 7,
  CLOUD_REGISTER_RECEIVER_RESULT_NOT_FOUND = 8,
  CLOUD_REGISTER_RECEIVER_RESULT_ALREADY_EXISTS = 9,
  CLOUD_REGISTER_RECEIVER_RESULT_UNAUTHENTICATED = 10,
  CLOUD_REGISTER_RECEIVER_RESULT_CANCELLED = 11,
  CLOUD_REGISTER_RECEIVER_RESULT_FAILED_PRECONDITION = 12,
  CLOUD_REGISTER_RECEIVER_RESULT_ABORTED = 13,
  CLOUD_REGISTER_RECEIVER_RESULT_OUT_OF_RANGE = 14,
  CLOUD_REGISTER_RECEIVER_RESULT_UNIMPLEMENTED = 15,
  CLOUD_REGISTER_RECEIVER_RESULT_DATA_LOSS = 16,
};

extern const uint32_t CloudRegisterReceiverResult_internal_data_[];
inline constexpr CloudRegisterReceiverResult CloudRegisterReceiverResult_MIN =
    static_cast<CloudRegisterReceiverResult>(0);
inline constexpr CloudRegisterReceiverResult CloudRegisterReceiverResult_MAX =
    static_cast<CloudRegisterReceiverResult>(16);
inline bool CloudRegisterReceiverResult_IsValid(int value) {
  return 0 <= value && value <= 16;
}
inline constexpr int CloudRegisterReceiverResult_ARRAYSIZE = 16 + 1;
const ::std::string& CloudRegisterReceiverResult_Name(CloudRegisterReceiverResult value);
template <typename T>
const ::std::string& CloudRegisterReceiverResult_Name(T value) {
  static_assert(::std::is_same<T, CloudRegisterReceiverResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CloudRegisterReceiverResult_Name().");
  return CloudRegisterReceiverResult_Name(static_cast<CloudRegisterReceiverResult>(value));
}
bool CloudRegisterReceiverResult_Parse(
    ::absl::string_view name, CloudRegisterReceiverResult* PROTOBUF_NONNULL value);
enum CloudActionType : int {
  CLOUD_ACTION_TYPE_UNKNOWN = 0,
  CLOUD_ACTION_TYPE_NORMAL = 1,
  CLOUD_ACTION_TYPE_RETRY = 2,
};

extern const uint32_t CloudActionType_internal_data_[];
inline constexpr CloudActionType CloudActionType_MIN =
    static_cast<CloudActionType>(0);
inline constexpr CloudActionType CloudActionType_MAX =
    static_cast<CloudActionType>(2);
inline bool CloudActionType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int CloudActionType_ARRAYSIZE = 2 + 1;
const ::std::string& CloudActionType_Name(CloudActionType value);
template <typename T>
const ::std::string& CloudActionType_Name(T value) {
  static_assert(::std::is_same<T, CloudActionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CloudActionType_Name().");
  return CloudActionType_Name(static_cast<CloudActionType>(value));
}
bool CloudActionType_Parse(
    ::absl::string_view name, CloudActionType* PROTOBUF_NONNULL value);

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace sharing
}  // namespace proto
}  // namespace nearby
}  // namespace location


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::location::nearby::proto::sharing::EventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::EventCategory> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::NearbySharingStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::Visibility> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DataUsage> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::EstablishConnectionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AttachmentTransmissionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ConnectionLayerStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ProcessReceivedAttachmentsStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::SessionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ResponseToIntroduction> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DeviceType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::OSType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DeviceRelationship> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::LogSource> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ServerActionName> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ServerResponseState> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::SyncPurpose> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ClientRole> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ScanType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ParsingFailedType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AdvertisingMode> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DiscoveryMode> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ActivityName> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ConsentType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ConsentAcceptanceStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ApkSource> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::InstallAPKStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::VerifyAPKStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ShowNotificationStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PermissionRequestResult> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PermissionRequestType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::SharingUseCase> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AppCrashReason> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AttachmentSourceType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PreferencesAction> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PreferencesActionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::FastInitState> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::FastInitType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DesktopNotification> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DesktopTransferEventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DecryptCertificateFailureStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ContactAccess> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::IdentityVerification> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ButtonStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::CloudCreateSharingResult> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::CloudRegisterReceiverResult> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::CloudActionType> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // proto_2fsharing_5fenums_2eproto_2epb_2eh
