// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Input_H
#define WINRT_Microsoft_UI_Input_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Microsoft.UI.Content.2.h"
#include "winrt/impl/Microsoft.UI.Dispatching.2.h"
#include "winrt/impl/Microsoft.UI.Input.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.System.2.h"
#include "winrt/impl/Windows.UI.Core.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::Handled()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ICharacterReceivedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::Handled(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ICharacterReceivedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Handled(value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_Handled(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::KeyCode()
    const {
  uint32_t value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ICharacterReceivedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_KeyCode(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_KeyCode(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::KeyStatus()
    const {
  winrt::Microsoft::UI::Input::PhysicalKeyStatus value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ICharacterReceivedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IContextMenuKeyEventArgs<D>::Handled() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IContextMenuKeyEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IContextMenuKeyEventArgs<D>::Handled(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IContextMenuKeyEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Handled(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_Handled(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_ICrossSlidingEventArgs<D>::CrossSlidingState()
    const {
  winrt::Microsoft::UI::Input::CrossSlidingState value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::ICrossSlidingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ICrossSlidingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CrossSlidingState(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_CrossSlidingState(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_ICrossSlidingEventArgs<D>::PointerDeviceType()
    const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::ICrossSlidingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ICrossSlidingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_ICrossSlidingEventArgs<D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::ICrossSlidingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ICrossSlidingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IDraggingEventArgs<D>::DraggingState() const {
  winrt::Microsoft::UI::Input::DraggingState value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IDraggingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IDraggingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IDraggingEventArgs>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_DraggingState(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)this;
    check_hresult(
        _winrt_abi_type->get_DraggingState(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IDraggingEventArgs<D>::PointerDeviceType()
    const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IDraggingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IDraggingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IDraggingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IDraggingEventArgs<D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IDraggingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IDraggingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IDraggingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IEnteredMoveSizeEventArgs<
    D>::PointerScreenPoint() const {
  winrt::Windows::Graphics::PointInt32 value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IEnteredMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IEnteredMoveSizeEventArgs<
    D>::MoveSizeOperation() const {
  winrt::Microsoft::UI::Input::MoveSizeOperation value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IEnteredMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<
    D>::PointerScreenPoint() const {
  winrt::Windows::Graphics::PointInt32 value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<
    D>::MoveSizeOperation() const {
  winrt::Microsoft::UI::Input::MoveSizeOperation value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<
    D>::MoveSizeWindowId() const {
  winrt::Microsoft::UI::WindowId value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MoveSizeWindowId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_MoveSizeWindowId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<D>::MoveSizeWindowId(
    winrt::Microsoft::UI::WindowId const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_MoveSizeWindowId(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_MoveSizeWindowId(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IExitedMoveSizeEventArgs<
    D>::PointerScreenPoint() const {
  winrt::Windows::Graphics::PointInt32 value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IExitedMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IExitedMoveSizeEventArgs<D>::MoveSizeOperation()
    const {
  winrt::Microsoft::UI::Input::MoveSizeOperation value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IExitedMoveSizeEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusChangedEventArgs<D>::Handled() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IFocusChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusChangedEventArgs<D>::Handled(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Handled(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IFocusChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_Handled(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequest<D>::CorrelationId()
    const {
  winrt::guid value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequest, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequest>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)this;
    check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequest<D>::HintRect() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequest, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequest>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HintRect(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)this;
    check_hresult(_winrt_abi_type->get_HintRect(&value));
  }
  return winrt::Windows::Foundation::IReference<
      winrt::Windows::Foundation::Rect>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequest<D>::Reason() const {
  winrt::Microsoft::UI::Input::FocusNavigationReason value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequest, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequest>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)this;
    check_hresult(
        _winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequestEventArgs<D>::Request()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IFocusNavigationRequestEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Request(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Request(&value));
  }
  return winrt::Microsoft::UI::Input::FocusNavigationRequest{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequestEventArgs<D>::Result()
    const {
  winrt::Microsoft::UI::Input::FocusNavigationResult value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IFocusNavigationRequestEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestEventArgs>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Result(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestEventArgs>**)this;
    check_hresult(
        _winrt_abi_type->get_Result(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequestEventArgs<D>::Result(
    winrt::Microsoft::UI::Input::FocusNavigationResult const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IFocusNavigationRequestEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Result(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_Result(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequestStatics<D>::Create(
    winrt::Microsoft::UI::Input::FocusNavigationReason const& reason) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IFocusNavigationRequestStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->Create(static_cast<int32_t>(reason), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)this;
    check_hresult(
        _winrt_abi_type->Create(static_cast<int32_t>(reason), &result));
  }
  return winrt::Microsoft::UI::Input::FocusNavigationRequest{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequestStatics<D>::Create(
    winrt::Microsoft::UI::Input::FocusNavigationReason const& reason,
    winrt::Windows::Foundation::Rect const& hintRect) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IFocusNavigationRequestStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWithHintRect(
        static_cast<int32_t>(reason), impl::bind_in(hintRect), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)this;
    check_hresult(_winrt_abi_type->CreateWithHintRect(
        static_cast<int32_t>(reason), impl::bind_in(hintRect), &result));
  }
  return winrt::Microsoft::UI::Input::FocusNavigationRequest{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IFocusNavigationRequestStatics<D>::Create(
    winrt::Microsoft::UI::Input::FocusNavigationReason const& reason,
    winrt::Windows::Foundation::Rect const& hintRect,
    winrt::guid const& correlationId) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IFocusNavigationRequestStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IFocusNavigationRequestStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWithHintRectAndId(
        static_cast<int32_t>(reason), impl::bind_in(hintRect),
        impl::bind_in(correlationId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)this;
    check_hresult(_winrt_abi_type->CreateWithHintRectAndId(
        static_cast<int32_t>(reason), impl::bind_in(hintRect),
        impl::bind_in(correlationId), &result));
  }
  return winrt::Microsoft::UI::Input::FocusNavigationRequest{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::AutoProcessInertia()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AutoProcessInertia(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_AutoProcessInertia(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::AutoProcessInertia(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_AutoProcessInertia(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_AutoProcessInertia(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideExact() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CrossSlideExact(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_CrossSlideExact(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideExact(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_CrossSlideExact(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_CrossSlideExact(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideHorizontally()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CrossSlideHorizontally(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_CrossSlideHorizontally(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideHorizontally(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_CrossSlideHorizontally(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_CrossSlideHorizontally(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideThresholds()
    const {
  winrt::Microsoft::UI::Input::CrossSlideThresholds value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CrossSlideThresholds(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_CrossSlideThresholds(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideThresholds(
    winrt::Microsoft::UI::Input::CrossSlideThresholds const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_CrossSlideThresholds(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(
        _winrt_abi_type->put_CrossSlideThresholds(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::GestureSettings() const {
  winrt::Microsoft::UI::Input::GestureSettings value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_GestureSettings(
        reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_GestureSettings(
        reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::GestureSettings(
    winrt::Microsoft::UI::Input::GestureSettings const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_GestureSettings(static_cast<uint32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(
        _winrt_abi_type->put_GestureSettings(static_cast<uint32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::IsActive() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsActive(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_IsActive(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::IsInertial() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsInertial(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_IsInertial(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotCenter() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PivotCenter(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_PivotCenter(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotCenter(
    winrt::Windows::Foundation::Point const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PivotCenter(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_PivotCenter(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotRadius() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PivotRadius(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_PivotRadius(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotRadius(
    float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PivotRadius(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_PivotRadius(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaExpansionDeceleration() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InertiaExpansionDeceleration(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_InertiaExpansionDeceleration(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaExpansionDeceleration(float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InertiaExpansionDeceleration(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_InertiaExpansionDeceleration(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaExpansion()
    const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InertiaExpansion(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_InertiaExpansion(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaExpansion(
    float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InertiaExpansion(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_InertiaExpansion(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaRotationAngle()
    const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InertiaRotationAngle(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_InertiaRotationAngle(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaRotationAngle(
    float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InertiaRotationAngle(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_InertiaRotationAngle(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaRotationDeceleration() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InertiaRotationDeceleration(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_InertiaRotationDeceleration(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaRotationDeceleration(float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InertiaRotationDeceleration(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_InertiaRotationDeceleration(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaTranslationDeceleration() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InertiaTranslationDeceleration(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_InertiaTranslationDeceleration(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaTranslationDeceleration(float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InertiaTranslationDeceleration(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_InertiaTranslationDeceleration(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaTranslationDisplacement() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InertiaTranslationDisplacement(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_InertiaTranslationDisplacement(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::InertiaTranslationDisplacement(float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InertiaTranslationDisplacement(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_InertiaTranslationDisplacement(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationExact()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ManipulationExact(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_ManipulationExact(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationExact(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ManipulationExact(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_ManipulationExact(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::MouseWheelParameters()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MouseWheelParameters(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_MouseWheelParameters(&value));
  }
  return winrt::Microsoft::UI::Input::MouseWheelParameters{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ShowGestureFeedback()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ShowGestureFeedback(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->get_ShowGestureFeedback(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ShowGestureFeedback(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ShowGestureFeedback(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->put_ShowGestureFeedback(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CanBeDoubleTap(
    winrt::Microsoft::UI::Input::PointerPoint const& value) const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CanBeDoubleTap(*(void**)(&value), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->CanBeDoubleTap(*(void**)(&value), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CompleteGesture() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CompleteGesture());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->CompleteGesture());
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessDownEvent(
    winrt::Microsoft::UI::Input::PointerPoint const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProcessDownEvent(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->ProcessDownEvent(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessMoveEvents(
    param::vector<winrt::Microsoft::UI::Input::PointerPoint> const& value)
    const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProcessMoveEvents(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->ProcessMoveEvents(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessMouseWheelEvent(
    winrt::Microsoft::UI::Input::PointerPoint const& value, bool isShiftKeyDown,
    bool isControlKeyDown) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProcessMouseWheelEvent(
        *(void**)(&value), isShiftKeyDown, isControlKeyDown));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->ProcessMouseWheelEvent(
        *(void**)(&value), isShiftKeyDown, isControlKeyDown));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessInertia() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProcessInertia());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->ProcessInertia());
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessUpEvent(
    winrt::Microsoft::UI::Input::PointerPoint const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProcessUpEvent(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->ProcessUpEvent(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Tapped(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::TappedEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Tapped(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(
        _winrt_abi_type->add_Tapped(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Tapped(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::TappedEventArgs> const& handler) const {
  return impl::make_event_revoker<D, Tapped_revoker>(this, Tapped(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Tapped(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Tapped(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_Tapped(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::RightTapped(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::RightTappedEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_RightTapped(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(
        _winrt_abi_type->add_RightTapped(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::RightTapped(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::RightTappedEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, RightTapped_revoker>(this,
                                                          RightTapped(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::RightTapped(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_RightTapped(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_RightTapped(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Holding(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::HoldingEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Holding(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(
        _winrt_abi_type->add_Holding(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Holding(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::HoldingEventArgs> const& handler) const {
  return impl::make_event_revoker<D, Holding_revoker>(this, Holding(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Holding(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Holding(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_Holding(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Dragging(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::DraggingEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Dragging(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(
        _winrt_abi_type->add_Dragging(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Dragging(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::DraggingEventArgs> const& handler) const {
  return impl::make_event_revoker<D, Dragging_revoker>(this, Dragging(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Dragging(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Dragging(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_Dragging(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationStarted(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::ManipulationStartedEventArgs> const&
        handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ManipulationStarted(*(void**)(&handler),
                                                           put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->add_ManipulationStarted(*(void**)(&handler),
                                                           put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationStarted(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::ManipulationStartedEventArgs> const&
        handler) const {
  return impl::make_event_revoker<D, ManipulationStarted_revoker>(
      this, ManipulationStarted(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationStarted(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ManipulationStarted(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_ManipulationStarted(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationUpdated(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs> const&
        handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ManipulationUpdated(*(void**)(&handler),
                                                           put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->add_ManipulationUpdated(*(void**)(&handler),
                                                           put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationUpdated(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs> const&
        handler) const {
  return impl::make_event_revoker<D, ManipulationUpdated_revoker>(
      this, ManipulationUpdated(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationUpdated(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ManipulationUpdated(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_ManipulationUpdated(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::
    ManipulationInertiaStarting(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::
                ManipulationInertiaStartingEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ManipulationInertiaStarting(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->add_ManipulationInertiaStarting(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::
    ManipulationInertiaStarting(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::
                ManipulationInertiaStartingEventArgs> const& handler) const {
  return impl::make_event_revoker<D, ManipulationInertiaStarting_revoker>(
      this, ManipulationInertiaStarting(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<
    D>::ManipulationInertiaStarting(winrt::event_token const& token)
    const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ManipulationInertiaStarting(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_ManipulationInertiaStarting(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationCompleted(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs> const&
        handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ManipulationCompleted(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(_winrt_abi_type->add_ManipulationCompleted(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationCompleted(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs> const&
        handler) const {
  return impl::make_event_revoker<D, ManipulationCompleted_revoker>(
      this, ManipulationCompleted(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationCompleted(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ManipulationCompleted(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_ManipulationCompleted(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSliding(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::CrossSlidingEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_CrossSliding(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    check_hresult(
        _winrt_abi_type->add_CrossSliding(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSliding(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::GestureRecognizer,
        winrt::Microsoft::UI::Input::CrossSlidingEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, CrossSliding_revoker>(
      this, CrossSliding(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSliding(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IGestureRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IGestureRecognizer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_CrossSliding(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
    _winrt_abi_type->remove_CrossSliding(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IHoldingEventArgs<D>::HoldingState() const {
  winrt::Microsoft::UI::Input::HoldingState value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IHoldingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IHoldingEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IHoldingEventArgs>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_HoldingState(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)this;
    check_hresult(
        _winrt_abi_type->get_HoldingState(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IHoldingEventArgs<D>::PointerDeviceType()
    const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IHoldingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IHoldingEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IHoldingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IHoldingEventArgs<D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IHoldingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IHoldingEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IHoldingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputActivationListener<D>::State() const {
  winrt::Microsoft::UI::Input::InputActivationState value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputActivationListener>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputActivationListener, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputActivationListener>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)this;
    check_hresult(
        _winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputActivationListener<D>::
    InputActivationChanged(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputActivationListener,
            winrt::Microsoft::UI::Input::
                InputActivationListenerActivationChangedEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputActivationListener>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputActivationListener, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputActivationListener>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_InputActivationChanged(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)this;
    check_hresult(_winrt_abi_type->add_InputActivationChanged(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputActivationListener<D>::
    InputActivationChanged(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputActivationListener,
            winrt::Microsoft::UI::Input::
                InputActivationListenerActivationChangedEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, InputActivationChanged_revoker>(
      this, InputActivationChanged(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputActivationListener<
    D>::InputActivationChanged(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputActivationListener>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputActivationListener, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputActivationListener>**)&_winrt_casted_result;
    _winrt_abi_type->remove_InputActivationChanged(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)this;
    _winrt_abi_type->remove_InputActivationChanged(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputActivationListenerStatics<
    D>::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputActivationListenerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputActivationListenerStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputActivationListenerStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputActivationListenerStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
  }
  return winrt::Microsoft::UI::Input::InputActivationListener{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputActivationListenerStatics2<
    D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island)
    const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputActivationListenerStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputActivationListenerStatics2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputActivationListenerStatics2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputActivationListenerStatics2>**)this;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  }
  return winrt::Microsoft::UI::Input::InputActivationListener{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputCursorStatics<D>::CreateFromCoreCursor(
    winrt::Windows::UI::Core::CoreCursor const& cursor) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputCursorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputCursorStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputCursorStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateFromCoreCursor(*(void**)(&cursor), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputCursorStatics>**)this;
    check_hresult(
        _winrt_abi_type->CreateFromCoreCursor(*(void**)(&cursor), &result));
  }
  return winrt::Microsoft::UI::Input::InputCursor{result,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursor<
    D>::ModuleName() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputDesktopNamedResourceCursor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopNamedResourceCursor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ModuleName(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopNamedResourceCursor>**)this;
    check_hresult(_winrt_abi_type->get_ModuleName(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursor<
    D>::ResourceName() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputDesktopNamedResourceCursor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopNamedResourceCursor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ResourceName(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopNamedResourceCursor>**)this;
    check_hresult(_winrt_abi_type->get_ResourceName(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursorStatics<
    D>::Create(param::hstring const& resourceName) const {
  void* result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::
                                    IInputDesktopNamedResourceCursorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IInputDesktopNamedResourceCursorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(*(void**)(&resourceName), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopNamedResourceCursorStatics>**)this;
    check_hresult(_winrt_abi_type->Create(*(void**)(&resourceName), &result));
  }
  return winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursorStatics<
    D>::CreateFromModule(param::hstring const& moduleName,
                         param::hstring const& resourceName) const {
  void* result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::
                                    IInputDesktopNamedResourceCursorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IInputDesktopNamedResourceCursorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateFromModule(
        *(void**)(&moduleName), *(void**)(&resourceName), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopNamedResourceCursorStatics>**)this;
    check_hresult(_winrt_abi_type->CreateFromModule(
        *(void**)(&moduleName), *(void**)(&resourceName), &result));
  }
  return winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopResourceCursor<D>::ModuleName()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopResourceCursor, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopResourceCursor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ModuleName(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>**)this;
    check_hresult(_winrt_abi_type->get_ModuleName(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopResourceCursor<D>::ResourceId()
    const {
  uint32_t value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopResourceCursor, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopResourceCursor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ResourceId(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>**)this;
    check_hresult(_winrt_abi_type->get_ResourceId(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopResourceCursorStatics<D>::Create(
    uint32_t resourceId) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputDesktopResourceCursorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopResourceCursorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(resourceId, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopResourceCursorStatics>**)this;
    check_hresult(_winrt_abi_type->Create(resourceId, &result));
  }
  return winrt::Microsoft::UI::Input::InputDesktopResourceCursor{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputDesktopResourceCursorStatics<
    D>::CreateFromModule(param::hstring const& moduleName,
                         uint32_t resourceId) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputDesktopResourceCursorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopResourceCursorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateFromModule(*(void**)(&moduleName),
                                                    resourceId, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputDesktopResourceCursorStatics>**)this;
    check_hresult(_winrt_abi_type->CreateFromModule(*(void**)(&moduleName),
                                                    resourceId, &result));
  }
  return winrt::Microsoft::UI::Input::InputDesktopResourceCursor{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::HasFocus() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HasFocus(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
    check_hresult(_winrt_abi_type->get_HasFocus(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::TrySetFocus() const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TrySetFocus(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
    check_hresult(_winrt_abi_type->TrySetFocus(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::GotFocus(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputFocusController,
        winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
    check_hresult(
        _winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::GotFocus(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputFocusController,
        winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, GotFocus_revoker>(this, GotFocus(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::GotFocus(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController>**)&_winrt_casted_result;
    _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
    _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::LostFocus(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputFocusController,
        winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_LostFocus(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
    check_hresult(
        _winrt_abi_type->add_LostFocus(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::LostFocus(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputFocusController,
        winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, LostFocus_revoker>(this,
                                                        LostFocus(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController<D>::LostFocus(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController>**)&_winrt_casted_result;
    _winrt_abi_type->remove_LostFocus(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
    _winrt_abi_type->remove_LostFocus(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController2<D>::DepartFocus(
    winrt::Microsoft::UI::Input::FocusNavigationRequest const& request) const {
  winrt::Microsoft::UI::Input::FocusNavigationResult result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->DepartFocus(
        *(void**)(&request), reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)this;
    check_hresult(_winrt_abi_type->DepartFocus(
        *(void**)(&request), reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController2<D>::
    NavigateFocusRequested(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputFocusController,
            winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_NavigateFocusRequested(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)this;
    check_hresult(_winrt_abi_type->add_NavigateFocusRequested(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController2<D>::
    NavigateFocusRequested(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputFocusController,
            winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, NavigateFocusRequested_revoker>(
      this, NavigateFocusRequested(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusController2<
    D>::NavigateFocusRequested(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputFocusController2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusController2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusController2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_NavigateFocusRequested(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)this;
    _winrt_abi_type->remove_NavigateFocusRequested(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusControllerStatics<D>::GetForIsland(
    winrt::Microsoft::UI::Content::ContentIsland const& island) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputFocusControllerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusControllerStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusControllerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputFocusControllerStatics>**)this;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  }
  return winrt::Microsoft::UI::Input::InputFocusController{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::ContainsFocus()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputFocusNavigationHost>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHost>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ContainsFocus(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
    check_hresult(_winrt_abi_type->get_ContainsFocus(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::NavigateFocus(
    winrt::Microsoft::UI::Input::FocusNavigationRequest const& request) const {
  winrt::Microsoft::UI::Input::FocusNavigationResult result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputFocusNavigationHost>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHost>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->NavigateFocus(
        *(void**)(&request), reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
    check_hresult(_winrt_abi_type->NavigateFocus(
        *(void**)(&request), reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::
    DepartFocusRequested(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputFocusNavigationHost,
            winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputFocusNavigationHost>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHost>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_DepartFocusRequested(*(void**)(&handler),
                                                            put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
    check_hresult(_winrt_abi_type->add_DepartFocusRequested(*(void**)(&handler),
                                                            put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::
    DepartFocusRequested(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputFocusNavigationHost,
            winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, DepartFocusRequested_revoker>(
      this, DepartFocusRequested(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<
    D>::DepartFocusRequested(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputFocusNavigationHost>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHost>**)&_winrt_casted_result;
    _winrt_abi_type->remove_DepartFocusRequested(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
    _winrt_abi_type->remove_DepartFocusRequested(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusNavigationHostStatics<D>::
    GetForSiteBridge(
        winrt::Microsoft::UI::Content::IContentSiteBridge const& site) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputFocusNavigationHostStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHostStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForSiteBridge(*(void**)(&site), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHostStatics>**)this;
    check_hresult(_winrt_abi_type->GetForSiteBridge(*(void**)(&site), &result));
  }
  return winrt::Microsoft::UI::Input::InputFocusNavigationHost{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputFocusNavigationHostStatics2<
    D>::GetForSiteLink(winrt::Microsoft::UI::Content::IContentSiteLink const&
                           contentSiteLink) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputFocusNavigationHostStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHostStatics2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetForSiteLink(*(void**)(&contentSiteLink), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputFocusNavigationHostStatics2>**)this;
    check_hresult(
        _winrt_abi_type->GetForSiteLink(*(void**)(&contentSiteLink), &result));
  }
  return winrt::Microsoft::UI::Input::InputFocusNavigationHost{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::GetCurrentKeyState(
    winrt::Windows::System::VirtualKey const& virtualKey) const {
  winrt::Microsoft::UI::Input::VirtualKeyStates result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetCurrentKeyState(
        static_cast<int32_t>(virtualKey),
        reinterpret_cast<uint32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(_winrt_abi_type->GetCurrentKeyState(
        static_cast<int32_t>(virtualKey),
        reinterpret_cast<uint32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::GetKeyState(
    winrt::Windows::System::VirtualKey const& virtualKey) const {
  winrt::Microsoft::UI::Input::VirtualKeyStates result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetKeyState(static_cast<int32_t>(virtualKey),
                                     reinterpret_cast<uint32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(
        _winrt_abi_type->GetKeyState(static_cast<int32_t>(virtualKey),
                                     reinterpret_cast<uint32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::CharacterReceived(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::CharacterReceivedEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_CharacterReceived(*(void**)(&handler),
                                                         put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(_winrt_abi_type->add_CharacterReceived(*(void**)(&handler),
                                                         put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::CharacterReceived(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::CharacterReceivedEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, CharacterReceived_revoker>(
      this, CharacterReceived(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::CharacterReceived(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_CharacterReceived(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    _winrt_abi_type->remove_CharacterReceived(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::ContextMenuKey(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ContextMenuKey(*(void**)(&handler),
                                                      put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(_winrt_abi_type->add_ContextMenuKey(*(void**)(&handler),
                                                      put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::ContextMenuKey(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, ContextMenuKey_revoker>(
      this, ContextMenuKey(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::ContextMenuKey(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ContextMenuKey(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    _winrt_abi_type->remove_ContextMenuKey(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyDown(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_KeyDown(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(
        _winrt_abi_type->add_KeyDown(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyDown(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  return impl::make_event_revoker<D, KeyDown_revoker>(this, KeyDown(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyDown(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_KeyDown(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    _winrt_abi_type->remove_KeyDown(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyUp(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_KeyUp(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(
        _winrt_abi_type->add_KeyUp(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyUp(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  return impl::make_event_revoker<D, KeyUp_revoker>(this, KeyUp(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyUp(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_KeyUp(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    _winrt_abi_type->remove_KeyUp(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyDown(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_SystemKeyDown(*(void**)(&handler),
                                                     put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(_winrt_abi_type->add_SystemKeyDown(*(void**)(&handler),
                                                     put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyDown(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  return impl::make_event_revoker<D, SystemKeyDown_revoker>(
      this, SystemKeyDown(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyDown(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_SystemKeyDown(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    _winrt_abi_type->remove_SystemKeyDown(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyUp(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_SystemKeyUp(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    check_hresult(
        _winrt_abi_type->add_SystemKeyUp(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyUp(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputKeyboardSource,
        winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const {
  return impl::make_event_revoker<D, SystemKeyUp_revoker>(this,
                                                          SystemKeyUp(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyUp(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_SystemKeyUp(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
    _winrt_abi_type->remove_SystemKeyUp(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSourceStatics<
    D>::GetKeyStateForCurrentThread(winrt::Windows::System::VirtualKey const&
                                        virtualKey) const {
  winrt::Windows::UI::Core::CoreVirtualKeyStates result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSourceStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetKeyStateForCurrentThread(
        static_cast<int32_t>(virtualKey),
        reinterpret_cast<uint32_t*>(&result)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>**)this;
    check_hresult(_winrt_abi_type->GetKeyStateForCurrentThread(
        static_cast<int32_t>(virtualKey),
        reinterpret_cast<uint32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputKeyboardSourceStatics2<D>::GetForIsland(
    winrt::Microsoft::UI::Content::ContentIsland const& island) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputKeyboardSourceStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputKeyboardSourceStatics2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2>**)this;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  }
  return winrt::Microsoft::UI::Input::InputKeyboardSource{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputLightDismissAction<D>::Dismissed(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputLightDismissAction,
        winrt::Microsoft::UI::Input::InputLightDismissEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputLightDismissAction>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputLightDismissAction, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputLightDismissAction>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Dismissed(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissAction>**)this;
    check_hresult(
        _winrt_abi_type->add_Dismissed(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputLightDismissAction<D>::Dismissed(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputLightDismissAction,
        winrt::Microsoft::UI::Input::InputLightDismissEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, Dismissed_revoker>(this,
                                                        Dismissed(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputLightDismissAction<D>::Dismissed(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputLightDismissAction>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputLightDismissAction, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputLightDismissAction>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Dismissed(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissAction>**)this;
    _winrt_abi_type->remove_Dismissed(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputLightDismissActionStatics<
    D>::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputLightDismissActionStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputLightDismissActionStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputLightDismissActionStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputLightDismissActionStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
  }
  return winrt::Microsoft::UI::Input::InputLightDismissAction{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<
    D>::DispatcherQueue() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueue{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<
    D>::ClearAllRegionRects() const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ClearAllRegionRects());
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->ClearAllRegionRects());
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<
    D>::ClearRegionRects(winrt::Microsoft::UI::Input::NonClientRegionKind const&
                             region) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->ClearRegionRects(static_cast<int32_t>(region)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(
        _winrt_abi_type->ClearRegionRects(static_cast<int32_t>(region)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::GetRegionRects(
    winrt::Microsoft::UI::Input::NonClientRegionKind const& region) const {
  uint32_t result_impl_size{};
  struct struct_Windows_Graphics_RectInt32* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetRegionRects(static_cast<int32_t>(region),
                                                  &result_impl_size, &result));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->GetRegionRects(static_cast<int32_t>(region),
                                                  &result_impl_size, &result));
  }
  return com_array<winrt::Windows::Graphics::RectInt32>{
      result, result_impl_size, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::SetRegionRects(
    winrt::Microsoft::UI::Input::NonClientRegionKind const& region,
    array_view<winrt::Windows::Graphics::RectInt32 const> rects) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetRegionRects(
        static_cast<int32_t>(region), rects.size(), get_abi(rects)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->SetRegionRects(
        static_cast<int32_t>(region), rects.size(), get_abi(rects)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::CaptionTapped(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs> const&
        handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_CaptionTapped(*(void**)(&handler),
                                                     put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_CaptionTapped(*(void**)(&handler),
                                                     put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::CaptionTapped(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs> const&
        handler) const {
  return impl::make_event_revoker<D, CaptionTapped_revoker>(
      this, CaptionTapped(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::CaptionTapped(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_CaptionTapped(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    _winrt_abi_type->remove_CaptionTapped(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerEntered(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler),
                                                      put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler),
                                                      put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerEntered(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, PointerEntered_revoker>(
      this, PointerEntered(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerEntered(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerExited(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler),
                                                     put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler),
                                                     put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerExited(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, PointerExited_revoker>(
      this, PointerExited(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerExited(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerMoved(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(
        _winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerMoved(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, PointerMoved_revoker>(
      this, PointerMoved(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerMoved(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerPressed(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler),
                                                      put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler),
                                                      put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerPressed(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler)
    const {
  return impl::make_event_revoker<D, PointerPressed_revoker>(
      this, PointerPressed(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerPressed(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::
    PointerReleased(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler),
                                                       put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler),
                                                       put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::
    PointerReleased(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, PointerReleased_revoker>(
      this, PointerReleased(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<
    D>::PointerReleased(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::RegionsChanged(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs> const&
        handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_RegionsChanged(*(void**)(&handler),
                                                      put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_RegionsChanged(*(void**)(&handler),
                                                      put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::RegionsChanged(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputNonClientPointerSource,
        winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs> const&
        handler) const {
  return impl::make_event_revoker<D, RegionsChanged_revoker>(
      this, RegionsChanged(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::RegionsChanged(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_RegionsChanged(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
    _winrt_abi_type->remove_RegionsChanged(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    EnteringMoveSize(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_EnteringMoveSize(*(void**)(&handler),
                                                        put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    check_hresult(_winrt_abi_type->add_EnteringMoveSize(*(void**)(&handler),
                                                        put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    EnteringMoveSize(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, EnteringMoveSize_revoker>(
      this, EnteringMoveSize(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<
    D>::EnteringMoveSize(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_EnteringMoveSize(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    _winrt_abi_type->remove_EnteringMoveSize(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    EnteredMoveSize(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_EnteredMoveSize(*(void**)(&handler),
                                                       put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    check_hresult(_winrt_abi_type->add_EnteredMoveSize(*(void**)(&handler),
                                                       put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    EnteredMoveSize(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, EnteredMoveSize_revoker>(
      this, EnteredMoveSize(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<
    D>::EnteredMoveSize(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_EnteredMoveSize(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    _winrt_abi_type->remove_EnteredMoveSize(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    WindowRectChanging(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::WindowRectChangingEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_WindowRectChanging(*(void**)(&handler),
                                                          put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    check_hresult(_winrt_abi_type->add_WindowRectChanging(*(void**)(&handler),
                                                          put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    WindowRectChanging(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::WindowRectChangingEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, WindowRectChanging_revoker>(
      this, WindowRectChanging(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<
    D>::WindowRectChanging(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_WindowRectChanging(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    _winrt_abi_type->remove_WindowRectChanging(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    WindowRectChanged(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::WindowRectChangedEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_WindowRectChanged(*(void**)(&handler),
                                                         put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    check_hresult(_winrt_abi_type->add_WindowRectChanged(*(void**)(&handler),
                                                         put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    WindowRectChanged(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::WindowRectChangedEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, WindowRectChanged_revoker>(
      this, WindowRectChanged(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<
    D>::WindowRectChanged(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_WindowRectChanged(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    _winrt_abi_type->remove_WindowRectChanged(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    ExitedMoveSize(winrt::Windows::Foundation::TypedEventHandler<
                   winrt::Microsoft::UI::Input::InputNonClientPointerSource,
                   winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs> const&
                       handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ExitedMoveSize(*(void**)(&handler),
                                                      put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    check_hresult(_winrt_abi_type->add_ExitedMoveSize(*(void**)(&handler),
                                                      put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::
    ExitedMoveSize(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, ExitedMoveSize_revoker>(
      this, ExitedMoveSize(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<
    D>::ExitedMoveSize(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSource2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ExitedMoveSize(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
    _winrt_abi_type->remove_ExitedMoveSize(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputNonClientPointerSourceStatics<
    D>::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IInputNonClientPointerSourceStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::
                  IInputNonClientPointerSourceStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputNonClientPointerSourceStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
  }
  return winrt::Microsoft::UI::Input::InputNonClientPointerSource{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputObject<D>::DispatcherQueue() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputObject>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputObject,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IInputObject>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputObject>**)this;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueue{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::Cursor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Cursor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->get_Cursor(&value));
  }
  return winrt::Microsoft::UI::Input::InputCursor{value,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::Cursor(
    winrt::Microsoft::UI::Input::InputCursor const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Cursor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->put_Cursor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::DeviceKinds() const {
  winrt::Microsoft::UI::Input::InputPointerSourceDeviceKinds value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_DeviceKinds(reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(
        _winrt_abi_type->get_DeviceKinds(reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerCaptureLost(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerCaptureLost(*(void**)(&handler),
                                                          put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerCaptureLost(*(void**)(&handler),
                                                          put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerCaptureLost(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerCaptureLost_revoker>(
      this, PointerCaptureLost(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerCaptureLost(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerCaptureLost(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerCaptureLost(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerEntered(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler),
                                                      put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler),
                                                      put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerEntered(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerEntered_revoker>(
      this, PointerEntered(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerEntered(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerExited(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler),
                                                     put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler),
                                                     put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerExited(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerExited_revoker>(
      this, PointerExited(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerExited(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerMoved(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(
        _winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerMoved(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerMoved_revoker>(
      this, PointerMoved(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerMoved(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerPressed(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler),
                                                      put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler),
                                                      put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerPressed(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerPressed_revoker>(
      this, PointerPressed(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerPressed(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerReleased(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler),
                                                       put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler),
                                                       put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerReleased(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerReleased_revoker>(
      this, PointerReleased(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerReleased(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedAway(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerRoutedAway(*(void**)(&handler),
                                                         put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerRoutedAway(*(void**)(&handler),
                                                         put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedAway(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerRoutedAway_revoker>(
      this, PointerRoutedAway(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedAway(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerRoutedAway(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerRoutedAway(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedReleased(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerRoutedReleased(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerRoutedReleased(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedReleased(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerRoutedReleased_revoker>(
      this, PointerRoutedReleased(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedReleased(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerRoutedReleased(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerRoutedReleased(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedTo(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerRoutedTo(*(void**)(&handler),
                                                       put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerRoutedTo(*(void**)(&handler),
                                                       put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedTo(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerRoutedTo_revoker>(
      this, PointerRoutedTo(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedTo(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerRoutedTo(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerRoutedTo(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerWheelChanged(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_PointerWheelChanged(*(void**)(&handler),
                                                           put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    check_hresult(_winrt_abi_type->add_PointerWheelChanged(*(void**)(&handler),
                                                           put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerWheelChanged(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::InputPointerSource,
        winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const {
  return impl::make_event_revoker<D, PointerWheelChanged_revoker>(
      this, PointerWheelChanged(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerWheelChanged(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputPointerSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_PointerWheelChanged(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
    _winrt_abi_type->remove_PointerWheelChanged(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPointerSourceStatics<D>::GetForIsland(
    winrt::Microsoft::UI::Content::ContentIsland const& island) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputPointerSourceStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPointerSourceStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPointerSourceStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSourceStatics>**)this;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  }
  return winrt::Microsoft::UI::Input::InputPointerSource{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputPreTranslateKeyboardSourceStatics<
    D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island)
    const {
  void* result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::
                                    IInputPreTranslateKeyboardSourceStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IInputPreTranslateKeyboardSourceStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputPreTranslateKeyboardSourceStatics>**)this;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
  }
  return winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputSystemCursor<D>::CursorShape() const {
  winrt::Microsoft::UI::Input::InputSystemCursorShape value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IInputSystemCursor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputSystemCursor, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputSystemCursor>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_CursorShape(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputSystemCursor>**)this;
    check_hresult(
        _winrt_abi_type->get_CursorShape(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IInputSystemCursorStatics<D>::Create(
    winrt::Microsoft::UI::Input::InputSystemCursorShape const& type) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IInputSystemCursorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IInputSystemCursorStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IInputSystemCursorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(static_cast<int32_t>(type), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IInputSystemCursorStatics>**)this;
    check_hresult(_winrt_abi_type->Create(static_cast<int32_t>(type), &result));
  }
  return winrt::Microsoft::UI::Input::InputSystemCursor{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::Handled() const {
  bool value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IKeyEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::Handled(bool value) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IKeyEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Handled(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_Handled(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::KeyStatus() const {
  winrt::Microsoft::UI::Input::PhysicalKeyStatus value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IKeyEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::Timestamp() const {
  uint64_t value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IKeyEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Timestamp(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Timestamp(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::VirtualKey() const {
  winrt::Windows::System::VirtualKey value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IKeyEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_VirtualKey(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
    check_hresult(
        _winrt_abi_type->get_VirtualKey(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<D>::Cumulative()
    const {
  winrt::Microsoft::UI::Input::ManipulationDelta value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationCompletedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<
    D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationCompletedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<D>::Position()
    const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationCompletedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<D>::Velocities()
    const {
  winrt::Microsoft::UI::Input::ManipulationVelocities value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationCompletedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationCompletedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<
    D>::Cumulative() const {
  winrt::Microsoft::UI::Input::ManipulationDelta value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationInertiaStartingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationInertiaStartingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<
    D>::Delta() const {
  winrt::Microsoft::UI::Input::ManipulationDelta value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationInertiaStartingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationInertiaStartingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<
    D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationInertiaStartingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationInertiaStartingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<
    D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationInertiaStartingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationInertiaStartingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<
    D>::Velocities() const {
  winrt::Microsoft::UI::Input::ManipulationVelocities value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationInertiaStartingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::
                IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationInertiaStartingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationStartedEventArgs<D>::Cumulative()
    const {
  winrt::Microsoft::UI::Input::ManipulationDelta value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationStartedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationStartedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationStartedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationStartedEventArgs<
    D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationStartedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationStartedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationStartedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationStartedEventArgs<D>::Position()
    const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationStartedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationStartedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationStartedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Cumulative()
    const {
  winrt::Microsoft::UI::Input::ManipulationDelta value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationUpdatedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Delta()
    const {
  winrt::Microsoft::UI::Input::ManipulationDelta value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationUpdatedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<
    D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationUpdatedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Position()
    const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationUpdatedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Velocities()
    const {
  winrt::Microsoft::UI::Input::ManipulationVelocities value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IManipulationUpdatedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::CharTranslation()
    const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CharTranslation(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->get_CharTranslation(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::CharTranslation(
    winrt::Windows::Foundation::Point const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_CharTranslation(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->put_CharTranslation(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaScale() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DeltaScale(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->get_DeltaScale(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaScale(
    float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_DeltaScale(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->put_DeltaScale(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaRotationAngle()
    const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DeltaRotationAngle(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->get_DeltaRotationAngle(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaRotationAngle(
    float value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_DeltaRotationAngle(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->put_DeltaRotationAngle(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::PageTranslation()
    const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PageTranslation(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->get_PageTranslation(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::PageTranslation(
    winrt::Windows::Foundation::Point const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IMouseWheelParameters>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IMouseWheelParameters>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PageTranslation(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
    check_hresult(_winrt_abi_type->put_PageTranslation(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_INonClientCaptionTappedEventArgs<D>::Point()
    const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       INonClientCaptionTappedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientCaptionTappedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientCaptionTappedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_INonClientCaptionTappedEventArgs<
    D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       INonClientCaptionTappedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientCaptionTappedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientCaptionTappedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<D>::Point() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::INonClientPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<
    D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::INonClientPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<D>::RegionKind()
    const {
  winrt::Microsoft::UI::Input::NonClientRegionKind value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::INonClientPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_RegionKind(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
    check_hresult(
        _winrt_abi_type->get_RegionKind(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<D>::IsPointInRegion()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::INonClientPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsPointInRegion(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_IsPointInRegion(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_INonClientRegionsChangedEventArgs<
    D>::ChangedRegions() const {
  uint32_t value_impl_size{};
  int32_t* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       INonClientRegionsChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientRegionsChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_ChangedRegions(&value_impl_size, &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    INonClientRegionsChangedEventArgs>**)this;
    check_hresult(
        _winrt_abi_type->get_ChangedRegions(&value_impl_size, &value));
  }
  return com_array<winrt::Microsoft::UI::Input::NonClientRegionKind>{
      value, value_impl_size, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::CurrentPoint() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CurrentPoint(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_CurrentPoint(&value));
  }
  return winrt::Microsoft::UI::Input::PointerPoint{value,
                                                   take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::Handled() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Handled(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::Handled(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Handled(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_Handled(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::KeyModifiers() const {
  winrt::Windows::System::VirtualKeyModifiers value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_KeyModifiers(reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
    check_hresult(
        _winrt_abi_type->get_KeyModifiers(reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::GetIntermediatePoints()
    const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetIntermediatePoints(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->GetIntermediatePoints(&result));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Microsoft::UI::Input::PointerPoint>{result,
                                                 take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::
    GetIntermediateTransformedPoints(
        winrt::Microsoft::UI::Input::IPointerPointTransform const& transform)
        const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetIntermediateTransformedPoints(
        *(void**)(&transform), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
    check_hresult(_winrt_abi_type->GetIntermediateTransformedPoints(
        *(void**)(&transform), &result));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Microsoft::UI::Input::PointerPoint>{result,
                                                 take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::FrameId() const {
  uint32_t value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_FrameId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(_winrt_abi_type->get_FrameId(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::IsInContact() const {
  bool value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsInContact(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(_winrt_abi_type->get_IsInContact(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::PointerId() const {
  uint32_t value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(_winrt_abi_type->get_PointerId(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::Properties() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Properties(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(_winrt_abi_type->get_Properties(&value));
  }
  return winrt::Microsoft::UI::Input::PointerPointProperties{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::Timestamp() const {
  uint64_t value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Timestamp(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(_winrt_abi_type->get_Timestamp(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPoint<D>::GetTransformedPoint(
    winrt::Microsoft::UI::Input::IPointerPointTransform const& transform)
    const {
  void* result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::IPointerPoint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetTransformedPoint(*(void**)(&transform), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
    check_hresult(
        _winrt_abi_type->GetTransformedPoint(*(void**)(&transform), &result));
  }
  return winrt::Microsoft::UI::Input::PointerPoint{result,
                                                   take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::ContactRect()
    const {
  winrt::Windows::Foundation::Rect value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ContactRect(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_ContactRect(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<
    D>::IsBarrelButtonPressed() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsBarrelButtonPressed(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsBarrelButtonPressed(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsCanceled() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsCanceled(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsCanceled(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsEraser() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsEraser(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsEraser(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<
    D>::IsHorizontalMouseWheel() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsHorizontalMouseWheel(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsHorizontalMouseWheel(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsInRange() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsInRange(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsInRange(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsInverted() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsInverted(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsInverted(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<
    D>::IsLeftButtonPressed() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsLeftButtonPressed(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsLeftButtonPressed(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<
    D>::IsMiddleButtonPressed() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsMiddleButtonPressed(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsMiddleButtonPressed(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsPrimary() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsPrimary(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsPrimary(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<
    D>::IsRightButtonPressed() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsRightButtonPressed(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsRightButtonPressed(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsXButton1Pressed()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsXButton1Pressed(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsXButton1Pressed(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsXButton2Pressed()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsXButton2Pressed(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_IsXButton2Pressed(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::MouseWheelDelta()
    const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MouseWheelDelta(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_MouseWheelDelta(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::Orientation()
    const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Orientation(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_Orientation(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::PointerUpdateKind()
    const {
  winrt::Microsoft::UI::Input::PointerUpdateKind value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerUpdateKind(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_PointerUpdateKind(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::Pressure() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Pressure(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_Pressure(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::TouchConfidence()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TouchConfidence(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_TouchConfidence(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::Twist() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Twist(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_Twist(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::XTilt() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_XTilt(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_XTilt(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::YTilt() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointProperties>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointProperties>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_YTilt(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
    check_hresult(_winrt_abi_type->get_YTilt(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointTransform<D>::Inverse() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointTransform>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointTransform, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointTransform>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Inverse(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)this;
    check_hresult(_winrt_abi_type->get_Inverse(&value));
  }
  return winrt::Microsoft::UI::Input::IPointerPointTransform{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointTransform<D>::TryTransform(
    winrt::Windows::Foundation::Point const& inPoint,
    winrt::Windows::Foundation::Point& outPoint) const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointTransform>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointTransform, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointTransform>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TryTransform(
        impl::bind_in(inPoint), impl::bind_out(outPoint), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)this;
    check_hresult(_winrt_abi_type->TryTransform(
        impl::bind_in(inPoint), impl::bind_out(outPoint), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPointTransform<D>::TryTransformBounds(
    winrt::Windows::Foundation::Rect const& inRect,
    winrt::Windows::Foundation::Rect& outRect) const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPointTransform>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPointTransform, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPointTransform>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TryTransformBounds(
        impl::bind_in(inRect), impl::bind_out(outRect), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)this;
    check_hresult(_winrt_abi_type->TryTransformBounds(
        impl::bind_in(inRect), impl::bind_out(outRect), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPredictor<D>::PredictionTime() const {
  winrt::Windows::Foundation::TimeSpan value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPredictor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPredictor,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPredictor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PredictionTime(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)this;
    check_hresult(_winrt_abi_type->get_PredictionTime(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPredictor<D>::PredictionTime(
    winrt::Windows::Foundation::TimeSpan const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPredictor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPredictor,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPredictor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PredictionTime(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)this;
    check_hresult(_winrt_abi_type->put_PredictionTime(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPredictor<D>::GetPredictedPoints(
    winrt::Microsoft::UI::Input::PointerPoint const& point) const {
  uint32_t result_impl_size{};
  void** result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPredictor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPredictor,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPredictor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetPredictedPoints(
        *(void**)(&point), &result_impl_size, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)this;
    check_hresult(_winrt_abi_type->GetPredictedPoints(
        *(void**)(&point), &result_impl_size, &result));
  }
  return com_array<winrt::Microsoft::UI::Input::PointerPoint>{
      result, result_impl_size, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IPointerPredictorStatics<D>::
    CreateForInputPointerSource(
        winrt::Microsoft::UI::Input::InputPointerSource const&
            inputPointerSource) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IPointerPredictorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IPointerPredictorStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IPointerPredictorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateForInputPointerSource(
        *(void**)(&inputPointerSource), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictorStatics>**)this;
    check_hresult(_winrt_abi_type->CreateForInputPointerSource(
        *(void**)(&inputPointerSource), &result));
  }
  return winrt::Microsoft::UI::Input::PointerPredictor{result,
                                                       take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_IRightTappedEventArgs<D>::PointerDeviceType()
    const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IRightTappedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IRightTappedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IRightTappedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IRightTappedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IRightTappedEventArgs<D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::IRightTappedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IRightTappedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IRightTappedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::IRightTappedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_ITappedEventArgs<D>::PointerDeviceType() const {
  winrt::Microsoft::UI::Input::PointerDeviceType value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::ITappedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::ITappedEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ITappedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerDeviceType(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_ITappedEventArgs<D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::ITappedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::ITappedEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ITappedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_ITappedEventArgs<D>::TapCount() const {
  uint32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::ITappedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::ITappedEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    ITappedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TapCount(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_TapCount(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<
    D>::PointerScreenPoint() const {
  winrt::Windows::Graphics::PointInt32 value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<
    D>::MoveSizeOperation() const {
  winrt::Microsoft::UI::Input::MoveSizeOperation value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<D>::OldWindowRect()
    const {
  winrt::Windows::Graphics::RectInt32 value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<D>::NewWindowRect()
    const {
  winrt::Windows::Graphics::RectInt32 value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<
    D>::PointerScreenPoint() const {
  winrt::Windows::Graphics::PointInt32 value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<
    D>::MoveSizeOperation() const {
  winrt::Microsoft::UI::Input::MoveSizeOperation value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_MoveSizeOperation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::OldWindowRect()
    const {
  winrt::Windows::Graphics::RectInt32 value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::NewWindowRect()
    const {
  winrt::Windows::Graphics::RectInt32 value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::NewWindowRect(
    winrt::Windows::Graphics::RectInt32 const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_NewWindowRect(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_NewWindowRect(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<
    D>::AllowRectChange() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AllowRectChange(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_AllowRectChange(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<
    D>::AllowRectChange(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_AllowRectChange(value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_AllowRectChange(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::ShowWindow()
    const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ShowWindow(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_ShowWindow(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::ShowWindow(
    bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::
                                       IWindowRectChangingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::
                    IWindowRectChangingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ShowWindow(value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_ShowWindow(value));
  }
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs> {
  int32_t __stdcall get_Handled(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().Handled());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Handled(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Handled(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_KeyCode(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().KeyCode());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_KeyStatus(
      struct struct_Microsoft_UI_Input_PhysicalKeyStatus* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(
        this->shim().KeyStatus());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs> {
  int32_t __stdcall get_Handled(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().Handled());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Handled(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Handled(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs> {
  int32_t __stdcall get_CrossSlidingState(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::CrossSlidingState>(
        this->shim().CrossSlidingState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IDraggingEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IDraggingEventArgs> {
  int32_t __stdcall get_DraggingState(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::DraggingState>(
        this->shim().DraggingState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs> {
  int32_t __stdcall get_PointerScreenPoint(
      struct struct_Windows_Graphics_PointInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::PointInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::PointInt32>(
        this->shim().PointerScreenPoint());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(
        this->shim().MoveSizeOperation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs> {
  int32_t __stdcall get_PointerScreenPoint(
      struct struct_Windows_Graphics_PointInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::PointInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::PointInt32>(
        this->shim().PointerScreenPoint());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(
        this->shim().MoveSizeOperation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MoveSizeWindowId(
      struct struct_Microsoft_UI_WindowId* value) noexcept final try {
    zero_abi<winrt::Microsoft::UI::WindowId>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::WindowId>(
        this->shim().MoveSizeWindowId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_MoveSizeWindowId(
      struct struct_Microsoft_UI_WindowId value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().MoveSizeWindowId(
        *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs> {
  int32_t __stdcall get_PointerScreenPoint(
      struct struct_Windows_Graphics_PointInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::PointInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::PointInt32>(
        this->shim().PointerScreenPoint());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(
        this->shim().MoveSizeOperation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs> {
  int32_t __stdcall get_Handled(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().Handled());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Handled(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Handled(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>
    : produce_base<D, winrt::Microsoft::UI::Input::IFocusNavigationRequest> {
  int32_t __stdcall get_CorrelationId(winrt::guid* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::guid>(this->shim().CorrelationId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_HintRect(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::IReference<
        winrt::Windows::Foundation::Rect>>(this->shim().HintRect());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Reason(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::FocusNavigationReason>(
        this->shim().Reason());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs> {
  int32_t __stdcall get_Request(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(
        this->shim().Request());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Result(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::FocusNavigationResult>(
        this->shim().Result());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Result(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Result(
        *reinterpret_cast<
            winrt::Microsoft::UI::Input::FocusNavigationResult const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics> {
  int32_t __stdcall Create(int32_t reason, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(
        this->shim().Create(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::FocusNavigationReason const*>(
                &reason)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateWithHintRect(
      int32_t reason, winrt::Windows::Foundation::Rect hintRect,
      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(
        this->shim().Create(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::FocusNavigationReason const*>(
                &reason),
            *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(
                &hintRect)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateWithHintRectAndId(
      int32_t reason, winrt::Windows::Foundation::Rect hintRect,
      winrt::guid correlationId, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(
        this->shim().Create(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::FocusNavigationReason const*>(
                &reason),
            *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(
                &hintRect),
            *reinterpret_cast<winrt::guid const*>(&correlationId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IGestureRecognizer>
    : produce_base<D, winrt::Microsoft::UI::Input::IGestureRecognizer> {
  int32_t __stdcall get_AutoProcessInertia(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().AutoProcessInertia());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AutoProcessInertia(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AutoProcessInertia(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_CrossSlideExact(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().CrossSlideExact());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_CrossSlideExact(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CrossSlideExact(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_CrossSlideHorizontally(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().CrossSlideHorizontally());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_CrossSlideHorizontally(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CrossSlideHorizontally(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_CrossSlideThresholds(
      struct struct_Microsoft_UI_Input_CrossSlideThresholds* value) noexcept
      final try {
    zero_abi<winrt::Microsoft::UI::Input::CrossSlideThresholds>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::CrossSlideThresholds>(
        this->shim().CrossSlideThresholds());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_CrossSlideThresholds(
      struct struct_Microsoft_UI_Input_CrossSlideThresholds value) noexcept
      final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CrossSlideThresholds(
        *reinterpret_cast<
            winrt::Microsoft::UI::Input::CrossSlideThresholds const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_GestureSettings(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::GestureSettings>(
        this->shim().GestureSettings());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_GestureSettings(uint32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().GestureSettings(
        *reinterpret_cast<winrt::Microsoft::UI::Input::GestureSettings const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsActive(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsActive());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsInertial(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsInertial());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PivotCenter(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Point>(
        this->shim().PivotCenter());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PivotCenter(
      winrt::Windows::Foundation::Point value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PivotCenter(
        *reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PivotRadius(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().PivotRadius());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PivotRadius(float value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PivotRadius(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InertiaExpansionDeceleration(
      float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().InertiaExpansionDeceleration());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InertiaExpansionDeceleration(float value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().InertiaExpansionDeceleration(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InertiaExpansion(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().InertiaExpansion());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InertiaExpansion(float value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InertiaExpansion(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InertiaRotationAngle(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().InertiaRotationAngle());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InertiaRotationAngle(float value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InertiaRotationAngle(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InertiaRotationDeceleration(float* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().InertiaRotationDeceleration());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InertiaRotationDeceleration(float value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().InertiaRotationDeceleration(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InertiaTranslationDeceleration(
      float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().InertiaTranslationDeceleration());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InertiaTranslationDeceleration(
      float value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InertiaTranslationDeceleration(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InertiaTranslationDisplacement(
      float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().InertiaTranslationDisplacement());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InertiaTranslationDisplacement(
      float value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InertiaTranslationDisplacement(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ManipulationExact(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ManipulationExact());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ManipulationExact(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ManipulationExact(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MouseWheelParameters(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::MouseWheelParameters>(
        this->shim().MouseWheelParameters());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ShowGestureFeedback(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ShowGestureFeedback());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ShowGestureFeedback(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ShowGestureFeedback(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CanBeDoubleTap(void* value, bool* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().CanBeDoubleTap(
        *reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(
            &value)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CompleteGesture() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CompleteGesture();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProcessDownEvent(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ProcessDownEvent(
        *reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProcessMoveEvents(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ProcessMoveEvents(
        *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<
            winrt::Microsoft::UI::Input::PointerPoint> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProcessMouseWheelEvent(void* value, bool isShiftKeyDown,
                                           bool isControlKeyDown) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ProcessMouseWheelEvent(
        *reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(
            &value),
        isShiftKeyDown, isControlKeyDown);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProcessInertia() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ProcessInertia();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProcessUpEvent(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ProcessUpEvent(
        *reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_Tapped(void* handler,
                               winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Tapped(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::TappedEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Tapped(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Tapped(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_RightTapped(void* handler,
                                    winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().RightTapped(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::RightTappedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_RightTapped(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().RightTapped(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_Holding(void* handler,
                                winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Holding(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::HoldingEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Holding(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Holding(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_Dragging(void* handler,
                                 winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Dragging(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::DraggingEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Dragging(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Dragging(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_ManipulationStarted(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ManipulationStarted(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::ManipulationStartedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ManipulationStarted(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ManipulationStarted(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_ManipulationUpdated(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ManipulationUpdated(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ManipulationUpdated(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ManipulationUpdated(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_ManipulationInertiaStarting(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(
        this->shim().ManipulationInertiaStarting(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Microsoft::UI::Input::GestureRecognizer,
                winrt::Microsoft::UI::Input::
                    ManipulationInertiaStartingEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ManipulationInertiaStarting(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ManipulationInertiaStarting(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_ManipulationCompleted(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ManipulationCompleted(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::
                ManipulationCompletedEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ManipulationCompleted(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ManipulationCompleted(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_CrossSliding(void* handler,
                                     winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().CrossSliding(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::GestureRecognizer,
            winrt::Microsoft::UI::Input::CrossSlidingEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_CrossSliding(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().CrossSliding(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IHoldingEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IHoldingEventArgs> {
  int32_t __stdcall get_HoldingState(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::HoldingState>(
        this->shim().HoldingState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputActivationListener>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputActivationListener> {
  int32_t __stdcall get_State(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::InputActivationState>(
        this->shim().State());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_InputActivationChanged(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token =
        detach_from<winrt::event_token>(this->shim().InputActivationChanged(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Microsoft::UI::Input::InputActivationListener,
                winrt::Microsoft::UI::Input::
                    InputActivationListenerActivationChangedEventArgs> const*>(
                &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_InputActivationChanged(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().InputActivationChanged(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::
                      IInputActivationListenerActivationChangedEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::
                          IInputActivationListenerActivationChangedEventArgs> {
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics> {
  int32_t __stdcall GetForWindowId(struct struct_Microsoft_UI_WindowId windowId,
                                   void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputActivationListener>(
        this->shim().GetForWindowId(
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                &windowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics2>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics2> {
  int32_t __stdcall GetForIsland(void* island, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputActivationListener>(
        this->shim().GetForIsland(
            *reinterpret_cast<
                winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputCursor>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputCursor> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputCursorFactory>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputCursorFactory> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputCursorStatics>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputCursorStatics> {
  int32_t __stdcall CreateFromCoreCursor(void* cursor,
                                         void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputCursor>(
        this->shim().CreateFromCoreCursor(
            *reinterpret_cast<winrt::Windows::UI::Core::CoreCursor const*>(
                &cursor)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputCustomCursor>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputCustomCursor> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputCustomCursorFactory>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputCustomCursorFactory> {
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor> {
  int32_t __stdcall get_ModuleName(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().ModuleName());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ResourceName(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().ResourceName());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>
    : produce_base<D, winrt::Microsoft::UI::Input::
                          IInputDesktopNamedResourceCursorStatics> {
  int32_t __stdcall Create(void* resourceName, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>(
        this->shim().Create(*reinterpret_cast<hstring const*>(&resourceName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateFromModule(void* moduleName, void* resourceName,
                                     void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>(
        this->shim().CreateFromModule(
            *reinterpret_cast<hstring const*>(&moduleName),
            *reinterpret_cast<hstring const*>(&resourceName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IInputDesktopResourceCursor> {
  int32_t __stdcall get_ModuleName(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().ModuleName());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ResourceId(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().ResourceId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics> {
  int32_t __stdcall Create(uint32_t resourceId, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>(
            this->shim().Create(resourceId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateFromModule(void* moduleName, uint32_t resourceId,
                                     void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>(
            this->shim().CreateFromModule(
                *reinterpret_cast<hstring const*>(&moduleName), resourceId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputFocusController>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusController> {
  int32_t __stdcall get_HasFocus(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().HasFocus());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TrySetFocus(bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().TrySetFocus());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_GotFocus(void* handler,
                                 winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().GotFocus(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputFocusController,
            winrt::Microsoft::UI::Input::FocusChangedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_GotFocus(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().GotFocus(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_LostFocus(void* handler,
                                  winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().LostFocus(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputFocusController,
            winrt::Microsoft::UI::Input::FocusChangedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_LostFocus(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().LostFocus(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputFocusController2>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusController2> {
  int32_t __stdcall DepartFocus(void* request, int32_t* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationResult>(
        this->shim().DepartFocus(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::FocusNavigationRequest const*>(
                &request)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_NavigateFocusRequested(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token =
        detach_from<winrt::event_token>(this->shim().NavigateFocusRequested(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Microsoft::UI::Input::InputFocusController,
                winrt::Microsoft::UI::Input::
                    FocusNavigationRequestEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_NavigateFocusRequested(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().NavigateFocusRequested(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputFocusControllerStatics>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IInputFocusControllerStatics> {
  int32_t __stdcall GetForIsland(void* island, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputFocusController>(
        this->shim().GetForIsland(
            *reinterpret_cast<
                winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost> {
  int32_t __stdcall get_ContainsFocus(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ContainsFocus());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall NavigateFocus(void* request, int32_t* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationResult>(
        this->shim().NavigateFocus(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::FocusNavigationRequest const*>(
                &request)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_DepartFocusRequested(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().DepartFocusRequested(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputFocusNavigationHost,
            winrt::Microsoft::UI::Input::
                FocusNavigationRequestEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_DepartFocusRequested(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().DepartFocusRequested(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics> {
  int32_t __stdcall GetForSiteBridge(void* site, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Input::InputFocusNavigationHost>(
            this->shim().GetForSiteBridge(
                *reinterpret_cast<
                    winrt::Microsoft::UI::Content::IContentSiteBridge const*>(
                    &site)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2> {
  int32_t __stdcall GetForSiteLink(void* contentSiteLink,
                                   void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Input::InputFocusNavigationHost>(
            this->shim().GetForSiteLink(
                *reinterpret_cast<
                    winrt::Microsoft::UI::Content::IContentSiteLink const*>(
                    &contentSiteLink)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSource>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputKeyboardSource> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2> {
  int32_t __stdcall GetCurrentKeyState(int32_t virtualKey,
                                       uint32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::VirtualKeyStates>(
        this->shim().GetCurrentKeyState(
            *reinterpret_cast<winrt::Windows::System::VirtualKey const*>(
                &virtualKey)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetKeyState(int32_t virtualKey,
                                uint32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::VirtualKeyStates>(
        this->shim().GetKeyState(
            *reinterpret_cast<winrt::Windows::System::VirtualKey const*>(
                &virtualKey)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_CharacterReceived(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().CharacterReceived(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputKeyboardSource,
            winrt::Microsoft::UI::Input::CharacterReceivedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_CharacterReceived(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().CharacterReceived(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_ContextMenuKey(void* handler,
                                       winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ContextMenuKey(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputKeyboardSource,
            winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ContextMenuKey(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ContextMenuKey(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_KeyDown(void* handler,
                                winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().KeyDown(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputKeyboardSource,
            winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_KeyDown(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().KeyDown(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_KeyUp(void* handler,
                              winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().KeyUp(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputKeyboardSource,
            winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_KeyUp(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().KeyUp(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_SystemKeyDown(void* handler,
                                      winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().SystemKeyDown(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputKeyboardSource,
            winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_SystemKeyDown(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().SystemKeyDown(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_SystemKeyUp(void* handler,
                                    winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().SystemKeyUp(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputKeyboardSource,
            winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_SystemKeyUp(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().SystemKeyUp(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics> {
  int32_t __stdcall GetKeyStateForCurrentThread(int32_t virtualKey,
                                                uint32_t* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::UI::Core::CoreVirtualKeyStates>(
        this->shim().GetKeyStateForCurrentThread(
            *reinterpret_cast<winrt::Windows::System::VirtualKey const*>(
                &virtualKey)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2> {
  int32_t __stdcall GetForIsland(void* island, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputKeyboardSource>(
        this->shim().GetForIsland(
            *reinterpret_cast<
                winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputLightDismissAction>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputLightDismissAction> {
  int32_t __stdcall add_Dismissed(void* handler,
                                  winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Dismissed(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputLightDismissAction,
            winrt::Microsoft::UI::Input::InputLightDismissEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Dismissed(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Dismissed(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputLightDismissActionStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputLightDismissActionStatics> {
  int32_t __stdcall GetForWindowId(struct struct_Microsoft_UI_WindowId windowId,
                                   void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputLightDismissAction>(
        this->shim().GetForWindowId(
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                &windowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputLightDismissEventArgs>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IInputLightDismissEventArgs> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IInputNonClientPointerSource> {
  int32_t __stdcall get_DispatcherQueue(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(
        this->shim().DispatcherQueue());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ClearAllRegionRects() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ClearAllRegionRects();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ClearRegionRects(int32_t region) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ClearRegionRects(
        *reinterpret_cast<
            winrt::Microsoft::UI::Input::NonClientRegionKind const*>(&region));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetRegionRects(
      int32_t region, uint32_t* __resultSize,
      struct struct_Windows_Graphics_RectInt32** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    std::tie(*__resultSize, *result) = detach_abi(this->shim().GetRegionRects(
        *reinterpret_cast<
            winrt::Microsoft::UI::Input::NonClientRegionKind const*>(&region)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetRegionRects(
      int32_t region, uint32_t __rectsSize,
      struct struct_Windows_Graphics_RectInt32* rects) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetRegionRects(
        *reinterpret_cast<
            winrt::Microsoft::UI::Input::NonClientRegionKind const*>(&region),
        array_view<winrt::Windows::Graphics::RectInt32 const>(
            reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(rects),
            reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(
                rects) +
                __rectsSize));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_CaptionTapped(void* handler,
                                      winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().CaptionTapped(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::
                NonClientCaptionTappedEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_CaptionTapped(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().CaptionTapped(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerEntered(void* handler,
                                       winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerEntered(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerEntered(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerEntered(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerExited(void* handler,
                                      winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerExited(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerExited(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerExited(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerMoved(void* handler,
                                     winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerMoved(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerMoved(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerMoved(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerPressed(void* handler,
                                       winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerPressed(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerPressed(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerPressed(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerReleased(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerReleased(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerReleased(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerReleased(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_RegionsChanged(void* handler,
                                       winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().RegionsChanged(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::
                NonClientRegionsChangedEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_RegionsChanged(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().RegionsChanged(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IInputNonClientPointerSource2> {
  int32_t __stdcall add_EnteringMoveSize(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().EnteringMoveSize(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_EnteringMoveSize(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().EnteringMoveSize(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_EnteredMoveSize(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().EnteredMoveSize(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_EnteredMoveSize(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().EnteredMoveSize(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_WindowRectChanging(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().WindowRectChanging(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::WindowRectChangingEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_WindowRectChanging(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().WindowRectChanging(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_WindowRectChanged(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().WindowRectChanged(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::WindowRectChangedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_WindowRectChanged(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().WindowRectChanged(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_ExitedMoveSize(void* handler,
                                       winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ExitedMoveSize(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputNonClientPointerSource,
            winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ExitedMoveSize(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ExitedMoveSize(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics> {
  int32_t __stdcall GetForWindowId(struct struct_Microsoft_UI_WindowId windowId,
                                   void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Input::InputNonClientPointerSource>(
            this->shim().GetForWindowId(
                *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                    &windowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputObject>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputObject> {
  int32_t __stdcall get_DispatcherQueue(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(
        this->shim().DispatcherQueue());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputObjectFactory>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputObjectFactory> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputPointerSource>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputPointerSource> {
  int32_t __stdcall get_Cursor(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::InputCursor>(
        this->shim().Cursor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Cursor(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Cursor(
        *reinterpret_cast<winrt::Microsoft::UI::Input::InputCursor const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeviceKinds(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::Input::InputPointerSourceDeviceKinds>(
            this->shim().DeviceKinds());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_PointerCaptureLost(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerCaptureLost(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerCaptureLost(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerCaptureLost(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerEntered(void* handler,
                                       winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerEntered(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerEntered(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerEntered(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerExited(void* handler,
                                      winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerExited(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerExited(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerExited(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerMoved(void* handler,
                                     winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerMoved(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerMoved(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerMoved(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerPressed(void* handler,
                                       winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerPressed(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerPressed(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerPressed(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerReleased(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerReleased(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerReleased(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerReleased(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerRoutedAway(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerRoutedAway(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerRoutedAway(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerRoutedAway(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerRoutedReleased(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerRoutedReleased(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerRoutedReleased(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerRoutedReleased(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerRoutedTo(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerRoutedTo(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerRoutedTo(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerRoutedTo(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_PointerWheelChanged(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().PointerWheelChanged(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::InputPointerSource,
            winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_PointerWheelChanged(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().PointerWheelChanged(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputPointerSourceStatics>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputPointerSourceStatics> {
  int32_t __stdcall GetForIsland(void* island, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputPointerSource>(
        this->shim().GetForIsland(
            *reinterpret_cast<
                winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSource>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSource> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics>
    : produce_base<D, winrt::Microsoft::UI::Input::
                          IInputPreTranslateKeyboardSourceStatics> {
  int32_t __stdcall GetForIsland(void* island, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource>(
        this->shim().GetForIsland(
            *reinterpret_cast<
                winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputSystemCursor>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputSystemCursor> {
  int32_t __stdcall get_CursorShape(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::InputSystemCursorShape>(
        this->shim().CursorShape());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IInputSystemCursorStatics>
    : produce_base<D, winrt::Microsoft::UI::Input::IInputSystemCursorStatics> {
  int32_t __stdcall Create(int32_t type, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::InputSystemCursor>(
        this->shim().Create(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::InputSystemCursorShape const*>(
                &type)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IKeyEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IKeyEventArgs> {
  int32_t __stdcall get_Handled(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().Handled());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Handled(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Handled(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_KeyStatus(
      struct struct_Microsoft_UI_Input_PhysicalKeyStatus* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(
        this->shim().KeyStatus());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Timestamp(uint64_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint64_t>(this->shim().Timestamp());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_VirtualKey(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::System::VirtualKey>(
        this->shim().VirtualKey());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>
    : produce_base<
          D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs> {
  int32_t __stdcall get_Cumulative(
      struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(
        this->shim().Cumulative());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Velocities(
      struct struct_Microsoft_UI_Input_ManipulationVelocities* value) noexcept
      final try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationVelocities>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationVelocities>(
        this->shim().Velocities());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>
    : produce_base<
          D,
          winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs> {
  int32_t __stdcall get_Cumulative(
      struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(
        this->shim().Cumulative());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Delta(
      struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(
        this->shim().Delta());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Velocities(
      struct struct_Microsoft_UI_Input_ManipulationVelocities* value) noexcept
      final try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationVelocities>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationVelocities>(
        this->shim().Velocities());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IManipulationStartedEventArgs> {
  int32_t __stdcall get_Cumulative(
      struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(
        this->shim().Cumulative());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs> {
  int32_t __stdcall get_Cumulative(
      struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(
        this->shim().Cumulative());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Delta(
      struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final
      try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(
        this->shim().Delta());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Velocities(
      struct struct_Microsoft_UI_Input_ManipulationVelocities* value) noexcept
      final try {
    zero_abi<winrt::Microsoft::UI::Input::ManipulationVelocities>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::ManipulationVelocities>(
        this->shim().Velocities());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>
    : produce_base<D, winrt::Microsoft::UI::Input::IMouseWheelParameters> {
  int32_t __stdcall get_CharTranslation(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Point>(
        this->shim().CharTranslation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_CharTranslation(
      winrt::Windows::Foundation::Point value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CharTranslation(
        *reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeltaScale(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().DeltaScale());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DeltaScale(float value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeltaScale(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeltaRotationAngle(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().DeltaRotationAngle());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DeltaRotationAngle(float value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeltaRotationAngle(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PageTranslation(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Point>(
        this->shim().PageTranslation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PageTranslation(
      winrt::Windows::Foundation::Point value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PageTranslation(
        *reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>
    : produce_base<
          D, winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs> {
  int32_t __stdcall get_Point(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Point());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs> {
  int32_t __stdcall get_Point(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Point());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RegionKind(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::NonClientRegionKind>(
        this->shim().RegionKind());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsPointInRegion(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsPointInRegion());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs>
    : produce_base<
          D, winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs> {
  int32_t __stdcall get_ChangedRegions(uint32_t* __valueSize,
                                       int32_t** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    std::tie(*__valueSize, *value) = detach_abi(this->shim().ChangedRegions());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IPointerEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IPointerEventArgs> {
  int32_t __stdcall get_CurrentPoint(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerPoint>(
        this->shim().CurrentPoint());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Handled(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().Handled());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Handled(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Handled(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_KeyModifiers(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::System::VirtualKeyModifiers>(
        this->shim().KeyModifiers());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetIntermediatePoints(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Microsoft::UI::Input::PointerPoint>>(
        this->shim().GetIntermediatePoints());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetIntermediateTransformedPoints(
      void* transform, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Microsoft::UI::Input::PointerPoint>>(
        this->shim().GetIntermediateTransformedPoints(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::IPointerPointTransform const*>(
                &transform)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IPointerPoint>
    : produce_base<D, winrt::Microsoft::UI::Input::IPointerPoint> {
  int32_t __stdcall get_FrameId(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().FrameId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsInContact(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsInContact());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerId(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().PointerId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Properties(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerPointProperties>(
        this->shim().Properties());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Timestamp(uint64_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint64_t>(this->shim().Timestamp());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetTransformedPoint(void* transform,
                                        void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::PointerPoint>(
        this->shim().GetTransformedPoint(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::IPointerPointTransform const*>(
                &transform)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IPointerPointProperties>
    : produce_base<D, winrt::Microsoft::UI::Input::IPointerPointProperties> {
  int32_t __stdcall get_ContactRect(
      winrt::Windows::Foundation::Rect* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Rect>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Rect>(
        this->shim().ContactRect());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsBarrelButtonPressed(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsBarrelButtonPressed());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsCanceled(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsCanceled());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsEraser(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsEraser());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsHorizontalMouseWheel(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsHorizontalMouseWheel());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsInRange(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsInRange());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsInverted(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsInverted());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsLeftButtonPressed(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsLeftButtonPressed());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsMiddleButtonPressed(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsMiddleButtonPressed());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsPrimary(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsPrimary());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsRightButtonPressed(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsRightButtonPressed());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsXButton1Pressed(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsXButton1Pressed());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsXButton2Pressed(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsXButton2Pressed());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MouseWheelDelta(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().MouseWheelDelta());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Orientation(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().Orientation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PointerUpdateKind(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerUpdateKind>(
        this->shim().PointerUpdateKind());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Pressure(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().Pressure());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_TouchConfidence(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().TouchConfidence());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Twist(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().Twist());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_XTilt(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().XTilt());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_YTilt(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().YTilt());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IPointerPointTransform>
    : produce_base<D, winrt::Microsoft::UI::Input::IPointerPointTransform> {
  int32_t __stdcall get_Inverse(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::IPointerPointTransform>(
        this->shim().Inverse());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryTransform(winrt::Windows::Foundation::Point inPoint,
                                 winrt::Windows::Foundation::Point* outPoint,
                                 bool* result) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(outPoint);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().TryTransform(
        *reinterpret_cast<winrt::Windows::Foundation::Point const*>(&inPoint),
        *reinterpret_cast<winrt::Windows::Foundation::Point*>(outPoint)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryTransformBounds(
      winrt::Windows::Foundation::Rect inRect,
      winrt::Windows::Foundation::Rect* outRect, bool* result) noexcept final
      try {
    zero_abi<winrt::Windows::Foundation::Rect>(outRect);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().TryTransformBounds(
        *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&inRect),
        *reinterpret_cast<winrt::Windows::Foundation::Rect*>(outRect)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IPointerPredictor>
    : produce_base<D, winrt::Microsoft::UI::Input::IPointerPredictor> {
  int32_t __stdcall get_PredictionTime(int64_t* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::TimeSpan>(
        this->shim().PredictionTime());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PredictionTime(int64_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PredictionTime(
        *reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetPredictedPoints(void* point, uint32_t* __resultSize,
                                       void*** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    std::tie(*__resultSize, *result) =
        detach_abi(this->shim().GetPredictedPoints(
            *reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(
                &point)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IPointerPredictorStatics>
    : produce_base<D, winrt::Microsoft::UI::Input::IPointerPredictorStatics> {
  int32_t __stdcall CreateForInputPointerSource(void* inputPointerSource,
                                                void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Input::PointerPredictor>(
        this->shim().CreateForInputPointerSource(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::InputPointerSource const*>(
                &inputPointerSource)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IRightTappedEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::IRightTappedEventArgs> {
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::ITappedEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::ITappedEventArgs> {
  int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(
        this->shim().PointerDeviceType());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_TapCount(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().TapCount());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs> {
  int32_t __stdcall get_PointerScreenPoint(
      struct struct_Windows_Graphics_PointInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::PointInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::PointInt32>(
        this->shim().PointerScreenPoint());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(
        this->shim().MoveSizeOperation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OldWindowRect(
      struct struct_Windows_Graphics_RectInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::RectInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::RectInt32>(
        this->shim().OldWindowRect());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_NewWindowRect(
      struct struct_Windows_Graphics_RectInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::RectInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::RectInt32>(
        this->shim().NewWindowRect());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>
    : produce_base<D,
                   winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs> {
  int32_t __stdcall get_PointerScreenPoint(
      struct struct_Windows_Graphics_PointInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::PointInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::PointInt32>(
        this->shim().PointerScreenPoint());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(
        this->shim().MoveSizeOperation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OldWindowRect(
      struct struct_Windows_Graphics_RectInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::RectInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::RectInt32>(
        this->shim().OldWindowRect());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_NewWindowRect(
      struct struct_Windows_Graphics_RectInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::RectInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::RectInt32>(
        this->shim().NewWindowRect());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_NewWindowRect(
      struct struct_Windows_Graphics_RectInt32 value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().NewWindowRect(
        *reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_AllowRectChange(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().AllowRectChange());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AllowRectChange(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AllowRectChange(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ShowWindow(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ShowWindow());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ShowWindow(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ShowWindow(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::UI::Input {
  constexpr auto operator|(GestureSettings const left,
                           GestureSettings const right) noexcept {
    return static_cast<GestureSettings>(impl::to_underlying_type(left) |
                                        impl::to_underlying_type(right));
  }
  constexpr auto operator|=(GestureSettings& left,
                            GestureSettings const right) noexcept {
    left = left | right;
    return left;
  }
  constexpr auto operator&(GestureSettings const left,
                           GestureSettings const right) noexcept {
    return static_cast<GestureSettings>(impl::to_underlying_type(left) &
                                        impl::to_underlying_type(right));
  }
  constexpr auto operator&=(GestureSettings& left,
                            GestureSettings const right) noexcept {
    left = left & right;
    return left;
  }
  constexpr auto operator~(GestureSettings const value) noexcept {
    return static_cast<GestureSettings>(~impl::to_underlying_type(value));
  }
  constexpr auto operator^(GestureSettings const left,
                           GestureSettings const right) noexcept {
    return static_cast<GestureSettings>(impl::to_underlying_type(left) ^
                                        impl::to_underlying_type(right));
  }
  constexpr auto operator^=(GestureSettings& left,
                            GestureSettings const right) noexcept {
    left = left ^ right;
    return left;
  }
  constexpr auto operator|(InputPointerSourceDeviceKinds const left,
                           InputPointerSourceDeviceKinds const right) noexcept {
    return static_cast<InputPointerSourceDeviceKinds>(
        impl::to_underlying_type(left) | impl::to_underlying_type(right));
  }
  constexpr auto operator|=(
      InputPointerSourceDeviceKinds& left,
      InputPointerSourceDeviceKinds const right) noexcept {
    left = left | right;
    return left;
  }
  constexpr auto operator&(InputPointerSourceDeviceKinds const left,
                           InputPointerSourceDeviceKinds const right) noexcept {
    return static_cast<InputPointerSourceDeviceKinds>(
        impl::to_underlying_type(left) & impl::to_underlying_type(right));
  }
  constexpr auto operator&=(
      InputPointerSourceDeviceKinds& left,
      InputPointerSourceDeviceKinds const right) noexcept {
    left = left & right;
    return left;
  }
  constexpr auto operator~(InputPointerSourceDeviceKinds const value) noexcept {
    return static_cast<InputPointerSourceDeviceKinds>(
        ~impl::to_underlying_type(value));
  }
  constexpr auto operator^(InputPointerSourceDeviceKinds const left,
                           InputPointerSourceDeviceKinds const right) noexcept {
    return static_cast<InputPointerSourceDeviceKinds>(
        impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
  }
  constexpr auto operator^=(
      InputPointerSourceDeviceKinds& left,
      InputPointerSourceDeviceKinds const right) noexcept {
    left = left ^ right;
    return left;
  }
  constexpr auto operator|(VirtualKeyStates const left,
                           VirtualKeyStates const right) noexcept {
    return static_cast<VirtualKeyStates>(impl::to_underlying_type(left) |
                                         impl::to_underlying_type(right));
  }
  constexpr auto operator|=(VirtualKeyStates& left,
                            VirtualKeyStates const right) noexcept {
    left = left | right;
    return left;
  }
  constexpr auto operator&(VirtualKeyStates const left,
                           VirtualKeyStates const right) noexcept {
    return static_cast<VirtualKeyStates>(impl::to_underlying_type(left) &
                                         impl::to_underlying_type(right));
  }
  constexpr auto operator&=(VirtualKeyStates& left,
                            VirtualKeyStates const right) noexcept {
    left = left & right;
    return left;
  }
  constexpr auto operator~(VirtualKeyStates const value) noexcept {
    return static_cast<VirtualKeyStates>(~impl::to_underlying_type(value));
  }
  constexpr auto operator^(VirtualKeyStates const left,
                           VirtualKeyStates const right) noexcept {
    return static_cast<VirtualKeyStates>(impl::to_underlying_type(left) ^
                                         impl::to_underlying_type(right));
  }
  constexpr auto operator^=(VirtualKeyStates& left,
                            VirtualKeyStates const right) noexcept {
    left = left ^ right;
    return left;
  }
  inline auto FocusNavigationRequest::Create(
      winrt::Microsoft::UI::Input::FocusNavigationReason const& reason) {
    return impl::call_factory<FocusNavigationRequest,
                              IFocusNavigationRequestStatics>(
        [&](IFocusNavigationRequestStatics const& f) {
          return f.Create(reason);
        });
  }
  inline auto FocusNavigationRequest::Create(
      winrt::Microsoft::UI::Input::FocusNavigationReason const& reason,
      winrt::Windows::Foundation::Rect const& hintRect) {
    return impl::call_factory<FocusNavigationRequest,
                              IFocusNavigationRequestStatics>(
        [&](IFocusNavigationRequestStatics const& f) {
          return f.Create(reason, hintRect);
        });
  }
  inline auto FocusNavigationRequest::Create(
      winrt::Microsoft::UI::Input::FocusNavigationReason const& reason,
      winrt::Windows::Foundation::Rect const& hintRect,
      winrt::guid const& correlationId) {
    return impl::call_factory<FocusNavigationRequest,
                              IFocusNavigationRequestStatics>(
        [&](IFocusNavigationRequestStatics const& f) {
          return f.Create(reason, hintRect, correlationId);
        });
  }
  inline GestureRecognizer::GestureRecognizer()
      : GestureRecognizer(
            impl::call_factory_cast<
                GestureRecognizer (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                GestureRecognizer>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<GestureRecognizer>();
                })) {}
  inline auto InputActivationListener::GetForWindowId(
      winrt::Microsoft::UI::WindowId const& windowId) {
    return impl::call_factory<InputActivationListener,
                              IInputActivationListenerStatics>(
        [&](IInputActivationListenerStatics const& f) {
          return f.GetForWindowId(windowId);
        });
  }
  inline auto InputActivationListener::GetForIsland(
      winrt::Microsoft::UI::Content::ContentIsland const& island) {
    return impl::call_factory<InputActivationListener,
                              IInputActivationListenerStatics2>(
        [&](IInputActivationListenerStatics2 const& f) {
          return f.GetForIsland(island);
        });
  }
  inline auto InputCursor::CreateFromCoreCursor(
      winrt::Windows::UI::Core::CoreCursor const& cursor) {
    return impl::call_factory<InputCursor, IInputCursorStatics>(
        [&](IInputCursorStatics const& f) {
          return f.CreateFromCoreCursor(cursor);
        });
  }
  inline auto InputDesktopNamedResourceCursor::Create(
      param::hstring const& resourceName) {
    return impl::call_factory<InputDesktopNamedResourceCursor,
                              IInputDesktopNamedResourceCursorStatics>(
        [&](IInputDesktopNamedResourceCursorStatics const& f) {
          return f.Create(resourceName);
        });
  }
  inline auto InputDesktopNamedResourceCursor::CreateFromModule(
      param::hstring const& moduleName, param::hstring const& resourceName) {
    return impl::call_factory<InputDesktopNamedResourceCursor,
                              IInputDesktopNamedResourceCursorStatics>(
        [&](IInputDesktopNamedResourceCursorStatics const& f) {
          return f.CreateFromModule(moduleName, resourceName);
        });
  }
  inline auto InputDesktopResourceCursor::Create(uint32_t resourceId) {
    return impl::call_factory<InputDesktopResourceCursor,
                              IInputDesktopResourceCursorStatics>(
        [&](IInputDesktopResourceCursorStatics const& f) {
          return f.Create(resourceId);
        });
  }
  inline auto InputDesktopResourceCursor::CreateFromModule(
      param::hstring const& moduleName, uint32_t resourceId) {
    return impl::call_factory<InputDesktopResourceCursor,
                              IInputDesktopResourceCursorStatics>(
        [&](IInputDesktopResourceCursorStatics const& f) {
          return f.CreateFromModule(moduleName, resourceId);
        });
  }
  inline auto InputFocusController::GetForIsland(
      winrt::Microsoft::UI::Content::ContentIsland const& island) {
    return impl::call_factory<InputFocusController,
                              IInputFocusControllerStatics>(
        [&](IInputFocusControllerStatics const& f) {
          return f.GetForIsland(island);
        });
  }
  inline auto InputFocusNavigationHost::GetForSiteBridge(
      winrt::Microsoft::UI::Content::IContentSiteBridge const& site) {
    return impl::call_factory<InputFocusNavigationHost,
                              IInputFocusNavigationHostStatics>(
        [&](IInputFocusNavigationHostStatics const& f) {
          return f.GetForSiteBridge(site);
        });
  }
  inline auto InputFocusNavigationHost::GetForSiteLink(
      winrt::Microsoft::UI::Content::IContentSiteLink const& contentSiteLink) {
    return impl::call_factory<InputFocusNavigationHost,
                              IInputFocusNavigationHostStatics2>(
        [&](IInputFocusNavigationHostStatics2 const& f) {
          return f.GetForSiteLink(contentSiteLink);
        });
  }
  inline auto InputKeyboardSource::GetKeyStateForCurrentThread(
      winrt::Windows::System::VirtualKey const& virtualKey) {
    return impl::call_factory<InputKeyboardSource, IInputKeyboardSourceStatics>(
        [&](IInputKeyboardSourceStatics const& f) {
          return f.GetKeyStateForCurrentThread(virtualKey);
        });
  }
  inline auto InputKeyboardSource::GetForIsland(
      winrt::Microsoft::UI::Content::ContentIsland const& island) {
    return impl::call_factory<InputKeyboardSource,
                              IInputKeyboardSourceStatics2>(
        [&](IInputKeyboardSourceStatics2 const& f) {
          return f.GetForIsland(island);
        });
  }
  inline auto InputLightDismissAction::GetForWindowId(
      winrt::Microsoft::UI::WindowId const& windowId) {
    return impl::call_factory<InputLightDismissAction,
                              IInputLightDismissActionStatics>(
        [&](IInputLightDismissActionStatics const& f) {
          return f.GetForWindowId(windowId);
        });
  }
  inline auto InputNonClientPointerSource::GetForWindowId(
      winrt::Microsoft::UI::WindowId const& windowId) {
    return impl::call_factory<InputNonClientPointerSource,
                              IInputNonClientPointerSourceStatics>(
        [&](IInputNonClientPointerSourceStatics const& f) {
          return f.GetForWindowId(windowId);
        });
  }
  inline auto InputPointerSource::GetForIsland(
      winrt::Microsoft::UI::Content::ContentIsland const& island) {
    return impl::call_factory<InputPointerSource, IInputPointerSourceStatics>(
        [&](IInputPointerSourceStatics const& f) {
          return f.GetForIsland(island);
        });
  }
  inline auto InputPreTranslateKeyboardSource::GetForIsland(
      winrt::Microsoft::UI::Content::ContentIsland const& island) {
    return impl::call_factory<InputPreTranslateKeyboardSource,
                              IInputPreTranslateKeyboardSourceStatics>(
        [&](IInputPreTranslateKeyboardSourceStatics const& f) {
          return f.GetForIsland(island);
        });
  }
  inline auto InputSystemCursor::Create(
      winrt::Microsoft::UI::Input::InputSystemCursorShape const& type) {
    return impl::call_factory<InputSystemCursor, IInputSystemCursorStatics>(
        [&](IInputSystemCursorStatics const& f) { return f.Create(type); });
  }
  inline auto PointerPredictor::CreateForInputPointerSource(
      winrt::Microsoft::UI::Input::InputPointerSource const&
          inputPointerSource) {
    return impl::call_factory<PointerPredictor, IPointerPredictorStatics>(
        [&](IPointerPredictorStatics const& f) {
          return f.CreateForInputPointerSource(inputPointerSource);
        });
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IDraggingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IFocusChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IFocusNavigationRequest>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IGestureRecognizer>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IHoldingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputActivationListener>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::
                IInputActivationListenerActivationChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputActivationListenerStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputActivationListenerStatics2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputCursorFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputCursorStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputCustomCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputCustomCursorFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputFocusController>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputFocusController2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputFocusControllerStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSource2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputLightDismissAction>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputLightDismissActionStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputLightDismissEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputObject>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputObjectFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputPointerSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputPointerSourceStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSource>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputSystemCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IInputSystemCursorStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IKeyEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IMouseWheelParameters>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IPointerEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IPointerPoint>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IPointerPointProperties>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IPointerPointTransform>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IPointerPredictor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IPointerPredictorStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IRightTappedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ITappedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::CharacterReceivedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::CrossSlidingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DraggingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::FocusChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::FocusNavigationRequest>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::GestureRecognizer>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::HoldingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputActivationListener>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::
                InputActivationListenerActivationChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputCursor> : winrt::impl::hash_base {
};
template <>
struct hash<winrt::Microsoft::UI::Input::InputCustomCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputFocusController>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputFocusNavigationHost>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputKeyboardSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputLightDismissAction>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputLightDismissEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputNonClientPointerSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputObject> : winrt::impl::hash_base {
};
template <>
struct hash<winrt::Microsoft::UI::Input::InputPointerSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::InputSystemCursor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::KeyEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ManipulationStartedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::MouseWheelParameters>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::NonClientPointerEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::PointerEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::PointerPoint>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::PointerPointProperties>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::PointerPredictor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::RightTappedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::TappedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::WindowRectChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::WindowRectChangingEventArgs>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
