// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_ApplicationModel_Resources_H
#define WINRT_Microsoft_Windows_ApplicationModel_Resources_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.ApplicationModel.Resources.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::Contrast() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Contrast(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_Contrast(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::Custom() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Custom(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_Custom(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::DeviceFamily() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DeviceFamily(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_DeviceFamily(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::HomeRegion() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HomeRegion(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_HomeRegion(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::Language() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Language(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_Language(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::LayoutDirection() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LayoutDirection(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_LayoutDirection(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::Scale() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Scale(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_Scale(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::TargetSize() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TargetSize(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_TargetSize(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<
    D>::Theme() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                           IKnownResourceQualifierNameStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::
            IKnownResourceQualifierNameStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Theme(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IKnownResourceQualifierNameStatics>**)this;
    check_hresult(_winrt_abi_type->get_Theme(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<
    D>::ValueAsString() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceCandidate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceCandidate,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ValueAsString(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)this;
    check_hresult(_winrt_abi_type->get_ValueAsString(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<
    D>::ValueAsBytes() const {
  uint32_t value_impl_size{};
  uint8_t* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceCandidate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceCandidate,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ValueAsBytes(&value_impl_size, &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)this;
    check_hresult(_winrt_abi_type->get_ValueAsBytes(&value_impl_size, &value));
  }
  return com_array<uint8_t>{value, value_impl_size, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<
    D>::Kind() const {
  winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidateKind
      value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceCandidate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceCandidate,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)this;
    check_hresult(
        _winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<
    D>::QualifierValues() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceCandidate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceCandidate,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_QualifierValues(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidate>**)this;
    check_hresult(_winrt_abi_type->get_QualifierValues(&value));
  }
  return winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidateFactory<
    D>::CreateInstance(winrt::Microsoft::Windows::ApplicationModel::Resources::
                           ResourceCandidateKind const& kind,
                       param::hstring const& data) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceCandidateFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceCandidateFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidateFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstance(static_cast<int32_t>(kind),
                                                  *(void**)(&data), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidateFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstance(static_cast<int32_t>(kind),
                                                  *(void**)(&data), &value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceCandidate{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidateFactory<
    D>::CreateInstance2(array_view<uint8_t const> data) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceCandidateFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceCandidateFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidateFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance2(data.size(), get_abi(data), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceCandidateFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance2(data.size(), get_abi(data), &value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceCandidate{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceContext<
    D>::QualifierValues() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceContext>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceContext,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceContext>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_QualifierValues(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceContext>**)this;
    check_hresult(_winrt_abi_type->get_QualifierValues(&value));
  }
  return winrt::Windows::Foundation::Collections::IMap<hstring, hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoader<
    D>::GetString(param::hstring const& resourceId) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceLoader>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoader>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetString(*(void**)(&resourceId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoader>**)this;
    check_hresult(_winrt_abi_type->GetString(*(void**)(&resourceId), &result));
  }
  return hstring{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoader<D>::
    GetStringForUri(winrt::Windows::Foundation::Uri const& resourceUri) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceLoader>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoader>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetStringForUri(*(void**)(&resourceUri), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoader>**)this;
    check_hresult(
        _winrt_abi_type->GetStringForUri(*(void**)(&resourceUri), &result));
  }
  return hstring{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoaderFactory<
    D>::CreateInstance(param::hstring const& fileName) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceLoaderFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceLoaderFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoaderFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(*(void**)(&fileName), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoaderFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(*(void**)(&fileName), &value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoaderFactory<
    D>::CreateInstance2(param::hstring const& fileName,
                        param::hstring const& resourceMap) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceLoaderFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceLoaderFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoaderFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstance2(
        *(void**)(&fileName), *(void**)(&resourceMap), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoaderFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstance2(
        *(void**)(&fileName), *(void**)(&resourceMap), &value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoaderStatics<
    D>::GetDefaultResourceFilePath() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceLoaderStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceLoaderStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoaderStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetDefaultResourceFilePath(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceLoaderStatics>**)this;
    check_hresult(_winrt_abi_type->GetDefaultResourceFilePath(&result));
  }
  return hstring{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<
    D>::MainResourceMap() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MainResourceMap(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)this;
    check_hresult(_winrt_abi_type->get_MainResourceMap(&value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<
    D>::CreateResourceContext() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateResourceContext(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)this;
    check_hresult(_winrt_abi_type->CreateResourceContext(&result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceContext{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<D>::
    ResourceNotFound(winrt::Windows::Foundation::TypedEventHandler<
                     winrt::Microsoft::Windows::ApplicationModel::Resources::
                         ResourceManager,
                     winrt::Microsoft::Windows::ApplicationModel::Resources::
                         ResourceNotFoundEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ResourceNotFound(*(void**)(&handler),
                                                        put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)this;
    check_hresult(_winrt_abi_type->add_ResourceNotFound(*(void**)(&handler),
                                                        put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<
    D>::ResourceNotFound(auto_revoke_t,
                         winrt::Windows::Foundation::TypedEventHandler<
                             winrt::Microsoft::Windows::ApplicationModel::
                                 Resources::ResourceManager,
                             winrt::Microsoft::Windows::ApplicationModel::
                                 Resources::ResourceNotFoundEventArgs> const&
                             handler) const {
  return impl::make_event_revoker<D, ResourceNotFound_revoker>(
      this, ResourceNotFound(handler));
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<
    D>::ResourceNotFound(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ResourceNotFound(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManager>**)this;
    _winrt_abi_type->remove_ResourceNotFound(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManagerFactory<
    D>::CreateInstance(param::hstring const& fileName) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceManagerFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceManagerFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManagerFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(*(void**)(&fileName), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceManagerFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(*(void**)(&fileName), &value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceManager{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::ResourceCount() const {
  uint32_t value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ResourceCount(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->get_ResourceCount(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::GetSubtree(param::hstring const& reference) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetSubtree(*(void**)(&reference), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->GetSubtree(*(void**)(&reference), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::TryGetSubtree(param::hstring const& reference) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->TryGetSubtree(*(void**)(&reference), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(
        _winrt_abi_type->TryGetSubtree(*(void**)(&reference), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::GetValue(param::hstring const& resource) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetValue(*(void**)(&resource), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->GetValue(*(void**)(&resource), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceCandidate{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::GetValue(param::hstring const& resource,
                 winrt::Microsoft::Windows::ApplicationModel::Resources::
                     ResourceContext const& context) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetValueWithContext(
        *(void**)(&resource), *(void**)(&context), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->GetValueWithContext(
        *(void**)(&resource), *(void**)(&context), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceCandidate{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::GetValueByIndex(uint32_t index) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetValueByIndex(index, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->GetValueByIndex(index, &result));
  }
  return winrt::Windows::Foundation::Collections::IKeyValuePair<
      hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::
                   ResourceCandidate>{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::GetValueByIndex(uint32_t index,
                        winrt::Microsoft::Windows::ApplicationModel::Resources::
                            ResourceContext const& context) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetValueByIndexWithContext(
        index, *(void**)(&context), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->GetValueByIndexWithContext(
        index, *(void**)(&context), &result));
  }
  return winrt::Windows::Foundation::Collections::IKeyValuePair<
      hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::
                   ResourceCandidate>{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::TryGetValue(param::hstring const& resource) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TryGetValue(*(void**)(&resource), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->TryGetValue(*(void**)(&resource), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceCandidate{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<
    D>::TryGetValue(param::hstring const& resource,
                    winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceContext const& context) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceMap>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TryGetValueWithContext(
        *(void**)(&resource), *(void**)(&context), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceMap>**)this;
    check_hresult(_winrt_abi_type->TryGetValueWithContext(
        *(void**)(&resource), *(void**)(&context), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceCandidate{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceNotFoundEventArgs<
    D>::Context() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceNotFoundEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceNotFoundEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceNotFoundEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Context(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceNotFoundEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Context(&value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::Resources::
      ResourceContext{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceNotFoundEventArgs<
    D>::Name() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceNotFoundEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceNotFoundEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceNotFoundEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Name(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceNotFoundEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Name(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_Resources_IResourceNotFoundEventArgs<
    D>::SetResolvedCandidate(winrt::Microsoft::Windows::ApplicationModel::
                                 Resources::ResourceCandidate const& candidate)
    const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       Resources::IResourceNotFoundEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     Resources::IResourceNotFoundEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceNotFoundEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetResolvedCandidate(*(void**)(&candidate)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::Resources::
                    IResourceNotFoundEventArgs>**)this;
    check_hresult(_winrt_abi_type->SetResolvedCandidate(*(void**)(&candidate)));
  }
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                      IKnownResourceQualifierNameStatics>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IKnownResourceQualifierNameStatics> {
  int32_t __stdcall get_Contrast(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Contrast());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Custom(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Custom());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeviceFamily(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().DeviceFamily());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_HomeRegion(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().HomeRegion());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Language(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Language());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LayoutDirection(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().LayoutDirection());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Scale(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Scale());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_TargetSize(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().TargetSize());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Theme(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Theme());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceCandidate> {
  int32_t __stdcall get_ValueAsString(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().ValueAsString());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ValueAsBytes(uint32_t* __valueSize,
                                     uint8_t** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    std::tie(*__valueSize, *value) = detach_abi(this->shim().ValueAsBytes());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Kind(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceCandidateKind>(this->shim().Kind());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_QualifierValues(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>>(
        this->shim().QualifierValues());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                      IResourceCandidateFactory>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceCandidateFactory> {
  int32_t __stdcall CreateInstance(int32_t kind, void* data,
                                   void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceCandidate>(this->shim().CreateInstance(
            *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::
                                  Resources::ResourceCandidateKind const*>(
                &kind),
            *reinterpret_cast<hstring const*>(&data)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateInstance2(uint32_t __dataSize, uint8_t* data,
                                    void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                             Resources::ResourceCandidate>(
        this->shim().CreateInstance2(array_view<uint8_t const>(
            reinterpret_cast<uint8_t const*>(data),
            reinterpret_cast<uint8_t const*>(data) + __dataSize)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceContext> {
  int32_t __stdcall get_QualifierValues(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::Collections::IMap<hstring, hstring>>(
        this->shim().QualifierValues());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext2>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceContext2> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceLoader> {
  int32_t __stdcall GetString(void* resourceId, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<hstring>(
        this->shim().GetString(*reinterpret_cast<hstring const*>(&resourceId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetStringForUri(void* resourceUri,
                                    void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<hstring>(this->shim().GetStringForUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
            &resourceUri)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                      IResourceLoaderFactory>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceLoaderFactory> {
  int32_t __stdcall CreateInstance(void* fileName, void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader>(
        this->shim().CreateInstance(
            *reinterpret_cast<hstring const*>(&fileName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateInstance2(void* fileName, void* resourceMap,
                                    void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader>(
        this->shim().CreateInstance2(
            *reinterpret_cast<hstring const*>(&fileName),
            *reinterpret_cast<hstring const*>(&resourceMap)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                      IResourceLoaderStatics>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceLoaderStatics> {
  int32_t __stdcall GetDefaultResourceFilePath(void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<hstring>(this->shim().GetDefaultResourceFilePath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceManager> {
  int32_t __stdcall get_MainResourceMap(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap>(
        this->shim().MainResourceMap());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateResourceContext(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceContext>(this->shim().CreateResourceContext());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_ResourceNotFound(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ResourceNotFound(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::Windows::ApplicationModel::Resources::
                ResourceManager,
            winrt::Microsoft::Windows::ApplicationModel::Resources::
                ResourceNotFoundEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ResourceNotFound(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ResourceNotFound(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager2>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceManager2> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                      IResourceManagerFactory>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceManagerFactory> {
  int32_t __stdcall CreateInstance(void* fileName, void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceManager>(this->shim().CreateInstance(
            *reinterpret_cast<hstring const*>(&fileName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceMap> {
  int32_t __stdcall get_ResourceCount(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().ResourceCount());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetSubtree(void* reference, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap>(
        this->shim().GetSubtree(*reinterpret_cast<hstring const*>(&reference)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryGetSubtree(void* reference, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap>(
        this->shim().TryGetSubtree(
            *reinterpret_cast<hstring const*>(&reference)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetValue(void* resource, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              Resources::ResourceCandidate>(
        this->shim().GetValue(*reinterpret_cast<hstring const*>(&resource)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetValueWithContext(void* resource, void* context,
                                        void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceCandidate>(this->shim().GetValue(
            *reinterpret_cast<hstring const*>(&resource),
            *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::
                                  Resources::ResourceContext const*>(
                &context)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetValueByIndex(uint32_t index,
                                    void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Windows::Foundation::Collections::IKeyValuePair<
            hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::
                         ResourceCandidate>>(
            this->shim().GetValueByIndex(index));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetValueByIndexWithContext(uint32_t index, void* context,
                                               void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Windows::Foundation::Collections::IKeyValuePair<
            hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::
                         ResourceCandidate>>(
            this->shim().GetValueByIndex(
                index,
                *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::
                                      Resources::ResourceContext const*>(
                    &context)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryGetValue(void* resource, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              Resources::ResourceCandidate>(
        this->shim().TryGetValue(*reinterpret_cast<hstring const*>(&resource)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryGetValueWithContext(void* resource, void* context,
                                           void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceCandidate>(this->shim().TryGetValue(
            *reinterpret_cast<hstring const*>(&resource),
            *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::
                                  Resources::ResourceContext const*>(
                &context)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                      IResourceNotFoundEventArgs>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::
                          IResourceNotFoundEventArgs> {
  int32_t __stdcall get_Context(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::
                        ResourceContext>(this->shim().Context());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Name(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Name());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetResolvedCandidate(void* candidate) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetResolvedCandidate(
        *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::
                              Resources::ResourceCandidate const*>(&candidate));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::ApplicationModel::Resources {
  inline auto KnownResourceQualifierName::Contrast() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) {
          return f.Contrast();
        });
  }
  inline auto KnownResourceQualifierName::Custom() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) { return f.Custom(); });
  }
  inline auto KnownResourceQualifierName::DeviceFamily() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) {
          return f.DeviceFamily();
        });
  }
  inline auto KnownResourceQualifierName::HomeRegion() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) {
          return f.HomeRegion();
        });
  }
  inline auto KnownResourceQualifierName::Language() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) {
          return f.Language();
        });
  }
  inline auto KnownResourceQualifierName::LayoutDirection() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) {
          return f.LayoutDirection();
        });
  }
  inline auto KnownResourceQualifierName::Scale() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) { return f.Scale(); });
  }
  inline auto KnownResourceQualifierName::TargetSize() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) {
          return f.TargetSize();
        });
  }
  inline auto KnownResourceQualifierName::Theme() {
    return impl::call_factory_cast<
        hstring (*)(IKnownResourceQualifierNameStatics const&),
        KnownResourceQualifierName, IKnownResourceQualifierNameStatics>(
        [](IKnownResourceQualifierNameStatics const& f) { return f.Theme(); });
  }
  inline ResourceCandidate::ResourceCandidate(
      winrt::Microsoft::Windows::ApplicationModel::Resources::
          ResourceCandidateKind const& kind,
      param::hstring const& data)
      : ResourceCandidate(
            impl::call_factory<ResourceCandidate, IResourceCandidateFactory>(
                [&](IResourceCandidateFactory const& f) {
                  return f.CreateInstance(kind, data);
                })) {}
  inline ResourceCandidate::ResourceCandidate(array_view<uint8_t const> data)
      : ResourceCandidate(
            impl::call_factory<ResourceCandidate, IResourceCandidateFactory>(
                [&](IResourceCandidateFactory const& f) {
                  return f.CreateInstance2(data);
                })) {}
  inline ResourceLoader::ResourceLoader()
      : ResourceLoader(
            impl::call_factory_cast<
                ResourceLoader (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                ResourceLoader>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<ResourceLoader>();
                })) {}
  inline ResourceLoader::ResourceLoader(param::hstring const& fileName)
      : ResourceLoader(
            impl::call_factory<ResourceLoader, IResourceLoaderFactory>(
                [&](IResourceLoaderFactory const& f) {
                  return f.CreateInstance(fileName);
                })) {}
  inline ResourceLoader::ResourceLoader(param::hstring const& fileName,
                                        param::hstring const& resourceMap)
      : ResourceLoader(
            impl::call_factory<ResourceLoader, IResourceLoaderFactory>(
                [&](IResourceLoaderFactory const& f) {
                  return f.CreateInstance2(fileName, resourceMap);
                })) {}
  inline auto ResourceLoader::GetDefaultResourceFilePath() {
    return impl::call_factory_cast<hstring (*)(IResourceLoaderStatics const&),
                                   ResourceLoader, IResourceLoaderStatics>(
        [](IResourceLoaderStatics const& f) {
          return f.GetDefaultResourceFilePath();
        });
  }
  inline ResourceManager::ResourceManager()
      : ResourceManager(
            impl::call_factory_cast<
                ResourceManager (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                ResourceManager>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<ResourceManager>();
                })) {}
  inline ResourceManager::ResourceManager(param::hstring const& fileName)
      : ResourceManager(
            impl::call_factory<ResourceManager, IResourceManagerFactory>(
                [&](IResourceManagerFactory const& f) {
                  return f.CreateInstance(fileName);
                })) {}
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                IKnownResourceQualifierNameStatics> : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                IResourceCandidateFactory> : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext2>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                IResourceLoaderFactory> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                IResourceLoaderStatics> : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                IResourceManagerFactory> : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                IResourceNotFoundEventArgs> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                KnownResourceQualifierName> : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::
                ResourceNotFoundEventArgs> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
