// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_Storage_H
#define WINRT_Microsoft_Windows_Storage_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.Storage.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Storage.2.h"
#include "winrt/impl/Windows.System.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<
    D>::IsMachinePathSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsMachinePathSupported(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_IsMachinePathSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::LocalCachePath()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LocalCachePath(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_LocalCachePath(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::LocalPath() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LocalPath(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_LocalPath(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::MachinePath()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MachinePath(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_MachinePath(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::SharedLocalPath()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SharedLocalPath(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_SharedLocalPath(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::TemporaryPath()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TemporaryPath(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_TemporaryPath(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::LocalCacheFolder()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LocalCacheFolder(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_LocalCacheFolder(&value));
  }
  return winrt::Windows::Storage::StorageFolder{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::LocalFolder()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LocalFolder(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_LocalFolder(&value));
  }
  return winrt::Windows::Storage::StorageFolder{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::MachineFolder()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MachineFolder(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_MachineFolder(&value));
  }
  return winrt::Windows::Storage::StorageFolder{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::SharedLocalFolder()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SharedLocalFolder(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_SharedLocalFolder(&value));
  }
  return winrt::Windows::Storage::StorageFolder{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::TemporaryFolder()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TemporaryFolder(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_TemporaryFolder(&value));
  }
  return winrt::Windows::Storage::StorageFolder{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::LocalSettings()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LocalSettings(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->get_LocalSettings(&value));
  }
  return winrt::Microsoft::Windows::Storage::ApplicationDataContainer{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<D>::ClearAsync(
    winrt::Microsoft::Windows::Storage::ApplicationDataLocality const& locality)
    const {
  void* operation{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ClearAsync(static_cast<int32_t>(locality),
                                              &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->ClearAsync(static_cast<int32_t>(locality),
                                              &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<
    D>::ClearPublisherCacheFolderAsync(param::hstring const& folderName) const {
  void* operation{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ClearPublisherCacheFolderAsync(
        *(void**)(&folderName), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->ClearPublisherCacheFolderAsync(
        *(void**)(&folderName), &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<
    D>::GetPublisherCachePath(param::hstring const& folderName) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetPublisherCachePath(*(void**)(&folderName),
                                                         &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->GetPublisherCachePath(*(void**)(&folderName),
                                                         &result));
  }
  return hstring{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationData<
    D>::GetPublisherCacheFolder(param::hstring const& folderName) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Storage::IApplicationData>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationData, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationData>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetPublisherCacheFolder(
        *(void**)(&folderName), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::IApplicationData>**)this;
    check_hresult(_winrt_abi_type->GetPublisherCacheFolder(
        *(void**)(&folderName), &result));
  }
  return winrt::Windows::Storage::StorageFolder{result,
                                                take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataContainer<
    D>::Containers() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataContainer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataContainer,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataContainer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Containers(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             IApplicationDataContainer>**)this;
    check_hresult(_winrt_abi_type->get_Containers(&value));
  }
  return winrt::Windows::Foundation::Collections::IMap<
      hstring, winrt::Microsoft::Windows::Storage::ApplicationDataContainer>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataContainer<D>::Name()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataContainer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataContainer,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataContainer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Name(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             IApplicationDataContainer>**)this;
    check_hresult(_winrt_abi_type->get_Name(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataContainer<D>::Locality()
    const {
  winrt::Microsoft::Windows::Storage::ApplicationDataLocality value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataContainer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataContainer,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataContainer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Locality(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             IApplicationDataContainer>**)this;
    check_hresult(
        _winrt_abi_type->get_Locality(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataContainer<D>::Values()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataContainer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataContainer,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataContainer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Values(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             IApplicationDataContainer>**)this;
    check_hresult(_winrt_abi_type->get_Values(&value));
  }
  return winrt::Windows::Foundation::Collections::IPropertySet{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataContainer<
    D>::CreateContainer(param::hstring const& name,
                        winrt::Microsoft::Windows::Storage::
                            ApplicationDataCreateDisposition const& disposition)
    const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataContainer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataContainer,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataContainer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateContainer(
        *(void**)(&name), static_cast<int32_t>(disposition), &result));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             IApplicationDataContainer>**)this;
    check_hresult(_winrt_abi_type->CreateContainer(
        *(void**)(&name), static_cast<int32_t>(disposition), &result));
  }
  return winrt::Microsoft::Windows::Storage::ApplicationDataContainer{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataContainer<
    D>::DeleteContainer(param::hstring const& name) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataContainer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataContainer,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataContainer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->DeleteContainer(*(void**)(&name)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             IApplicationDataContainer>**)this;
    check_hresult(_winrt_abi_type->DeleteContainer(*(void**)(&name)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataStatics<D>::GetDefault()
    const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::IApplicationDataStatics>**)this;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  }
  return winrt::Microsoft::Windows::Storage::ApplicationData{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataStatics<D>::GetForUser(
    winrt::Windows::System::User const& user) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForUser(*(void**)(&user), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::IApplicationDataStatics>**)this;
    check_hresult(_winrt_abi_type->GetForUser(*(void**)(&user), &result));
  }
  return winrt::Microsoft::Windows::Storage::ApplicationData{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_IApplicationDataStatics<
    D>::GetForPackageFamily(param::hstring const& packageFamilyName) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::
                                       IApplicationDataStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::IApplicationDataStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::
                    IApplicationDataStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForPackageFamily(
        *(void**)(&packageFamilyName), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::IApplicationDataStatics>**)this;
    check_hresult(_winrt_abi_type->GetForPackageFamily(
        *(void**)(&packageFamilyName), &result));
  }
  return winrt::Microsoft::Windows::Storage::ApplicationData{
      result, take_ownership_from_abi};
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Storage::IApplicationData>
    : produce_base<D, winrt::Microsoft::Windows::Storage::IApplicationData> {
  int32_t __stdcall get_IsMachinePathSupported(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsMachinePathSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LocalCachePath(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().LocalCachePath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LocalPath(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().LocalPath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MachinePath(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().MachinePath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SharedLocalPath(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().SharedLocalPath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_TemporaryPath(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().TemporaryPath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LocalCacheFolder(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Storage::StorageFolder>(
        this->shim().LocalCacheFolder());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LocalFolder(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Storage::StorageFolder>(
        this->shim().LocalFolder());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MachineFolder(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Storage::StorageFolder>(
        this->shim().MachineFolder());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SharedLocalFolder(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Storage::StorageFolder>(
        this->shim().SharedLocalFolder());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_TemporaryFolder(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Storage::StorageFolder>(
        this->shim().TemporaryFolder());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LocalSettings(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::ApplicationDataContainer>(
        this->shim().LocalSettings());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ClearAsync(int32_t locality,
                               void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(
        this->shim().ClearAsync(
            *reinterpret_cast<winrt::Microsoft::Windows::Storage::
                                  ApplicationDataLocality const*>(&locality)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ClearPublisherCacheFolderAsync(
      void* folderName, void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(
        this->shim().ClearPublisherCacheFolderAsync(
            *reinterpret_cast<hstring const*>(&folderName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetPublisherCachePath(void* folderName,
                                          void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<hstring>(this->shim().GetPublisherCachePath(
        *reinterpret_cast<hstring const*>(&folderName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetPublisherCacheFolder(void* folderName,
                                            void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Storage::StorageFolder>(
        this->shim().GetPublisherCacheFolder(
            *reinterpret_cast<hstring const*>(&folderName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Storage::IApplicationDataContainer>
    : produce_base<
          D, winrt::Microsoft::Windows::Storage::IApplicationDataContainer> {
  int32_t __stdcall get_Containers(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IMap<
        hstring, winrt::Microsoft::Windows::Storage::ApplicationDataContainer>>(
        this->shim().Containers());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Name(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Name());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Locality(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::ApplicationDataLocality>(
        this->shim().Locality());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Values(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IPropertySet>(
        this->shim().Values());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateContainer(void* name, int32_t disposition,
                                    void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::Storage::ApplicationDataContainer>(
        this->shim().CreateContainer(
            *reinterpret_cast<hstring const*>(&name),
            *reinterpret_cast<winrt::Microsoft::Windows::Storage::
                                  ApplicationDataCreateDisposition const*>(
                &disposition)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall DeleteContainer(void* name) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeleteContainer(*reinterpret_cast<hstring const*>(&name));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Storage::IApplicationDataStatics>
    : produce_base<
          D, winrt::Microsoft::Windows::Storage::IApplicationDataStatics> {
  int32_t __stdcall GetDefault(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Storage::ApplicationData>(
        this->shim().GetDefault());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetForUser(void* user, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Storage::ApplicationData>(
        this->shim().GetForUser(
            *reinterpret_cast<winrt::Windows::System::User const*>(&user)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetForPackageFamily(void* packageFamilyName,
                                        void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Storage::ApplicationData>(
        this->shim().GetForPackageFamily(
            *reinterpret_cast<hstring const*>(&packageFamilyName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::Storage {
  inline auto ApplicationData::GetDefault() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::Storage::ApplicationData (*)(
            IApplicationDataStatics const&),
        ApplicationData, IApplicationDataStatics>(
        [](IApplicationDataStatics const& f) { return f.GetDefault(); });
  }
  inline auto ApplicationData::GetForUser(
      winrt::Windows::System::User const& user) {
    return impl::call_factory<ApplicationData, IApplicationDataStatics>(
        [&](IApplicationDataStatics const& f) { return f.GetForUser(user); });
  }
  inline auto ApplicationData::GetForPackageFamily(
      param::hstring const& packageFamilyName) {
    return impl::call_factory<ApplicationData, IApplicationDataStatics>(
        [&](IApplicationDataStatics const& f) {
          return f.GetForPackageFamily(packageFamilyName);
        });
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::Storage::IApplicationData>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::IApplicationDataContainer>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::IApplicationDataStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::ApplicationData>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::ApplicationDataContainer>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
