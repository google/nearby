// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Windows_ApplicationModel_UserDataTasks_H
#define WINRT_Windows_ApplicationModel_UserDataTasks_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Windows.ApplicationModel.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.System.2.h"
#include "winrt/impl/Windows.ApplicationModel.UserDataTasks.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Id() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::ListId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ListId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_ListId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::RemoteId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RemoteId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_RemoteId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::RemoteId(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RemoteId(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_RemoteId(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::CompletedDate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CompletedDate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_CompletedDate(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::CompletedDate(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CompletedDate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_CompletedDate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Details() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Details(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_Details(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Details(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Details(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_Details(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::DetailsKind() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDetailsKind value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DetailsKind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_DetailsKind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::DetailsKind(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDetailsKind const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DetailsKind(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_DetailsKind(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::DueDate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DueDate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_DueDate(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::DueDate(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DueDate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_DueDate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Kind() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskKind value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Priority() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskPriority value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Priority(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_Priority(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Priority(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskPriority const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Priority(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_Priority(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::RecurrenceProperties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RecurrenceProperties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_RecurrenceProperties(&value));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceProperties{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::RecurrenceProperties(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceProperties const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RecurrenceProperties(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_RecurrenceProperties(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::RegenerationProperties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RegenerationProperties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_RegenerationProperties(&value));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationProperties{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::RegenerationProperties(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationProperties const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RegenerationProperties(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_RegenerationProperties(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Reminder() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reminder(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_Reminder(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Reminder(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Reminder(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_Reminder(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Sensitivity() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskSensitivity value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Sensitivity(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_Sensitivity(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Sensitivity(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskSensitivity const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Sensitivity(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_Sensitivity(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Subject() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Subject(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_Subject(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::Subject(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Subject(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_Subject(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::StartDate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StartDate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->get_StartDate(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTask<D>::StartDate(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_StartDate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>**)this;
            check_hresult(_winrt_abi_type->put_StartDate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskBatch<D>::Tasks() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Tasks(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskBatch>**)this;
            check_hresult(_winrt_abi_type->get_Tasks(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::Id() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::UserDataAccountId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UserDataAccountId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_UserDataAccountId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::DisplayName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_DisplayName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::DisplayName(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DisplayName(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->put_DisplayName(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::SourceDisplayName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceDisplayName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_SourceDisplayName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::OtherAppReadAccess() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppReadAccess value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OtherAppReadAccess(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_OtherAppReadAccess(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::OtherAppReadAccess(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppReadAccess const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OtherAppReadAccess(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->put_OtherAppReadAccess(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::OtherAppWriteAccess() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppWriteAccess value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OtherAppWriteAccess(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_OtherAppWriteAccess(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::OtherAppWriteAccess(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppWriteAccess const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OtherAppWriteAccess(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->put_OtherAppWriteAccess(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::LimitedWriteOperations() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LimitedWriteOperations(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_LimitedWriteOperations(&value));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListLimitedWriteOperations{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::SyncManager() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SyncManager(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->get_SyncManager(&value));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncManager{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::RegisterSyncManagerAsync() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RegisterSyncManagerAsync(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->RegisterSyncManagerAsync(&result));
        }
        return winrt::Windows::Foundation::IAsyncAction{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::GetTaskReader() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTaskReader(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->GetTaskReader(&result));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskReader{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::GetTaskReader(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQueryOptions const& options) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTaskReaderWithOptions(*(void**)(&options), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->GetTaskReaderWithOptions(*(void**)(&options), &value));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskReader{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::GetTaskAsync(param::hstring const& userDataTask) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTaskAsync(*(void**)(&userDataTask), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->GetTaskAsync(*(void**)(&userDataTask), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::SaveTaskAsync(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask const& userDataTask) const
    {
        void* action{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveTaskAsync(*(void**)(&userDataTask), &action));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->SaveTaskAsync(*(void**)(&userDataTask), &action));
        }
        return winrt::Windows::Foundation::IAsyncAction{ action, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::DeleteTaskAsync(param::hstring const& userDataTaskId) const
    {
        void* action{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DeleteTaskAsync(*(void**)(&userDataTaskId), &action));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->DeleteTaskAsync(*(void**)(&userDataTaskId), &action));
        }
        return winrt::Windows::Foundation::IAsyncAction{ action, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::DeleteAsync() const
    {
        void* asyncAction{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DeleteAsync(&asyncAction));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->DeleteAsync(&asyncAction));
        }
        return winrt::Windows::Foundation::IAsyncAction{ asyncAction, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskList<D>::SaveAsync() const
    {
        void* asyncAction{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveAsync(&asyncAction));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>**)this;
            check_hresult(_winrt_abi_type->SaveAsync(&asyncAction));
        }
        return winrt::Windows::Foundation::IAsyncAction{ asyncAction, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListLimitedWriteOperations<D>::TryCompleteTaskAsync(param::hstring const& userDataTaskId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryCompleteTaskAsync(*(void**)(&userDataTaskId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)this;
            check_hresult(_winrt_abi_type->TryCompleteTaskAsync(*(void**)(&userDataTaskId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListLimitedWriteOperations<D>::TryCreateOrUpdateTaskAsync(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask const& userDataTask) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryCreateOrUpdateTaskAsync(*(void**)(&userDataTask), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)this;
            check_hresult(_winrt_abi_type->TryCreateOrUpdateTaskAsync(*(void**)(&userDataTask), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<bool>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListLimitedWriteOperations<D>::TryDeleteTaskAsync(param::hstring const& userDataTaskId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryDeleteTaskAsync(*(void**)(&userDataTaskId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)this;
            check_hresult(_winrt_abi_type->TryDeleteTaskAsync(*(void**)(&userDataTaskId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<bool>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListLimitedWriteOperations<D>::TrySkipOccurrenceAsync(param::hstring const& userDataTaskId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TrySkipOccurrenceAsync(*(void**)(&userDataTaskId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>**)this;
            check_hresult(_winrt_abi_type->TrySkipOccurrenceAsync(*(void**)(&userDataTaskId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<bool>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::LastAttemptedSyncTime() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LastAttemptedSyncTime(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->get_LastAttemptedSyncTime(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::LastAttemptedSyncTime(winrt::Windows::Foundation::DateTime const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LastAttemptedSyncTime(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->put_LastAttemptedSyncTime(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::LastSuccessfulSyncTime() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LastSuccessfulSyncTime(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->get_LastSuccessfulSyncTime(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::LastSuccessfulSyncTime(winrt::Windows::Foundation::DateTime const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LastSuccessfulSyncTime(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->put_LastSuccessfulSyncTime(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::Status() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::Status(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncStatus const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::SyncAsync() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SyncAsync(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->SyncAsync(&result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<bool>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::SyncStatusChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncManager, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SyncStatusChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            check_hresult(_winrt_abi_type->add_SyncStatusChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::SyncStatusChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncManager, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, SyncStatusChanged_revoker>(this, SyncStatusChanged(handler));
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskListSyncManager<D>::SyncStatusChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SyncStatusChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>**)this;
            _winrt_abi_type->remove_SyncStatusChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskManager<D>::RequestStoreAsync(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskStoreAccessType const& accessType) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RequestStoreAsync(static_cast<int32_t>(accessType), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager>**)this;
            check_hresult(_winrt_abi_type->RequestStoreAsync(static_cast<int32_t>(accessType), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskStore>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskManager<D>::User() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_User(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager>**)this;
            check_hresult(_winrt_abi_type->get_User(&value));
        }
        return winrt::Windows::System::User{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskManagerStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskManager{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskManagerStatics<D>::GetForUser(winrt::Windows::System::User const& user) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForUser(*(void**)(&user), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics>**)this;
            check_hresult(_winrt_abi_type->GetForUser(*(void**)(&user), &result));
        }
        return winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskManager{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskQueryOptions<D>::SortProperty() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQuerySortProperty value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SortProperty(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)this;
            check_hresult(_winrt_abi_type->get_SortProperty(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskQueryOptions<D>::SortProperty(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQuerySortProperty const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SortProperty(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)this;
            check_hresult(_winrt_abi_type->put_SortProperty(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskQueryOptions<D>::Kind() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQueryKind value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)this;
            check_hresult(_winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskQueryOptions<D>::Kind(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQueryKind const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Kind(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>**)this;
            check_hresult(_winrt_abi_type->put_Kind(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskReader<D>::ReadBatchAsync() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskReader>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskReader, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskReader>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ReadBatchAsync(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskReader>**)this;
            check_hresult(_winrt_abi_type->ReadBatchAsync(&result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskBatch>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Unit() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceUnit value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Unit(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_Unit(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Unit(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceUnit const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Unit(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_Unit(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Occurrences() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Occurrences(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_Occurrences(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Occurrences(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Occurrences(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_Occurrences(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Until() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Until(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_Until(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Until(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Until(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_Until(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Interval() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Interval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_Interval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Interval(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Interval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_Interval(value));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::DaysOfWeek() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DaysOfWeek(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_DaysOfWeek(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDaysOfWeek>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::DaysOfWeek(winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDaysOfWeek> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DaysOfWeek(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_DaysOfWeek(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::WeekOfMonth() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_WeekOfMonth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_WeekOfMonth(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskWeekOfMonth>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::WeekOfMonth(winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskWeekOfMonth> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_WeekOfMonth(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_WeekOfMonth(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Month() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Month(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_Month(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Month(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Month(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_Month(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Day() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Day(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->get_Day(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRecurrenceProperties<D>::Day(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Day(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>**)this;
            check_hresult(_winrt_abi_type->put_Day(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Unit() const
    {
        winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationUnit value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Unit(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->get_Unit(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Unit(winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationUnit const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Unit(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->put_Unit(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Occurrences() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Occurrences(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->get_Occurrences(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Occurrences(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Occurrences(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->put_Occurrences(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Until() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Until(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->get_Until(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Until(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Until(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->put_Until(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Interval() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Interval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->get_Interval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskRegenerationProperties<D>::Interval(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Interval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>**)this;
            check_hresult(_winrt_abi_type->put_Interval(value));
        }
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskStore<D>::CreateListAsync(param::hstring const& name) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateListAsync(*(void**)(&name), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)this;
            check_hresult(_winrt_abi_type->CreateListAsync(*(void**)(&name), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskStore<D>::CreateListAsync(param::hstring const& name, param::hstring const& userDataAccountId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateListInAccountAsync(*(void**)(&name), *(void**)(&userDataAccountId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)this;
            check_hresult(_winrt_abi_type->CreateListInAccountAsync(*(void**)(&name), *(void**)(&userDataAccountId), &result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskStore<D>::FindListsAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FindListsAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)this;
            check_hresult(_winrt_abi_type->FindListsAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_ApplicationModel_UserDataTasks_IUserDataTaskStore<D>::GetListAsync(param::hstring const& taskListId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetListAsync(*(void**)(&taskListId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>**)this;
            check_hresult(_winrt_abi_type->GetListAsync(*(void**)(&taskListId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>{ operation, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ListId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ListId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RemoteId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().RemoteId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RemoteId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemoteId(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompletedDate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().CompletedDate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CompletedDate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CompletedDate(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Details(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Details());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Details(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Details(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DetailsKind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDetailsKind>(this->shim().DetailsKind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DetailsKind(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DetailsKind(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDetailsKind const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DueDate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().DueDate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DueDate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DueDate(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Kind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskKind>(this->shim().Kind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Priority(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskPriority>(this->shim().Priority());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Priority(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Priority(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskPriority const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RecurrenceProperties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceProperties>(this->shim().RecurrenceProperties());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RecurrenceProperties(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RecurrenceProperties(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceProperties const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RegenerationProperties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationProperties>(this->shim().RegenerationProperties());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RegenerationProperties(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RegenerationProperties(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationProperties const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Reminder(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().Reminder());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Reminder(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Reminder(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Sensitivity(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskSensitivity>(this->shim().Sensitivity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Sensitivity(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Sensitivity(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskSensitivity const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Subject(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Subject());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Subject(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Subject(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StartDate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().StartDate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StartDate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartDate(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskBatch> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskBatch>
    {
        int32_t __stdcall get_Tasks(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask>>(this->shim().Tasks());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UserDataAccountId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().UserDataAccountId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DisplayName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DisplayName(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisplayName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SourceDisplayName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().SourceDisplayName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OtherAppReadAccess(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppReadAccess>(this->shim().OtherAppReadAccess());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OtherAppReadAccess(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OtherAppReadAccess(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppReadAccess const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OtherAppWriteAccess(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppWriteAccess>(this->shim().OtherAppWriteAccess());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OtherAppWriteAccess(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OtherAppWriteAccess(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListOtherAppWriteAccess const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LimitedWriteOperations(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListLimitedWriteOperations>(this->shim().LimitedWriteOperations());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SyncManager(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncManager>(this->shim().SyncManager());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RegisterSyncManagerAsync(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().RegisterSyncManagerAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetTaskReader(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskReader>(this->shim().GetTaskReader());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetTaskReaderWithOptions(void* options, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskReader>(this->shim().GetTaskReader(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQueryOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetTaskAsync(void* userDataTask, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask>>(this->shim().GetTaskAsync(*reinterpret_cast<hstring const*>(&userDataTask)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveTaskAsync(void* userDataTask, void** action) noexcept final try
        {
            clear_abi(action);
            typename D::abi_guard guard(this->shim());
            *action = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveTaskAsync(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask const*>(&userDataTask)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DeleteTaskAsync(void* userDataTaskId, void** action) noexcept final try
        {
            clear_abi(action);
            typename D::abi_guard guard(this->shim());
            *action = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().DeleteTaskAsync(*reinterpret_cast<hstring const*>(&userDataTaskId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DeleteAsync(void** asyncAction) noexcept final try
        {
            clear_abi(asyncAction);
            typename D::abi_guard guard(this->shim());
            *asyncAction = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().DeleteAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveAsync(void** asyncAction) noexcept final try
        {
            clear_abi(asyncAction);
            typename D::abi_guard guard(this->shim());
            *asyncAction = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations>
    {
        int32_t __stdcall TryCompleteTaskAsync(void* userDataTaskId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<hstring>>(this->shim().TryCompleteTaskAsync(*reinterpret_cast<hstring const*>(&userDataTaskId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryCreateOrUpdateTaskAsync(void* userDataTask, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<bool>>(this->shim().TryCreateOrUpdateTaskAsync(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask const*>(&userDataTask)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryDeleteTaskAsync(void* userDataTaskId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<bool>>(this->shim().TryDeleteTaskAsync(*reinterpret_cast<hstring const*>(&userDataTaskId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TrySkipOccurrenceAsync(void* userDataTaskId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<bool>>(this->shim().TrySkipOccurrenceAsync(*reinterpret_cast<hstring const*>(&userDataTaskId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager>
    {
        int32_t __stdcall get_LastAttemptedSyncTime(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().LastAttemptedSyncTime());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LastAttemptedSyncTime(int64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LastAttemptedSyncTime(*reinterpret_cast<winrt::Windows::Foundation::DateTime const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LastSuccessfulSyncTime(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().LastSuccessfulSyncTime());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LastSuccessfulSyncTime(int64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LastSuccessfulSyncTime(*reinterpret_cast<winrt::Windows::Foundation::DateTime const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Status(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Status(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncStatus const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SyncAsync(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<bool>>(this->shim().SyncAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_SyncStatusChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SyncStatusChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncManager, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SyncStatusChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SyncStatusChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager>
    {
        int32_t __stdcall RequestStoreAsync(int32_t accessType, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskStore>>(this->shim().RequestStoreAsync(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskStoreAccessType const*>(&accessType)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_User(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::System::User>(this->shim().User());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskManager>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetForUser(void* user, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskManager>(this->shim().GetForUser(*reinterpret_cast<winrt::Windows::System::User const*>(&user)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions>
    {
        int32_t __stdcall get_SortProperty(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQuerySortProperty>(this->shim().SortProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SortProperty(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SortProperty(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQuerySortProperty const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Kind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQueryKind>(this->shim().Kind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Kind(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Kind(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQueryKind const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskReader> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskReader>
    {
        int32_t __stdcall ReadBatchAsync(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskBatch>>(this->shim().ReadBatchAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties>
    {
        int32_t __stdcall get_Unit(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceUnit>(this->shim().Unit());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Unit(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Unit(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceUnit const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Occurrences(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().Occurrences());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Occurrences(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Occurrences(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Until(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().Until());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Until(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Until(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Interval(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Interval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Interval(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Interval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DaysOfWeek(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDaysOfWeek>>(this->shim().DaysOfWeek());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DaysOfWeek(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DaysOfWeek(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskDaysOfWeek> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WeekOfMonth(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskWeekOfMonth>>(this->shim().WeekOfMonth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_WeekOfMonth(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WeekOfMonth(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskWeekOfMonth> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Month(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().Month());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Month(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Month(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Day(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().Day());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Day(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Day(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties>
    {
        int32_t __stdcall get_Unit(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationUnit>(this->shim().Unit());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Unit(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Unit(*reinterpret_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationUnit const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Occurrences(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().Occurrences());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Occurrences(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Occurrences(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Until(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().Until());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Until(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Until(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Interval(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Interval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Interval(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Interval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore> : produce_base<D, winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore>
    {
        int32_t __stdcall CreateListAsync(void* name, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>>(this->shim().CreateListAsync(*reinterpret_cast<hstring const*>(&name)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateListInAccountAsync(void* name, void* userDataAccountId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>>(this->shim().CreateListAsync(*reinterpret_cast<hstring const*>(&name), *reinterpret_cast<hstring const*>(&userDataAccountId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindListsAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>>>(this->shim().FindListsAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetListAsync(void* taskListId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList>>(this->shim().GetListAsync(*reinterpret_cast<hstring const*>(&taskListId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Windows::ApplicationModel::UserDataTasks
{
    constexpr auto operator|(UserDataTaskDaysOfWeek const left, UserDataTaskDaysOfWeek const right) noexcept
    {
        return static_cast<UserDataTaskDaysOfWeek>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(UserDataTaskDaysOfWeek& left, UserDataTaskDaysOfWeek const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(UserDataTaskDaysOfWeek const left, UserDataTaskDaysOfWeek const right) noexcept
    {
        return static_cast<UserDataTaskDaysOfWeek>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(UserDataTaskDaysOfWeek& left, UserDataTaskDaysOfWeek const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(UserDataTaskDaysOfWeek const value) noexcept
    {
        return static_cast<UserDataTaskDaysOfWeek>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(UserDataTaskDaysOfWeek const left, UserDataTaskDaysOfWeek const right) noexcept
    {
        return static_cast<UserDataTaskDaysOfWeek>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(UserDataTaskDaysOfWeek& left, UserDataTaskDaysOfWeek const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline UserDataTask::UserDataTask() :
        UserDataTask(impl::call_factory_cast<UserDataTask(*)(winrt::Windows::Foundation::IActivationFactory const&), UserDataTask>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<UserDataTask>(); }))
    {
    }
    inline auto UserDataTaskManager::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskManager(*)(IUserDataTaskManagerStatics const&), UserDataTaskManager, IUserDataTaskManagerStatics>([](IUserDataTaskManagerStatics const& f) { return f.GetDefault(); });
    }
    inline auto UserDataTaskManager::GetForUser(winrt::Windows::System::User const& user)
    {
        return impl::call_factory<UserDataTaskManager, IUserDataTaskManagerStatics>([&](IUserDataTaskManagerStatics const& f) { return f.GetForUser(user); });
    }
    inline UserDataTaskQueryOptions::UserDataTaskQueryOptions() :
        UserDataTaskQueryOptions(impl::call_factory_cast<UserDataTaskQueryOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), UserDataTaskQueryOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<UserDataTaskQueryOptions>(); }))
    {
    }
    inline UserDataTaskRecurrenceProperties::UserDataTaskRecurrenceProperties() :
        UserDataTaskRecurrenceProperties(impl::call_factory_cast<UserDataTaskRecurrenceProperties(*)(winrt::Windows::Foundation::IActivationFactory const&), UserDataTaskRecurrenceProperties>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<UserDataTaskRecurrenceProperties>(); }))
    {
    }
    inline UserDataTaskRegenerationProperties::UserDataTaskRegenerationProperties() :
        UserDataTaskRegenerationProperties(impl::call_factory_cast<UserDataTaskRegenerationProperties(*)(winrt::Windows::Foundation::IActivationFactory const&), UserDataTaskRegenerationProperties>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<UserDataTaskRegenerationProperties>(); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTask> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskBatch> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskList> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListLimitedWriteOperations> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskListSyncManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskQueryOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskReader> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRecurrenceProperties> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskRegenerationProperties> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::IUserDataTaskStore> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTask> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskBatch> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskList> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListLimitedWriteOperations> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskListSyncManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskQueryOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskReader> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRecurrenceProperties> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskRegenerationProperties> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::ApplicationModel::UserDataTasks::UserDataTaskStore> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
