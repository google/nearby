// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Windowing_H
#define WINRT_Microsoft_UI_Windowing_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Microsoft.UI.Dispatching.2.h"
#include "winrt/impl/Microsoft.UI.Windowing.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.UI.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Id() const {
  winrt::Microsoft::UI::WindowId value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Id(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_Id(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::IsShownInSwitchers() const {
  bool value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsShownInSwitchers(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_IsShownInSwitchers(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::IsShownInSwitchers(
    bool value) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsShownInSwitchers(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->put_IsShownInSwitchers(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::IsVisible() const {
  bool value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsVisible(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_IsVisible(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::OwnerWindowId() const {
  winrt::Microsoft::UI::WindowId value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OwnerWindowId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_OwnerWindowId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Position() const {
  winrt::Windows::Graphics::PointInt32 value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Presenter() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Presenter(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_Presenter(&value));
  }
  return winrt::Microsoft::UI::Windowing::AppWindowPresenter{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Size() const {
  winrt::Windows::Graphics::SizeInt32 value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Title() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Title(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_Title(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Title(
    param::hstring const& value) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::TitleBar() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TitleBar(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->get_TitleBar(&value));
  }
  return winrt::Microsoft::UI::Windowing::AppWindowTitleBar{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroy() const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Destroy());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->Destroy());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Hide() const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Hide());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->Hide());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Move(
    winrt::Windows::Graphics::PointInt32 const& position) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Move(impl::bind_in(position)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->Move(impl::bind_in(position)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::MoveAndResize(
    winrt::Windows::Graphics::RectInt32 const& rect) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->MoveAndResize(impl::bind_in(rect)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->MoveAndResize(impl::bind_in(rect)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::MoveAndResize(
    winrt::Windows::Graphics::RectInt32 const& rect,
    winrt::Microsoft::UI::Windowing::DisplayArea const& displayarea) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->MoveAndResizeRelativeToDisplayArea(
        impl::bind_in(rect), *(void**)(&displayarea)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->MoveAndResizeRelativeToDisplayArea(
        impl::bind_in(rect), *(void**)(&displayarea)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Resize(
    winrt::Windows::Graphics::SizeInt32 const& size) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Resize(impl::bind_in(size)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->Resize(impl::bind_in(size)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetIcon(
    param::hstring const& iconPath) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetIcon(*(void**)(&iconPath)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->SetIcon(*(void**)(&iconPath)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetIcon(
    winrt::Microsoft::UI::IconId const& iconId) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetIconWithIconId(impl::bind_in(iconId)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->SetIconWithIconId(impl::bind_in(iconId)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetPresenter(
    winrt::Microsoft::UI::Windowing::AppWindowPresenter const&
        appWindowPresenter) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetPresenter(*(void**)(&appWindowPresenter)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(
        _winrt_abi_type->SetPresenter(*(void**)(&appWindowPresenter)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetPresenter(
    winrt::Microsoft::UI::Windowing::AppWindowPresenterKind const&
        appWindowPresenterKind) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetPresenterByKind(
        static_cast<int32_t>(appWindowPresenterKind)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->SetPresenterByKind(
        static_cast<int32_t>(appWindowPresenterKind)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Show() const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Show());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->Show());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Show(
    bool activateWindow) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ShowWithActivation(activateWindow));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(_winrt_abi_type->ShowWithActivation(activateWindow));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Changed(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::AppWindow,
        winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs> const&
        handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Changed(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(
        _winrt_abi_type->add_Changed(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Changed(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::AppWindow,
        winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs> const&
        handler) const {
  return impl::make_event_revoker<D, Changed_revoker>(this, Changed(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Changed(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Changed(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    _winrt_abi_type->remove_Changed(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Closing(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::AppWindow,
        winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs> const&
        handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(
        _winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Closing(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::AppWindow,
        winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs> const&
        handler) const {
  return impl::make_event_revoker<D, Closing_revoker>(this, Closing(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Closing(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Closing(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    _winrt_abi_type->remove_Closing(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroying(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::AppWindow,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Destroying(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    check_hresult(
        _winrt_abi_type->add_Destroying(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroying(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::AppWindow,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  return impl::make_event_revoker<D, Destroying_revoker>(this,
                                                         Destroying(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroying(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Destroying(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
    _winrt_abi_type->remove_Destroying(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::ClientSize() const {
  winrt::Windows::Graphics::SizeInt32 value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ClientSize(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
    check_hresult(_winrt_abi_type->get_ClientSize(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::MoveInZOrderAtBottom()
    const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->MoveInZOrderAtBottom());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
    check_hresult(_winrt_abi_type->MoveInZOrderAtBottom());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::MoveInZOrderAtTop() const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->MoveInZOrderAtTop());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
    check_hresult(_winrt_abi_type->MoveInZOrderAtTop());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::MoveInZOrderBelow(
    winrt::Microsoft::UI::WindowId const& windowId) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->MoveInZOrderBelow(impl::bind_in(windowId)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
    check_hresult(_winrt_abi_type->MoveInZOrderBelow(impl::bind_in(windowId)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::ResizeClient(
    winrt::Windows::Graphics::SizeInt32 const& size) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ResizeClient(impl::bind_in(size)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
    check_hresult(_winrt_abi_type->ResizeClient(impl::bind_in(size)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow2<
    D>::ShowOnceWithRequestedStartupState() const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ShowOnceWithRequestedStartupState());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
    check_hresult(_winrt_abi_type->ShowOnceWithRequestedStartupState());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow3<D>::
    AssociateWithDispatcherQueue(
        winrt::Microsoft::UI::Dispatching::DispatcherQueue const&
            dispatcherQueue) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow3,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->AssociateWithDispatcherQueue(
        *(void**)(&dispatcherQueue)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow3>**)this;
    check_hresult(_winrt_abi_type->AssociateWithDispatcherQueue(
        *(void**)(&dispatcherQueue)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow3<D>::DispatcherQueue() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow3,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow3>**)this;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueue{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTaskbarIcon(
    param::hstring const& iconPath) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow4>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow4>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetTaskbarIcon(*(void**)(&iconPath)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
    check_hresult(_winrt_abi_type->SetTaskbarIcon(*(void**)(&iconPath)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTaskbarIcon(
    winrt::Microsoft::UI::IconId const& iconId) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow4>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow4>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetTaskbarIconWithIconId(impl::bind_in(iconId)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
    check_hresult(
        _winrt_abi_type->SetTaskbarIconWithIconId(impl::bind_in(iconId)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTitleBarIcon(
    param::hstring const& iconPath) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow4>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow4>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetTitleBarIcon(*(void**)(&iconPath)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
    check_hresult(_winrt_abi_type->SetTitleBarIcon(*(void**)(&iconPath)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTitleBarIcon(
    winrt::Microsoft::UI::IconId const& iconId) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Windowing::IAppWindow4>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindow4>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetTitleBarIconWithIconId(impl::bind_in(iconId)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
    check_hresult(
        _winrt_abi_type->SetTitleBarIconWithIconId(impl::bind_in(iconId)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<
    D>::DidPositionChange() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DidPositionChange(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_DidPositionChange(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<
    D>::DidPresenterChange() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DidPresenterChange(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_DidPresenterChange(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<
    D>::DidSizeChange() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DidSizeChange(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_DidSizeChange(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<
    D>::DidVisibilityChange() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DidVisibilityChange(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_DidVisibilityChange(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<
    D>::DidZOrderChange() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DidZOrderChange(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)this;
    check_hresult(_winrt_abi_type->get_DidZOrderChange(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<
    D>::IsZOrderAtBottom() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsZOrderAtBottom(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)this;
    check_hresult(_winrt_abi_type->get_IsZOrderAtBottom(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<
    D>::IsZOrderAtTop() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsZOrderAtTop(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)this;
    check_hresult(_winrt_abi_type->get_IsZOrderAtTop(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<
    D>::ZOrderBelowWindowId() const {
  winrt::Microsoft::UI::WindowId value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowChangedEventArgs2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ZOrderBelowWindowId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowChangedEventArgs2>**)this;
    check_hresult(_winrt_abi_type->get_ZOrderBelowWindowId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowClosingEventArgs<D>::Cancel()
    const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowClosingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowClosingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Cancel(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Cancel(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowClosingEventArgs<D>::Cancel(
    bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowClosingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowClosingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Cancel(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>**)this;
    check_hresult(_winrt_abi_type->put_Cancel(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowPresenter<D>::Kind() const {
  winrt::Microsoft::UI::Windowing::AppWindowPresenterKind value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowPresenter>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowPresenter>**)this;
    check_hresult(
        _winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::Create() const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
    check_hresult(_winrt_abi_type->Create(&result));
  }
  return winrt::Microsoft::UI::Windowing::AppWindow{result,
                                                    take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::Create(
    winrt::Microsoft::UI::Windowing::AppWindowPresenter const&
        appWindowPresenter) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWithPresenter(
        *(void**)(&appWindowPresenter), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
    check_hresult(_winrt_abi_type->CreateWithPresenter(
        *(void**)(&appWindowPresenter), &result));
  }
  return winrt::Microsoft::UI::Windowing::AppWindow{result,
                                                    take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::Create(
    winrt::Microsoft::UI::Windowing::AppWindowPresenter const&
        appWindowPresenter,
    winrt::Microsoft::UI::WindowId const& ownerWindowId) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWithPresenterAndOwner(
        *(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
    check_hresult(_winrt_abi_type->CreateWithPresenterAndOwner(
        *(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId), &result));
  }
  return winrt::Microsoft::UI::Windowing::AppWindow{result,
                                                    take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::GetFromWindowId(
    winrt::Microsoft::UI::WindowId const& windowId) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetFromWindowId(impl::bind_in(windowId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetFromWindowId(impl::bind_in(windowId), &result));
  }
  return winrt::Microsoft::UI::Windowing::AppWindow{result,
                                                    take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowStatics2<D>::Create(
    winrt::Microsoft::UI::Windowing::AppWindowPresenter const&
        appWindowPresenter,
    winrt::Microsoft::UI::WindowId const& ownerWindowId,
    winrt::Microsoft::UI::Dispatching::DispatcherQueue const& DispatcherQueue)
    const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowStatics2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowStatics2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWithDispatcherQueue(
        *(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId),
        *(void**)(&DispatcherQueue), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics2>**)this;
    check_hresult(_winrt_abi_type->CreateWithDispatcherQueue(
        *(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId),
        *(void**)(&DispatcherQueue), &result));
  }
  return winrt::Microsoft::UI::Windowing::AppWindow{result,
                                                    take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::BackgroundColor()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_BackgroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_BackgroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::BackgroundColor(
    winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
        value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_BackgroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->put_BackgroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonBackgroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonBackgroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonBackgroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonBackgroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonBackgroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonBackgroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonForegroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonForegroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonForegroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonForegroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonForegroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonForegroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonHoverBackgroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonHoverBackgroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonHoverBackgroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonHoverBackgroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonHoverBackgroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonHoverBackgroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonHoverForegroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonHoverForegroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonHoverForegroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonHoverForegroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonHoverForegroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonHoverForegroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonInactiveBackgroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonInactiveBackgroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonInactiveBackgroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonInactiveBackgroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonInactiveBackgroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonInactiveBackgroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonInactiveForegroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonInactiveForegroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonInactiveForegroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonInactiveForegroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonInactiveForegroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonInactiveForegroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonPressedBackgroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonPressedBackgroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonPressedBackgroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonPressedBackgroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonPressedBackgroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonPressedBackgroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ButtonPressedForegroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ButtonPressedForegroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ButtonPressedForegroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    ButtonPressedForegroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_ButtonPressedForegroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_ButtonPressedForegroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ExtendsContentIntoTitleBar() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExtendsContentIntoTitleBar(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ExtendsContentIntoTitleBar(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::ExtendsContentIntoTitleBar(bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ExtendsContentIntoTitleBar(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->put_ExtendsContentIntoTitleBar(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ForegroundColor()
    const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForegroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_ForegroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ForegroundColor(
    winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
        value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForegroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->put_ForegroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::Height() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Height(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_Height(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::IconShowOptions()
    const {
  winrt::Microsoft::UI::Windowing::IconShowOptions value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IconShowOptions(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_IconShowOptions(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::IconShowOptions(
    winrt::Microsoft::UI::Windowing::IconShowOptions const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_IconShowOptions(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_IconShowOptions(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::InactiveBackgroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InactiveBackgroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_InactiveBackgroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    InactiveBackgroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_InactiveBackgroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_InactiveBackgroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<
    D>::InactiveForegroundColor() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InactiveForegroundColor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_InactiveForegroundColor(&value));
  }
  return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::
    InactiveForegroundColor(
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const&
            value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_InactiveForegroundColor(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->put_InactiveForegroundColor(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::LeftInset() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LeftInset(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_LeftInset(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::RightInset() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RightInset(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->get_RightInset(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ResetToDefault()
    const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ResetToDefault());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(_winrt_abi_type->ResetToDefault());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::SetDragRectangles(
    array_view<winrt::Windows::Graphics::RectInt32 const> value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetDragRectangles(value.size(), get_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
    check_hresult(
        _winrt_abi_type->SetDragRectangles(value.size(), get_abi(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar2<
    D>::PreferredHeightOption() const {
  winrt::Microsoft::UI::Windowing::TitleBarHeightOption value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreferredHeightOption(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>**)this;
    check_hresult(_winrt_abi_type->get_PreferredHeightOption(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar2<D>::
    PreferredHeightOption(
        winrt::Microsoft::UI::Windowing::TitleBarHeightOption const& value)
        const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PreferredHeightOption(
        static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>**)this;
    check_hresult(_winrt_abi_type->put_PreferredHeightOption(
        static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar3<D>::PreferredTheme()
    const {
  winrt::Microsoft::UI::Windowing::TitleBarTheme value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreferredTheme(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>**)this;
    check_hresult(_winrt_abi_type->get_PreferredTheme(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar3<D>::PreferredTheme(
    winrt::Microsoft::UI::Windowing::TitleBarTheme const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBar3>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_PreferredTheme(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>**)this;
    check_hresult(
        _winrt_abi_type->put_PreferredTheme(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IAppWindowTitleBarStatics<
    D>::IsCustomizationSupported() const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IAppWindowTitleBarStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IAppWindowTitleBarStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsCustomizationSupported(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics>**)this;
    check_hresult(_winrt_abi_type->IsCustomizationSupported(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_ICompactOverlayPresenter<D>::InitialSize()
    const {
  winrt::Microsoft::UI::Windowing::CompactOverlaySize value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       ICompactOverlayPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    ICompactOverlayPresenter>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_InitialSize(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>**)this;
    check_hresult(
        _winrt_abi_type->get_InitialSize(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_ICompactOverlayPresenter<D>::InitialSize(
    winrt::Microsoft::UI::Windowing::CompactOverlaySize const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       ICompactOverlayPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    ICompactOverlayPresenter>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_InitialSize(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>**)this;
    check_hresult(
        _winrt_abi_type->put_InitialSize(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_ICompactOverlayPresenterStatics<D>::Create()
    const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       ICompactOverlayPresenterStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    ICompactOverlayPresenterStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    ICompactOverlayPresenterStatics>**)this;
    check_hresult(_winrt_abi_type->Create(&result));
  }
  return winrt::Microsoft::UI::Windowing::CompactOverlayPresenter{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::DisplayId() const {
  winrt::Microsoft::UI::DisplayId value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayArea>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayArea>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DisplayId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
    check_hresult(_winrt_abi_type->get_DisplayId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::IsPrimary() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayArea>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayArea>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsPrimary(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
    check_hresult(_winrt_abi_type->get_IsPrimary(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::OuterBounds() const {
  winrt::Windows::Graphics::RectInt32 value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayArea>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayArea>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OuterBounds(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
    check_hresult(_winrt_abi_type->get_OuterBounds(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::WorkArea() const {
  winrt::Windows::Graphics::RectInt32 value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayArea>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayArea>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_WorkArea(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
    check_hresult(_winrt_abi_type->get_WorkArea(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::Primary() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Primary(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
    check_hresult(_winrt_abi_type->get_Primary(&value));
  }
  return winrt::Microsoft::UI::Windowing::DisplayArea{value,
                                                      take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::CreateWatcher()
    const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWatcher(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
    check_hresult(_winrt_abi_type->CreateWatcher(&result));
  }
  return winrt::Microsoft::UI::Windowing::DisplayAreaWatcher{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::FindAll() const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->FindAll(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
    check_hresult(_winrt_abi_type->FindAll(&result));
  }
  return winrt::Windows::Foundation::Collections::IVectorView<
      winrt::Microsoft::UI::Windowing::DisplayArea>{result,
                                                    take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::GetFromWindowId(
    winrt::Microsoft::UI::WindowId const& windowId,
    winrt::Microsoft::UI::Windowing::DisplayAreaFallback const&
        displayAreaFallback) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetFromWindowId(
        impl::bind_in(windowId), static_cast<int32_t>(displayAreaFallback),
        &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
    check_hresult(_winrt_abi_type->GetFromWindowId(
        impl::bind_in(windowId), static_cast<int32_t>(displayAreaFallback),
        &result));
  }
  return winrt::Microsoft::UI::Windowing::DisplayArea{result,
                                                      take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::GetFromPoint(
    winrt::Windows::Graphics::PointInt32 const& point,
    winrt::Microsoft::UI::Windowing::DisplayAreaFallback const&
        displayAreaFallback) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetFromPoint(
        impl::bind_in(point), static_cast<int32_t>(displayAreaFallback),
        &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
    check_hresult(_winrt_abi_type->GetFromPoint(
        impl::bind_in(point), static_cast<int32_t>(displayAreaFallback),
        &result));
  }
  return winrt::Microsoft::UI::Windowing::DisplayArea{result,
                                                      take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::GetFromRect(
    winrt::Windows::Graphics::RectInt32 const& rect,
    winrt::Microsoft::UI::Windowing::DisplayAreaFallback const&
        displayAreaFallback) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetFromRect(
        impl::bind_in(rect), static_cast<int32_t>(displayAreaFallback),
        &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
    check_hresult(_winrt_abi_type->GetFromRect(
        impl::bind_in(rect), static_cast<int32_t>(displayAreaFallback),
        &result));
  }
  return winrt::Microsoft::UI::Windowing::DisplayArea{result,
                                                      take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics2<D>::GetFromDisplayId(
    winrt::Microsoft::UI::DisplayId const& displayId) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaStatics2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetFromDisplayId(impl::bind_in(displayId), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>**)this;
    check_hresult(
        _winrt_abi_type->GetFromDisplayId(impl::bind_in(displayId), &result));
  }
  return winrt::Microsoft::UI::Windowing::DisplayArea{result,
                                                      take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Status() const {
  winrt::Microsoft::UI::Windowing::DisplayAreaWatcherStatus value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Start() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Start());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(_winrt_abi_type->Start());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stop() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Stop());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(_winrt_abi_type->Stop());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Added(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Added(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(
        _winrt_abi_type->add_Added(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Added(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const {
  return impl::make_event_revoker<D, Added_revoker>(this, Added(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Added(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Added(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    _winrt_abi_type->remove_Added(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::
    EnumerationCompleted(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
            winrt::Windows::Foundation::IInspectable> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_EnumerationCompleted(*(void**)(&handler),
                                                            put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(_winrt_abi_type->add_EnumerationCompleted(*(void**)(&handler),
                                                            put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::
    EnumerationCompleted(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
            winrt::Windows::Foundation::IInspectable> const& handler) const {
  return impl::make_event_revoker<D, EnumerationCompleted_revoker>(
      this, EnumerationCompleted(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<
    D>::EnumerationCompleted(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    _winrt_abi_type->remove_EnumerationCompleted(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    _winrt_abi_type->remove_EnumerationCompleted(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Removed(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Removed(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(
        _winrt_abi_type->add_Removed(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Removed(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const {
  return impl::make_event_revoker<D, Removed_revoker>(this, Removed(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Removed(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Removed(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    _winrt_abi_type->remove_Removed(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stopped(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Stopped(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(
        _winrt_abi_type->add_Stopped(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stopped(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  return impl::make_event_revoker<D, Stopped_revoker>(this, Stopped(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stopped(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Stopped(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    _winrt_abi_type->remove_Stopped(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Updated(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Updated(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    check_hresult(
        _winrt_abi_type->add_Updated(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Updated(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
        winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const {
  return impl::make_event_revoker<D, Updated_revoker>(this, Updated(handler));
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Updated(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IDisplayAreaWatcher>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Updated(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
    _winrt_abi_type->remove_Updated(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IFullScreenPresenterStatics<D>::Create()
    const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IFullScreenPresenterStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IFullScreenPresenterStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IFullScreenPresenterStatics>**)this;
    check_hresult(_winrt_abi_type->Create(&result));
  }
  return winrt::Microsoft::UI::Windowing::FullScreenPresenter{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::HasBorder() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HasBorder(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->get_HasBorder(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::HasTitleBar()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HasTitleBar(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->get_HasTitleBar(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsAlwaysOnTop()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsAlwaysOnTop(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->get_IsAlwaysOnTop(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsAlwaysOnTop(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsAlwaysOnTop(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->put_IsAlwaysOnTop(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMaximizable()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsMaximizable(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->get_IsMaximizable(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMaximizable(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsMaximizable(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->put_IsMaximizable(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMinimizable()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsMinimizable(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->get_IsMinimizable(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMinimizable(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsMinimizable(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->put_IsMinimizable(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsModal() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsModal(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->get_IsModal(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsModal(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsModal(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->put_IsModal(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsResizable()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsResizable(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->get_IsResizable(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsResizable(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsResizable(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->put_IsResizable(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::State() const {
  winrt::Microsoft::UI::Windowing::OverlappedPresenterState value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(
        _winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::Maximize() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Maximize());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->Maximize());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::Minimize() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Minimize());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->Minimize());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::Restore() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Restore());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(_winrt_abi_type->Restore());
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<
    D>::SetBorderAndTitleBar(bool hasBorder, bool hasTitleBar) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetBorderAndTitleBar(hasBorder, hasTitleBar));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
    check_hresult(
        _winrt_abi_type->SetBorderAndTitleBar(hasBorder, hasTitleBar));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter2<D>::Minimize(
    bool activateWindow) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->MinimizeWithActivation(activateWindow));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>**)this;
    check_hresult(_winrt_abi_type->MinimizeWithActivation(activateWindow));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter2<D>::Restore(
    bool activateWindow) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RestoreWithActivation(activateWindow));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>**)this;
    check_hresult(_winrt_abi_type->RestoreWithActivation(activateWindow));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<
    D>::PreferredMinimumHeight() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreferredMinimumHeight(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(_winrt_abi_type->get_PreferredMinimumHeight(&value));
  }
  return winrt::Windows::Foundation::IReference<int32_t>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::
    PreferredMinimumHeight(
        winrt::Windows::Foundation::IReference<int32_t> const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_PreferredMinimumHeight(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(
        _winrt_abi_type->put_PreferredMinimumHeight(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<
    D>::PreferredMinimumWidth() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreferredMinimumWidth(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(_winrt_abi_type->get_PreferredMinimumWidth(&value));
  }
  return winrt::Windows::Foundation::IReference<int32_t>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::
    PreferredMinimumWidth(
        winrt::Windows::Foundation::IReference<int32_t> const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_PreferredMinimumWidth(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(
        _winrt_abi_type->put_PreferredMinimumWidth(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<
    D>::PreferredMaximumWidth() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreferredMaximumWidth(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(_winrt_abi_type->get_PreferredMaximumWidth(&value));
  }
  return winrt::Windows::Foundation::IReference<int32_t>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::
    PreferredMaximumWidth(
        winrt::Windows::Foundation::IReference<int32_t> const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_PreferredMaximumWidth(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(
        _winrt_abi_type->put_PreferredMaximumWidth(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<
    D>::PreferredMaximumHeight() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreferredMaximumHeight(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(_winrt_abi_type->get_PreferredMaximumHeight(&value));
  }
  return winrt::Windows::Foundation::IReference<int32_t>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::
    PreferredMaximumHeight(
        winrt::Windows::Foundation::IReference<int32_t> const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenter3>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_PreferredMaximumHeight(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
    check_hresult(
        _winrt_abi_type->put_PreferredMaximumHeight(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<D>::Create()
    const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IOverlappedPresenterStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)this;
    check_hresult(_winrt_abi_type->Create(&result));
  }
  return winrt::Microsoft::UI::Windowing::OverlappedPresenter{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<
    D>::CreateForContextMenu() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IOverlappedPresenterStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateForContextMenu(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)this;
    check_hresult(_winrt_abi_type->CreateForContextMenu(&result));
  }
  return winrt::Microsoft::UI::Windowing::OverlappedPresenter{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<
    D>::CreateForDialog() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IOverlappedPresenterStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateForDialog(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)this;
    check_hresult(_winrt_abi_type->CreateForDialog(&result));
  }
  return winrt::Microsoft::UI::Windowing::OverlappedPresenter{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<
    D>::CreateForToolWindow() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IOverlappedPresenterStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateForToolWindow(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics>**)this;
    check_hresult(_winrt_abi_type->CreateForToolWindow(&result));
  }
  return winrt::Microsoft::UI::Windowing::OverlappedPresenter{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics2<
    D>::RequestedStartupState() const {
  winrt::Microsoft::UI::Windowing::OverlappedPresenterState value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::
                                       IOverlappedPresenterStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RequestedStartupState(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Windowing::
                    IOverlappedPresenterStatics2>**)this;
    check_hresult(_winrt_abi_type->get_RequestedStartupState(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow> {
  int32_t __stdcall get_Id(
      struct struct_Microsoft_UI_WindowId* value) noexcept final try {
    zero_abi<winrt::Microsoft::UI::WindowId>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::WindowId>(this->shim().Id());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsShownInSwitchers(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsShownInSwitchers());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsShownInSwitchers(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsShownInSwitchers(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsVisible(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsVisible());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OwnerWindowId(
      struct struct_Microsoft_UI_WindowId* value) noexcept final try {
    zero_abi<winrt::Microsoft::UI::WindowId>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::WindowId>(
        this->shim().OwnerWindowId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      struct struct_Windows_Graphics_PointInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::PointInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::PointInt32>(
        this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Presenter(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Windowing::AppWindowPresenter>(
        this->shim().Presenter());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Size(
      struct struct_Windows_Graphics_SizeInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::SizeInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Graphics::SizeInt32>(this->shim().Size());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Title(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Title());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Title(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Title(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_TitleBar(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Windowing::AppWindowTitleBar>(
        this->shim().TitleBar());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Destroy() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Destroy();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Hide() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Hide();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Move(
      struct struct_Windows_Graphics_PointInt32 position) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Move(
        *reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(
            &position));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall MoveAndResize(
      struct struct_Windows_Graphics_RectInt32 rect) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().MoveAndResize(
        *reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(&rect));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall MoveAndResizeRelativeToDisplayArea(
      struct struct_Windows_Graphics_RectInt32 rect,
      void* displayarea) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().MoveAndResize(
        *reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(&rect),
        *reinterpret_cast<winrt::Microsoft::UI::Windowing::DisplayArea const*>(
            &displayarea));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Resize(
      struct struct_Windows_Graphics_SizeInt32 size) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Resize(
        *reinterpret_cast<winrt::Windows::Graphics::SizeInt32 const*>(&size));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetIcon(void* iconPath) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetIcon(*reinterpret_cast<hstring const*>(&iconPath));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetIconWithIconId(
      struct struct_Microsoft_UI_IconId iconId) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetIcon(
        *reinterpret_cast<winrt::Microsoft::UI::IconId const*>(&iconId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetPresenter(void* appWindowPresenter) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetPresenter(
        *reinterpret_cast<
            winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(
            &appWindowPresenter));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetPresenterByKind(
      int32_t appWindowPresenterKind) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetPresenter(
        *reinterpret_cast<
            winrt::Microsoft::UI::Windowing::AppWindowPresenterKind const*>(
            &appWindowPresenterKind));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Show() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Show();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ShowWithActivation(bool activateWindow) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Show(activateWindow);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_Changed(void* handler,
                                winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Changed(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::AppWindow,
            winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Changed(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Changed(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_Closing(void* handler,
                                winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Closing(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::AppWindow,
            winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Closing(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Closing(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_Destroying(void* handler,
                                   winrt::event_token* token) noexcept final
      try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Destroying(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::AppWindow,
            winrt::Windows::Foundation::IInspectable> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Destroying(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Destroying(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow2>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow2> {
  int32_t __stdcall get_ClientSize(
      struct struct_Windows_Graphics_SizeInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::SizeInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::SizeInt32>(
        this->shim().ClientSize());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall MoveInZOrderAtBottom() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().MoveInZOrderAtBottom();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall MoveInZOrderAtTop() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().MoveInZOrderAtTop();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall MoveInZOrderBelow(
      struct struct_Microsoft_UI_WindowId windowId) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().MoveInZOrderBelow(
        *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ResizeClient(
      struct struct_Windows_Graphics_SizeInt32 size) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ResizeClient(
        *reinterpret_cast<winrt::Windows::Graphics::SizeInt32 const*>(&size));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ShowOnceWithRequestedStartupState() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ShowOnceWithRequestedStartupState();
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow3>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow3> {
  int32_t __stdcall AssociateWithDispatcherQueue(
      void* dispatcherQueue) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AssociateWithDispatcherQueue(
        *reinterpret_cast<
            winrt::Microsoft::UI::Dispatching::DispatcherQueue const*>(
            &dispatcherQueue));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DispatcherQueue(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(
        this->shim().DispatcherQueue());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow4>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow4> {
  int32_t __stdcall SetTaskbarIcon(void* iconPath) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetTaskbarIcon(*reinterpret_cast<hstring const*>(&iconPath));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetTaskbarIconWithIconId(
      struct struct_Microsoft_UI_IconId iconId) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetTaskbarIcon(
        *reinterpret_cast<winrt::Microsoft::UI::IconId const*>(&iconId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetTitleBarIcon(void* iconPath) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetTitleBarIcon(*reinterpret_cast<hstring const*>(&iconPath));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetTitleBarIconWithIconId(
      struct struct_Microsoft_UI_IconId iconId) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetTitleBarIcon(
        *reinterpret_cast<winrt::Microsoft::UI::IconId const*>(&iconId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs> {
  int32_t __stdcall get_DidPositionChange(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DidPositionChange());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DidPresenterChange(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DidPresenterChange());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DidSizeChange(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DidSizeChange());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DidVisibilityChange(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DidVisibilityChange());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2> {
  int32_t __stdcall get_DidZOrderChange(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DidZOrderChange());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsZOrderAtBottom(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsZOrderAtBottom());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsZOrderAtTop(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsZOrderAtTop());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ZOrderBelowWindowId(
      struct struct_Microsoft_UI_WindowId* value) noexcept final try {
    zero_abi<winrt::Microsoft::UI::WindowId>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::WindowId>(
        this->shim().ZOrderBelowWindowId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs> {
  int32_t __stdcall get_Cancel(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().Cancel());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Cancel(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Cancel(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenter>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenter> {
  int32_t __stdcall get_Kind(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::Windowing::AppWindowPresenterKind>(
            this->shim().Kind());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenterFactory>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::IAppWindowPresenterFactory> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics> {
  int32_t __stdcall Create(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(
        this->shim().Create());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateWithPresenter(void* appWindowPresenter,
                                        void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(
        this->shim().Create(
            *reinterpret_cast<
                winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(
                &appWindowPresenter)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateWithPresenterAndOwner(
      void* appWindowPresenter,
      struct struct_Microsoft_UI_WindowId ownerWindowId,
      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(
        this->shim().Create(
            *reinterpret_cast<
                winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(
                &appWindowPresenter),
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                &ownerWindowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetFromWindowId(
      struct struct_Microsoft_UI_WindowId windowId,
      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(
        this->shim().GetFromWindowId(
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                &windowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics2>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics2> {
  int32_t __stdcall CreateWithDispatcherQueue(
      void* appWindowPresenter,
      struct struct_Microsoft_UI_WindowId ownerWindowId, void* DispatcherQueue,
      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(
        this->shim().Create(
            *reinterpret_cast<
                winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(
                &appWindowPresenter),
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                &ownerWindowId),
            *reinterpret_cast<
                winrt::Microsoft::UI::Dispatching::DispatcherQueue const*>(
                &DispatcherQueue)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar> {
  int32_t __stdcall get_BackgroundColor(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().BackgroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_BackgroundColor(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().BackgroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonBackgroundColor(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonBackgroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonBackgroundColor(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonBackgroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonForegroundColor(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonForegroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonForegroundColor(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonForegroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonHoverBackgroundColor(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonHoverBackgroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonHoverBackgroundColor(void* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonHoverBackgroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonHoverForegroundColor(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonHoverForegroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonHoverForegroundColor(void* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonHoverForegroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonInactiveBackgroundColor(
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonInactiveBackgroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonInactiveBackgroundColor(
      void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonInactiveBackgroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonInactiveForegroundColor(
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonInactiveForegroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonInactiveForegroundColor(
      void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonInactiveForegroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonPressedBackgroundColor(
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonPressedBackgroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonPressedBackgroundColor(void* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonPressedBackgroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ButtonPressedForegroundColor(
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ButtonPressedForegroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ButtonPressedForegroundColor(void* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ButtonPressedForegroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExtendsContentIntoTitleBar(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ExtendsContentIntoTitleBar());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ExtendsContentIntoTitleBar(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ExtendsContentIntoTitleBar(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForegroundColor(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().ForegroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForegroundColor(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForegroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Height(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().Height());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IconShowOptions(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Windowing::IconShowOptions>(
        this->shim().IconShowOptions());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IconShowOptions(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IconShowOptions(
        *reinterpret_cast<
            winrt::Microsoft::UI::Windowing::IconShowOptions const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InactiveBackgroundColor(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().InactiveBackgroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InactiveBackgroundColor(void* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().InactiveBackgroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InactiveForegroundColor(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(
        this->shim().InactiveForegroundColor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InactiveForegroundColor(void* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().InactiveForegroundColor(
        *reinterpret_cast<winrt::Windows::Foundation::IReference<
            winrt::Windows::UI::Color> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LeftInset(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().LeftInset());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RightInset(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().RightInset());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ResetToDefault() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ResetToDefault();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetDragRectangles(
      uint32_t __valueSize,
      struct struct_Windows_Graphics_RectInt32* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetDragRectangles(
        array_view<winrt::Windows::Graphics::RectInt32 const>(
            reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(value),
            reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(
                value) +
                __valueSize));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2> {
  int32_t __stdcall get_PreferredHeightOption(int32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Windowing::TitleBarHeightOption>(
        this->shim().PreferredHeightOption());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreferredHeightOption(int32_t value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreferredHeightOption(
        *reinterpret_cast<
            winrt::Microsoft::UI::Windowing::TitleBarHeightOption const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3> {
  int32_t __stdcall get_PreferredTheme(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Windowing::TitleBarTheme>(
        this->shim().PreferredTheme());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreferredTheme(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreferredTheme(
        *reinterpret_cast<
            winrt::Microsoft::UI::Windowing::TitleBarTheme const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics>
    : produce_base<D,
                   winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics> {
  int32_t __stdcall IsCustomizationSupported(bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsCustomizationSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>
    : produce_base<D,
                   winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter> {
  int32_t __stdcall get_InitialSize(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Windowing::CompactOverlaySize>(
        this->shim().InitialSize());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InitialSize(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InitialSize(
        *reinterpret_cast<
            winrt::Microsoft::UI::Windowing::CompactOverlaySize const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics> {
  int32_t __stdcall Create(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter>(
            this->shim().Create());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayArea>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayArea> {
  int32_t __stdcall get_DisplayId(
      struct struct_Microsoft_UI_DisplayId* value) noexcept final try {
    zero_abi<winrt::Microsoft::UI::DisplayId>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::DisplayId>(this->shim().DisplayId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsPrimary(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsPrimary());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OuterBounds(
      struct struct_Windows_Graphics_RectInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::RectInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::RectInt32>(
        this->shim().OuterBounds());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_WorkArea(
      struct struct_Windows_Graphics_RectInt32* value) noexcept final try {
    zero_abi<winrt::Windows::Graphics::RectInt32>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Graphics::RectInt32>(
        this->shim().WorkArea());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics> {
  int32_t __stdcall get_Primary(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(
        this->shim().Primary());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateWatcher(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher>(
        this->shim().CreateWatcher());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall FindAll(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<
        winrt::Microsoft::UI::Windowing::DisplayArea>>(this->shim().FindAll());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetFromWindowId(
      struct struct_Microsoft_UI_WindowId windowId, int32_t displayAreaFallback,
      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(
        this->shim().GetFromWindowId(
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId),
            *reinterpret_cast<
                winrt::Microsoft::UI::Windowing::DisplayAreaFallback const*>(
                &displayAreaFallback)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetFromPoint(
      struct struct_Windows_Graphics_PointInt32 point,
      int32_t displayAreaFallback, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(
        this->shim().GetFromPoint(
            *reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(
                &point),
            *reinterpret_cast<
                winrt::Microsoft::UI::Windowing::DisplayAreaFallback const*>(
                &displayAreaFallback)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetFromRect(struct struct_Windows_Graphics_RectInt32 rect,
                                int32_t displayAreaFallback,
                                void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(
        this->shim().GetFromRect(
            *reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(
                &rect),
            *reinterpret_cast<
                winrt::Microsoft::UI::Windowing::DisplayAreaFallback const*>(
                &displayAreaFallback)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2> {
  int32_t __stdcall GetFromDisplayId(
      struct struct_Microsoft_UI_DisplayId displayId,
      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(
        this->shim().GetFromDisplayId(
            *reinterpret_cast<winrt::Microsoft::UI::DisplayId const*>(
                &displayId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher> {
  int32_t __stdcall get_Status(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::Windowing::DisplayAreaWatcherStatus>(
            this->shim().Status());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Start() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Start();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Stop() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Stop();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_Added(void* handler,
                              winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Added(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
            winrt::Microsoft::UI::Windowing::DisplayArea> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Added(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Added(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_EnumerationCompleted(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().EnumerationCompleted(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
            winrt::Windows::Foundation::IInspectable> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_EnumerationCompleted(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().EnumerationCompleted(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_Removed(void* handler,
                                winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Removed(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
            winrt::Microsoft::UI::Windowing::DisplayArea> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Removed(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Removed(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_Stopped(void* handler,
                                winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Stopped(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
            winrt::Windows::Foundation::IInspectable> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Stopped(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Stopped(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_Updated(void* handler,
                                winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Updated(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Windowing::DisplayAreaWatcher,
            winrt::Microsoft::UI::Windowing::DisplayArea> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Updated(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Updated(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenter>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenter> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics> {
  int32_t __stdcall Create(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::FullScreenPresenter>(
        this->shim().Create());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter> {
  int32_t __stdcall get_HasBorder(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().HasBorder());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_HasTitleBar(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().HasTitleBar());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsAlwaysOnTop(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsAlwaysOnTop());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsAlwaysOnTop(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsAlwaysOnTop(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsMaximizable(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsMaximizable());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsMaximizable(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsMaximizable(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsMinimizable(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsMinimizable());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsMinimizable(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsMinimizable(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsModal(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsModal());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsModal(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsModal(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsResizable(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsResizable());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsResizable(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsResizable(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_State(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenterState>(
            this->shim().State());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Maximize() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Maximize();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Minimize() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Minimize();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Restore() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Restore();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetBorderAndTitleBar(bool hasBorder,
                                         bool hasTitleBar) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetBorderAndTitleBar(hasBorder, hasTitleBar);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter2> {
  int32_t __stdcall MinimizeWithActivation(bool activateWindow) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().Minimize(activateWindow);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RestoreWithActivation(bool activateWindow) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().Restore(activateWindow);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>
    : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3> {
  int32_t __stdcall get_PreferredMinimumHeight(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(
        this->shim().PreferredMinimumHeight());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreferredMinimumHeight(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreferredMinimumHeight(
        *reinterpret_cast<
            winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PreferredMinimumWidth(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(
        this->shim().PreferredMinimumWidth());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreferredMinimumWidth(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreferredMinimumWidth(
        *reinterpret_cast<
            winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PreferredMaximumWidth(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(
        this->shim().PreferredMaximumWidth());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreferredMaximumWidth(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreferredMaximumWidth(
        *reinterpret_cast<
            winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PreferredMaximumHeight(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(
        this->shim().PreferredMaximumHeight());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreferredMaximumHeight(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreferredMaximumHeight(
        *reinterpret_cast<
            winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics> {
  int32_t __stdcall Create(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(
        this->shim().Create());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateForContextMenu(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(
        this->shim().CreateForContextMenu());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateForDialog(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(
        this->shim().CreateForDialog());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateForToolWindow(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(
        this->shim().CreateForToolWindow());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2>
    : produce_base<
          D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2> {
  int32_t __stdcall get_RequestedStartupState(int32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenterState>(
            this->shim().RequestedStartupState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::UI::Windowing {
  inline auto AppWindow::Create() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::AppWindow (*)(
            IAppWindowStatics const&),
        AppWindow, IAppWindowStatics>(
        [](IAppWindowStatics const& f) { return f.Create(); });
  }
  inline auto AppWindow::Create(
      winrt::Microsoft::UI::Windowing::AppWindowPresenter const&
          appWindowPresenter) {
    return impl::call_factory<AppWindow, IAppWindowStatics>(
        [&](IAppWindowStatics const& f) {
          return f.Create(appWindowPresenter);
        });
  }
  inline auto AppWindow::Create(
      winrt::Microsoft::UI::Windowing::AppWindowPresenter const&
          appWindowPresenter,
      winrt::Microsoft::UI::WindowId const& ownerWindowId) {
    return impl::call_factory<AppWindow, IAppWindowStatics>(
        [&](IAppWindowStatics const& f) {
          return f.Create(appWindowPresenter, ownerWindowId);
        });
  }
  inline auto AppWindow::GetFromWindowId(
      winrt::Microsoft::UI::WindowId const& windowId) {
    return impl::call_factory<AppWindow, IAppWindowStatics>(
        [&](IAppWindowStatics const& f) {
          return f.GetFromWindowId(windowId);
        });
  }
  inline auto AppWindow::Create(
      winrt::Microsoft::UI::Windowing::AppWindowPresenter const&
          appWindowPresenter,
      winrt::Microsoft::UI::WindowId const& ownerWindowId,
      winrt::Microsoft::UI::Dispatching::DispatcherQueue const&
          DispatcherQueue) {
    return impl::call_factory<AppWindow, IAppWindowStatics2>(
        [&](IAppWindowStatics2 const& f) {
          return f.Create(appWindowPresenter, ownerWindowId, DispatcherQueue);
        });
  }
  inline auto AppWindowTitleBar::IsCustomizationSupported() {
    return impl::call_factory_cast<bool (*)(IAppWindowTitleBarStatics const&),
                                   AppWindowTitleBar,
                                   IAppWindowTitleBarStatics>(
        [](IAppWindowTitleBarStatics const& f) {
          return f.IsCustomizationSupported();
        });
  }
  inline auto CompactOverlayPresenter::Create() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::CompactOverlayPresenter (*)(
            ICompactOverlayPresenterStatics const&),
        CompactOverlayPresenter, ICompactOverlayPresenterStatics>(
        [](ICompactOverlayPresenterStatics const& f) { return f.Create(); });
  }
  inline auto DisplayArea::Primary() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::DisplayArea (*)(
            IDisplayAreaStatics const&),
        DisplayArea, IDisplayAreaStatics>(
        [](IDisplayAreaStatics const& f) { return f.Primary(); });
  }
  inline auto DisplayArea::CreateWatcher() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcher (*)(
            IDisplayAreaStatics const&),
        DisplayArea, IDisplayAreaStatics>(
        [](IDisplayAreaStatics const& f) { return f.CreateWatcher(); });
  }
  inline auto DisplayArea::FindAll() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::Collections::IVectorView<
            winrt::Microsoft::UI::Windowing::DisplayArea> (*)(
            IDisplayAreaStatics const&),
        DisplayArea, IDisplayAreaStatics>(
        [](IDisplayAreaStatics const& f) { return f.FindAll(); });
  }
  inline auto DisplayArea::GetFromWindowId(
      winrt::Microsoft::UI::WindowId const& windowId,
      winrt::Microsoft::UI::Windowing::DisplayAreaFallback const&
          displayAreaFallback) {
    return impl::call_factory<DisplayArea, IDisplayAreaStatics>(
        [&](IDisplayAreaStatics const& f) {
          return f.GetFromWindowId(windowId, displayAreaFallback);
        });
  }
  inline auto DisplayArea::GetFromPoint(
      winrt::Windows::Graphics::PointInt32 const& point,
      winrt::Microsoft::UI::Windowing::DisplayAreaFallback const&
          displayAreaFallback) {
    return impl::call_factory<DisplayArea, IDisplayAreaStatics>(
        [&](IDisplayAreaStatics const& f) {
          return f.GetFromPoint(point, displayAreaFallback);
        });
  }
  inline auto DisplayArea::GetFromRect(
      winrt::Windows::Graphics::RectInt32 const& rect,
      winrt::Microsoft::UI::Windowing::DisplayAreaFallback const&
          displayAreaFallback) {
    return impl::call_factory<DisplayArea, IDisplayAreaStatics>(
        [&](IDisplayAreaStatics const& f) {
          return f.GetFromRect(rect, displayAreaFallback);
        });
  }
  inline auto DisplayArea::GetFromDisplayId(
      winrt::Microsoft::UI::DisplayId const& displayId) {
    return impl::call_factory<DisplayArea, IDisplayAreaStatics2>(
        [&](IDisplayAreaStatics2 const& f) {
          return f.GetFromDisplayId(displayId);
        });
  }
  inline auto FullScreenPresenter::Create() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::FullScreenPresenter (*)(
            IFullScreenPresenterStatics const&),
        FullScreenPresenter, IFullScreenPresenterStatics>(
        [](IFullScreenPresenterStatics const& f) { return f.Create(); });
  }
  inline auto OverlappedPresenter::Create() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::OverlappedPresenter (*)(
            IOverlappedPresenterStatics const&),
        OverlappedPresenter, IOverlappedPresenterStatics>(
        [](IOverlappedPresenterStatics const& f) { return f.Create(); });
  }
  inline auto OverlappedPresenter::CreateForContextMenu() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::OverlappedPresenter (*)(
            IOverlappedPresenterStatics const&),
        OverlappedPresenter, IOverlappedPresenterStatics>(
        [](IOverlappedPresenterStatics const& f) {
          return f.CreateForContextMenu();
        });
  }
  inline auto OverlappedPresenter::CreateForDialog() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::OverlappedPresenter (*)(
            IOverlappedPresenterStatics const&),
        OverlappedPresenter, IOverlappedPresenterStatics>(
        [](IOverlappedPresenterStatics const& f) {
          return f.CreateForDialog();
        });
  }
  inline auto OverlappedPresenter::CreateForToolWindow() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::OverlappedPresenter (*)(
            IOverlappedPresenterStatics const&),
        OverlappedPresenter, IOverlappedPresenterStatics>(
        [](IOverlappedPresenterStatics const& f) {
          return f.CreateForToolWindow();
        });
  }
  inline auto OverlappedPresenter::RequestedStartupState() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Windowing::OverlappedPresenterState (*)(
            IOverlappedPresenterStatics2 const&),
        OverlappedPresenter, IOverlappedPresenterStatics2>(
        [](IOverlappedPresenterStatics2 const& f) {
          return f.RequestedStartupState();
        });
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindow>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindow2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindow3>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindow4>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowPresenter>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowPresenterFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowStatics2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IDisplayArea>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IFullScreenPresenter>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::AppWindow>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::AppWindowPresenter>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::AppWindowTitleBar>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::DisplayArea>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::FullScreenPresenter>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Windowing::OverlappedPresenter>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
