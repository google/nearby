// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Dispatching_H
#define WINRT_Microsoft_UI_Dispatching_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.h"
#include "winrt/impl/Microsoft.UI.Dispatching.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherExitDeferral<D>::Complete()
    const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Dispatching::
                                       IDispatcherExitDeferral>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherExitDeferral, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherExitDeferral>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Complete());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Dispatching::IDispatcherExitDeferral>**)this;
    check_hresult(_winrt_abi_type->Complete());
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::CreateTimer() const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateTimer(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>**)this;
    check_hresult(_winrt_abi_type->CreateTimer(&result));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueueTimer{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::TryEnqueue(
    winrt::Microsoft::UI::Dispatching::DispatcherQueueHandler const& callback)
    const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TryEnqueue(*(void**)(&callback), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>**)this;
    check_hresult(_winrt_abi_type->TryEnqueue(*(void**)(&callback), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::TryEnqueue(
    winrt::Microsoft::UI::Dispatching::DispatcherQueuePriority const& priority,
    winrt::Microsoft::UI::Dispatching::DispatcherQueueHandler const& callback)
    const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TryEnqueueWithPriority(
        static_cast<int32_t>(priority), *(void**)(&callback), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>**)this;
    check_hresult(_winrt_abi_type->TryEnqueueWithPriority(
        static_cast<int32_t>(priority), *(void**)(&callback), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::ShutdownStarting(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Dispatching::DispatcherQueue,
        winrt::Microsoft::UI::Dispatching::
            DispatcherQueueShutdownStartingEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ShutdownStarting(*(void**)(&handler),
                                                        put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>**)this;
    check_hresult(_winrt_abi_type->add_ShutdownStarting(*(void**)(&handler),
                                                        put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::ShutdownStarting(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Dispatching::DispatcherQueue,
        winrt::Microsoft::UI::Dispatching::
            DispatcherQueueShutdownStartingEventArgs> const& handler) const {
  return impl::make_event_revoker<D, ShutdownStarting_revoker>(
      this, ShutdownStarting(handler));
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::ShutdownStarting(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ShutdownStarting(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>**)this;
    _winrt_abi_type->remove_ShutdownStarting(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::ShutdownCompleted(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Dispatching::DispatcherQueue,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_ShutdownCompleted(*(void**)(&handler),
                                                         put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>**)this;
    check_hresult(_winrt_abi_type->add_ShutdownCompleted(*(void**)(&handler),
                                                         put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::ShutdownCompleted(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Dispatching::DispatcherQueue,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  return impl::make_event_revoker<D, ShutdownCompleted_revoker>(
      this, ShutdownCompleted(handler));
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue<D>::ShutdownCompleted(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue>**)&_winrt_casted_result;
    _winrt_abi_type->remove_ShutdownCompleted(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>**)this;
    _winrt_abi_type->remove_ShutdownCompleted(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue2<D>::HasThreadAccess()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HasThreadAccess(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue2>**)this;
    check_hresult(_winrt_abi_type->get_HasThreadAccess(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<
    D>::EnqueueEventLoopExit() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnqueueEventLoopExit());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    check_hresult(_winrt_abi_type->EnqueueEventLoopExit());
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<
    D>::EnsureSystemDispatcherQueue() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureSystemDispatcherQueue());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    check_hresult(_winrt_abi_type->EnsureSystemDispatcherQueue());
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::RunEventLoop()
    const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RunEventLoop());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    check_hresult(_winrt_abi_type->RunEventLoop());
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::RunEventLoop(
    winrt::Microsoft::UI::Dispatching::DispatcherRunOptions const& options,
    winrt::Microsoft::UI::Dispatching::DispatcherExitDeferral const& deferral)
    const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RunEventLoopWithOptions(
        static_cast<uint32_t>(options), *(void**)(&deferral)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    check_hresult(_winrt_abi_type->RunEventLoopWithOptions(
        static_cast<uint32_t>(options), *(void**)(&deferral)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::
    FrameworkShutdownStarting(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Dispatching::DispatcherQueue,
            winrt::Microsoft::UI::Dispatching::
                DispatcherQueueShutdownStartingEventArgs> const& handler)
        const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_FrameworkShutdownStarting(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    check_hresult(_winrt_abi_type->add_FrameworkShutdownStarting(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::
    FrameworkShutdownStarting(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Dispatching::DispatcherQueue,
            winrt::Microsoft::UI::Dispatching::
                DispatcherQueueShutdownStartingEventArgs> const& handler)
        const {
  return impl::make_event_revoker<D, FrameworkShutdownStarting_revoker>(
      this, FrameworkShutdownStarting(handler));
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::
    FrameworkShutdownStarting(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    _winrt_abi_type->remove_FrameworkShutdownStarting(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    _winrt_abi_type->remove_FrameworkShutdownStarting(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::
    FrameworkShutdownCompleted(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Dispatching::DispatcherQueue,
            winrt::Windows::Foundation::IInspectable> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_FrameworkShutdownCompleted(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    check_hresult(_winrt_abi_type->add_FrameworkShutdownCompleted(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::
    FrameworkShutdownCompleted(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Dispatching::DispatcherQueue,
            winrt::Windows::Foundation::IInspectable> const& handler) const {
  return impl::make_event_revoker<D, FrameworkShutdownCompleted_revoker>(
      this, FrameworkShutdownCompleted(handler));
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueue3<D>::
    FrameworkShutdownCompleted(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueue3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueue3>**)&_winrt_casted_result;
    _winrt_abi_type->remove_FrameworkShutdownCompleted(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>**)this;
    _winrt_abi_type->remove_FrameworkShutdownCompleted(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueController<
    D>::DispatcherQueue() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Dispatching::
                                       IDispatcherQueueController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueController,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueController>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Dispatching::
                                             IDispatcherQueueController>**)this;
    check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueue{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueController<
    D>::ShutdownQueueAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Dispatching::
                                       IDispatcherQueueController>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueController,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueController>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ShutdownQueueAsync(&operation));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Dispatching::
                                             IDispatcherQueueController>**)this;
    check_hresult(_winrt_abi_type->ShutdownQueueAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueController2<
    D>::ShutdownQueue() const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Dispatching::
                                       IDispatcherQueueController2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueController2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueController2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ShutdownQueue());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueController2>**)this;
    check_hresult(_winrt_abi_type->ShutdownQueue());
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueControllerStatics<
    D>::CreateOnDedicatedThread() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Dispatching::
                                       IDispatcherQueueControllerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueControllerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueControllerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateOnDedicatedThread(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueControllerStatics>**)this;
    check_hresult(_winrt_abi_type->CreateOnDedicatedThread(&result));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueueController{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueControllerStatics<
    D>::CreateOnCurrentThread() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Dispatching::
                                       IDispatcherQueueControllerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueControllerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueControllerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateOnCurrentThread(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueControllerStatics>**)this;
    check_hresult(_winrt_abi_type->CreateOnCurrentThread(&result));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueueController{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueShutdownStartingEventArgs<
    D>::GetDeferral() const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Dispatching::
                           IDispatcherQueueShutdownStartingEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Dispatching::
                                     IDispatcherQueueShutdownStartingEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Dispatching::
                IDispatcherQueueShutdownStartingEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetDeferral(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueShutdownStartingEventArgs>**)this;
    check_hresult(_winrt_abi_type->GetDeferral(&result));
  }
  return winrt::Windows::Foundation::Deferral{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueStatics<
    D>::GetForCurrentThread() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Dispatching::
                                       IDispatcherQueueStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForCurrentThread(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Dispatching::IDispatcherQueueStatics>**)this;
    check_hresult(_winrt_abi_type->GetForCurrentThread(&result));
  }
  return winrt::Microsoft::UI::Dispatching::DispatcherQueue{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::Interval()
    const {
  winrt::Windows::Foundation::TimeSpan value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Interval(put_abi(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(_winrt_abi_type->get_Interval(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::Interval(
    winrt::Windows::Foundation::TimeSpan const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Interval(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(_winrt_abi_type->put_Interval(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::IsRunning()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsRunning(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(_winrt_abi_type->get_IsRunning(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::IsRepeating()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsRepeating(&value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(_winrt_abi_type->get_IsRepeating(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::IsRepeating(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsRepeating(value));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(_winrt_abi_type->put_IsRepeating(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::Start() const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Start());
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(_winrt_abi_type->Start());
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::Stop() const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Stop());
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(_winrt_abi_type->Stop());
  }
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::Tick(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Dispatching::DispatcherQueueTimer,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_Tick(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    check_hresult(
        _winrt_abi_type->add_Tick(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::Tick(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Dispatching::DispatcherQueueTimer,
        winrt::Windows::Foundation::IInspectable> const& handler) const {
  return impl::make_event_revoker<D, Tick_revoker>(this, Tick(handler));
}
template <typename D>
auto consume_Microsoft_UI_Dispatching_IDispatcherQueueTimer<D>::Tick(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Dispatching::
                    IDispatcherQueueTimer>**)&_winrt_casted_result;
    _winrt_abi_type->remove_Tick(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>**)this;
    _winrt_abi_type->remove_Tick(impl::bind_in(token));
  }
}
template <typename H>
struct delegate<winrt::Microsoft::UI::Dispatching::DispatcherQueueHandler, H>
    final : implements_delegate<
                winrt::Microsoft::UI::Dispatching::DispatcherQueueHandler, H> {
  delegate(H&& handler)
      : implements_delegate<
            winrt::Microsoft::UI::Dispatching::DispatcherQueueHandler, H>(
            std::forward<H>(handler)) {}

  int32_t __stdcall Invoke() noexcept final try {
    (*this)();
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::IDispatcherExitDeferral>
    : produce_base<D,
                   winrt::Microsoft::UI::Dispatching::IDispatcherExitDeferral> {
  int32_t __stdcall Complete() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Complete();
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue>
    : produce_base<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue> {
  int32_t __stdcall CreateTimer(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueueTimer>(
            this->shim().CreateTimer());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryEnqueue(void* callback, bool* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().TryEnqueue(
        *reinterpret_cast<
            winrt::Microsoft::UI::Dispatching::DispatcherQueueHandler const*>(
            &callback)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryEnqueueWithPriority(int32_t priority, void* callback,
                                           bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().TryEnqueue(
        *reinterpret_cast<
            winrt::Microsoft::UI::Dispatching::DispatcherQueuePriority const*>(
            &priority),
        *reinterpret_cast<
            winrt::Microsoft::UI::Dispatching::DispatcherQueueHandler const*>(
            &callback)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_ShutdownStarting(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ShutdownStarting(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Dispatching::DispatcherQueue,
            winrt::Microsoft::UI::Dispatching::
                DispatcherQueueShutdownStartingEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ShutdownStarting(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ShutdownStarting(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_ShutdownCompleted(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().ShutdownCompleted(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Dispatching::DispatcherQueue,
            winrt::Windows::Foundation::IInspectable> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_ShutdownCompleted(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().ShutdownCompleted(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue2>
    : produce_base<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue2> {
  int32_t __stdcall get_HasThreadAccess(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().HasThreadAccess());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>
    : produce_base<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueue3> {
  int32_t __stdcall EnqueueEventLoopExit() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().EnqueueEventLoopExit();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureSystemDispatcherQueue() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().EnsureSystemDispatcherQueue();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RunEventLoop() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().RunEventLoop();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RunEventLoopWithOptions(uint32_t options,
                                            void* deferral) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().RunEventLoop(
        *reinterpret_cast<
            winrt::Microsoft::UI::Dispatching::DispatcherRunOptions const*>(
            &options),
        *reinterpret_cast<
            winrt::Microsoft::UI::Dispatching::DispatcherExitDeferral const*>(
            &deferral));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_FrameworkShutdownStarting(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token =
        detach_from<winrt::event_token>(this->shim().FrameworkShutdownStarting(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Microsoft::UI::Dispatching::DispatcherQueue,
                winrt::Microsoft::UI::Dispatching::
                    DispatcherQueueShutdownStartingEventArgs> const*>(
                &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_FrameworkShutdownStarting(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().FrameworkShutdownStarting(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_FrameworkShutdownCompleted(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token =
        detach_from<winrt::event_token>(this->shim().FrameworkShutdownCompleted(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Microsoft::UI::Dispatching::DispatcherQueue,
                winrt::Windows::Foundation::IInspectable> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_FrameworkShutdownCompleted(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().FrameworkShutdownCompleted(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueueController>
    : produce_base<
          D, winrt::Microsoft::UI::Dispatching::IDispatcherQueueController> {
  int32_t __stdcall get_DispatcherQueue(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(
        this->shim().DispatcherQueue());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ShutdownQueueAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(
        this->shim().ShutdownQueueAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Dispatching::IDispatcherQueueController2>
    : produce_base<
          D, winrt::Microsoft::UI::Dispatching::IDispatcherQueueController2> {
  int32_t __stdcall ShutdownQueue() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ShutdownQueue();
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Dispatching::IDispatcherQueueControllerStatics>
    : produce_base<D, winrt::Microsoft::UI::Dispatching::
                          IDispatcherQueueControllerStatics> {
  int32_t __stdcall CreateOnDedicatedThread(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::UI::Dispatching::DispatcherQueueController>(
        this->shim().CreateOnDedicatedThread());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateOnCurrentThread(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::UI::Dispatching::DispatcherQueueController>(
        this->shim().CreateOnCurrentThread());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::
                      IDispatcherQueueShutdownStartingEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Dispatching::
                          IDispatcherQueueShutdownStartingEventArgs> {
  int32_t __stdcall GetDeferral(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Foundation::Deferral>(
        this->shim().GetDeferral());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueueStatics>
    : produce_base<D,
                   winrt::Microsoft::UI::Dispatching::IDispatcherQueueStatics> {
  int32_t __stdcall GetForCurrentThread(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(
        this->shim().GetForCurrentThread());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>
    : produce_base<D,
                   winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer> {
  int32_t __stdcall get_Interval(int64_t* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::TimeSpan>(
        this->shim().Interval());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Interval(int64_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Interval(
        *reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsRunning(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsRunning());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsRepeating(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsRepeating());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsRepeating(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsRepeating(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Start() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Start();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Stop() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Stop();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_Tick(void* handler,
                             winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().Tick(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Dispatching::DispatcherQueueTimer,
            winrt::Windows::Foundation::IInspectable> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_Tick(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().Tick(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::UI::Dispatching {
  constexpr auto operator|(DispatcherRunOptions const left,
                           DispatcherRunOptions const right) noexcept {
    return static_cast<DispatcherRunOptions>(impl::to_underlying_type(left) |
                                             impl::to_underlying_type(right));
  }
  constexpr auto operator|=(DispatcherRunOptions& left,
                            DispatcherRunOptions const right) noexcept {
    left = left | right;
    return left;
  }
  constexpr auto operator&(DispatcherRunOptions const left,
                           DispatcherRunOptions const right) noexcept {
    return static_cast<DispatcherRunOptions>(impl::to_underlying_type(left) &
                                             impl::to_underlying_type(right));
  }
  constexpr auto operator&=(DispatcherRunOptions& left,
                            DispatcherRunOptions const right) noexcept {
    left = left & right;
    return left;
  }
  constexpr auto operator~(DispatcherRunOptions const value) noexcept {
    return static_cast<DispatcherRunOptions>(~impl::to_underlying_type(value));
  }
  constexpr auto operator^(DispatcherRunOptions const left,
                           DispatcherRunOptions const right) noexcept {
    return static_cast<DispatcherRunOptions>(impl::to_underlying_type(left) ^
                                             impl::to_underlying_type(right));
  }
  constexpr auto operator^=(DispatcherRunOptions& left,
                            DispatcherRunOptions const right) noexcept {
    left = left ^ right;
    return left;
  }
  inline DispatcherExitDeferral::DispatcherExitDeferral()
      : DispatcherExitDeferral(
            impl::call_factory_cast<
                DispatcherExitDeferral (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                DispatcherExitDeferral>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<DispatcherExitDeferral>();
                })) {}
  inline auto DispatcherQueue::GetForCurrentThread() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Dispatching::DispatcherQueue (*)(
            IDispatcherQueueStatics const&),
        DispatcherQueue, IDispatcherQueueStatics>(
        [](IDispatcherQueueStatics const& f) {
          return f.GetForCurrentThread();
        });
  }
  inline auto DispatcherQueueController::CreateOnDedicatedThread() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Dispatching::DispatcherQueueController (*)(
            IDispatcherQueueControllerStatics const&),
        DispatcherQueueController, IDispatcherQueueControllerStatics>(
        [](IDispatcherQueueControllerStatics const& f) {
          return f.CreateOnDedicatedThread();
        });
  }
  inline auto DispatcherQueueController::CreateOnCurrentThread() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Dispatching::DispatcherQueueController (*)(
            IDispatcherQueueControllerStatics const&),
        DispatcherQueueController, IDispatcherQueueControllerStatics>(
        [](IDispatcherQueueControllerStatics const& f) {
          return f.CreateOnCurrentThread();
        });
  }
  template <typename L>
  DispatcherQueueHandler::DispatcherQueueHandler(L handler)
      : DispatcherQueueHandler(impl::make_delegate<DispatcherQueueHandler>(
            std::forward<L>(handler))) {}
  template <typename F>
  DispatcherQueueHandler::DispatcherQueueHandler(F * handler)
      : DispatcherQueueHandler(
            [=](auto&&... args) { return handler(args...); }) {}
  template <typename O, typename M>
  DispatcherQueueHandler::DispatcherQueueHandler(O * object, M method)
      : DispatcherQueueHandler(
            [=](auto&&... args) { return ((*object).*(method))(args...); }) {}
  template <typename O, typename M>
  DispatcherQueueHandler::DispatcherQueueHandler(com_ptr<O> && object, M method)
      : DispatcherQueueHandler([o = std::move(object), method](auto&&... args) {
          return ((*o).*(method))(args...);
        }) {}
  template <typename O, typename LM>
  DispatcherQueueHandler::DispatcherQueueHandler(weak_ref<O> && object,
                                                 LM && lambda_or_method)
      : DispatcherQueueHandler(
            [o = std::move(object),
             lm = std::forward<LM>(lambda_or_method)](auto&&... args) {
              if (auto s = o.get()) {
                if constexpr (std::is_member_function_pointer_v<LM>)
                  ((*s).*(lm))(args...);
                else
                  lm(args...);
              }
            }) {}
  template <typename O, typename M>
  DispatcherQueueHandler::DispatcherQueueHandler(std::shared_ptr<O> && object,
                                                 M method)
      : DispatcherQueueHandler([o = std::move(object), method](auto&&... args) {
          return ((*o).*(method))(args...);
        }) {}
  template <typename O, typename LM>
  DispatcherQueueHandler::DispatcherQueueHandler(std::weak_ptr<O> && object,
                                                 LM && lambda_or_method)
      : DispatcherQueueHandler(
            [o = std::move(object),
             lm = std::forward<LM>(lambda_or_method)](auto&&... args) {
              if (auto s = o.lock()) {
                if constexpr (std::is_member_function_pointer_v<LM>)
                  ((*s).*(lm))(args...);
                else
                  lm(args...);
              }
            }) {}
  inline auto DispatcherQueueHandler::operator()() const {
    check_hresult((*(impl::abi_t<DispatcherQueueHandler>**)this)->Invoke());
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherExitDeferral>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherQueue>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherQueue2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherQueue3>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherQueueController>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherQueueController2>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Dispatching::IDispatcherQueueControllerStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::
                IDispatcherQueueShutdownStartingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherQueueStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::IDispatcherQueueTimer>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::DispatcherExitDeferral>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::DispatcherQueue>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::DispatcherQueueController>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Dispatching::DispatcherQueueShutdownStartingEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Dispatching::DispatcherQueueTimer>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
