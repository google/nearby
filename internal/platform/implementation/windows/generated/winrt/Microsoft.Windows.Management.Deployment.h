// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_Management_Deployment_H
#define WINRT_Microsoft_Windows_Management_Deployment_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.ApplicationModel.DynamicDependency.2.h"
#include "winrt/impl/Microsoft.Windows.Management.Deployment.2.h"
#include "winrt/impl/Windows.ApplicationModel.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::TargetVolume() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TargetVolume(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_TargetVolume(&value));
  }
  return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::
    TargetVolume(
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume const&
            value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_TargetVolume(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_TargetVolume(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::DependencyPackageUris() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DependencyPackageUris(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_DependencyPackageUris(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Windows::Foundation::Uri>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::OptionalPackageFamilyNames() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::OptionalPackageUris() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OptionalPackageUris(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_OptionalPackageUris(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Windows::Foundation::Uri>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::RelatedPackageUris() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RelatedPackageUris(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_RelatedPackageUris(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Windows::Foundation::Uri>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ExternalLocationUri() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExternalLocationUri(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ExternalLocationUri(&value));
  }
  return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::
    ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ExternalLocationUri(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ExternalLocationUri(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::StubPackageOption() const {
  winrt::Microsoft::Windows::Management::Deployment::StubPackageOption value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_StubPackageOption(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_StubPackageOption(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::StubPackageOption(winrt::Microsoft::Windows::Management::Deployment::
                              StubPackageOption const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_StubPackageOption(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->put_StubPackageOption(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::AllowUnsigned() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AllowUnsigned(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_AllowUnsigned(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::AllowUnsigned(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_AllowUnsigned(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_AllowUnsigned(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::DeveloperMode() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DeveloperMode(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_DeveloperMode(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::DeveloperMode(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_DeveloperMode(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_DeveloperMode(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ForceAppShutdown() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForceAppShutdown(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ForceAppShutdown(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ForceAppShutdown(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForceAppShutdown(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ForceAppShutdown(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ForceTargetAppShutdown() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForceTargetAppShutdown(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ForceTargetAppShutdown(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ForceTargetAppShutdown(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForceTargetAppShutdown(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ForceTargetAppShutdown(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ForceUpdateFromAnyVersion() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForceUpdateFromAnyVersion(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ForceUpdateFromAnyVersion(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ForceUpdateFromAnyVersion(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForceUpdateFromAnyVersion(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ForceUpdateFromAnyVersion(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::InstallAllResources() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InstallAllResources(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_InstallAllResources(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::InstallAllResources(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InstallAllResources(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_InstallAllResources(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::RequiredContentGroupOnly() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RequiredContentGroupOnly(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_RequiredContentGroupOnly(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::RequiredContentGroupOnly(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_RequiredContentGroupOnly(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_RequiredContentGroupOnly(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::RetainFilesOnFailure() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RetainFilesOnFailure(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_RetainFilesOnFailure(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::RetainFilesOnFailure(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_RetainFilesOnFailure(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_RetainFilesOnFailure(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::StageInPlace() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_StageInPlace(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_StageInPlace(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::StageInPlace(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_StageInPlace(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_StageInPlace(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::DeferRegistrationWhenPackagesAreInUse() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_DeferRegistrationWhenPackagesAreInUse(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->get_DeferRegistrationWhenPackagesAreInUse(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::DeferRegistrationWhenPackagesAreInUse(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_DeferRegistrationWhenPackagesAreInUse(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->put_DeferRegistrationWhenPackagesAreInUse(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::IsExpectedDigestsSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsExpectedDigestsSupported(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_IsExpectedDigestsSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::ExpectedDigests() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExpectedDigests(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ExpectedDigests(&value));
  }
  return winrt::Windows::Foundation::Collections::IMap<
      winrt::Windows::Foundation::Uri, hstring>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::IsLimitToExistingPackagesSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_IsLimitToExistingPackagesSupported(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->get_IsLimitToExistingPackagesSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::LimitToExistingPackages() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LimitToExistingPackages(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_LimitToExistingPackages(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<
    D>::LimitToExistingPackages(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IAddPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_LimitToExistingPackages(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IAddPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_LimitToExistingPackages(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IEnsureReadyOptions<
    D>::AddPackageOptions() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IEnsureReadyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IEnsureReadyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AddPackageOptions(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IEnsureReadyOptions>**)this;
    check_hresult(_winrt_abi_type->get_AddPackageOptions(&value));
  }
  return winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IEnsureReadyOptions2<
    D>::RegisterNewerIfAvailable() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IEnsureReadyOptions2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IEnsureReadyOptions2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RegisterNewerIfAvailable(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IEnsureReadyOptions2>**)this;
    check_hresult(_winrt_abi_type->get_RegisterNewerIfAvailable(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IEnsureReadyOptions2<
    D>::RegisterNewerIfAvailable(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IEnsureReadyOptions2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IEnsureReadyOptions2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_RegisterNewerIfAvailable(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IEnsureReadyOptions2>**)this;
    check_hresult(_winrt_abi_type->put_RegisterNewerIfAvailable(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::IsPackageReady(param::hstring const& package) const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->IsPackageReady(*(void**)(&package), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(
        _winrt_abi_type->IsPackageReady(*(void**)(&package), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::IsPackageReadyByUri(winrt::Windows::Foundation::Uri const& packageUri)
    const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->IsPackageReadyByUri(*(void**)(&packageUri), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(
        _winrt_abi_type->IsPackageReadyByUri(*(void**)(&packageUri), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::IsPackageSetReady(winrt::Microsoft::Windows::Management::Deployment::
                              PackageSet const& packageSet) const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->IsPackageSetReady(*(void**)(&packageSet), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(
        _winrt_abi_type->IsPackageSetReady(*(void**)(&packageSet), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::EnsurePackageReadyAsync(param::hstring const& package,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::EnsureReadyOptions const&
                                        options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsurePackageReadyAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->EnsurePackageReadyAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::EnsurePackageReadyByUriAsync(winrt::Windows::Foundation::Uri const&
                                         packageUri,
                                     winrt::Microsoft::Windows::Management::
                                         Deployment::EnsureReadyOptions const&
                                             options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsurePackageReadyByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->EnsurePackageReadyByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::EnsurePackageSetReadyAsync(winrt::Microsoft::Windows::Management::
                                       Deployment::PackageSet const& packageSet,
                                   winrt::Microsoft::Windows::Management::
                                       Deployment::EnsureReadyOptions const&
                                           options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsurePackageSetReadyAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->EnsurePackageSetReadyAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::AddPackageAsync(param::hstring const& package,
                        winrt::Microsoft::Windows::Management::Deployment::
                            AddPackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->AddPackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->AddPackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::AddPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri,
                             winrt::Microsoft::Windows::Management::Deployment::
                                 AddPackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->AddPackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->AddPackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::AddPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::
                               PackageSet const& packageSet,
                           winrt::Microsoft::Windows::Management::Deployment::
                               AddPackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->AddPackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->AddPackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::StagePackageAsync(param::hstring const& package,
                          winrt::Microsoft::Windows::Management::Deployment::
                              StagePackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->StagePackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->StagePackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::StagePackageByUriAsync(winrt::Windows::Foundation::Uri const&
                                   packageUri,
                               winrt::Microsoft::Windows::Management::
                                   Deployment::StagePackageOptions const&
                                       options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->StagePackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->StagePackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::StagePackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::
                                 PackageSet const& packageSet,
                             winrt::Microsoft::Windows::Management::Deployment::
                                 StagePackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->StagePackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->StagePackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RegisterPackageAsync(param::hstring const& package,
                             winrt::Microsoft::Windows::Management::Deployment::
                                 RegisterPackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RegisterPackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RegisterPackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RegisterPackageByUriAsync(winrt::Windows::Foundation::Uri const&
                                      packageUri,
                                  winrt::Microsoft::Windows::Management::
                                      Deployment::RegisterPackageOptions const&
                                          options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RegisterPackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RegisterPackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RegisterPackageSetAsync(winrt::Microsoft::Windows::Management::
                                    Deployment::PackageSet const& packageSet,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::RegisterPackageOptions const&
                                        options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RegisterPackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RegisterPackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RemovePackageAsync(param::hstring const& package,
                           winrt::Microsoft::Windows::Management::Deployment::
                               RemovePackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemovePackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RemovePackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RemovePackageByFullNameAsync(param::hstring const& packageFullName,
                                     winrt::Microsoft::Windows::Management::
                                         Deployment::RemovePackageOptions const&
                                             options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemovePackageByFullNameAsync(
        *(void**)(&packageFullName), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RemovePackageByFullNameAsync(
        *(void**)(&packageFullName), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::
    RemovePackageByFamilyNameAsync(
        param::hstring const& packageFamilyName,
        winrt::Microsoft::Windows::Management::Deployment::
            RemovePackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemovePackageByFamilyNameAsync(
        *(void**)(&packageFamilyName), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RemovePackageByFamilyNameAsync(
        *(void**)(&packageFamilyName), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RemovePackageByUriAsync(winrt::Windows::Foundation::Uri const&
                                    packageUri,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::RemovePackageOptions const&
                                        options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemovePackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RemovePackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RemovePackageSetAsync(winrt::Microsoft::Windows::Management::
                                  Deployment::PackageSet const& packageSet,
                              winrt::Microsoft::Windows::Management::
                                  Deployment::RemovePackageOptions const&
                                      options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemovePackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RemovePackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::ResetPackageAsync(param::hstring const& package) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->ResetPackageAsync(*(void**)(&package), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(
        _winrt_abi_type->ResetPackageAsync(*(void**)(&package), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::ResetPackageByUriAsync(winrt::Windows::Foundation::Uri const&
                                   packageUri) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ResetPackageByUriAsync(
        *(void**)(&packageUri), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->ResetPackageByUriAsync(
        *(void**)(&packageUri), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::ResetPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::
                                 PackageSet const& packageSet) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ResetPackageSetAsync(*(void**)(&packageSet),
                                                        &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->ResetPackageSetAsync(*(void**)(&packageSet),
                                                        &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RepairPackageAsync(param::hstring const& package) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->RepairPackageAsync(*(void**)(&package), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(
        _winrt_abi_type->RepairPackageAsync(*(void**)(&package), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RepairPackageByUriAsync(winrt::Windows::Foundation::Uri const&
                                    packageUri) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RepairPackageByUriAsync(
        *(void**)(&packageUri), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RepairPackageByUriAsync(
        *(void**)(&packageUri), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::RepairPackageSetAsync(winrt::Microsoft::Windows::Management::
                                  Deployment::PackageSet const& packageSet)
    const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RepairPackageSetAsync(*(void**)(&packageSet),
                                                         &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->RepairPackageSetAsync(*(void**)(&packageSet),
                                                         &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::ProvisionPackageAsync(param::hstring const& package,
                              winrt::Microsoft::Windows::Management::
                                  Deployment::ProvisionPackageOptions const&
                                      options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProvisionPackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->ProvisionPackageAsync(
        *(void**)(&package), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::
    ProvisionPackageByUriAsync(
        winrt::Windows::Foundation::Uri const& packageUri,
        winrt::Microsoft::Windows::Management::Deployment::
            ProvisionPackageOptions const& options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProvisionPackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->ProvisionPackageByUriAsync(
        *(void**)(&packageUri), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::ProvisionPackageSetAsync(winrt::Microsoft::Windows::Management::
                                     Deployment::PackageSet const& packageSet,
                                 winrt::Microsoft::Windows::Management::
                                     Deployment::ProvisionPackageOptions const&
                                         options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ProvisionPackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->ProvisionPackageSetAsync(
        *(void**)(&packageSet), *(void**)(&options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::DeprovisionPackageAsync(param::hstring const& package) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->DeprovisionPackageAsync(*(void**)(&package),
                                                           &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->DeprovisionPackageAsync(*(void**)(&package),
                                                           &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::DeprovisionPackageByUriAsync(winrt::Windows::Foundation::Uri const&
                                         packageUri) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->DeprovisionPackageByUriAsync(
        *(void**)(&packageUri), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->DeprovisionPackageByUriAsync(
        *(void**)(&packageUri), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::DeprovisionPackageSetAsync(winrt::Microsoft::Windows::Management::
                                       Deployment::PackageSet const& packageSet)
    const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->DeprovisionPackageSetAsync(
        *(void**)(&packageSet), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->DeprovisionPackageSetAsync(
        *(void**)(&packageSet), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentResult,
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentProgress>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::IsPackageRegistrationPending(param::hstring const& packageFamilyName)
    const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageRegistrationPending(
        *(void**)(&packageFamilyName), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->IsPackageRegistrationPending(
        *(void**)(&packageFamilyName), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<
    D>::IsPackageRegistrationPendingForUser(param::hstring const&
                                                userSecurityId,
                                            param::hstring const&
                                                packageFamilyName) const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageRegistrationPendingForUser(
        *(void**)(&userSecurityId), *(void**)(&packageFamilyName), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager>**)this;
    check_hresult(_winrt_abi_type->IsPackageRegistrationPendingForUser(
        *(void**)(&userSecurityId), *(void**)(&packageFamilyName), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager2<
    D>::IsPackageReadyOrNewerAvailable(param::hstring const& package) const {
  winrt::Microsoft::Windows::Management::Deployment::
      PackageReadyOrNewerAvailableStatus result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::IPackageDeploymentManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageReadyOrNewerAvailable(
        *(void**)(&package), reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)this;
    check_hresult(_winrt_abi_type->IsPackageReadyOrNewerAvailable(
        *(void**)(&package), reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager2<
    D>::IsPackageReadyOrNewerAvailableByUri(winrt::Windows::Foundation::
                                                Uri const& packageUri) const {
  winrt::Microsoft::Windows::Management::Deployment::
      PackageReadyOrNewerAvailableStatus result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::IPackageDeploymentManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageReadyOrNewerAvailableByUri(
        *(void**)(&packageUri), reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)this;
    check_hresult(_winrt_abi_type->IsPackageReadyOrNewerAvailableByUri(
        *(void**)(&packageUri), reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager2<
    D>::
    IsPackageSetReadyOrNewerAvailable(
        winrt::Microsoft::Windows::Management::Deployment::PackageSet const&
            packageSet) const {
  winrt::Microsoft::Windows::Management::Deployment::
      PackageReadyOrNewerAvailableStatus result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::IPackageDeploymentManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageSetReadyOrNewerAvailable(
        *(void**)(&packageSet), reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)this;
    check_hresult(_winrt_abi_type->IsPackageSetReadyOrNewerAvailable(
        *(void**)(&packageSet), reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager2<
    D>::IsPackageProvisioned(param::hstring const& package) const {
  bool result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::IPackageDeploymentManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->IsPackageProvisioned(*(void**)(&package), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)this;
    check_hresult(
        _winrt_abi_type->IsPackageProvisioned(*(void**)(&package), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager2<
    D>::IsPackageProvisionedByUri(winrt::Windows::Foundation::Uri const&
                                      packageUri) const {
  bool result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::IPackageDeploymentManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageProvisionedByUri(
        *(void**)(&packageUri), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)this;
    check_hresult(_winrt_abi_type->IsPackageProvisionedByUri(
        *(void**)(&packageUri), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager2<
    D>::IsPackageSetProvisioned(winrt::Microsoft::Windows::Management::
                                    Deployment::PackageSet const& packageSet)
    const {
  bool result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::Management::
                                    Deployment::IPackageDeploymentManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentManager2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageSetProvisioned(
        *(void**)(&packageSet), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManager2>**)this;
    check_hresult(_winrt_abi_type->IsPackageSetProvisioned(
        *(void**)(&packageSet), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManagerStatics<
    D>::GetDefault() const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageDeploymentManagerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::
            IPackageDeploymentManagerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManagerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManagerStatics>**)this;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  }
  return winrt::Microsoft::Windows::Management::Deployment::
      PackageDeploymentManager{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManagerStatics2<
    D>::
    IsPackageDeploymentFeatureSupported(
        winrt::Microsoft::Windows::Management::Deployment::
            PackageDeploymentFeature const& feature) const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageDeploymentManagerStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::
            IPackageDeploymentManagerStatics2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManagerStatics2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsPackageDeploymentFeatureSupported(
        static_cast<int32_t>(feature), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentManagerStatics2>**)this;
    check_hresult(_winrt_abi_type->IsPackageDeploymentFeatureSupported(
        static_cast<int32_t>(feature), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<
    D>::Status() const {
  winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentStatus
      value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentResult,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)this;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<
    D>::Error() const {
  winrt::hresult value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentResult,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Error(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)this;
    check_hresult(_winrt_abi_type->get_Error(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<
    D>::ExtendedError() const {
  winrt::hresult value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentResult,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)this;
    check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<
    D>::ErrorText() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentResult,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ErrorText(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)this;
    check_hresult(_winrt_abi_type->get_ErrorText(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<
    D>::ActivityId() const {
  winrt::guid value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageDeploymentResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageDeploymentResult,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ActivityId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageDeploymentResult>**)this;
    check_hresult(_winrt_abi_type->get_ActivityId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::
    AddPackageSet(
        winrt::Microsoft::Windows::Management::Deployment::PackageSet const&
            packageSet) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageRuntimeManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageRuntimeManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManager>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->AddPackageSet(*(void**)(&packageSet), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManager>**)this;
    check_hresult(
        _winrt_abi_type->AddPackageSet(*(void**)(&packageSet), &result));
  }
  return winrt::Microsoft::Windows::Management::Deployment::
      PackageSetRuntimeDisposition{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::
    AddPackageSet(
        winrt::Microsoft::Windows::Management::Deployment::PackageSet const&
            packageSet,
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            CreatePackageDependencyOptions const& createOptions,
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            AddPackageDependencyOptions const& addOptions) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageRuntimeManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageRuntimeManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->AddPackageSetWithOptions(
        *(void**)(&packageSet), *(void**)(&createOptions),
        *(void**)(&addOptions), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManager>**)this;
    check_hresult(_winrt_abi_type->AddPackageSetWithOptions(
        *(void**)(&packageSet), *(void**)(&createOptions),
        *(void**)(&addOptions), &result));
  }
  return winrt::Microsoft::Windows::Management::Deployment::
      PackageSetRuntimeDisposition{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<
    D>::RemovePackageSet(winrt::Microsoft::Windows::Management::Deployment::
                             PackageSetRuntimeDisposition const&
                                 packageSetRuntimeDisposition) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageRuntimeManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageRuntimeManager,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemovePackageSet(
        *(void**)(&packageSetRuntimeDisposition)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManager>**)this;
    check_hresult(_winrt_abi_type->RemovePackageSet(
        *(void**)(&packageSetRuntimeDisposition)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManagerStatics<
    D>::GetDefault() const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageRuntimeManagerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageRuntimeManagerStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManagerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageRuntimeManagerStatics>**)this;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  }
  return winrt::Microsoft::Windows::Management::Deployment::
      PackageRuntimeManager{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Id()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSet>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSet,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSet>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Id(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageSet>**)this;
    check_hresult(_winrt_abi_type->get_Id(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Id(
    param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSet>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSet,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSet>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Id(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageSet>**)this;
    check_hresult(_winrt_abi_type->put_Id(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<
    D>::PackageUri() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSet>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSet,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSet>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageUri(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageSet>**)this;
    check_hresult(_winrt_abi_type->get_PackageUri(&value));
  }
  return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::PackageUri(
    winrt::Windows::Foundation::Uri const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSet>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSet,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSet>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PackageUri(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageSet>**)this;
    check_hresult(_winrt_abi_type->put_PackageUri(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Items()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSet>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSet,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSet>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Items(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageSet>**)this;
    check_hresult(_winrt_abi_type->get_Items(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::Id()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Id(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->get_Id(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::Id(
    param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Id(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->put_Id(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<
    D>::PackageFamilyName() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageFamilyName(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->get_PackageFamilyName(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<
    D>::PackageFamilyName(param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PackageFamilyName(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->put_PackageFamilyName(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<
    D>::MinVersion() const {
  winrt::Windows::ApplicationModel::PackageVersion value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MinVersion(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->get_MinVersion(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<
    D>::MinVersion(winrt::Windows::ApplicationModel::PackageVersion const&
                       value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_MinVersion(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->put_MinVersion(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<
    D>::ProcessorArchitectureFilter() const {
  winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyProcessorArchitectures value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ProcessorArchitectureFilter(
        reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->get_ProcessorArchitectureFilter(
        reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::
    ProcessorArchitectureFilter(
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            PackageDependencyProcessorArchitectures const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ProcessorArchitectureFilter(
        static_cast<uint32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->put_ProcessorArchitectureFilter(
        static_cast<uint32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<
    D>::PackageUri() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageUri(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->get_PackageUri(&value));
  }
  return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<
    D>::PackageUri(winrt::Windows::Foundation::Uri const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageSetItem>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PackageUri(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItem>**)this;
    check_hresult(_winrt_abi_type->put_PackageUri(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<
    D>::PackageSetItemId() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageSetItemRuntimeDisposition>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::
            IPackageSetItemRuntimeDisposition,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageSetItemId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)this;
    check_hresult(_winrt_abi_type->get_PackageSetItemId(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<
    D>::PackageFullName() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageSetItemRuntimeDisposition>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::
            IPackageSetItemRuntimeDisposition,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageFullName(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)this;
    check_hresult(_winrt_abi_type->get_PackageFullName(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<
    D>::PackageDependencyId() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageSetItemRuntimeDisposition>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::
            IPackageSetItemRuntimeDisposition,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageDependencyId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)this;
    check_hresult(_winrt_abi_type->get_PackageDependencyId(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<
    D>::PackageDependencyContextId() const {
  winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyContextId value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageSetItemRuntimeDisposition>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::
            IPackageSetItemRuntimeDisposition,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_PackageDependencyContextId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetItemRuntimeDisposition>**)this;
    check_hresult(
        _winrt_abi_type->get_PackageDependencyContextId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<
    D>::PackageSetId() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageSetRuntimeDisposition>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageSetRuntimeDisposition,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetRuntimeDisposition>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageSetId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetRuntimeDisposition>**)this;
    check_hresult(_winrt_abi_type->get_PackageSetId(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<
    D>::PackageSetId(param::hstring const& value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageSetRuntimeDisposition>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageSetRuntimeDisposition,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetRuntimeDisposition>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PackageSetId(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetRuntimeDisposition>**)this;
    check_hresult(_winrt_abi_type->put_PackageSetId(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<
    D>::PackageSetItemRuntimeDispositions() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::Management::Deployment::
                           IPackageSetRuntimeDisposition>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageSetRuntimeDisposition,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetRuntimeDisposition>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_PackageSetItemRuntimeDispositions(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageSetRuntimeDisposition>**)this;
    check_hresult(
        _winrt_abi_type->get_PackageSetItemRuntimeDispositions(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Microsoft::Windows::Management::Deployment::
          PackageSetItemRuntimeDisposition>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<
    D>::IsSystemVolume() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsSystemVolume(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->get_IsSystemVolume(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<
    D>::MountPoint() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MountPoint(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->get_MountPoint(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::Name()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Name(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->get_Name(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<
    D>::PackageStorePath() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageStorePath(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->get_PackageStorePath(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<
    D>::SupportsHardLinks() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SupportsHardLinks(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->get_SupportsHardLinks(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<
    D>::IsFullTrustPackageSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsFullTrustPackageSupported(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->get_IsFullTrustPackageSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<
    D>::IsAppxInstallSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsAppxInstallSupported(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->get_IsAppxInstallSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<
    D>::IsRepairNeeded() const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsRepairNeeded(&result));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->IsRepairNeeded(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::Repair()
    const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolume>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IPackageVolume,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolume>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Repair());
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Management::
                                             Deployment::IPackageVolume>**)this;
    check_hresult(_winrt_abi_type->Repair());
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatics<
    D>::FindPackageVolumes() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolumeStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageVolumeStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolumeStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->FindPackageVolumes(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolumeStatics>**)this;
    check_hresult(_winrt_abi_type->FindPackageVolumes(&result));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Microsoft::Windows::Management::Deployment::PackageVolume>{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatics<
    D>::FindPackageVolumeByPath(param::hstring const& packageStorePath) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolumeStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageVolumeStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolumeStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->FindPackageVolumeByPath(
        *(void**)(&packageStorePath), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolumeStatics>**)this;
    check_hresult(_winrt_abi_type->FindPackageVolumeByPath(
        *(void**)(&packageStorePath), &result));
  }
  return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatics<
    D>::FindPackageVolumeByName(param::hstring const& name) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IPackageVolumeStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IPackageVolumeStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolumeStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->FindPackageVolumeByName(*(void**)(&name), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IPackageVolumeStatics>**)this;
    check_hresult(
        _winrt_abi_type->FindPackageVolumeByName(*(void**)(&name), &result));
  }
  return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<
    D>::IsOptionalPackageFamilyNamesSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IProvisionPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IProvisionPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_IsOptionalPackageFamilyNamesSupported(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->get_IsOptionalPackageFamilyNamesSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<
    D>::OptionalPackageFamilyNames() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IProvisionPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IProvisionPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<
    D>::IsProjectionOrderPackageFamilyNamesSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IProvisionPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IProvisionPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_IsProjectionOrderPackageFamilyNamesSupported(
            &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->get_IsProjectionOrderPackageFamilyNamesSupported(
            &value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<
    D>::ProjectionOrderPackageFamilyNames() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IProvisionPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IProvisionPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_ProjectionOrderPackageFamilyNames(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IProvisionPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->get_ProjectionOrderPackageFamilyNames(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::AppDataVolume() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AppDataVolume(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_AppDataVolume(&value));
  }
  return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::AppDataVolume(winrt::Microsoft::Windows::Management::Deployment::
                          PackageVolume const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_AppDataVolume(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_AppDataVolume(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::DependencyPackageFamilyNames() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DependencyPackageFamilyNames(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_DependencyPackageFamilyNames(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::DependencyPackageUris() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DependencyPackageUris(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_DependencyPackageUris(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Windows::Foundation::Uri>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::OptionalPackageFamilyNames() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ExternalLocationUri() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExternalLocationUri(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ExternalLocationUri(&value));
  }
  return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ExternalLocationUri(winrt::Windows::Foundation::Uri const& value)
    const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ExternalLocationUri(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ExternalLocationUri(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::AllowUnsigned() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AllowUnsigned(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_AllowUnsigned(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::AllowUnsigned(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_AllowUnsigned(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_AllowUnsigned(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::DeveloperMode() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DeveloperMode(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_DeveloperMode(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::DeveloperMode(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_DeveloperMode(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_DeveloperMode(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ForceAppShutdown() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForceAppShutdown(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ForceAppShutdown(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ForceAppShutdown(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForceAppShutdown(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ForceAppShutdown(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ForceTargetAppShutdown() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForceTargetAppShutdown(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ForceTargetAppShutdown(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ForceTargetAppShutdown(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForceTargetAppShutdown(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ForceTargetAppShutdown(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ForceUpdateFromAnyVersion() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForceUpdateFromAnyVersion(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ForceUpdateFromAnyVersion(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ForceUpdateFromAnyVersion(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForceUpdateFromAnyVersion(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ForceUpdateFromAnyVersion(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::InstallAllResources() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InstallAllResources(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_InstallAllResources(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::InstallAllResources(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InstallAllResources(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_InstallAllResources(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::StageInPlace() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_StageInPlace(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_StageInPlace(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::StageInPlace(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_StageInPlace(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_StageInPlace(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::DeferRegistrationWhenPackagesAreInUse() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_DeferRegistrationWhenPackagesAreInUse(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->get_DeferRegistrationWhenPackagesAreInUse(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::DeferRegistrationWhenPackagesAreInUse(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_DeferRegistrationWhenPackagesAreInUse(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->put_DeferRegistrationWhenPackagesAreInUse(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::IsExpectedDigestsSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsExpectedDigestsSupported(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_IsExpectedDigestsSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<
    D>::ExpectedDigests() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRegisterPackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRegisterPackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExpectedDigests(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRegisterPackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ExpectedDigests(&value));
  }
  return winrt::Windows::Foundation::Collections::IMap<
      winrt::Windows::Foundation::Uri, hstring>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::FailIfNotFound() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_FailIfNotFound(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_FailIfNotFound(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::FailIfNotFound(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_FailIfNotFound(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_FailIfNotFound(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::PreserveApplicationData() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreserveApplicationData(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_PreserveApplicationData(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::PreserveApplicationData(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PreserveApplicationData(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_PreserveApplicationData(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::PreserveRoamableApplicationData() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PreserveRoamableApplicationData(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_PreserveRoamableApplicationData(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::PreserveRoamableApplicationData(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PreserveRoamableApplicationData(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_PreserveRoamableApplicationData(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::RemoveForAllUsers() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RemoveForAllUsers(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_RemoveForAllUsers(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<
    D>::RemoveForAllUsers(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IRemovePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::Management::
                                     Deployment::IRemovePackageOptions,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_RemoveForAllUsers(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IRemovePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_RemoveForAllUsers(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::TargetVolume() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TargetVolume(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_TargetVolume(&value));
  }
  return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::
    TargetVolume(
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume const&
            value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_TargetVolume(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_TargetVolume(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::DependencyPackageUris() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DependencyPackageUris(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_DependencyPackageUris(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Windows::Foundation::Uri>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::OptionalPackageFamilyNames() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_OptionalPackageFamilyNames(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::OptionalPackageUris() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_OptionalPackageUris(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_OptionalPackageUris(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Windows::Foundation::Uri>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::RelatedPackageUris() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RelatedPackageUris(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_RelatedPackageUris(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Windows::Foundation::Uri>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::ExternalLocationUri() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExternalLocationUri(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ExternalLocationUri(&value));
  }
  return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::
    ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ExternalLocationUri(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ExternalLocationUri(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::StubPackageOption() const {
  winrt::Microsoft::Windows::Management::Deployment::StubPackageOption value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_StubPackageOption(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_StubPackageOption(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::StubPackageOption(winrt::Microsoft::Windows::Management::Deployment::
                              StubPackageOption const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_StubPackageOption(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(
        _winrt_abi_type->put_StubPackageOption(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::DeveloperMode() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DeveloperMode(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_DeveloperMode(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::DeveloperMode(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_DeveloperMode(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_DeveloperMode(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::ForceUpdateFromAnyVersion() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ForceUpdateFromAnyVersion(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ForceUpdateFromAnyVersion(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::ForceUpdateFromAnyVersion(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ForceUpdateFromAnyVersion(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_ForceUpdateFromAnyVersion(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::InstallAllResources() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_InstallAllResources(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_InstallAllResources(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::InstallAllResources(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_InstallAllResources(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_InstallAllResources(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::RequiredContentGroupOnly() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RequiredContentGroupOnly(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_RequiredContentGroupOnly(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::RequiredContentGroupOnly(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_RequiredContentGroupOnly(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_RequiredContentGroupOnly(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::StageInPlace() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_StageInPlace(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_StageInPlace(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::StageInPlace(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_StageInPlace(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_StageInPlace(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::AllowUnsigned() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AllowUnsigned(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_AllowUnsigned(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::AllowUnsigned(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_AllowUnsigned(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->put_AllowUnsigned(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::IsExpectedDigestsSupported() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsExpectedDigestsSupported(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_IsExpectedDigestsSupported(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<
    D>::ExpectedDigests() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Management::
                                       Deployment::IStagePackageOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExpectedDigests(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Management::Deployment::
                    IStagePackageOptions>**)this;
    check_hresult(_winrt_abi_type->get_ExpectedDigests(&value));
  }
  return winrt::Windows::Foundation::Collections::IMap<
      winrt::Windows::Foundation::Uri, hstring>{value, take_ownership_from_abi};
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IAddPackageOptions> {
  int32_t __stdcall get_TargetVolume(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(
        this->shim().TargetVolume());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_TargetVolume(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().TargetVolume(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              PackageVolume const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().OptionalPackageFamilyNames());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OptionalPackageUris(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Windows::Foundation::Uri>>(this->shim().OptionalPackageUris());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RelatedPackageUris(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Windows::Foundation::Uri>>(this->shim().RelatedPackageUris());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Uri>(
        this->shim().ExternalLocationUri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ExternalLocationUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_StubPackageOption(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(
        this->shim().StubPackageOption());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_StubPackageOption(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().StubPackageOption(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              StubPackageOption const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().AllowUnsigned());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AllowUnsigned(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DeveloperMode());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DeveloperMode(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeveloperMode(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForceAppShutdown(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ForceAppShutdown());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForceAppShutdown(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForceAppShutdown(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForceTargetAppShutdown(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ForceTargetAppShutdown());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForceTargetAppShutdown(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForceTargetAppShutdown(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForceUpdateFromAnyVersion(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().InstallAllResources());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InstallAllResources(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InstallAllResources(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RequiredContentGroupOnly(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().RequiredContentGroupOnly());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_RequiredContentGroupOnly(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().RequiredContentGroupOnly(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RetainFilesOnFailure(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().RetainFilesOnFailure());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_RetainFilesOnFailure(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().RetainFilesOnFailure(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_StageInPlace(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().StageInPlace());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_StageInPlace(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().StageInPlace(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeferRegistrationWhenPackagesAreInUse(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<bool>(this->shim().DeferRegistrationWhenPackagesAreInUse());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DeferRegistrationWhenPackagesAreInUse(
      bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeferRegistrationWhenPackagesAreInUse(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IMap<
        winrt::Windows::Foundation::Uri, hstring>>(
        this->shim().ExpectedDigests());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsLimitToExistingPackagesSupported(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<bool>(this->shim().IsLimitToExistingPackagesSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LimitToExistingPackages(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().LimitToExistingPackages());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_LimitToExistingPackages(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().LimitToExistingPackages(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IEnsureReadyOptions> {
  int32_t __stdcall get_AddPackageOptions(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>(
        this->shim().AddPackageOptions());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions2>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IEnsureReadyOptions2> {
  int32_t __stdcall get_RegisterNewerIfAvailable(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().RegisterNewerIfAvailable());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_RegisterNewerIfAvailable(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().RegisterNewerIfAvailable(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Management::Deployment::
                      IPackageDeploymentManager>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageDeploymentManager> {
  int32_t __stdcall IsPackageReady(void* package, bool* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsPackageReady(
        *reinterpret_cast<hstring const*>(&package)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageReadyByUri(void* packageUri,
                                        bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsPackageReadyByUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
            &packageUri)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageSetReady(void* packageSet,
                                      bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsPackageSetReady(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              PackageSet const*>(&packageSet)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsurePackageReadyAsync(void* package, void* options,
                                            void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().EnsurePackageReadyAsync(
                *reinterpret_cast<hstring const*>(&package),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::EnsureReadyOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsurePackageReadyByUriAsync(
      void* packageUri, void* options, void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().EnsurePackageReadyByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::EnsureReadyOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsurePackageSetReadyAsync(void* packageSet, void* options,
                                               void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().EnsurePackageSetReadyAsync(
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::PackageSet const*>(
                    &packageSet),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::EnsureReadyOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall AddPackageAsync(void* package, void* options,
                                    void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().AddPackageAsync(
                *reinterpret_cast<hstring const*>(&package),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::AddPackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall AddPackageByUriAsync(void* packageUri, void* options,
                                         void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().AddPackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::AddPackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall AddPackageSetAsync(void* packageSet, void* options,
                                       void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().AddPackageSetAsync(
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::PackageSet const*>(
                    &packageSet),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::AddPackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall StagePackageAsync(void* package, void* options,
                                      void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().StagePackageAsync(
                *reinterpret_cast<hstring const*>(&package),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::StagePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall StagePackageByUriAsync(void* packageUri, void* options,
                                           void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().StagePackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::StagePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall StagePackageSetAsync(void* packageSet, void* options,
                                         void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().StagePackageSetAsync(
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::PackageSet const*>(
                    &packageSet),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::StagePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RegisterPackageAsync(void* package, void* options,
                                         void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RegisterPackageAsync(
                *reinterpret_cast<hstring const*>(&package),
                *reinterpret_cast<
                    winrt::Microsoft::Windows::Management::Deployment::
                        RegisterPackageOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RegisterPackageByUriAsync(void* packageUri, void* options,
                                              void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RegisterPackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri),
                *reinterpret_cast<
                    winrt::Microsoft::Windows::Management::Deployment::
                        RegisterPackageOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RegisterPackageSetAsync(void* packageSet, void* options,
                                            void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<
        winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
        this->shim().RegisterPackageSetAsync(
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::PackageSet const*>(&packageSet),
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::RegisterPackageOptions const*>(
                &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RemovePackageAsync(void* package, void* options,
                                       void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RemovePackageAsync(
                *reinterpret_cast<hstring const*>(&package),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::RemovePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RemovePackageByFullNameAsync(
      void* packageFullName, void* options, void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RemovePackageByFullNameAsync(
                *reinterpret_cast<hstring const*>(&packageFullName),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::RemovePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RemovePackageByFamilyNameAsync(
      void* packageFamilyName, void* options, void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RemovePackageByFamilyNameAsync(
                *reinterpret_cast<hstring const*>(&packageFamilyName),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::RemovePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RemovePackageByUriAsync(void* packageUri, void* options,
                                            void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RemovePackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::RemovePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RemovePackageSetAsync(void* packageSet, void* options,
                                          void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RemovePackageSetAsync(
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::PackageSet const*>(
                    &packageSet),
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::RemovePackageOptions const*>(
                    &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ResetPackageAsync(void* package,
                                      void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().ResetPackageAsync(
                *reinterpret_cast<hstring const*>(&package)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ResetPackageByUriAsync(void* packageUri,
                                           void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().ResetPackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ResetPackageSetAsync(void* packageSet,
                                         void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().ResetPackageSetAsync(
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::PackageSet const*>(
                    &packageSet)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RepairPackageAsync(void* package,
                                       void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RepairPackageAsync(
                *reinterpret_cast<hstring const*>(&package)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RepairPackageByUriAsync(void* packageUri,
                                            void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RepairPackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RepairPackageSetAsync(void* packageSet,
                                          void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().RepairPackageSetAsync(
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::PackageSet const*>(
                    &packageSet)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProvisionPackageAsync(void* package, void* options,
                                          void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().ProvisionPackageAsync(
                *reinterpret_cast<hstring const*>(&package),
                *reinterpret_cast<
                    winrt::Microsoft::Windows::Management::Deployment::
                        ProvisionPackageOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProvisionPackageByUriAsync(void* packageUri, void* options,
                                               void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().ProvisionPackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri),
                *reinterpret_cast<
                    winrt::Microsoft::Windows::Management::Deployment::
                        ProvisionPackageOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ProvisionPackageSetAsync(void* packageSet, void* options,
                                             void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<
        winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
        this->shim().ProvisionPackageSetAsync(
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::PackageSet const*>(&packageSet),
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::ProvisionPackageOptions const*>(
                &options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall DeprovisionPackageAsync(void* package,
                                            void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().DeprovisionPackageAsync(
                *reinterpret_cast<hstring const*>(&package)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall DeprovisionPackageByUriAsync(
      void* packageUri, void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().DeprovisionPackageByUriAsync(
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &packageUri)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall DeprovisionPackageSetAsync(void* packageSet,
                                               void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentResult,
            winrt::Microsoft::Windows::Management::Deployment::
                PackageDeploymentProgress>>(
            this->shim().DeprovisionPackageSetAsync(
                *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                      Deployment::PackageSet const*>(
                    &packageSet)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageRegistrationPending(void* packageFamilyName,
                                                 bool* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsPackageRegistrationPending(
        *reinterpret_cast<hstring const*>(&packageFamilyName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageRegistrationPendingForUser(
      void* userSecurityId, void* packageFamilyName,
      bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<bool>(this->shim().IsPackageRegistrationPendingForUser(
            *reinterpret_cast<hstring const*>(&userSecurityId),
            *reinterpret_cast<hstring const*>(&packageFamilyName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Management::Deployment::
                      IPackageDeploymentManager2>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageDeploymentManager2> {
  int32_t __stdcall IsPackageReadyOrNewerAvailable(
      void* package, int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::
                              PackageReadyOrNewerAvailableStatus>(
        this->shim().IsPackageReadyOrNewerAvailable(
            *reinterpret_cast<hstring const*>(&package)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageReadyOrNewerAvailableByUri(
      void* packageUri, int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::
                              PackageReadyOrNewerAvailableStatus>(
        this->shim().IsPackageReadyOrNewerAvailableByUri(
            *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                &packageUri)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageSetReadyOrNewerAvailable(
      void* packageSet, int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::
                              PackageReadyOrNewerAvailableStatus>(
        this->shim().IsPackageSetReadyOrNewerAvailable(
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::PackageSet const*>(&packageSet)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageProvisioned(void* package,
                                         bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsPackageProvisioned(
        *reinterpret_cast<hstring const*>(&package)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageProvisionedByUri(void* packageUri,
                                              bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsPackageProvisionedByUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
            &packageUri)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsPackageSetProvisioned(void* packageSet,
                                            bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsPackageSetProvisioned(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              PackageSet const*>(&packageSet)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Management::Deployment::
                      IPackageDeploymentManagerStatics>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageDeploymentManagerStatics> {
  int32_t __stdcall GetDefault(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::Management::Deployment::
                        PackageDeploymentManager>(this->shim().GetDefault());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Management::Deployment::
                      IPackageDeploymentManagerStatics2>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageDeploymentManagerStatics2> {
  int32_t __stdcall IsPackageDeploymentFeatureSupported(
      int32_t feature, bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<bool>(this->shim().IsPackageDeploymentFeatureSupported(
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::PackageDeploymentFeature const*>(
                &feature)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageDeploymentResult> {
  int32_t __stdcall get_Status(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::
                             PackageDeploymentStatus>(this->shim().Status());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Error(winrt::hresult* value) noexcept final try {
    zero_abi<winrt::hresult>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::hresult>(this->shim().Error());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final
      try {
    zero_abi<winrt::hresult>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ErrorText(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().ErrorText());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ActivityId(winrt::guid* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::guid>(this->shim().ActivityId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageRuntimeManager> {
  int32_t __stdcall AddPackageSet(void* packageSet,
                                  void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::
                              PackageSetRuntimeDisposition>(
        this->shim().AddPackageSet(
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::PackageSet const*>(&packageSet)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall AddPackageSetWithOptions(void* packageSet,
                                             void* createOptions,
                                             void* addOptions,
                                             void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::
                              PackageSetRuntimeDisposition>(
        this->shim().AddPackageSet(
            *reinterpret_cast<winrt::Microsoft::Windows::Management::
                                  Deployment::PackageSet const*>(&packageSet),
            *reinterpret_cast<
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    CreatePackageDependencyOptions const*>(&createOptions),
            *reinterpret_cast<
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    AddPackageDependencyOptions const*>(&addOptions)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RemovePackageSet(
      void* packageSetRuntimeDisposition) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().RemovePackageSet(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              PackageSetRuntimeDisposition const*>(
            &packageSetRuntimeDisposition));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Management::Deployment::
                      IPackageRuntimeManagerStatics>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageRuntimeManagerStatics> {
  int32_t __stdcall GetDefault(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::
                              PackageRuntimeManager>(this->shim().GetDefault());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::Windows::Management::Deployment::IPackageSet>
    : produce_base<
          D, winrt::Microsoft::Windows::Management::Deployment::IPackageSet> {
  int32_t __stdcall get_Id(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Id());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Id(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Id(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageUri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Uri>(this->shim().PackageUri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PackageUri(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PackageUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Items(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>>(
        this->shim().Items());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem>
    : produce_base<
          D,
          winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem> {
  int32_t __stdcall get_Id(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Id());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Id(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Id(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageFamilyName(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageFamilyName());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PackageFamilyName(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PackageFamilyName(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MinVersion(
      struct struct_Windows_ApplicationModel_PackageVersion* value) noexcept
      final try {
    zero_abi<winrt::Windows::ApplicationModel::PackageVersion>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::ApplicationModel::PackageVersion>(
        this->shim().MinVersion());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_MinVersion(
      struct struct_Windows_ApplicationModel_PackageVersion value) noexcept
      final try {
    typename D::abi_guard guard(this->shim());
    this->shim().MinVersion(
        *reinterpret_cast<
            winrt::Windows::ApplicationModel::PackageVersion const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ProcessorArchitectureFilter(
      uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            PackageDependencyProcessorArchitectures>(
        this->shim().ProcessorArchitectureFilter());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ProcessorArchitectureFilter(
      uint32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ProcessorArchitectureFilter(
        *reinterpret_cast<
            winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                PackageDependencyProcessorArchitectures const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageUri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Uri>(this->shim().PackageUri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PackageUri(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PackageUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Management::Deployment::
                      IPackageSetItemRuntimeDisposition>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageSetItemRuntimeDisposition> {
  int32_t __stdcall get_PackageSetItemId(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageSetItemId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageFullName(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageFullName());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageDependencyId(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageDependencyId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageDependencyContextId(
      struct
      struct_Microsoft_Windows_ApplicationModel_DynamicDependency_PackageDependencyContextId*
          value) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                 PackageDependencyContextId>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                             DynamicDependency::PackageDependencyContextId>(
        this->shim().PackageDependencyContextId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Management::Deployment::
                      IPackageSetRuntimeDisposition>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageSetRuntimeDisposition> {
  int32_t __stdcall get_PackageSetId(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageSetId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PackageSetId(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PackageSetId(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageSetItemRuntimeDispositions(
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Microsoft::Windows::Management::Deployment::
            PackageSetItemRuntimeDisposition>>(
        this->shim().PackageSetItemRuntimeDispositions());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolume>
    : produce_base<
          D,
          winrt::Microsoft::Windows::Management::Deployment::IPackageVolume> {
  int32_t __stdcall get_IsSystemVolume(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsSystemVolume());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MountPoint(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().MountPoint());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Name(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Name());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageStorePath(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageStorePath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SupportsHardLinks(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().SupportsHardLinks());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsFullTrustPackageSupported(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsFullTrustPackageSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsAppxInstallSupported(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsAppxInstallSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsRepairNeeded(bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsRepairNeeded());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Repair() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Repair();
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IPackageVolumeStatics> {
  int32_t __stdcall FindPackageVolumes(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume>>(
        this->shim().FindPackageVolumes());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall FindPackageVolumeByPath(void* packageStorePath,
                                            void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(
        this->shim().FindPackageVolumeByPath(
            *reinterpret_cast<hstring const*>(&packageStorePath)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall FindPackageVolumeByName(void* name,
                                            void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(
        this->shim().FindPackageVolumeByName(
            *reinterpret_cast<hstring const*>(&name)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IProvisionPackageOptions> {
  int32_t __stdcall get_IsOptionalPackageFamilyNamesSupported(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<bool>(this->shim().IsOptionalPackageFamilyNamesSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().OptionalPackageFamilyNames());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsProjectionOrderPackageFamilyNamesSupported(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(
        this->shim().IsProjectionOrderPackageFamilyNamesSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ProjectionOrderPackageFamilyNames(
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().ProjectionOrderPackageFamilyNames());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IRegisterPackageOptions> {
  int32_t __stdcall get_AppDataVolume(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(
        this->shim().AppDataVolume());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AppDataVolume(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AppDataVolume(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              PackageVolume const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DependencyPackageFamilyNames(
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().DependencyPackageFamilyNames());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().OptionalPackageFamilyNames());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Uri>(
        this->shim().ExternalLocationUri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ExternalLocationUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().AllowUnsigned());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AllowUnsigned(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DeveloperMode());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DeveloperMode(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeveloperMode(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForceAppShutdown(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ForceAppShutdown());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForceAppShutdown(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForceAppShutdown(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForceTargetAppShutdown(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ForceTargetAppShutdown());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForceTargetAppShutdown(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForceTargetAppShutdown(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForceUpdateFromAnyVersion(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().InstallAllResources());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InstallAllResources(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InstallAllResources(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_StageInPlace(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().StageInPlace());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_StageInPlace(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().StageInPlace(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeferRegistrationWhenPackagesAreInUse(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<bool>(this->shim().DeferRegistrationWhenPackagesAreInUse());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DeferRegistrationWhenPackagesAreInUse(
      bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeferRegistrationWhenPackagesAreInUse(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IMap<
        winrt::Windows::Foundation::Uri, hstring>>(
        this->shim().ExpectedDigests());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IRemovePackageOptions> {
  int32_t __stdcall get_FailIfNotFound(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().FailIfNotFound());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_FailIfNotFound(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().FailIfNotFound(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PreserveApplicationData(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().PreserveApplicationData());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreserveApplicationData(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreserveApplicationData(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PreserveRoamableApplicationData(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().PreserveRoamableApplicationData());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PreserveRoamableApplicationData(
      bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PreserveRoamableApplicationData(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RemoveForAllUsers(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().RemoveForAllUsers());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_RemoveForAllUsers(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().RemoveForAllUsers(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions>
    : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::
                          IStagePackageOptions> {
  int32_t __stdcall get_TargetVolume(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(
        this->shim().TargetVolume());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_TargetVolume(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().TargetVolume(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              PackageVolume const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().OptionalPackageFamilyNames());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_OptionalPackageUris(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Windows::Foundation::Uri>>(this->shim().OptionalPackageUris());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RelatedPackageUris(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Windows::Foundation::Uri>>(this->shim().RelatedPackageUris());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Uri>(
        this->shim().ExternalLocationUri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ExternalLocationUri(
        *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_StubPackageOption(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(
        this->shim().StubPackageOption());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_StubPackageOption(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().StubPackageOption(
        *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::
                              StubPackageOption const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().DeveloperMode());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DeveloperMode(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DeveloperMode(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().ForceUpdateFromAnyVersion(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().InstallAllResources());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_InstallAllResources(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InstallAllResources(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RequiredContentGroupOnly(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().RequiredContentGroupOnly());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_RequiredContentGroupOnly(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().RequiredContentGroupOnly(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_StageInPlace(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().StageInPlace());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_StageInPlace(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().StageInPlace(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().AllowUnsigned());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AllowUnsigned(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IMap<
        winrt::Windows::Foundation::Uri, hstring>>(
        this->shim().ExpectedDigests());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::Management::Deployment {
  inline AddPackageOptions::AddPackageOptions()
      : AddPackageOptions(
            impl::call_factory_cast<
                AddPackageOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                AddPackageOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<AddPackageOptions>();
                })) {}
  inline EnsureReadyOptions::EnsureReadyOptions()
      : EnsureReadyOptions(
            impl::call_factory_cast<
                EnsureReadyOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                EnsureReadyOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<EnsureReadyOptions>();
                })) {}
  inline auto PackageDeploymentManager::GetDefault() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::Management::Deployment::
            PackageDeploymentManager (*)(
                IPackageDeploymentManagerStatics const&),
        PackageDeploymentManager, IPackageDeploymentManagerStatics>(
        [](IPackageDeploymentManagerStatics const& f) {
          return f.GetDefault();
        });
  }
  inline auto PackageDeploymentManager::IsPackageDeploymentFeatureSupported(
      winrt::Microsoft::Windows::Management::Deployment::
          PackageDeploymentFeature const& feature) {
    return impl::call_factory<PackageDeploymentManager,
                              IPackageDeploymentManagerStatics2>(
        [&](IPackageDeploymentManagerStatics2 const& f) {
          return f.IsPackageDeploymentFeatureSupported(feature);
        });
  }
  inline auto PackageRuntimeManager::GetDefault() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::Management::Deployment::
            PackageRuntimeManager (*)(IPackageRuntimeManagerStatics const&),
        PackageRuntimeManager, IPackageRuntimeManagerStatics>(
        [](IPackageRuntimeManagerStatics const& f) { return f.GetDefault(); });
  }
  inline PackageSet::PackageSet()
      : PackageSet(impl::call_factory_cast<
                   PackageSet (*)(
                       winrt::Windows::Foundation::IActivationFactory const&),
                   PackageSet>(
            [](winrt::Windows::Foundation::IActivationFactory const& f) {
              return f.template ActivateInstance<PackageSet>();
            })) {}
  inline PackageSetItem::PackageSetItem()
      : PackageSetItem(
            impl::call_factory_cast<
                PackageSetItem (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                PackageSetItem>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<PackageSetItem>();
                })) {}
  inline PackageSetItemRuntimeDisposition::PackageSetItemRuntimeDisposition()
      : PackageSetItemRuntimeDisposition(
            impl::call_factory_cast<
                PackageSetItemRuntimeDisposition (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                PackageSetItemRuntimeDisposition>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<
                      PackageSetItemRuntimeDisposition>();
                })) {}
  inline PackageSetRuntimeDisposition::PackageSetRuntimeDisposition()
      : PackageSetRuntimeDisposition(
            impl::call_factory_cast<
                PackageSetRuntimeDisposition (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                PackageSetRuntimeDisposition>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<
                      PackageSetRuntimeDisposition>();
                })) {}
  inline auto PackageVolume::FindPackageVolumes() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::Collections::IVector<
            winrt::Microsoft::Windows::Management::Deployment::
                PackageVolume> (*)(IPackageVolumeStatics const&),
        PackageVolume, IPackageVolumeStatics>(
        [](IPackageVolumeStatics const& f) { return f.FindPackageVolumes(); });
  }
  inline auto PackageVolume::FindPackageVolumeByPath(
      param::hstring const& packageStorePath) {
    return impl::call_factory<PackageVolume, IPackageVolumeStatics>(
        [&](IPackageVolumeStatics const& f) {
          return f.FindPackageVolumeByPath(packageStorePath);
        });
  }
  inline auto PackageVolume::FindPackageVolumeByName(
      param::hstring const& name) {
    return impl::call_factory<PackageVolume, IPackageVolumeStatics>(
        [&](IPackageVolumeStatics const& f) {
          return f.FindPackageVolumeByName(name);
        });
  }
  inline ProvisionPackageOptions::ProvisionPackageOptions()
      : ProvisionPackageOptions(
            impl::call_factory_cast<
                ProvisionPackageOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                ProvisionPackageOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<ProvisionPackageOptions>();
                })) {}
  inline RegisterPackageOptions::RegisterPackageOptions()
      : RegisterPackageOptions(
            impl::call_factory_cast<
                RegisterPackageOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                RegisterPackageOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<RegisterPackageOptions>();
                })) {}
  inline RemovePackageOptions::RemovePackageOptions()
      : RemovePackageOptions(
            impl::call_factory_cast<
                RemovePackageOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                RemovePackageOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<RemovePackageOptions>();
                })) {}
  inline StagePackageOptions::StagePackageOptions()
      : StagePackageOptions(
            impl::call_factory_cast<
                StagePackageOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                StagePackageOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<StagePackageOptions>();
                })) {}
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                IPackageDeploymentManager> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                IPackageDeploymentManager2> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                IPackageDeploymentManagerStatics> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                IPackageDeploymentManagerStatics2> : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                IPackageRuntimeManagerStatics> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSet>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                IPackageSetItemRuntimeDisposition> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                IPackageSetRuntimeDisposition> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageVolume>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSet>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                PackageSetItemRuntimeDisposition> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::
                PackageSetRuntimeDisposition> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
