// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Input_DragDrop_H
#define WINRT_Microsoft_UI_Input_DragDrop_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.Input.h"
#include "winrt/impl/Microsoft.UI.Content.2.h"
#include "winrt/impl/Microsoft.UI.Input.2.h"
#include "winrt/impl/Microsoft.UI.Input.DragDrop.2.h"
#include "winrt/impl/Windows.ApplicationModel.DataTransfer.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<
    D>::AreConcurrentOperationsEnabled() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragDropManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AreConcurrentOperationsEnabled(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
    check_hresult(_winrt_abi_type->get_AreConcurrentOperationsEnabled(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<
    D>::AreConcurrentOperationsEnabled(bool value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragDropManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_AreConcurrentOperationsEnabled(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
    check_hresult(_winrt_abi_type->put_AreConcurrentOperationsEnabled(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::TargetRequested(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::DragDrop::DragDropManager,
        winrt::Microsoft::UI::Input::DragDrop::
            DropOperationTargetRequestedEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragDropManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_TargetRequested(*(void**)(&handler),
                                                       put_abi(token)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
    check_hresult(_winrt_abi_type->add_TargetRequested(*(void**)(&handler),
                                                       put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::TargetRequested(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Input::DragDrop::DragDropManager,
        winrt::Microsoft::UI::Input::DragDrop::
            DropOperationTargetRequestedEventArgs> const& handler) const {
  return impl::make_event_revoker<D, TargetRequested_revoker>(
      this, TargetRequested(handler));
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::TargetRequested(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragDropManager>**)&_winrt_casted_result;
    _winrt_abi_type->remove_TargetRequested(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
    _winrt_abi_type->remove_TargetRequested(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragDropManagerStatics<
    D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const&
                         content) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::
                                       IDragDropManagerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragDropManagerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&content), &result));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                                             IDragDropManagerStatics>**)this;
    check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&content), &result));
  }
  return winrt::Microsoft::UI::Input::DragDrop::DragDropManager{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::AllowedOperations()
    const {
  winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                                             IDragInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AllowedOperations(
        reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
    check_hresult(_winrt_abi_type->get_AllowedOperations(
        reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::Data() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                                             IDragInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Data(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
    check_hresult(_winrt_abi_type->get_Data(&value));
  }
  return winrt::Windows::ApplicationModel::DataTransfer::DataPackageView{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::Modifiers() const {
  winrt::Microsoft::UI::Input::DragDrop::DragDropModifiers value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                                             IDragInfo>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Modifiers(reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
    check_hresult(
        _winrt_abi_type->get_Modifiers(reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::Position() const {
  winrt::Windows::Foundation::Point value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                                             IDragInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
    check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::AllowedOperations()
    const {
  winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_AllowedOperations(
        reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(_winrt_abi_type->get_AllowedOperations(
        reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::AllowedOperations(
    winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation const&
        value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_AllowedOperations(static_cast<uint32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(
        _winrt_abi_type->put_AllowedOperations(static_cast<uint32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::Data() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Data(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(_winrt_abi_type->get_Data(&value));
  }
  return winrt::Windows::ApplicationModel::DataTransfer::DataPackage{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::DragUIContentMode()
    const {
  winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DragUIContentMode(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(_winrt_abi_type->get_DragUIContentMode(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::DragUIContentMode(
    winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode const& value)
    const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_DragUIContentMode(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(
        _winrt_abi_type->put_DragUIContentMode(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::
    SetDragUIContentFromSoftwareBitmap(
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap(
        *(void**)(&bitmap)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap(
        *(void**)(&bitmap)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::
    SetDragUIContentFromSoftwareBitmap(
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap,
        winrt::Windows::Foundation::Point const& anchorPoint) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap2(
        *(void**)(&bitmap), impl::bind_in(anchorPoint)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap2(
        *(void**)(&bitmap), impl::bind_in(anchorPoint)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::StartAsync(
    winrt::Microsoft::UI::Input::DragDrop::DragDropManager const& initialTarget,
    winrt::Microsoft::UI::Input::PointerPoint const& initialPointerPoint)
    const {
  void* operation{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragOperation>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->StartAsync(*(void**)(&initialTarget),
                                              *(void**)(&initialPointerPoint),
                                              &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
    check_hresult(_winrt_abi_type->StartAsync(*(void**)(&initialTarget),
                                              *(void**)(&initialPointerPoint),
                                              &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::Caption() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Caption(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->get_Caption(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::Caption(
    param::hstring const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Caption(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->put_Caption(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsCaptionVisible()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsCaptionVisible(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->get_IsCaptionVisible(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsCaptionVisible(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsCaptionVisible(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->put_IsCaptionVisible(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsContentVisible()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsContentVisible(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->get_IsContentVisible(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsContentVisible(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsContentVisible(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->put_IsContentVisible(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsGlyphVisible()
    const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IsGlyphVisible(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->get_IsGlyphVisible(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsGlyphVisible(
    bool value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_IsGlyphVisible(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->put_IsGlyphVisible(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::Clear() const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Clear());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->Clear());
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::
    SetContentFromSoftwareBitmap(
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetContentFromSoftwareBitmap(*(void**)(&bitmap)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(
        _winrt_abi_type->SetContentFromSoftwareBitmap(*(void**)(&bitmap)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::
    SetContentFromSoftwareBitmap(
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap,
        winrt::Windows::Foundation::Point const& anchorPoint) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDragUIOverride>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetContentFromSoftwareBitmap2(
        *(void**)(&bitmap), impl::bind_in(anchorPoint)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
    check_hresult(_winrt_abi_type->SetContentFromSoftwareBitmap2(
        *(void**)(&bitmap), impl::bind_in(anchorPoint)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::DropAsync(
    winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::
                                       IDropOperationTarget>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDropOperationTarget>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->DropAsync(*(void**)(&dragInfo), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
    check_hresult(_winrt_abi_type->DropAsync(*(void**)(&dragInfo), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::EnterAsync(
    winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo,
    winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const& dragUIOverride)
    const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::
                                       IDropOperationTarget>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDropOperationTarget>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnterAsync(
        *(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
    check_hresult(_winrt_abi_type->EnterAsync(
        *(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::LeaveAsync(
    winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::
                                       IDropOperationTarget>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDropOperationTarget>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->LeaveAsync(*(void**)(&dragInfo), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
    check_hresult(
        _winrt_abi_type->LeaveAsync(*(void**)(&dragInfo), &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::OverAsync(
    winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo,
    winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const& dragUIOverride)
    const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::
                                       IDropOperationTarget>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDropOperationTarget>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->OverAsync(
        *(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
    check_hresult(_winrt_abi_type->OverAsync(
        *(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTargetRequestedEventArgs<
    D>::SetTarget(winrt::Microsoft::UI::Input::DragDrop::
                      IDropOperationTarget const& target) const {
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Input::DragDrop::
                                    IDropOperationTargetRequestedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::
                                     IDropOperationTargetRequestedEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Input::DragDrop::
                IDropOperationTargetRequestedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetTarget(*(void**)(&target)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Input::DragDrop::
                    IDropOperationTargetRequestedEventArgs>**)this;
    check_hresult(_winrt_abi_type->SetTarget(*(void**)(&target)));
  }
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>
    : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager> {
  int32_t __stdcall get_AreConcurrentOperationsEnabled(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().AreConcurrentOperationsEnabled());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AreConcurrentOperationsEnabled(
      bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AreConcurrentOperationsEnabled(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_TargetRequested(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().TargetRequested(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Input::DragDrop::DragDropManager,
            winrt::Microsoft::UI::Input::DragDrop::
                DropOperationTargetRequestedEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_TargetRequested(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().TargetRequested(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics> {
  int32_t __stdcall GetForIsland(void* content, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Input::DragDrop::DragDropManager>(
            this->shim().GetForIsland(
                *reinterpret_cast<
                    winrt::Microsoft::UI::Content::ContentIsland const*>(
                    &content)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>
    : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo> {
  int32_t __stdcall get_AllowedOperations(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(
        this->shim().AllowedOperations());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Data(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>(
        this->shim().Data());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Modifiers(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::Input::DragDrop::DragDropModifiers>(
            this->shim().Modifiers());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Position(
      winrt::Windows::Foundation::Point* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Point>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>
    : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation> {
  int32_t __stdcall get_AllowedOperations(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(
        this->shim().AllowedOperations());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_AllowedOperations(uint32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AllowedOperations(
        *reinterpret_cast<winrt::Windows::ApplicationModel::DataTransfer::
                              DataPackageOperation const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Data(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(
        this->shim().Data());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DragUIContentMode(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode>(
            this->shim().DragUIContentMode());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DragUIContentMode(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DragUIContentMode(
        *reinterpret_cast<
            winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetDragUIContentFromSoftwareBitmap(
      void* bitmap) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetDragUIContentFromSoftwareBitmap(
        *reinterpret_cast<
            winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetDragUIContentFromSoftwareBitmap2(
      void* bitmap,
      winrt::Windows::Foundation::Point anchorPoint) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetDragUIContentFromSoftwareBitmap(
        *reinterpret_cast<
            winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap),
        *reinterpret_cast<winrt::Windows::Foundation::Point const*>(
            &anchorPoint));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall StartAsync(void* initialTarget, void* initialPointerPoint,
                               void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(
        this->shim().StartAsync(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::DragDrop::DragDropManager const*>(
                &initialTarget),
            *reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(
                &initialPointerPoint)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>
    : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride> {
  int32_t __stdcall get_Caption(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Caption());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Caption(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Caption(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsCaptionVisible(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsCaptionVisible());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsCaptionVisible(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsCaptionVisible(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsContentVisible(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsContentVisible());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsContentVisible(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsContentVisible(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IsGlyphVisible(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().IsGlyphVisible());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_IsGlyphVisible(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().IsGlyphVisible(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Clear() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Clear();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetContentFromSoftwareBitmap(void* bitmap) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetContentFromSoftwareBitmap(
        *reinterpret_cast<
            winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetContentFromSoftwareBitmap2(
      void* bitmap,
      winrt::Windows::Foundation::Point anchorPoint) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetContentFromSoftwareBitmap(
        *reinterpret_cast<
            winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap),
        *reinterpret_cast<winrt::Windows::Foundation::Point const*>(
            &anchorPoint));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>
    : produce_base<
          D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget> {
  int32_t __stdcall DropAsync(void* dragInfo, void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(
        this->shim().DropAsync(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(
                &dragInfo)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnterAsync(void* dragInfo, void* dragUIOverride,
                               void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(
        this->shim().EnterAsync(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(
                &dragInfo),
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const*>(
                &dragUIOverride)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall LeaveAsync(void* dragInfo, void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(
        this->shim().LeaveAsync(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(
                &dragInfo)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall OverAsync(void* dragInfo, void* dragUIOverride,
                              void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(
        this->shim().OverAsync(
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(
                &dragInfo),
            *reinterpret_cast<
                winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const*>(
                &dragUIOverride)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Input::DragDrop::
                      IDropOperationTargetRequestedEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::
                          IDropOperationTargetRequestedEventArgs> {
  int32_t __stdcall SetTarget(void* target) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetTarget(
        *reinterpret_cast<
            winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget const*>(
            &target));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::UI::Input::DragDrop {
  constexpr auto operator|(DragDropModifiers const left,
                           DragDropModifiers const right) noexcept {
    return static_cast<DragDropModifiers>(impl::to_underlying_type(left) |
                                          impl::to_underlying_type(right));
  }
  constexpr auto operator|=(DragDropModifiers& left,
                            DragDropModifiers const right) noexcept {
    left = left | right;
    return left;
  }
  constexpr auto operator&(DragDropModifiers const left,
                           DragDropModifiers const right) noexcept {
    return static_cast<DragDropModifiers>(impl::to_underlying_type(left) &
                                          impl::to_underlying_type(right));
  }
  constexpr auto operator&=(DragDropModifiers& left,
                            DragDropModifiers const right) noexcept {
    left = left & right;
    return left;
  }
  constexpr auto operator~(DragDropModifiers const value) noexcept {
    return static_cast<DragDropModifiers>(~impl::to_underlying_type(value));
  }
  constexpr auto operator^(DragDropModifiers const left,
                           DragDropModifiers const right) noexcept {
    return static_cast<DragDropModifiers>(impl::to_underlying_type(left) ^
                                          impl::to_underlying_type(right));
  }
  constexpr auto operator^=(DragDropModifiers& left,
                            DragDropModifiers const right) noexcept {
    left = left ^ right;
    return left;
  }
  inline auto DragDropManager::GetForIsland(
      winrt::Microsoft::UI::Content::ContentIsland const& content) {
    return impl::call_factory<DragDropManager, IDragDropManagerStatics>(
        [&](IDragDropManagerStatics const& f) {
          return f.GetForIsland(content);
        });
  }
  inline DragOperation::DragOperation()
      : DragOperation(
            impl::call_factory_cast<
                DragOperation (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                DragOperation>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<DragOperation>();
                })) {}
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::
                IDropOperationTargetRequestedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::DragDropManager>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::DragInfo>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::DragOperation>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::DragUIOverride>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Input::DragDrop::
                DropOperationTargetRequestedEventArgs>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
