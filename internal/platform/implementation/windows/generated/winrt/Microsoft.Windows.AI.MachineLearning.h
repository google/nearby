// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_MachineLearning_H
#define WINRT_Microsoft_Windows_AI_MachineLearning_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.h"
#include "winrt/impl/Microsoft.Windows.AI.MachineLearning.2.h"
#include "winrt/impl/Windows.ApplicationModel.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<D>::Id()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Id(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_Id(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<D>::Name()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Name(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_Name(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::Publisher() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Publisher(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_Publisher(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::SourceId() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SourceId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_SourceId(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<D>::Uri()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Uri(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_Uri(&value));
  }
  return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::ExecutionProviders() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExecutionProviders(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_ExecutionProviders(&value));
  }
  return winrt::Windows::Foundation::Collections::IVectorView<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::ModelSizeInBytes() const {
  uint64_t value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ModelSizeInBytes(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_ModelSizeInBytes(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::Version() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Version(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_Version(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::License() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_License(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_License(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::LicenseUri() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LicenseUri(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_LicenseUri(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::LicenseText() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LicenseText(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->get_LicenseText(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::GetStatus() const {
  winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelStatus result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetStatus(reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(
        _winrt_abi_type->GetStatus(reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<
    D>::GetInstanceAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetInstanceAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->GetInstanceAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::MachineLearning::
          CatalogModelInstanceResult,
      double>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInfo<D>::
    GetInstanceAsync(param::async_iterable<
                     winrt::Windows::Foundation::Collections::IKeyValuePair<
                         hstring, hstring>> const& additionalHeaders) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::ICatalogModelInfo>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetInstanceAsync2(
        *(void**)(&additionalHeaders), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInfo>**)this;
    check_hresult(_winrt_abi_type->GetInstanceAsync2(
        *(void**)(&additionalHeaders), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::MachineLearning::
          CatalogModelInstanceResult,
      double>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInstance<
    D>::ModelPaths() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    ICatalogModelInstance>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInstance,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstance>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ModelPaths(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstance>**)this;
    check_hresult(_winrt_abi_type->get_ModelPaths(&value));
  }
  return winrt::Windows::Foundation::Collections::IVectorView<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInstance<
    D>::ModelInfo() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    ICatalogModelInstance>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInstance,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstance>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ModelInfo(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstance>**)this;
    check_hresult(_winrt_abi_type->get_ModelInfo(&value));
  }
  return winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInstanceResult<
    D>::Status() const {
  winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInstanceStatus
      value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    ICatalogModelInstanceResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            ICatalogModelInstanceResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)this;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInstanceResult<
    D>::ExtendedError() const {
  winrt::hresult value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    ICatalogModelInstanceResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            ICatalogModelInstanceResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)this;
    check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInstanceResult<
    D>::DiagnosticText() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    ICatalogModelInstanceResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            ICatalogModelInstanceResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DiagnosticText(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)this;
    check_hresult(_winrt_abi_type->get_DiagnosticText(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_ICatalogModelInstanceResult<
    D>::GetInstance() const {
  void* result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    ICatalogModelInstanceResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            ICatalogModelInstanceResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetInstance(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    ICatalogModelInstanceResult>**)this;
    check_hresult(_winrt_abi_type->GetInstance(&result));
  }
  return winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInstance{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProvider<D>::Name()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IExecutionProvider>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Name(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)this;
    check_hresult(_winrt_abi_type->get_Name(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProvider<
    D>::LibraryPath() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IExecutionProvider>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LibraryPath(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)this;
    check_hresult(_winrt_abi_type->get_LibraryPath(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProvider<
    D>::PackageId() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IExecutionProvider>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)this;
    check_hresult(_winrt_abi_type->get_PackageId(&value));
  }
  return winrt::Windows::ApplicationModel::PackageId{value,
                                                     take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProvider<
    D>::ReadyState() const {
  winrt::Microsoft::Windows::AI::MachineLearning::ExecutionProviderReadyState
      value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IExecutionProvider>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_ReadyState(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)this;
    check_hresult(
        _winrt_abi_type->get_ReadyState(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProvider<
    D>::Certification() const {
  winrt::Microsoft::Windows::AI::MachineLearning::ExecutionProviderCertification
      value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IExecutionProvider>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Certification(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)this;
    check_hresult(
        _winrt_abi_type->get_Certification(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProvider<
    D>::EnsureReadyAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IExecutionProvider>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)this;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::MachineLearning::
          ExecutionProviderReadyResult,
      double>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProvider<
    D>::TryRegister() const {
  bool result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IExecutionProvider>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->TryRegister(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProvider>**)this;
    check_hresult(_winrt_abi_type->TryRegister(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProviderCatalog<
    D>::FindAllProviders() const {
  uint32_t result_impl_size{};
  void** result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IExecutionProviderCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::AI::
                                     MachineLearning::IExecutionProviderCatalog,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalog>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->FindAllProviders(&result_impl_size, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalog>**)this;
    check_hresult(
        _winrt_abi_type->FindAllProviders(&result_impl_size, &result));
  }
  return com_array<
      winrt::Microsoft::Windows::AI::MachineLearning::ExecutionProvider>{
      result, result_impl_size, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProviderCatalog<
    D>::EnsureAndRegisterCertifiedAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IExecutionProviderCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::AI::
                                     MachineLearning::IExecutionProviderCatalog,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalog>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureAndRegisterCertifiedAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalog>**)this;
    check_hresult(_winrt_abi_type->EnsureAndRegisterCertifiedAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Windows::Foundation::Collections::IVector<
          winrt::Microsoft::Windows::AI::MachineLearning::ExecutionProvider>,
      double>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProviderCatalog<
    D>::RegisterCertifiedAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IExecutionProviderCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::AI::
                                     MachineLearning::IExecutionProviderCatalog,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalog>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RegisterCertifiedAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalog>**)this;
    check_hresult(_winrt_abi_type->RegisterCertifiedAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Windows::Foundation::Collections::IVector<
          winrt::Microsoft::Windows::AI::MachineLearning::ExecutionProvider>,
      double>{operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProviderCatalogStatics<
    D>::GetDefault() const {
  void* result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IExecutionProviderCatalogStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            IExecutionProviderCatalogStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalogStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderCatalogStatics>**)this;
    check_hresult(_winrt_abi_type->GetDefault(&result));
  }
  return winrt::Microsoft::Windows::AI::MachineLearning::
      ExecutionProviderCatalog{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProviderReadyResult<
    D>::Status() const {
  winrt::Microsoft::Windows::AI::MachineLearning::
      ExecutionProviderReadyResultState value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IExecutionProviderReadyResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            IExecutionProviderReadyResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderReadyResult>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderReadyResult>**)this;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProviderReadyResult<
    D>::ExtendedError() const {
  winrt::hresult value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IExecutionProviderReadyResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            IExecutionProviderReadyResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderReadyResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderReadyResult>**)this;
    check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IExecutionProviderReadyResult<
    D>::DiagnosticText() const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IExecutionProviderReadyResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            IExecutionProviderReadyResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderReadyResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DiagnosticText(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IExecutionProviderReadyResult>**)this;
    check_hresult(_winrt_abi_type->get_DiagnosticText(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalog<D>::Sources()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Sources(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)this;
    check_hresult(_winrt_abi_type->get_Sources(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalogSource>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalog<
    D>::ExecutionProviders() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExecutionProviders(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)this;
    check_hresult(_winrt_abi_type->get_ExecutionProviders(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalog<
    D>::GetAvailableModel(param::hstring const& idOrName) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetAvailableModel(*(void**)(&idOrName), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)this;
    check_hresult(
        _winrt_abi_type->GetAvailableModel(*(void**)(&idOrName), &result));
  }
  return winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalog<
    D>::GetAvailableModels() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetAvailableModels(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)this;
    check_hresult(_winrt_abi_type->GetAvailableModels(&result));
  }
  return winrt::Windows::Foundation::Collections::IVector<
      winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalog<
    D>::FindModelAsync(param::hstring const& idOrName) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->FindModelAsync(*(void**)(&idOrName), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)this;
    check_hresult(
        _winrt_abi_type->FindModelAsync(*(void**)(&idOrName), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalog<
    D>::FindAllModelsAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalog>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->FindAllModelsAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalog>**)this;
    check_hresult(_winrt_abi_type->FindAllModelsAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalogFactory<
    D>::CreateInstance(array_view<winrt::Microsoft::Windows::AI::
                                      MachineLearning::ModelCatalogSource const>
                           sources) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalogFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstance(sources.size(),
                                                  get_abi(sources), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstance(sources.size(),
                                                  get_abi(sources), &value));
  }
  return winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalog{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalogSource<D>::Id()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalogSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Id(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSource>**)this;
    check_hresult(_winrt_abi_type->get_Id(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalogSource<D>::Uri()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::
                                       MachineLearning::IModelCatalogSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Uri(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSource>**)this;
    check_hresult(_winrt_abi_type->get_Uri(&value));
  }
  return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalogSourceStatics<
    D>::CreateFromUriAsync(winrt::Windows::Foundation::Uri const& location)
    const {
  void* operation{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IModelCatalogSourceStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            IModelCatalogSourceStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSourceStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateFromUriAsync(*(void**)(&location), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSourceStatics>**)this;
    check_hresult(
        _winrt_abi_type->CreateFromUriAsync(*(void**)(&location), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalogSource>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_MachineLearning_IModelCatalogSourceStatics<
    D>::CreateFromUriAsync(winrt::Windows::Foundation::Uri const& location,
                           param::async_iterable<
                               winrt::Windows::Foundation::Collections::
                                   IKeyValuePair<hstring, hstring>> const&
                               additionalHeaders) const {
  void* operation{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::Windows::AI::MachineLearning::
                                    IModelCatalogSourceStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::MachineLearning::
            IModelCatalogSourceStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSourceStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateFromUriAsync2(
        *(void**)(&location), *(void**)(&additionalHeaders), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::MachineLearning::
                    IModelCatalogSourceStatics>**)this;
    check_hresult(_winrt_abi_type->CreateFromUriAsync2(
        *(void**)(&location), *(void**)(&additionalHeaders), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalogSource>{
      operation, take_ownership_from_abi};
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo>
    : produce_base<
          D,
          winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo> {
  int32_t __stdcall get_Id(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Id());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Name(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Name());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Publisher(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Publisher());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SourceId(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().SourceId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Uri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().Uri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExecutionProviders(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::Collections::IVectorView<hstring>>(
        this->shim().ExecutionProviders());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ModelSizeInBytes(uint64_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint64_t>(this->shim().ModelSizeInBytes());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Version(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Version());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_License(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().License());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LicenseUri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().LicenseUri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LicenseText(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().LicenseText());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetStatus(int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelStatus>(
        this->shim().GetStatus());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetInstanceAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::MachineLearning::
                CatalogModelInstanceResult,
            double>>(this->shim().GetInstanceAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetInstanceAsync2(void* additionalHeaders,
                                      void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::MachineLearning::
                CatalogModelInstanceResult,
            double>>(
            this->shim().GetInstanceAsync(
                *reinterpret_cast<
                    winrt::Windows::Foundation::Collections::IIterable<
                        winrt::Windows::Foundation::Collections::IKeyValuePair<
                            hstring, hstring>> const*>(&additionalHeaders)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInstance>
    : produce_base<D, winrt::Microsoft::Windows::AI::MachineLearning::
                          ICatalogModelInstance> {
  int32_t __stdcall get_ModelPaths(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Windows::Foundation::Collections::IVectorView<hstring>>(
        this->shim().ModelPaths());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ModelInfo(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>(
        this->shim().ModelInfo());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInstanceResult>
    : produce_base<D, winrt::Microsoft::Windows::AI::MachineLearning::
                          ICatalogModelInstanceResult> {
  int32_t __stdcall get_Status(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::AI::MachineLearning::
                             CatalogModelInstanceStatus>(this->shim().Status());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final
      try {
    zero_abi<winrt::hresult>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DiagnosticText(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().DiagnosticText());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetInstance(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInstance>(
        this->shim().GetInstance());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider>
    : produce_base<
          D,
          winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider> {
  int32_t __stdcall get_Name(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Name());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LibraryPath(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().LibraryPath());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageId(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::ApplicationModel::PackageId>(
        this->shim().PackageId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ReadyState(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::Windows::AI::MachineLearning::
                        ExecutionProviderReadyState>(this->shim().ReadyState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Certification(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::AI::MachineLearning::
                             ExecutionProviderCertification>(
        this->shim().Certification());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::MachineLearning::
                ExecutionProviderReadyResult,
            double>>(this->shim().EnsureReadyAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall TryRegister(bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().TryRegister());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProviderCatalog>
    : produce_base<D, winrt::Microsoft::Windows::AI::MachineLearning::
                          IExecutionProviderCatalog> {
  int32_t __stdcall FindAllProviders(uint32_t* __resultSize,
                                     void*** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    std::tie(*__resultSize, *result) =
        detach_abi(this->shim().FindAllProviders());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureAndRegisterCertifiedAsync(
      void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Windows::Foundation::Collections::IVector<
                winrt::Microsoft::Windows::AI::MachineLearning::
                    ExecutionProvider>,
            double>>(this->shim().EnsureAndRegisterCertifiedAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RegisterCertifiedAsync(void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Windows::Foundation::Collections::IVector<
                winrt::Microsoft::Windows::AI::MachineLearning::
                    ExecutionProvider>,
            double>>(this->shim().RegisterCertifiedAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::MachineLearning::
                      IExecutionProviderCatalogStatics>
    : produce_base<D, winrt::Microsoft::Windows::AI::MachineLearning::
                          IExecutionProviderCatalogStatics> {
  int32_t __stdcall GetDefault(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::AI::MachineLearning::
                        ExecutionProviderCatalog>(this->shim().GetDefault());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::MachineLearning::
                      IExecutionProviderReadyResult>
    : produce_base<D, winrt::Microsoft::Windows::AI::MachineLearning::
                          IExecutionProviderReadyResult> {
  int32_t __stdcall get_Status(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::AI::MachineLearning::
                             ExecutionProviderReadyResultState>(
        this->shim().Status());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final
      try {
    zero_abi<winrt::hresult>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DiagnosticText(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().DiagnosticText());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog>
    : produce_base<
          D, winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog> {
  int32_t __stdcall get_Sources(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalogSource>>(
        this->shim().Sources());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExecutionProviders(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().ExecutionProviders());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetAvailableModel(void* idOrName,
                                      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>(
        this->shim().GetAvailableModel(
            *reinterpret_cast<hstring const*>(&idOrName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetAvailableModels(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Foundation::Collections::IVector<
        winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>>(
        this->shim().GetAvailableModels());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall FindModelAsync(void* idOrName,
                                   void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>>(
        this->shim().FindModelAsync(
            *reinterpret_cast<hstring const*>(&idOrName)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall FindAllModelsAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Windows::Foundation::Collections::IVectorView<
            winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>>>(
        this->shim().FindAllModelsAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogFactory>
    : produce_base<D, winrt::Microsoft::Windows::AI::MachineLearning::
                          IModelCatalogFactory> {
  int32_t __stdcall CreateInstance(uint32_t __sourcesSize, void** sources,
                                   void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::AI::MachineLearning::
                             ModelCatalog>(this->shim().CreateInstance(
        array_view<winrt::Microsoft::Windows::AI::MachineLearning::
                       ModelCatalogSource const>(
            reinterpret_cast<winrt::Microsoft::Windows::AI::MachineLearning::
                                 ModelCatalogSource const*>(sources),
            reinterpret_cast<winrt::Microsoft::Windows::AI::MachineLearning::
                                 ModelCatalogSource const*>(sources) +
                __sourcesSize)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogSource>
    : produce_base<
          D,
          winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogSource> {
  int32_t __stdcall get_Id(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Id());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Uri(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().Uri());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogSourceStatics>
    : produce_base<D, winrt::Microsoft::Windows::AI::MachineLearning::
                          IModelCatalogSourceStatics> {
  int32_t __stdcall CreateFromUriAsync(void* location,
                                       void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalogSource>>(
        this->shim().CreateFromUriAsync(
            *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                &location)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateFromUriAsync2(void* location, void* additionalHeaders,
                                        void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalogSource>>(
        this->shim().CreateFromUriAsync(
            *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                &location),
            *reinterpret_cast<
                winrt::Windows::Foundation::Collections::IIterable<
                    winrt::Windows::Foundation::Collections::IKeyValuePair<
                        hstring, hstring>> const*>(&additionalHeaders)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::MachineLearning {
  inline auto ExecutionProviderCatalog::GetDefault() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::AI::MachineLearning::
            ExecutionProviderCatalog (*)(
                IExecutionProviderCatalogStatics const&),
        ExecutionProviderCatalog, IExecutionProviderCatalogStatics>(
        [](IExecutionProviderCatalogStatics const& f) {
          return f.GetDefault();
        });
  }
  inline ModelCatalog::ModelCatalog(
      array_view<winrt::Microsoft::Windows::AI::MachineLearning::
                     ModelCatalogSource const>
          sources)
      : ModelCatalog(impl::call_factory<ModelCatalog, IModelCatalogFactory>(
            [&](IModelCatalogFactory const& f) {
              return f.CreateInstance(sources);
            })) {}
  inline auto ModelCatalogSource::CreateFromUriAsync(
      winrt::Windows::Foundation::Uri const& location) {
    return impl::call_factory<ModelCatalogSource, IModelCatalogSourceStatics>(
        [&](IModelCatalogSourceStatics const& f) {
          return f.CreateFromUriAsync(location);
        });
  }
  inline auto ModelCatalogSource::CreateFromUriAsync(
      winrt::Windows::Foundation::Uri const& location,
      param::async_iterable<
          winrt::Windows::Foundation::Collections::IKeyValuePair<
              hstring, hstring>> const& additionalHeaders) {
    return impl::call_factory<ModelCatalogSource, IModelCatalogSourceStatics>(
        [&](IModelCatalogSourceStatics const& f) {
          return f.CreateFromUriAsync(location, additionalHeaders);
        });
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInfo>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInstance>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::ICatalogModelInstanceResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProvider>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::IExecutionProviderCatalog>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::
                IExecutionProviderCatalogStatics> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::
                IExecutionProviderReadyResult> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalog>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogSource>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::IModelCatalogSourceStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInfo>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInstance>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::CatalogModelInstanceResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::ExecutionProvider>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::MachineLearning::ExecutionProviderCatalog>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::
                ExecutionProviderReadyResult> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalog>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::MachineLearning::ModelCatalogSource>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
