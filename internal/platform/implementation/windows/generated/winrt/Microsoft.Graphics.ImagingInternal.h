// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_ImagingInternal_H
#define WINRT_Microsoft_Graphics_ImagingInternal_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Graphics.ImagingInternal.2.h"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IDepthMapCreatorSession<D>::
    CreateAsync(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            inputBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            inputBufferViewData,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            outputBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            outputBufferViewData) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IDepthMapCreatorSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IDepthMapCreatorSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateAsync(
        impl::bind_in(inputBufferView), impl::bind_in(inputBufferViewData),
        impl::bind_in(outputBufferView), impl::bind_in(outputBufferViewData),
        &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IDepthMapCreatorSession>**)this;
    check_hresult(_winrt_abi_type->CreateAsync(
        impl::bind_in(inputBufferView), impl::bind_in(inputBufferViewData),
        impl::bind_in(outputBufferView), impl::bind_in(outputBufferViewData),
        &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IDepthMapCreatorSession2<D>::
    Create(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
               inputImageBufferResource,
           winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
               outputImageBufferResource,
           uint32_t priority, uint32_t frequency) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IDepthMapCreatorSession2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IDepthMapCreatorSession2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(*(void**)(&inputImageBufferResource),
                                          *(void**)(&outputImageBufferResource),
                                          priority, frequency));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IDepthMapCreatorSession2>**)this;
    check_hresult(_winrt_abi_type->Create(*(void**)(&inputImageBufferResource),
                                          *(void**)(&outputImageBufferResource),
                                          priority, frequency));
  }
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IImageObjectExtractorSession<
    D>::InitializeWithImageBuffer(winrt::Microsoft::Windows::PrivateCommon::
                                      ImageBufferResource const&
                                          inputImageBufferResource,
                                  uint32_t priority, uint32_t frequency,
                                  array_view<float> encoding) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IImageObjectExtractorSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::
                                     IImageObjectExtractorSession,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageObjectExtractorSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->InitializeWithImageBuffer(
        *(void**)(&inputImageBufferResource), priority, frequency,
        encoding.size(), put_abi(encoding)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageObjectExtractorSession>**)this;
    check_hresult(_winrt_abi_type->InitializeWithImageBuffer(
        *(void**)(&inputImageBufferResource), priority, frequency,
        encoding.size(), put_abi(encoding)));
  }
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IImageObjectExtractorSession<
    D>::
    GetBackground(
        array_view<float const> encoding,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            outputImageBufferResource,
        array_view<winrt::Windows::Graphics::RectInt32 const> rects,
        array_view<winrt::Windows::Graphics::PointInt32 const> inclusionPoints,
        array_view<winrt::Windows::Graphics::PointInt32 const> exclusionPoints,
        uint32_t priority, uint32_t frequency) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IImageObjectExtractorSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::
                                     IImageObjectExtractorSession,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageObjectExtractorSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetBackground(
        encoding.size(), get_abi(encoding),
        *(void**)(&outputImageBufferResource), rects.size(), get_abi(rects),
        inclusionPoints.size(), get_abi(inclusionPoints),
        exclusionPoints.size(), get_abi(exclusionPoints), priority, frequency));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageObjectExtractorSession>**)this;
    check_hresult(_winrt_abi_type->GetBackground(
        encoding.size(), get_abi(encoding),
        *(void**)(&outputImageBufferResource), rects.size(), get_abi(rects),
        inclusionPoints.size(), get_abi(inclusionPoints),
        exclusionPoints.size(), get_abi(exclusionPoints), priority, frequency));
  }
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IImageObjectExtractorSession<
    D>::GetModelProperties() const {
  winrt::Microsoft::Graphics::ImagingInternal::ModelProperties result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IImageObjectExtractorSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::
                                     IImageObjectExtractorSession,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageObjectExtractorSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetModelProperties(put_abi(result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageObjectExtractorSession>**)this;
    check_hresult(_winrt_abi_type->GetModelProperties(put_abi(result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IImageScalerSession<D>::
    ScaleImage(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            inputImageBufferResource,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            outputImageBufferResource,
        int32_t width, int32_t height, uint32_t priority,
        uint32_t frequency) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IImageScalerSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageScalerSession>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->ScaleImage(*(void**)(&inputImageBufferResource),
                                    *(void**)(&outputImageBufferResource),
                                    width, height, priority, frequency));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageScalerSession>**)this;
    check_hresult(
        _winrt_abi_type->ScaleImage(*(void**)(&inputImageBufferResource),
                                    *(void**)(&outputImageBufferResource),
                                    width, height, priority, frequency));
  }
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IImageScalerSession<
    D>::MaxSupportedScaleFactor() const {
  int32_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IImageScalerSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageScalerSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->MaxSupportedScaleFactor(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageScalerSession>**)this;
    check_hresult(_winrt_abi_type->MaxSupportedScaleFactor(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IImageSegmenterSession<D>::
    RemoveBackground(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            inputImageBufferResource,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            outputImageBufferResource) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IImageSegmenterSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageSegmenterSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemoveBackground(
        *(void**)(&inputImageBufferResource),
        *(void**)(&outputImageBufferResource)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IImageSegmenterSession>**)this;
    check_hresult(_winrt_abi_type->RemoveBackground(
        *(void**)(&inputImageBufferResource),
        *(void**)(&outputImageBufferResource)));
  }
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IParallaxCreatorSession<D>::
    CreateParallaxImagesAsync(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            inputView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            inputViewData,
        param::async_vector_view<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const&
            outputViews,
        param::async_vector_view<winrt::Microsoft::Windows::PrivateCommon::
                                     ImageBufferViewData> const& outputViewData,
        winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const&
            options) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IParallaxCreatorSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IParallaxCreatorSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(
        impl::bind_in(inputView), impl::bind_in(inputViewData),
        *(void**)(&outputViews), *(void**)(&outputViewData),
        impl::bind_in(options), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IParallaxCreatorSession>**)this;
    check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(
        impl::bind_in(inputView), impl::bind_in(inputViewData),
        *(void**)(&outputViews), *(void**)(&outputViewData),
        impl::bind_in(options), &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IParallaxCreatorSession2<D>::
    CreateParallaxImagesAsync(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            inputView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            inputViewData,
        param::async_vector_view<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const&
            outputViews,
        param::async_vector_view<winrt::Microsoft::Windows::PrivateCommon::
                                     ImageBufferViewData> const& outputViewData,
        winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const&
            options,
        uint32_t priority, uint32_t frequency) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IParallaxCreatorSession2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IParallaxCreatorSession2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(
        impl::bind_in(inputView), impl::bind_in(inputViewData),
        *(void**)(&outputViews), *(void**)(&outputViewData),
        impl::bind_in(options), priority, frequency, &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IParallaxCreatorSession2>**)this;
    check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(
        impl::bind_in(inputView), impl::bind_in(inputViewData),
        *(void**)(&outputViews), *(void**)(&outputViewData),
        impl::bind_in(options), priority, frequency, &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_IParallaxCreatorSession3<D>::
    CreateParallaxImages(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            inputImageBufferResource,
        array_view<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const>
            outputImageBufferResources,
        winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const&
            options,
        uint32_t priority, uint32_t frequency) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       IParallaxCreatorSession3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IParallaxCreatorSession3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateParallaxImages(
        *(void**)(&inputImageBufferResource), outputImageBufferResources.size(),
        get_abi(outputImageBufferResources), impl::bind_in(options), priority,
        frequency));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    IParallaxCreatorSession3>**)this;
    check_hresult(_winrt_abi_type->CreateParallaxImages(
        *(void**)(&inputImageBufferResource), outputImageBufferResources.size(),
        get_abi(outputImageBufferResources), impl::bind_in(options), priority,
        frequency));
  }
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_ITrimapImageSegmenterSession<
    D>::
    RemoveBackgroundAsync(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            inputImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            inputImageBufferViewData,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            outputImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            outputImageBufferViewData,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            fgMaskImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            fgMaskImageBufferViewData,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            bgMaskImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            bgMaskImageBufferViewData) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       ITrimapImageSegmenterSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::
                                     ITrimapImageSegmenterSession,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    ITrimapImageSegmenterSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemoveBackgroundAsync(
        impl::bind_in(inputImageBufferView),
        impl::bind_in(inputImageBufferViewData),
        impl::bind_in(outputImageBufferView),
        impl::bind_in(outputImageBufferViewData),
        impl::bind_in(fgMaskImageBufferView),
        impl::bind_in(fgMaskImageBufferViewData),
        impl::bind_in(bgMaskImageBufferView),
        impl::bind_in(bgMaskImageBufferViewData), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    ITrimapImageSegmenterSession>**)this;
    check_hresult(_winrt_abi_type->RemoveBackgroundAsync(
        impl::bind_in(inputImageBufferView),
        impl::bind_in(inputImageBufferViewData),
        impl::bind_in(outputImageBufferView),
        impl::bind_in(outputImageBufferViewData),
        impl::bind_in(fgMaskImageBufferView),
        impl::bind_in(fgMaskImageBufferViewData),
        impl::bind_in(bgMaskImageBufferView),
        impl::bind_in(bgMaskImageBufferViewData), &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_ITrimapImageSegmenterSession2<
    D>::
    RemoveBackgroundAsync(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            inputImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            inputImageBufferViewData,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            outputImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            outputImageBufferViewData,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            fgMaskImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            fgMaskImageBufferViewData,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const&
            bgMaskImageBufferView,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const&
            bgMaskImageBufferViewData,
        uint32_t priority, uint32_t frequency) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       ITrimapImageSegmenterSession2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::
                                     ITrimapImageSegmenterSession2,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    ITrimapImageSegmenterSession2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemoveBackgroundAsync(
        impl::bind_in(inputImageBufferView),
        impl::bind_in(inputImageBufferViewData),
        impl::bind_in(outputImageBufferView),
        impl::bind_in(outputImageBufferViewData),
        impl::bind_in(fgMaskImageBufferView),
        impl::bind_in(fgMaskImageBufferViewData),
        impl::bind_in(bgMaskImageBufferView),
        impl::bind_in(bgMaskImageBufferViewData), priority, frequency,
        &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    ITrimapImageSegmenterSession2>**)this;
    check_hresult(_winrt_abi_type->RemoveBackgroundAsync(
        impl::bind_in(inputImageBufferView),
        impl::bind_in(inputImageBufferViewData),
        impl::bind_in(outputImageBufferView),
        impl::bind_in(outputImageBufferViewData),
        impl::bind_in(fgMaskImageBufferView),
        impl::bind_in(fgMaskImageBufferViewData),
        impl::bind_in(bgMaskImageBufferView),
        impl::bind_in(bgMaskImageBufferViewData), priority, frequency,
        &operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_ImagingInternal_ITrimapImageSegmenterSession3<
    D>::
    RemoveBackground(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            inputImageBufferResource,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            outputImageBufferResource,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            fgMaskImageBufferResource,
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const&
            bgMaskImageBufferResource,
        uint32_t priority, uint32_t frequency) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::
                                       ITrimapImageSegmenterSession3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::
                                     ITrimapImageSegmenterSession3,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    ITrimapImageSegmenterSession3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemoveBackground(
        *(void**)(&inputImageBufferResource),
        *(void**)(&outputImageBufferResource),
        *(void**)(&fgMaskImageBufferResource),
        *(void**)(&bgMaskImageBufferResource), priority, frequency));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::
                    ITrimapImageSegmenterSession3>**)this;
    check_hresult(_winrt_abi_type->RemoveBackground(
        *(void**)(&inputImageBufferResource),
        *(void**)(&outputImageBufferResource),
        *(void**)(&fgMaskImageBufferResource),
        *(void**)(&bgMaskImageBufferResource), priority, frequency));
  }
}
template <typename D>
struct produce<
    D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          IDepthMapCreatorSession> {
  int32_t __stdcall CreateAsync(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          inputBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          inputBufferViewData,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          outputBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          outputBufferViewData,
      void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<
        winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateAsync(
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &inputBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(&inputBufferViewData),
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &outputBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &outputBufferViewData)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          IDepthMapCreatorSession2> {
  int32_t __stdcall Create(void* inputImageBufferResource,
                           void* outputImageBufferResource, uint32_t priority,
                           uint32_t frequency) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Create(
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &inputImageBufferResource),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &outputImageBufferResource),
        priority, frequency);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          IImageObjectExtractorSession> {
  int32_t __stdcall InitializeWithImageBuffer(
      void* inputImageBufferResource, uint32_t priority, uint32_t frequency,
      uint32_t __encodingSize, float* encoding) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().InitializeWithImageBuffer(
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &inputImageBufferResource),
        priority, frequency,
        array_view<float>(reinterpret_cast<float*>(encoding),
                          reinterpret_cast<float*>(encoding) + __encodingSize));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetBackground(
      uint32_t __encodingSize, float* encoding, void* outputImageBufferResource,
      uint32_t __rectsSize, struct struct_Windows_Graphics_RectInt32* rects,
      uint32_t __inclusionPointsSize,
      struct struct_Windows_Graphics_PointInt32* inclusionPoints,
      uint32_t __exclusionPointsSize,
      struct struct_Windows_Graphics_PointInt32* exclusionPoints,
      uint32_t priority, uint32_t frequency) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().GetBackground(
        array_view<float const>(
            reinterpret_cast<float const*>(encoding),
            reinterpret_cast<float const*>(encoding) + __encodingSize),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &outputImageBufferResource),
        array_view<winrt::Windows::Graphics::RectInt32 const>(
            reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(rects),
            reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(
                rects) +
                __rectsSize),
        array_view<winrt::Windows::Graphics::PointInt32 const>(
            reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(
                inclusionPoints),
            reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(
                inclusionPoints) +
                __inclusionPointsSize),
        array_view<winrt::Windows::Graphics::PointInt32 const>(
            reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(
                exclusionPoints),
            reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(
                exclusionPoints) +
                __exclusionPointsSize),
        priority, frequency);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetModelProperties(
      struct struct_Microsoft_Graphics_ImagingInternal_ModelProperties*
          result) noexcept final try {
    zero_abi<winrt::Microsoft::Graphics::ImagingInternal::ModelProperties>(
        result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Graphics::ImagingInternal::ModelProperties>(
        this->shim().GetModelProperties());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<D,
               winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>
    : produce_base<
          D, winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession> {
  int32_t __stdcall ScaleImage(void* inputImageBufferResource,
                               void* outputImageBufferResource, int32_t width,
                               int32_t height, uint32_t priority,
                               uint32_t frequency) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ScaleImage(
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &inputImageBufferResource),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &outputImageBufferResource),
        width, height, priority, frequency);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall MaxSupportedScaleFactor(int32_t* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<int32_t>(this->shim().MaxSupportedScaleFactor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D, winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession>
    : produce_base<
          D,
          winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession> {
  int32_t __stdcall RemoveBackground(
      void* inputImageBufferResource,
      void* outputImageBufferResource) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().RemoveBackground(
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &inputImageBufferResource),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &outputImageBufferResource));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          IParallaxCreatorSession> {
  int32_t __stdcall CreateParallaxImagesAsync(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          inputViewData,
      void* outputViews, void* outputViewData,
      struct struct_Microsoft_Graphics_ImagingInternal_ParallaxImageOptions
          options,
      void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<
        winrt::Windows::Foundation::
            IAsyncAction>(this->shim().CreateParallaxImagesAsync(
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &inputView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(&inputViewData),
        *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const*>(
            &outputViews),
        *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<
            winrt::Microsoft::Windows::PrivateCommon::
                ImageBufferViewData> const*>(&outputViewData),
        *reinterpret_cast<winrt::Microsoft::Graphics::ImagingInternal::
                              ParallaxImageOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          IParallaxCreatorSession2> {
  int32_t __stdcall CreateParallaxImagesAsync(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          inputViewData,
      void* outputViews, void* outputViewData,
      struct struct_Microsoft_Graphics_ImagingInternal_ParallaxImageOptions
          options,
      uint32_t priority, uint32_t frequency, void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<
        winrt::Windows::Foundation::
            IAsyncAction>(this->shim().CreateParallaxImagesAsync(
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &inputView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(&inputViewData),
        *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const*>(
            &outputViews),
        *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<
            winrt::Microsoft::Windows::PrivateCommon::
                ImageBufferViewData> const*>(&outputViewData),
        *reinterpret_cast<winrt::Microsoft::Graphics::ImagingInternal::
                              ParallaxImageOptions const*>(&options),
        priority, frequency));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          IParallaxCreatorSession3> {
  int32_t __stdcall CreateParallaxImages(
      void* inputImageBufferResource, uint32_t __outputImageBufferResourcesSize,
      void** outputImageBufferResources,
      struct struct_Microsoft_Graphics_ImagingInternal_ParallaxImageOptions
          options,
      uint32_t priority, uint32_t frequency) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CreateParallaxImages(
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &inputImageBufferResource),
        array_view<winrt::Microsoft::Windows::PrivateCommon::
                       ImageBufferResource const>(
            reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                                 ImageBufferResource const*>(
                outputImageBufferResources),
            reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                                 ImageBufferResource const*>(
                outputImageBufferResources) +
                __outputImageBufferResourcesSize),
        *reinterpret_cast<winrt::Microsoft::Graphics::ImagingInternal::
                              ParallaxImageOptions const*>(&options),
        priority, frequency);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          ITrimapImageSegmenterSession> {
  int32_t __stdcall RemoveBackgroundAsync(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          inputImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          inputImageBufferViewData,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          outputImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          outputImageBufferViewData,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          fgMaskImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          fgMaskImageBufferViewData,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          bgMaskImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          bgMaskImageBufferViewData,
      void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<
        winrt::Windows::Foundation::
            IAsyncAction>(this->shim().RemoveBackgroundAsync(
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &inputImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &inputImageBufferViewData),
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &outputImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &outputImageBufferViewData),
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &fgMaskImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &fgMaskImageBufferViewData),
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &bgMaskImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &bgMaskImageBufferViewData)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          ITrimapImageSegmenterSession2> {
  int32_t __stdcall RemoveBackgroundAsync(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          inputImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          inputImageBufferViewData,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          outputImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          outputImageBufferViewData,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          fgMaskImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          fgMaskImageBufferViewData,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView
          bgMaskImageBufferView,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData
          bgMaskImageBufferViewData,
      uint32_t priority, uint32_t frequency, void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<
        winrt::Windows::Foundation::
            IAsyncAction>(this->shim().RemoveBackgroundAsync(
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &inputImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &inputImageBufferViewData),
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &outputImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &outputImageBufferViewData),
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &fgMaskImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &fgMaskImageBufferViewData),
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(
            &bgMaskImageBufferView),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferViewData const*>(
            &bgMaskImageBufferViewData),
        priority, frequency));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3>
    : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::
                          ITrimapImageSegmenterSession3> {
  int32_t __stdcall RemoveBackground(void* inputImageBufferResource,
                                     void* outputImageBufferResource,
                                     void* fgMaskImageBufferResource,
                                     void* bgMaskImageBufferResource,
                                     uint32_t priority,
                                     uint32_t frequency) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().RemoveBackground(
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &inputImageBufferResource),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &outputImageBufferResource),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &fgMaskImageBufferResource),
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &bgMaskImageBufferResource),
        priority, frequency);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Graphics::ImagingInternal {}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
