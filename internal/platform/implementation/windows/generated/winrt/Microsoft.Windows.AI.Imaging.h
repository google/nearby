// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_Imaging_H
#define WINRT_Microsoft_Windows_AI_Imaging_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.h"
#include "winrt/impl/Microsoft.Graphics.Imaging.2.h"
#include "winrt/impl/Microsoft.Windows.AI.2.h"
#include "winrt/impl/Microsoft.Windows.AI.ContentSafety.2.h"
#include "winrt/impl/Microsoft.Windows.AI.Imaging.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGenerator<D>::
    DescribeAsync(
        winrt::Microsoft::Graphics::Imaging::ImageBuffer const& image,
        winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionKind const&
            kind,
        winrt::Microsoft::Windows::AI::ContentSafety::
            ContentFilterOptions const& contentFilterOptions) const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageDescriptionGenerator>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGenerator>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->DescribeAsync(
        *(void**)(&image), static_cast<int32_t>(kind),
        *(void**)(&contentFilterOptions), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGenerator>**)this;
    check_hresult(_winrt_abi_type->DescribeAsync(
        *(void**)(&image), static_cast<int32_t>(kind),
        *(void**)(&contentFilterOptions), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult, hstring>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<
    D>::GetReadyState() const {
  winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageDescriptionGeneratorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::
                                     IImageDescriptionGeneratorStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGeneratorStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<
    D>::EnsureReadyAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageDescriptionGeneratorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::
                                     IImageDescriptionGeneratorStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGeneratorStatics>**)this;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<
    D>::CreateAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageDescriptionGeneratorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::
                                     IImageDescriptionGeneratorStatics,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionGeneratorStatics>**)this;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionResult<
    D>::Description() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageDescriptionResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Description(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionResult>**)this;
    check_hresult(_winrt_abi_type->get_Description(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionResult<D>::Status()
    const {
  winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResultStatus value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageDescriptionResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionResult>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageDescriptionResult>**)this;
    check_hresult(
        _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractor<D>::
    GetSoftwareBitmapObjectMask(
        winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const&
            hint) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractor>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetSoftwareBitmapObjectMask(*(void**)(&hint),
                                                               &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractor>**)this;
    check_hresult(_winrt_abi_type->GetSoftwareBitmapObjectMask(*(void**)(&hint),
                                                               &result));
  }
  return winrt::Windows::Graphics::Imaging::SoftwareBitmap{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractor<D>::
    GetImageBufferObjectMask(
        winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const&
            hint) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractor>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractor>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetImageBufferObjectMask(*(void**)(&hint), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractor>**)this;
    check_hresult(
        _winrt_abi_type->GetImageBufferObjectMask(*(void**)(&hint), &result));
  }
  return winrt::Microsoft::Graphics::Imaging::ImageBuffer{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<
    D>::IncludeRects() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorHint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IncludeRects(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHint>**)this;
    check_hresult(_winrt_abi_type->get_IncludeRects(&value));
  }
  return winrt::Windows::Foundation::Collections::IVectorView<
      winrt::Windows::Graphics::RectInt32>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<
    D>::IncludePoints() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorHint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_IncludePoints(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHint>**)this;
    check_hresult(_winrt_abi_type->get_IncludePoints(&value));
  }
  return winrt::Windows::Foundation::Collections::IVectorView<
      winrt::Windows::Graphics::PointInt32>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<
    D>::ExcludePoints() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorHint>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHint>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ExcludePoints(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHint>**)this;
    check_hresult(_winrt_abi_type->get_ExcludePoints(&value));
  }
  return winrt::Windows::Foundation::Collections::IVectorView<
      winrt::Windows::Graphics::PointInt32>{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHintFactory<D>::
    CreateInstance(
        param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects,
        param::vector<winrt::Windows::Graphics::PointInt32> const&
            includePoints,
        param::vector<winrt::Windows::Graphics::PointInt32> const&
            excludePoints) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorHintFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::
                                     IImageObjectExtractorHintFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHintFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstance(
        *(void**)(&includeRects), *(void**)(&includePoints),
        *(void**)(&excludePoints), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorHintFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstance(
        *(void**)(&includeRects), *(void**)(&includePoints),
        *(void**)(&excludePoints), &value));
  }
  return winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::
    CreateWithSoftwareBitmapAsync(
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
        const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWithSoftwareBitmapAsync(
        *(void**)(&softwareBitmap), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)this;
    check_hresult(_winrt_abi_type->CreateWithSoftwareBitmapAsync(
        *(void**)(&softwareBitmap), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::
    CreateWithImageBufferAsync(
        winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer)
        const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateWithImageBufferAsync(
        *(void**)(&imageBuffer), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)this;
    check_hresult(_winrt_abi_type->CreateWithImageBufferAsync(
        *(void**)(&imageBuffer), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<
    D>::GetReadyState() const {
  winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<
    D>::EnsureReadyAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectExtractorStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectExtractorStatics>**)this;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemover<D>::
    RemoveFromSoftwareBitmap(
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap,
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const&
            softwareBitmapMask) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectRemover>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemover>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemoveFromSoftwareBitmap(
        *(void**)(&softwareBitmap), *(void**)(&softwareBitmapMask), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>**)this;
    check_hresult(_winrt_abi_type->RemoveFromSoftwareBitmap(
        *(void**)(&softwareBitmap), *(void**)(&softwareBitmapMask), &result));
  }
  return winrt::Windows::Graphics::Imaging::SoftwareBitmap{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemover<D>::
    RemoveFromImageBuffer(
        winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer,
        winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBufferMask)
        const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectRemover>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemover>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RemoveFromImageBuffer(
        *(void**)(&imageBuffer), *(void**)(&imageBufferMask), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>**)this;
    check_hresult(_winrt_abi_type->RemoveFromImageBuffer(
        *(void**)(&imageBuffer), *(void**)(&imageBufferMask), &result));
  }
  return winrt::Microsoft::Graphics::Imaging::ImageBuffer{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemoverStatics<
    D>::GetReadyState() const {
  winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectRemoverStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemoverStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemoverStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemoverStatics<
    D>::EnsureReadyAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectRemoverStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemoverStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemoverStatics>**)this;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemoverStatics<
    D>::CreateAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageObjectRemoverStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemoverStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageObjectRemoverStatics>**)this;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::ScaleSoftwareBitmap(
    winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap,
    int32_t width, int32_t height) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageScaler>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ScaleSoftwareBitmap(
        *(void**)(&softwareBitmap), width, height, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
    check_hresult(_winrt_abi_type->ScaleSoftwareBitmap(
        *(void**)(&softwareBitmap), width, height, &result));
  }
  return winrt::Windows::Graphics::Imaging::SoftwareBitmap{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::ScaleImageBuffer(
    winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer,
    int32_t width, int32_t height) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageScaler>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ScaleImageBuffer(*(void**)(&imageBuffer),
                                                    width, height, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
    check_hresult(_winrt_abi_type->ScaleImageBuffer(*(void**)(&imageBuffer),
                                                    width, height, &result));
  }
  return winrt::Microsoft::Graphics::Imaging::ImageBuffer{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<
    D>::MaxSupportedScaleFactor() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageScaler>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MaxSupportedScaleFactor(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
    check_hresult(_winrt_abi_type->get_MaxSupportedScaleFactor(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<
    D>::GetReadyState() const {
  winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageScalerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageScalerStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<
    D>::EnsureReadyAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageScalerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageScalerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<D>::CreateAsync()
    const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       IImageScalerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IImageScalerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::Imaging::ImageScaler>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Text() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedLine>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Text(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
    check_hresult(_winrt_abi_type->get_Text(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::BoundingBox()
    const {
  winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedLine>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
    check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Words() const {
  uint32_t value_impl_size{};
  void** value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedLine>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Words(&value_impl_size, &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
    check_hresult(_winrt_abi_type->get_Words(&value_impl_size, &value));
  }
  return com_array<winrt::Microsoft::Windows::AI::Imaging::RecognizedWord>{
      value, value_impl_size, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Style() const {
  winrt::Microsoft::Windows::AI::Imaging::RecognizedLineStyle value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedLine>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
    check_hresult(
        _winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<
    D>::LineStyleConfidence() const {
  float value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedLine>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LineStyleConfidence(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
    check_hresult(_winrt_abi_type->get_LineStyleConfidence(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedText<D>::Lines() const {
  uint32_t value_impl_size{};
  void** value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedText, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedText>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Lines(&value_impl_size, &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)this;
    check_hresult(_winrt_abi_type->get_Lines(&value_impl_size, &value));
  }
  return com_array<winrt::Microsoft::Windows::AI::Imaging::RecognizedLine>{
      value, value_impl_size, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedText<D>::TextAngle()
    const {
  float value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedText, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedText>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_TextAngle(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)this;
    check_hresult(_winrt_abi_type->get_TextAngle(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::Text() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedWord>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Text(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
    check_hresult(_winrt_abi_type->get_Text(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::BoundingBox()
    const {
  winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedWord>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
    check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::MatchConfidence()
    const {
  float value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    IRecognizedWord>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_MatchConfidence(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
    check_hresult(_winrt_abi_type->get_MatchConfidence(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer<D>::
    RecognizeTextFromImageAsync(
        winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer)
        const {
  void* operation{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(
        *(void**)(&imageBuffer), &operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)this;
    check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(
        *(void**)(&imageBuffer), &operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::Imaging::RecognizedText>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer<D>::
    RecognizeTextFromImage(
        winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer)
        const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RecognizeTextFromImage(
        *(void**)(&imageBuffer), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)this;
    check_hresult(_winrt_abi_type->RecognizeTextFromImage(
        *(void**)(&imageBuffer), &result));
  }
  return winrt::Microsoft::Windows::AI::Imaging::RecognizedText{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<
    D>::GetReadyState() const {
  winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       ITextRecognizerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizerStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizerStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<
    D>::EnsureReadyAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       ITextRecognizerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizerStatics>**)this;
    check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperationWithProgress<
      winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<
    D>::CreateAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::
                                       ITextRecognizerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::Imaging::
                    ITextRecognizerStatics>**)this;
    check_hresult(_winrt_abi_type->CreateAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>{
      operation, take_ownership_from_abi};
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>
    : produce_base<
          D,
          winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator> {
  int32_t __stdcall DescribeAsync(void* image, int32_t kind,
                                  void* contentFilterOptions,
                                  void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult,
            hstring>>(
            this->shim().DescribeAsync(
                *reinterpret_cast<
                    winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(
                    &image),
                *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::
                                      ImageDescriptionKind const*>(&kind),
                *reinterpret_cast<winrt::Microsoft::Windows::AI::ContentSafety::
                                      ContentFilterOptions const*>(
                    &contentFilterOptions)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D,
    winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::
                          IImageDescriptionGeneratorStatics> {
  int32_t __stdcall GetReadyState(int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(
        this->shim().GetReadyState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(
            this->shim().EnsureReadyAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>>(
        this->shim().CreateAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>
    : produce_base<
          D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult> {
  int32_t __stdcall get_Description(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Description());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Status(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResultStatus>(
        this->shim().Status());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>
    : produce_base<
          D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor> {
  int32_t __stdcall GetSoftwareBitmapObjectMask(void* hint,
                                                void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(
        this->shim().GetSoftwareBitmapObjectMask(
            *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::
                                  ImageObjectExtractorHint const*>(&hint)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetImageBufferObjectMask(void* hint,
                                             void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(
        this->shim().GetImageBufferObjectMask(
            *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::
                                  ImageObjectExtractorHint const*>(&hint)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>
    : produce_base<
          D,
          winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint> {
  int32_t __stdcall get_IncludeRects(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<
        winrt::Windows::Graphics::RectInt32>>(this->shim().IncludeRects());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_IncludePoints(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<
        winrt::Windows::Graphics::PointInt32>>(this->shim().IncludePoints());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_ExcludePoints(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<
        winrt::Windows::Graphics::PointInt32>>(this->shim().ExcludePoints());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::
                          IImageObjectExtractorHintFactory> {
  int32_t __stdcall CreateInstance(void* includeRects, void* includePoints,
                                   void* excludePoints,
                                   void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint>(
        this->shim().CreateInstance(
            *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<
                winrt::Windows::Graphics::RectInt32> const*>(&includeRects),
            *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<
                winrt::Windows::Graphics::PointInt32> const*>(&includePoints),
            *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<
                winrt::Windows::Graphics::PointInt32> const*>(&excludePoints)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::
                          IImageObjectExtractorStatics> {
  int32_t __stdcall CreateWithSoftwareBitmapAsync(
      void* softwareBitmap, void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>>(
        this->shim().CreateWithSoftwareBitmapAsync(
            *reinterpret_cast<
                winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(
                &softwareBitmap)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateWithImageBufferAsync(void* imageBuffer,
                                               void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>>(
        this->shim().CreateWithImageBufferAsync(
            *reinterpret_cast<
                winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(
                &imageBuffer)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetReadyState(int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(
        this->shim().GetReadyState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(
            this->shim().EnsureReadyAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>
    : produce_base<
          D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover> {
  int32_t __stdcall RemoveFromSoftwareBitmap(void* softwareBitmap,
                                             void* softwareBitmapMask,
                                             void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(
        this->shim().RemoveFromSoftwareBitmap(
            *reinterpret_cast<
                winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(
                &softwareBitmap),
            *reinterpret_cast<
                winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(
                &softwareBitmapMask)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RemoveFromImageBuffer(void* imageBuffer,
                                          void* imageBufferMask,
                                          void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(
        this->shim().RemoveFromImageBuffer(
            *reinterpret_cast<
                winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(
                &imageBuffer),
            *reinterpret_cast<
                winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(
                &imageBufferMask)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>
    : produce_base<
          D,
          winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics> {
  int32_t __stdcall GetReadyState(int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(
        this->shim().GetReadyState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(
            this->shim().EnsureReadyAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover>>(
        this->shim().CreateAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler> {
  int32_t __stdcall ScaleSoftwareBitmap(void* softwareBitmap, int32_t width,
                                        int32_t height,
                                        void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(
        this->shim().ScaleSoftwareBitmap(
            *reinterpret_cast<
                winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(
                &softwareBitmap),
            width, height));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall ScaleImageBuffer(void* imageBuffer, int32_t width,
                                     int32_t height,
                                     void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(
        this->shim().ScaleImageBuffer(
            *reinterpret_cast<
                winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(
                &imageBuffer),
            width, height));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MaxSupportedScaleFactor(int32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().MaxSupportedScaleFactor());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>
    : produce_base<
          D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics> {
  int32_t __stdcall GetReadyState(int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(
        this->shim().GetReadyState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(
            this->shim().EnsureReadyAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::Imaging::ImageScaler>>(
        this->shim().CreateAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine> {
  int32_t __stdcall get_Text(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Text());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_BoundingBox(
      struct struct_Microsoft_Windows_AI_Imaging_RecognizedTextBoundingBox*
          value) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(
        value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(
        this->shim().BoundingBox());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Words(uint32_t* __valueSize,
                              void*** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    std::tie(*__valueSize, *value) = detach_abi(this->shim().Words());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_Style(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::AI::Imaging::RecognizedLineStyle>(
        this->shim().Style());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LineStyleConfidence(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().LineStyleConfidence());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText> {
  int32_t __stdcall get_Lines(uint32_t* __valueSize,
                              void*** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    std::tie(*__valueSize, *value) = detach_abi(this->shim().Lines());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_TextAngle(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().TextAngle());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord> {
  int32_t __stdcall get_Text(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Text());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_BoundingBox(
      struct struct_Microsoft_Windows_AI_Imaging_RecognizedTextBoundingBox*
          value) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(
        value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(
        this->shim().BoundingBox());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_MatchConfidence(float* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<float>(this->shim().MatchConfidence());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>
    : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer> {
  int32_t __stdcall RecognizeTextFromImageAsync(void* imageBuffer,
                                                void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::Imaging::RecognizedText>>(
        this->shim().RecognizeTextFromImageAsync(
            *reinterpret_cast<
                winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(
                &imageBuffer)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RecognizeTextFromImage(void* imageBuffer,
                                           void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>(
            this->shim().RecognizeTextFromImage(
                *reinterpret_cast<
                    winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(
                    &imageBuffer)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>
    : produce_base<
          D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics> {
  int32_t __stdcall GetReadyState(int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(
        this->shim().GetReadyState());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation =
        detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(
            this->shim().EnsureReadyAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>>(
        this->shim().CreateAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::Imaging {
  inline auto ImageDescriptionGenerator::GetReadyState() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::AI::AIFeatureReadyState (*)(
            IImageDescriptionGeneratorStatics const&),
        ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>(
        [](IImageDescriptionGeneratorStatics const& f) {
          return f.GetReadyState();
        });
  }
  inline auto ImageDescriptionGenerator::EnsureReadyAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double> (*)(
            IImageDescriptionGeneratorStatics const&),
        ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>(
        [](IImageDescriptionGeneratorStatics const& f) {
          return f.EnsureReadyAsync();
        });
  }
  inline auto ImageDescriptionGenerator::CreateAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperation<
            winrt::Microsoft::Windows::AI::Imaging::
                ImageDescriptionGenerator> (*)(
            IImageDescriptionGeneratorStatics const&),
        ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>(
        [](IImageDescriptionGeneratorStatics const& f) {
          return f.CreateAsync();
        });
  }
  inline auto ImageObjectExtractor::CreateWithSoftwareBitmapAsync(
      winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) {
    return impl::call_factory<ImageObjectExtractor,
                              IImageObjectExtractorStatics>(
        [&](IImageObjectExtractorStatics const& f) {
          return f.CreateWithSoftwareBitmapAsync(softwareBitmap);
        });
  }
  inline auto ImageObjectExtractor::CreateWithImageBufferAsync(
      winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) {
    return impl::call_factory<ImageObjectExtractor,
                              IImageObjectExtractorStatics>(
        [&](IImageObjectExtractorStatics const& f) {
          return f.CreateWithImageBufferAsync(imageBuffer);
        });
  }
  inline auto ImageObjectExtractor::GetReadyState() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::AI::AIFeatureReadyState (*)(
            IImageObjectExtractorStatics const&),
        ImageObjectExtractor, IImageObjectExtractorStatics>(
        [](IImageObjectExtractorStatics const& f) {
          return f.GetReadyState();
        });
  }
  inline auto ImageObjectExtractor::EnsureReadyAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double> (*)(
            IImageObjectExtractorStatics const&),
        ImageObjectExtractor, IImageObjectExtractorStatics>(
        [](IImageObjectExtractorStatics const& f) {
          return f.EnsureReadyAsync();
        });
  }
  inline ImageObjectExtractorHint::ImageObjectExtractorHint(
      param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects,
      param::vector<winrt::Windows::Graphics::PointInt32> const& includePoints,
      param::vector<winrt::Windows::Graphics::PointInt32> const& excludePoints)
      : ImageObjectExtractorHint(
            impl::call_factory<ImageObjectExtractorHint,
                               IImageObjectExtractorHintFactory>(
                [&](IImageObjectExtractorHintFactory const& f) {
                  return f.CreateInstance(includeRects, includePoints,
                                          excludePoints);
                })) {}
  inline auto ImageObjectRemover::GetReadyState() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::AI::AIFeatureReadyState (*)(
            IImageObjectRemoverStatics const&),
        ImageObjectRemover, IImageObjectRemoverStatics>(
        [](IImageObjectRemoverStatics const& f) { return f.GetReadyState(); });
  }
  inline auto ImageObjectRemover::EnsureReadyAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double> (*)(
            IImageObjectRemoverStatics const&),
        ImageObjectRemover, IImageObjectRemoverStatics>(
        [](IImageObjectRemoverStatics const& f) {
          return f.EnsureReadyAsync();
        });
  }
  inline auto ImageObjectRemover::CreateAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperation<
            winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover> (*)(
            IImageObjectRemoverStatics const&),
        ImageObjectRemover, IImageObjectRemoverStatics>(
        [](IImageObjectRemoverStatics const& f) { return f.CreateAsync(); });
  }
  inline auto ImageScaler::GetReadyState() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::AI::AIFeatureReadyState (*)(
            IImageScalerStatics const&),
        ImageScaler, IImageScalerStatics>(
        [](IImageScalerStatics const& f) { return f.GetReadyState(); });
  }
  inline auto ImageScaler::EnsureReadyAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double> (*)(
            IImageScalerStatics const&),
        ImageScaler, IImageScalerStatics>(
        [](IImageScalerStatics const& f) { return f.EnsureReadyAsync(); });
  }
  inline auto ImageScaler::CreateAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperation<
            winrt::Microsoft::Windows::AI::Imaging::ImageScaler> (*)(
            IImageScalerStatics const&),
        ImageScaler, IImageScalerStatics>(
        [](IImageScalerStatics const& f) { return f.CreateAsync(); });
  }
  inline auto TextRecognizer::GetReadyState() {
    return impl::call_factory_cast<
        winrt::Microsoft::Windows::AI::AIFeatureReadyState (*)(
            ITextRecognizerStatics const&),
        TextRecognizer, ITextRecognizerStatics>(
        [](ITextRecognizerStatics const& f) { return f.GetReadyState(); });
  }
  inline auto TextRecognizer::EnsureReadyAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperationWithProgress<
            winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double> (*)(
            ITextRecognizerStatics const&),
        TextRecognizer, ITextRecognizerStatics>(
        [](ITextRecognizerStatics const& f) { return f.EnsureReadyAsync(); });
  }
  inline auto TextRecognizer::CreateAsync() {
    return impl::call_factory_cast<
        winrt::Windows::Foundation::IAsyncOperation<
            winrt::Microsoft::Windows::AI::Imaging::TextRecognizer> (*)(
            ITextRecognizerStatics const&),
        TextRecognizer, ITextRecognizerStatics>(
        [](ITextRecognizerStatics const& f) { return f.CreateAsync(); });
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageScaler>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedLine>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedWord>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
