// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_Imaging_H
#define WINRT_Microsoft_Graphics_Imaging_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Graphics.Imaging.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::Buffer() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBuffer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Buffer(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
    check_hresult(_winrt_abi_type->get_Buffer(&value));
  }
  return winrt::Windows::Storage::Streams::IBuffer{value,
                                                   take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::PixelFormat() const {
  winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBuffer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_PixelFormat(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
    check_hresult(
        _winrt_abi_type->get_PixelFormat(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::PixelHeight() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBuffer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PixelHeight(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
    check_hresult(_winrt_abi_type->get_PixelHeight(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::PixelWidth() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBuffer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PixelWidth(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
    check_hresult(_winrt_abi_type->get_PixelWidth(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::RowStride() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBuffer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_RowStride(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
    check_hresult(_winrt_abi_type->get_RowStride(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::CopyToByteArray(
    array_view<uint8_t> values) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBuffer>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CopyToByteArray(values.size(), put_abi(values)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
    check_hresult(
        _winrt_abi_type->CopyToByteArray(values.size(), put_abi(values)));
  }
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::CopyToSoftwareBitmap()
    const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBuffer>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CopyToSoftwareBitmap(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
    check_hresult(_winrt_abi_type->CopyToSoftwareBitmap(&result));
  }
  return winrt::Windows::Graphics::Imaging::SoftwareBitmap{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics<D>::CreateForBuffer(
    winrt::Windows::Storage::Streams::IBuffer const& buffer,
    winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat const&
        pixelFormat,
    int32_t width, int32_t height, int32_t rowStride) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBufferStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBufferStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateForBuffer(
        *(void**)(&buffer), static_cast<int32_t>(pixelFormat), width, height,
        rowStride, &result));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>**)this;
    check_hresult(_winrt_abi_type->CreateForBuffer(
        *(void**)(&buffer), static_cast<int32_t>(pixelFormat), width, height,
        rowStride, &result));
  }
  return winrt::Microsoft::Graphics::Imaging::ImageBuffer{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics<D>::
    CreateForSoftwareBitmap(
        winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
        const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Graphics::Imaging::IImageBufferStatics, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Graphics::Imaging::
                    IImageBufferStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateForSoftwareBitmap(
        *(void**)(&softwareBitmap), &result));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>**)this;
    check_hresult(_winrt_abi_type->CreateForSoftwareBitmap(
        *(void**)(&softwareBitmap), &result));
  }
  return winrt::Microsoft::Graphics::Imaging::ImageBuffer{
      result, take_ownership_from_abi};
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>
    : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer> {
  int32_t __stdcall get_Buffer(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Storage::Streams::IBuffer>(
        this->shim().Buffer());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PixelFormat(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat>(
        this->shim().PixelFormat());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PixelHeight(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().PixelHeight());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PixelWidth(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().PixelWidth());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_RowStride(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().RowStride());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CopyToByteArray(uint32_t __valuesSize,
                                    uint8_t* values) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CopyToByteArray(
        array_view<uint8_t>(reinterpret_cast<uint8_t*>(values),
                            reinterpret_cast<uint8_t*>(values) + __valuesSize));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CopyToSoftwareBitmap(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(
        this->shim().CopyToSoftwareBitmap());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>
    : produce_base<D,
                   winrt::Microsoft::Graphics::Imaging::IImageBufferStatics> {
  int32_t __stdcall CreateForBuffer(void* buffer, int32_t pixelFormat,
                                    int32_t width, int32_t height,
                                    int32_t rowStride,
                                    void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(
        this->shim().CreateForBuffer(
            *reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(
                &buffer),
            *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::
                                  ImageBufferPixelFormat const*>(&pixelFormat),
            width, height, rowStride));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateForSoftwareBitmap(void* softwareBitmap,
                                            void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(
        this->shim().CreateForSoftwareBitmap(
            *reinterpret_cast<
                winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(
                &softwareBitmap)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Imaging {
  inline auto ImageBuffer::CreateForBuffer(
      winrt::Windows::Storage::Streams::IBuffer const& buffer,
      winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat const&
          pixelFormat,
      int32_t width, int32_t height, int32_t rowStride) {
    return impl::call_factory<ImageBuffer, IImageBufferStatics>(
        [&](IImageBufferStatics const& f) {
          return f.CreateForBuffer(buffer, pixelFormat, width, height,
                                   rowStride);
        });
  }
  inline auto ImageBuffer::CreateForSoftwareBitmap(
      winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) {
    return impl::call_factory<ImageBuffer, IImageBufferStatics>(
        [&](IImageBufferStatics const& f) {
          return f.CreateForSoftwareBitmap(softwareBitmap);
        });
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Graphics::Imaging::IImageBuffer>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Graphics::Imaging::ImageBuffer>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
