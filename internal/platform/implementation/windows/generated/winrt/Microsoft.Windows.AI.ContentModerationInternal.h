// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_ContentModerationInternal_H
#define WINRT_Microsoft_Windows_AI_ContentModerationInternal_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.h"
#include "winrt/impl/Microsoft.Windows.AI.ContentModerationInternal.2.h"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_AI_ContentModerationInternal_IImageContentModerationSession<
    D>::ValidateImage(winrt::Microsoft::Windows::PrivateCommon::
                          ImageBufferResource const& inputImageBufferResource,
                      uint32_t priority, uint32_t frequency) const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::ContentModerationInternal::
                        IImageContentModerationSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::ContentModerationInternal::
            IImageContentModerationSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    IImageContentModerationSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->ValidateImage(
        *(void**)(&inputImageBufferResource), priority, frequency, &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    IImageContentModerationSession>**)this;
    check_hresult(_winrt_abi_type->ValidateImage(
        *(void**)(&inputImageBufferResource), priority, frequency, &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_ContentModerationInternal_IImageContentModerationSession<
    D>::AnalyzeImage(winrt::Microsoft::Windows::PrivateCommon::
                         ImageBufferResource const& inputImageBufferResource,
                     uint32_t priority, uint32_t frequency) const {
  winrt::Microsoft::Windows::AI::ContentModerationInternal::
      ImageContentAnalysisScores result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::ContentModerationInternal::
                        IImageContentModerationSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::ContentModerationInternal::
            IImageContentModerationSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    IImageContentModerationSession>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->AnalyzeImage(*(void**)(&inputImageBufferResource),
                                      priority, frequency, put_abi(result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    IImageContentModerationSession>**)this;
    check_hresult(
        _winrt_abi_type->AnalyzeImage(*(void**)(&inputImageBufferResource),
                                      priority, frequency, put_abi(result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_ContentModerationInternal_ITextBlockListSession<
    D>::IsTextBlocked(param::hstring const& query,
                      param::hstring const& inputLanguage) const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::AI::
                           ContentModerationInternal::ITextBlockListSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::ContentModerationInternal::
            ITextBlockListSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    ITextBlockListSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsTextBlocked(
        *(void**)(&query), *(void**)(&inputLanguage), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    ITextBlockListSession>**)this;
    check_hresult(_winrt_abi_type->IsTextBlocked(
        *(void**)(&query), *(void**)(&inputLanguage), &result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_AI_ContentModerationInternal_ITextContentModerationSession<
    D>::AnalyzeText(param::hstring const& text, uint32_t priority,
                    uint32_t frequency) const {
  winrt::Microsoft::Windows::AI::ContentModerationInternal::
      TextContentAnalysisScores result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::AI::ContentModerationInternal::
                        ITextContentModerationSession>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::AI::ContentModerationInternal::
            ITextContentModerationSession,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    ITextContentModerationSession>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->AnalyzeText(*(void**)(&text), priority,
                                               frequency, put_abi(result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                    ITextContentModerationSession>**)this;
    check_hresult(_winrt_abi_type->AnalyzeText(*(void**)(&text), priority,
                                               frequency, put_abi(result)));
  }
  return result;
}
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::
                      IImageContentModerationSession>
    : produce_base<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::
                          IImageContentModerationSession> {
  int32_t __stdcall ValidateImage(void* inputImageBufferResource,
                                  uint32_t priority, uint32_t frequency,
                                  bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().ValidateImage(
        *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                              ImageBufferResource const*>(
            &inputImageBufferResource),
        priority, frequency));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall AnalyzeImage(
      void* inputImageBufferResource, uint32_t priority, uint32_t frequency,
      struct
      struct_Microsoft_Windows_AI_ContentModerationInternal_ImageContentAnalysisScores*
          result) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                 ImageContentAnalysisScores>(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                        ImageContentAnalysisScores>(this->shim().AnalyzeImage(
            *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                                  ImageBufferResource const*>(
                &inputImageBufferResource),
            priority, frequency));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::
                      ITextBlockListSession>
    : produce_base<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::
                          ITextBlockListSession> {
  int32_t __stdcall IsTextBlocked(void* query, void* inputLanguage,
                                  bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsTextBlocked(
        *reinterpret_cast<hstring const*>(&query),
        *reinterpret_cast<hstring const*>(&inputLanguage)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::
                      ITextContentModerationSession>
    : produce_base<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::
                          ITextContentModerationSession> {
  int32_t __stdcall AnalyzeText(
      void* text, uint32_t priority, uint32_t frequency,
      struct
      struct_Microsoft_Windows_AI_ContentModerationInternal_TextContentAnalysisScores*
          result) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                 TextContentAnalysisScores>(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                        TextContentAnalysisScores>(this->shim().AnalyzeText(
            *reinterpret_cast<hstring const*>(&text), priority, frequency));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::
    ContentModerationInternal {}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                IImageContentModerationSession> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                ITextBlockListSession> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::AI::ContentModerationInternal::
                ITextContentModerationSession> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
