// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Xaml_Hosting_H
#define WINRT_Microsoft_UI_Xaml_Hosting_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.Xaml.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Microsoft.UI.Composition.2.h"
#include "winrt/impl/Microsoft.UI.Content.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.Controls.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.Hosting.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.Media.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::Content()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Content(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->get_Content(&value));
  }
  return winrt::Microsoft::UI::Xaml::UIElement{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::Content(
    winrt::Microsoft::UI::Xaml::UIElement const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::HasFocus()
    const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HasFocus(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->get_HasFocus(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<
    D>::SystemBackdrop() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SystemBackdrop(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->get_SystemBackdrop(&value));
  }
  return winrt::Microsoft::UI::Xaml::Media::SystemBackdrop{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<
    D>::SystemBackdrop(winrt::Microsoft::UI::Xaml::Media::SystemBackdrop const&
                           value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_SystemBackdrop(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->put_SystemBackdrop(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::SiteBridge()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SiteBridge(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->get_SiteBridge(&value));
  }
  return winrt::Microsoft::UI::Content::DesktopChildSiteBridge{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::
    TakeFocusRequested(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource,
            winrt::Microsoft::UI::Xaml::Hosting::
                DesktopWindowXamlSourceTakeFocusRequestedEventArgs> const&
            handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_TakeFocusRequested(*(void**)(&handler),
                                                          put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->add_TakeFocusRequested(*(void**)(&handler),
                                                          put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::
    TakeFocusRequested(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource,
            winrt::Microsoft::UI::Xaml::Hosting::
                DesktopWindowXamlSourceTakeFocusRequestedEventArgs> const&
            handler) const {
  return impl::make_event_revoker<D, TakeFocusRequested_revoker>(
      this, TakeFocusRequested(handler));
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<
    D>::TakeFocusRequested(winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_TakeFocusRequested(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    _winrt_abi_type->remove_TakeFocusRequested(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::GotFocus(
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource,
        winrt::Microsoft::UI::Xaml::Hosting::
            DesktopWindowXamlSourceGotFocusEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(
        _winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::GotFocus(
    auto_revoke_t,
    winrt::Windows::Foundation::TypedEventHandler<
        winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource,
        winrt::Microsoft::UI::Xaml::Hosting::
            DesktopWindowXamlSourceGotFocusEventArgs> const& handler) const {
  return impl::make_event_revoker<D, GotFocus_revoker>(this, GotFocus(handler));
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::GotFocus(
    winrt::event_token const& token) const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::
    NavigateFocus(winrt::Microsoft::UI::Xaml::Hosting::
                      XamlSourceFocusNavigationRequest const& request) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->NavigateFocus(*(void**)(&request), &result));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->NavigateFocus(*(void**)(&request), &result));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::Initialize(
    winrt::Microsoft::UI::WindowId const& parentWindowId) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Initialize(impl::bind_in(parentWindowId)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource>**)this;
    check_hresult(_winrt_abi_type->Initialize(impl::bind_in(parentWindowId)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource2<
    D>::ShouldConstrainPopupsToWorkArea() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ShouldConstrainPopupsToWorkArea(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource2>**)this;
    check_hresult(_winrt_abi_type->get_ShouldConstrainPopupsToWorkArea(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource2<
    D>::ShouldConstrainPopupsToWorkArea(bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSource2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSource2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ShouldConstrainPopupsToWorkArea(value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IDesktopWindowXamlSource2>**)this;
    check_hresult(_winrt_abi_type->put_ShouldConstrainPopupsToWorkArea(value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSourceFactory<D>::
    CreateInstance(
        winrt::Windows::Foundation::IInspectable const& baseInterface,
        winrt::Windows::Foundation::IInspectable& innerInterface) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IDesktopWindowXamlSourceFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSourceFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstance(
        *(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSourceFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstance(
        *(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSourceGotFocusEventArgs<
    D>::Request() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::UI::Xaml::Hosting::
                           IDesktopWindowXamlSourceGotFocusEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::
                                     IDesktopWindowXamlSourceGotFocusEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Xaml::Hosting::
                IDesktopWindowXamlSourceGotFocusEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Request(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSourceGotFocusEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Request(&value));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSourceTakeFocusRequestedEventArgs<
    D>::Request() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::UI::Xaml::Hosting::
                        IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::
            IDesktopWindowXamlSourceTakeFocusRequestedEventArgs,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Xaml::Hosting::
                IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Request(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>**)this;
    check_hresult(_winrt_abi_type->get_Request(&value));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<
    D>::GetElementVisual(winrt::Microsoft::UI::Xaml::UIElement const& element)
    const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetElementVisual(*(void**)(&element), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetElementVisual(*(void**)(&element), &result));
  }
  return winrt::Microsoft::UI::Composition::Visual{result,
                                                   take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<
    D>::GetElementChildVisual(winrt::Microsoft::UI::Xaml::UIElement const&
                                  element) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GetElementChildVisual(*(void**)(&element), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(
        _winrt_abi_type->GetElementChildVisual(*(void**)(&element), &result));
  }
  return winrt::Microsoft::UI::Composition::Visual{result,
                                                   take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::
    SetElementChildVisual(
        winrt::Microsoft::UI::Xaml::UIElement const& element,
        winrt::Microsoft::UI::Composition::Visual const& visual) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetElementChildVisual(*(void**)(&element),
                                                         *(void**)(&visual)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(_winrt_abi_type->SetElementChildVisual(*(void**)(&element),
                                                         *(void**)(&visual)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::
    GetScrollViewerManipulationPropertySet(
        winrt::Microsoft::UI::Xaml::Controls::ScrollViewer const& scrollViewer)
        const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetScrollViewerManipulationPropertySet(
        *(void**)(&scrollViewer), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(_winrt_abi_type->GetScrollViewerManipulationPropertySet(
        *(void**)(&scrollViewer), &result));
  }
  return winrt::Microsoft::UI::Composition::CompositionPropertySet{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::
    SetImplicitShowAnimation(
        winrt::Microsoft::UI::Xaml::UIElement const& element,
        winrt::Microsoft::UI::Composition::ICompositionAnimationBase const&
            animation) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetImplicitShowAnimation(
        *(void**)(&element), *(void**)(&animation)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(_winrt_abi_type->SetImplicitShowAnimation(
        *(void**)(&element), *(void**)(&animation)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::
    SetImplicitHideAnimation(
        winrt::Microsoft::UI::Xaml::UIElement const& element,
        winrt::Microsoft::UI::Composition::ICompositionAnimationBase const&
            animation) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SetImplicitHideAnimation(
        *(void**)(&element), *(void**)(&animation)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(_winrt_abi_type->SetImplicitHideAnimation(
        *(void**)(&element), *(void**)(&animation)));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<
    D>::SetIsTranslationEnabled(winrt::Microsoft::UI::Xaml::UIElement const&
                                    element,
                                bool value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetIsTranslationEnabled(*(void**)(&element), value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(
        _winrt_abi_type->SetIsTranslationEnabled(*(void**)(&element), value));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::
    GetPointerPositionPropertySet(
        winrt::Microsoft::UI::Xaml::UIElement const& targetElement) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IElementCompositionPreviewStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetPointerPositionPropertySet(
        *(void**)(&targetElement), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IElementCompositionPreviewStatics>**)this;
    check_hresult(_winrt_abi_type->GetPointerPositionPropertySet(
        *(void**)(&targetElement), &result));
  }
  return winrt::Microsoft::UI::Composition::CompositionPropertySet{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManager2<D>::
    XamlShutdownCompletedOnThread(
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager,
            winrt::Microsoft::UI::Xaml::Hosting::
                XamlShutdownCompletedOnThreadEventArgs> const& handler) const {
  winrt::event_token token{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IWindowsXamlManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IWindowsXamlManager2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->add_XamlShutdownCompletedOnThread(
        *(void**)(&handler), put_abi(token)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>**)this;
    check_hresult(_winrt_abi_type->add_XamlShutdownCompletedOnThread(
        *(void**)(&handler), put_abi(token)));
  }
  return token;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManager2<D>::
    XamlShutdownCompletedOnThread(
        auto_revoke_t,
        winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager,
            winrt::Microsoft::UI::Xaml::Hosting::
                XamlShutdownCompletedOnThreadEventArgs> const& handler) const {
  return impl::make_event_revoker<D, XamlShutdownCompletedOnThread_revoker>(
      this, XamlShutdownCompletedOnThread(handler));
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManager2<
    D>::XamlShutdownCompletedOnThread(winrt::event_token const& token)
    const noexcept {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IWindowsXamlManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IWindowsXamlManager2>**)&_winrt_casted_result;
    _winrt_abi_type->remove_XamlShutdownCompletedOnThread(impl::bind_in(token));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>**)this;
    _winrt_abi_type->remove_XamlShutdownCompletedOnThread(impl::bind_in(token));
  }
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManagerStatics<
    D>::InitializeForCurrentThread() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IWindowsXamlManagerStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IWindowsXamlManagerStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->InitializeForCurrentThread(&result));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                                             IWindowsXamlManagerStatics>**)this;
    check_hresult(_winrt_abi_type->InitializeForCurrentThread(&result));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManagerStatics2<
    D>::GetForCurrentThread() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IWindowsXamlManagerStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IWindowsXamlManagerStatics2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetForCurrentThread(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IWindowsXamlManagerStatics2>**)this;
    check_hresult(_winrt_abi_type->GetForCurrentThread(&result));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlShutdownCompletedOnThreadEventArgs<
    D>::GetDispatcherQueueDeferral() const {
  void* result{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Xaml::Hosting::
                                    IXamlShutdownCompletedOnThreadEventArgs>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::
                                     IXamlShutdownCompletedOnThreadEventArgs,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Xaml::Hosting::
                IXamlShutdownCompletedOnThreadEventArgs>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetDispatcherQueueDeferral(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlShutdownCompletedOnThreadEventArgs>**)this;
    check_hresult(_winrt_abi_type->GetDispatcherQueueDeferral(&result));
  }
  return winrt::Windows::Foundation::Deferral{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequest<
    D>::Reason() const {
  winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IXamlSourceFocusNavigationRequest>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequest>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequest>**)this;
    check_hresult(
        _winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequest<
    D>::HintRect() const {
  winrt::Windows::Foundation::Rect value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IXamlSourceFocusNavigationRequest>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequest>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_HintRect(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequest>**)this;
    check_hresult(_winrt_abi_type->get_HintRect(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequest<
    D>::CorrelationId() const {
  winrt::guid value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IXamlSourceFocusNavigationRequest>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequest>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequest>**)this;
    check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequestFactory<
    D>::CreateInstance(winrt::Microsoft::UI::Xaml::Hosting::
                           XamlSourceFocusNavigationReason const& reason)
    const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Xaml::Hosting::
                                    IXamlSourceFocusNavigationRequestFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::
                                     IXamlSourceFocusNavigationRequestFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Xaml::Hosting::
                IXamlSourceFocusNavigationRequestFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(static_cast<int32_t>(reason), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequestFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(static_cast<int32_t>(reason), &value));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequestFactory<
    D>::CreateInstanceWithHintRect(winrt::Microsoft::UI::Xaml::Hosting::
                                       XamlSourceFocusNavigationReason const&
                                           reason,
                                   winrt::Windows::Foundation::Rect const&
                                       hintRect) const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Xaml::Hosting::
                                    IXamlSourceFocusNavigationRequestFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::
                                     IXamlSourceFocusNavigationRequestFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Xaml::Hosting::
                IXamlSourceFocusNavigationRequestFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstanceWithHintRect(
        static_cast<int32_t>(reason), impl::bind_in(hintRect), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequestFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstanceWithHintRect(
        static_cast<int32_t>(reason), impl::bind_in(hintRect), &value));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequestFactory<
    D>::
    CreateInstanceWithHintRectAndCorrelationId(
        winrt::Microsoft::UI::Xaml::Hosting::
            XamlSourceFocusNavigationReason const& reason,
        winrt::Windows::Foundation::Rect const& hintRect,
        winrt::guid const& correlationId) const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Xaml::Hosting::
                                    IXamlSourceFocusNavigationRequestFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::
                                     IXamlSourceFocusNavigationRequestFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Xaml::Hosting::
                IXamlSourceFocusNavigationRequestFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstanceWithHintRectAndCorrelationId(
        static_cast<int32_t>(reason), impl::bind_in(hintRect),
        impl::bind_in(correlationId), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationRequestFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstanceWithHintRectAndCorrelationId(
        static_cast<int32_t>(reason), impl::bind_in(hintRect),
        impl::bind_in(correlationId), &value));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationResult<
    D>::WasFocusMoved() const {
  bool value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::
                                       IXamlSourceFocusNavigationResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_WasFocusMoved(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationResult>**)this;
    check_hresult(_winrt_abi_type->get_WasFocusMoved(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationResultFactory<
    D>::CreateInstance(bool focusMoved) const {
  void* value{};
  if constexpr (!std::is_same_v<D,
                                winrt::Microsoft::UI::Xaml::Hosting::
                                    IXamlSourceFocusNavigationResultFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::
                                     IXamlSourceFocusNavigationResultFactory,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::UI::Xaml::Hosting::
                IXamlSourceFocusNavigationResultFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstance(focusMoved, &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::
                    IXamlSourceFocusNavigationResultFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstance(focusMoved, &value));
  }
  return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult{
      value, take_ownership_from_abi};
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>
    : produce_base<
          D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource> {
  int32_t __stdcall get_Content(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Xaml::UIElement>(
        this->shim().Content());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Content(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Content(
        *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_HasFocus(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().HasFocus());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SystemBackdrop(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(
        this->shim().SystemBackdrop());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_SystemBackdrop(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SystemBackdrop(
        *reinterpret_cast<
            winrt::Microsoft::UI::Xaml::Media::SystemBackdrop const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SiteBridge(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>(
        this->shim().SiteBridge());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall add_TakeFocusRequested(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().TakeFocusRequested(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource,
            winrt::Microsoft::UI::Xaml::Hosting::
                DesktopWindowXamlSourceTakeFocusRequestedEventArgs> const*>(
            &handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_TakeFocusRequested(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().TakeFocusRequested(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall add_GotFocus(void* handler,
                                 winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(this->shim().GotFocus(
        *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
            winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource,
            winrt::Microsoft::UI::Xaml::Hosting::
                DesktopWindowXamlSourceGotFocusEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_GotFocus(winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().GotFocus(*reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
  int32_t __stdcall NavigateFocus(void* request, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult>(
        this->shim().NavigateFocus(
            *reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::
                                  XamlSourceFocusNavigationRequest const*>(
                &request)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Initialize(
      struct struct_Microsoft_UI_WindowId parentWindowId) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Initialize(
        *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
            &parentWindowId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>
    : produce_base<
          D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2> {
  int32_t __stdcall get_ShouldConstrainPopupsToWorkArea(
      bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().ShouldConstrainPopupsToWorkArea());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ShouldConstrainPopupsToWorkArea(
      bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ShouldConstrainPopupsToWorkArea(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IDesktopWindowXamlSourceFactory> {
  int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface,
                                   void** value) noexcept final try {
    if (innerInterface) *innerInterface = nullptr;
    winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource>(
        this->shim().CreateInstance(
            *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(
                &baseInterface),
            winrt_impl_innerInterface));
    if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::
                      IDesktopWindowXamlSourceGotFocusEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IDesktopWindowXamlSourceGotFocusEventArgs> {
  int32_t __stdcall get_Request(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(
        this->shim().Request());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::
                      IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IDesktopWindowXamlSourceTakeFocusRequestedEventArgs> {
  int32_t __stdcall get_Request(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(
        this->shim().Request());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreview>
    : produce_base<
          D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreview> {
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IElementCompositionPreviewStatics> {
  int32_t __stdcall GetElementVisual(void* element,
                                     void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Composition::Visual>(
        this->shim().GetElementVisual(
            *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
                &element)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetElementChildVisual(void* element,
                                          void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::UI::Composition::Visual>(
        this->shim().GetElementChildVisual(
            *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
                &element)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetElementChildVisual(void* element,
                                          void* visual) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetElementChildVisual(
        *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
            &element),
        *reinterpret_cast<winrt::Microsoft::UI::Composition::Visual const*>(
            &visual));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetScrollViewerManipulationPropertySet(
      void* scrollViewer, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Composition::CompositionPropertySet>(
            this->shim().GetScrollViewerManipulationPropertySet(
                *reinterpret_cast<
                    winrt::Microsoft::UI::Xaml::Controls::ScrollViewer const*>(
                    &scrollViewer)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetImplicitShowAnimation(void* element,
                                             void* animation) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetImplicitShowAnimation(
        *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
            &element),
        *reinterpret_cast<winrt::Microsoft::UI::Composition::
                              ICompositionAnimationBase const*>(&animation));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetImplicitHideAnimation(void* element,
                                             void* animation) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetImplicitHideAnimation(
        *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
            &element),
        *reinterpret_cast<winrt::Microsoft::UI::Composition::
                              ICompositionAnimationBase const*>(&animation));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetIsTranslationEnabled(void* element,
                                            bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetIsTranslationEnabled(
        *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
            &element),
        value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetPointerPositionPropertySet(void* targetElement,
                                                  void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Composition::CompositionPropertySet>(
            this->shim().GetPointerPositionPropertySet(
                *reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(
                    &targetElement)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager>
    : produce_base<D,
                   winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager> {};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>
    : produce_base<D,
                   winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2> {
  int32_t __stdcall add_XamlShutdownCompletedOnThread(
      void* handler, winrt::event_token* token) noexcept final try {
    zero_abi<winrt::event_token>(token);
    typename D::abi_guard guard(this->shim());
    *token = detach_from<winrt::event_token>(
        this->shim().XamlShutdownCompletedOnThread(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager,
                winrt::Microsoft::UI::Xaml::Hosting::
                    XamlShutdownCompletedOnThreadEventArgs> const*>(&handler)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall remove_XamlShutdownCompletedOnThread(
      winrt::event_token token) noexcept final {
    typename D::abi_guard guard(this->shim());
    this->shim().XamlShutdownCompletedOnThread(
        *reinterpret_cast<winrt::event_token const*>(&token));
    return 0;
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics>
    : produce_base<
          D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics> {
  int32_t __stdcall InitializeForCurrentThread(void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager>(
            this->shim().InitializeForCurrentThread());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2>
    : produce_base<
          D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2> {
  int32_t __stdcall GetForCurrentThread(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager>(
            this->shim().GetForCurrentThread());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::
                      IXamlShutdownCompletedOnThreadEventArgs>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IXamlShutdownCompletedOnThreadEventArgs> {
  int32_t __stdcall GetDispatcherQueueDeferral(void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Windows::Foundation::Deferral>(
        this->shim().GetDispatcherQueueDeferral());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IXamlSourceFocusNavigationRequest> {
  int32_t __stdcall get_Reason(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason>(
        this->shim().Reason());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_HintRect(
      winrt::Windows::Foundation::Rect* value) noexcept final try {
    zero_abi<winrt::Windows::Foundation::Rect>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Rect>(this->shim().HintRect());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_CorrelationId(winrt::guid* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::guid>(this->shim().CorrelationId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::
                      IXamlSourceFocusNavigationRequestFactory>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IXamlSourceFocusNavigationRequestFactory> {
  int32_t __stdcall CreateInstance(int32_t reason, void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(
        this->shim().CreateInstance(
            *reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::
                                  XamlSourceFocusNavigationReason const*>(
                &reason)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateInstanceWithHintRect(
      int32_t reason, winrt::Windows::Foundation::Rect hintRect,
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(
        this->shim().CreateInstanceWithHintRect(
            *reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::
                                  XamlSourceFocusNavigationReason const*>(
                &reason),
            *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(
                &hintRect)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateInstanceWithHintRectAndCorrelationId(
      int32_t reason, winrt::Windows::Foundation::Rect hintRect,
      winrt::guid correlationId, void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(
        this->shim().CreateInstanceWithHintRectAndCorrelationId(
            *reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::
                                  XamlSourceFocusNavigationReason const*>(
                &reason),
            *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(
                &hintRect),
            *reinterpret_cast<winrt::guid const*>(&correlationId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IXamlSourceFocusNavigationResult> {
  int32_t __stdcall get_WasFocusMoved(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().WasFocusMoved());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::
                      IXamlSourceFocusNavigationResultFactory>
    : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::
                          IXamlSourceFocusNavigationResultFactory> {
  int32_t __stdcall CreateInstance(bool focusMoved, void** value) noexcept final
      try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult>(
        this->shim().CreateInstance(focusMoved));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::UI::Xaml::Hosting {
  inline DesktopWindowXamlSource::DesktopWindowXamlSource() {
    winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
    *this = impl::call_factory<DesktopWindowXamlSource,
                               IDesktopWindowXamlSourceFactory>(
        [&](IDesktopWindowXamlSourceFactory const& f) {
          return f.CreateInstance(baseInterface, innerInterface);
        });
  }
  inline auto ElementCompositionPreview::GetElementVisual(
      winrt::Microsoft::UI::Xaml::UIElement const& element) {
    return impl::call_factory<ElementCompositionPreview,
                              IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.GetElementVisual(element);
        });
  }
  inline auto ElementCompositionPreview::GetElementChildVisual(
      winrt::Microsoft::UI::Xaml::UIElement const& element) {
    return impl::call_factory<ElementCompositionPreview,
                              IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.GetElementChildVisual(element);
        });
  }
  inline auto ElementCompositionPreview::SetElementChildVisual(
      winrt::Microsoft::UI::Xaml::UIElement const& element,
      winrt::Microsoft::UI::Composition::Visual const& visual) {
    impl::call_factory<ElementCompositionPreview,
                       IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.SetElementChildVisual(element, visual);
        });
  }
  inline auto ElementCompositionPreview::GetScrollViewerManipulationPropertySet(
      winrt::Microsoft::UI::Xaml::Controls::ScrollViewer const& scrollViewer) {
    return impl::call_factory<ElementCompositionPreview,
                              IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.GetScrollViewerManipulationPropertySet(scrollViewer);
        });
  }
  inline auto ElementCompositionPreview::SetImplicitShowAnimation(
      winrt::Microsoft::UI::Xaml::UIElement const& element,
      winrt::Microsoft::UI::Composition::ICompositionAnimationBase const&
          animation) {
    impl::call_factory<ElementCompositionPreview,
                       IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.SetImplicitShowAnimation(element, animation);
        });
  }
  inline auto ElementCompositionPreview::SetImplicitHideAnimation(
      winrt::Microsoft::UI::Xaml::UIElement const& element,
      winrt::Microsoft::UI::Composition::ICompositionAnimationBase const&
          animation) {
    impl::call_factory<ElementCompositionPreview,
                       IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.SetImplicitHideAnimation(element, animation);
        });
  }
  inline auto ElementCompositionPreview::SetIsTranslationEnabled(
      winrt::Microsoft::UI::Xaml::UIElement const& element, bool value) {
    impl::call_factory<ElementCompositionPreview,
                       IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.SetIsTranslationEnabled(element, value);
        });
  }
  inline auto ElementCompositionPreview::GetPointerPositionPropertySet(
      winrt::Microsoft::UI::Xaml::UIElement const& targetElement) {
    return impl::call_factory<ElementCompositionPreview,
                              IElementCompositionPreviewStatics>(
        [&](IElementCompositionPreviewStatics const& f) {
          return f.GetPointerPositionPropertySet(targetElement);
        });
  }
  inline auto WindowsXamlManager::InitializeForCurrentThread() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager (*)(
            IWindowsXamlManagerStatics const&),
        WindowsXamlManager, IWindowsXamlManagerStatics>(
        [](IWindowsXamlManagerStatics const& f) {
          return f.InitializeForCurrentThread();
        });
  }
  inline auto WindowsXamlManager::GetForCurrentThread() {
    return impl::call_factory_cast<
        winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager (*)(
            IWindowsXamlManagerStatics2 const&),
        WindowsXamlManager, IWindowsXamlManagerStatics2>(
        [](IWindowsXamlManagerStatics2 const& f) {
          return f.GetForCurrentThread();
        });
  }
  inline XamlSourceFocusNavigationRequest::XamlSourceFocusNavigationRequest(
      winrt::Microsoft::UI::Xaml::Hosting::
          XamlSourceFocusNavigationReason const& reason)
      : XamlSourceFocusNavigationRequest(
            impl::call_factory<XamlSourceFocusNavigationRequest,
                               IXamlSourceFocusNavigationRequestFactory>(
                [&](IXamlSourceFocusNavigationRequestFactory const& f) {
                  return f.CreateInstance(reason);
                })) {}
  inline XamlSourceFocusNavigationRequest::XamlSourceFocusNavigationRequest(
      winrt::Microsoft::UI::Xaml::Hosting::
          XamlSourceFocusNavigationReason const& reason,
      winrt::Windows::Foundation::Rect const& hintRect)
      : XamlSourceFocusNavigationRequest(
            impl::call_factory<XamlSourceFocusNavigationRequest,
                               IXamlSourceFocusNavigationRequestFactory>(
                [&](IXamlSourceFocusNavigationRequestFactory const& f) {
                  return f.CreateInstanceWithHintRect(reason, hintRect);
                })) {}
  inline XamlSourceFocusNavigationRequest::XamlSourceFocusNavigationRequest(
      winrt::Microsoft::UI::Xaml::Hosting::
          XamlSourceFocusNavigationReason const& reason,
      winrt::Windows::Foundation::Rect const& hintRect,
      winrt::guid const& correlationId)
      : XamlSourceFocusNavigationRequest(
            impl::call_factory<XamlSourceFocusNavigationRequest,
                               IXamlSourceFocusNavigationRequestFactory>(
                [&](IXamlSourceFocusNavigationRequestFactory const& f) {
                  return f.CreateInstanceWithHintRectAndCorrelationId(
                      reason, hintRect, correlationId);
                })) {}
  inline XamlSourceFocusNavigationResult::XamlSourceFocusNavigationResult(
      bool focusMoved)
      : XamlSourceFocusNavigationResult(
            impl::call_factory<XamlSourceFocusNavigationResult,
                               IXamlSourceFocusNavigationResultFactory>(
                [&](IXamlSourceFocusNavigationResultFactory const& f) {
                  return f.CreateInstance(focusMoved);
                })) {}
  template <typename D, typename... Interfaces>
  struct DesktopWindowXamlSourceT
      : implements<D, winrt::Windows::Foundation::IInspectable, composing,
                   Interfaces...>,
        impl::require<
            D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource,
            winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2,
            winrt::Windows::Foundation::IClosable>,
        impl::base<D, DesktopWindowXamlSource> {
    using composable = DesktopWindowXamlSource;

   protected:
    DesktopWindowXamlSourceT() {
      impl::call_factory<DesktopWindowXamlSource,
                         IDesktopWindowXamlSourceFactory>(
          [&](IDesktopWindowXamlSourceFactory const& f) {
            [[maybe_unused]] auto winrt_impl_discarded =
                f.CreateInstance(*this, this->m_inner);
          });
    }
  };
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::
                IDesktopWindowXamlSourceGotFocusEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::
                IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreview>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::
                IXamlShutdownCompletedOnThreadEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::
                IXamlSourceFocusNavigationRequestFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::
                IXamlSourceFocusNavigationResultFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::
                DesktopWindowXamlSourceGotFocusEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::
                DesktopWindowXamlSourceTakeFocusRequestedEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::ElementCompositionPreview>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Xaml::Hosting::XamlShutdownCompletedOnThreadEventArgs>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
