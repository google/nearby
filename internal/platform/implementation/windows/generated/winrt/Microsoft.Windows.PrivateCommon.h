// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_PrivateCommon_H
#define WINRT_Microsoft_Windows_PrivateCommon_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IAnchorInstance<D>::AnchorInstance(
    winrt::Windows::Foundation::IInspectable const& instance) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IAnchorInstance>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IAnchorInstance>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->AnchorInstance(*(void**)(&instance)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance>**)this;
    check_hresult(_winrt_abi_type->AnchorInstance(*(void**)(&instance)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IGetSessionHostProcessId<
    D>::GetSessionHostProcessId() const {
  uint32_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IGetSessionHostProcessId>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IGetSessionHostProcessId>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetSessionHostProcessId(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IGetSessionHostProcessId>**)this;
    check_hresult(_winrt_abi_type->GetSessionHostProcessId(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<
    D>::GetImageBufferView() const {
  winrt::Microsoft::Windows::PrivateCommon::ImageBufferView result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferPrivate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetImageBufferView(put_abi(result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)this;
    check_hresult(_winrt_abi_type->GetImageBufferView(put_abi(result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<
    D>::GetImageBufferViewData(uint32_t targetProcessId) const {
  winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferPrivate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetImageBufferViewData(targetProcessId,
                                                          put_abi(result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)this;
    check_hresult(_winrt_abi_type->GetImageBufferViewData(targetProcessId,
                                                          put_abi(result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<
    D>::SyncBufferWithOutValue() const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferPrivate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->SyncBufferWithOutValue());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)this;
    check_hresult(_winrt_abi_type->SyncBufferWithOutValue());
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<
    D>::GetImageBufferResource(winrt::Windows::Foundation::IInspectable const&
                                   sessionAsInspectable) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferPrivate>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetImageBufferResource(
        *(void**)(&sessionAsInspectable), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferPrivate>**)this;
    check_hresult(_winrt_abi_type->GetImageBufferResource(
        *(void**)(&sessionAsInspectable), &result));
  }
  return winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource{
      result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<
    D>::BufferData() const {
  winrt::Microsoft::Windows::PrivateCommon::ImageBufferData value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_BufferData(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->get_BufferData(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::
    BufferData(winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const&
                   value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_BufferData(impl::bind_in(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->put_BufferData(impl::bind_in(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Buffer()
    const {
  uint64_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Buffer(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->Buffer(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Width()
    const {
  uint32_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Width(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->Width(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Height()
    const {
  uint32_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Height(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->Height(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<
    D>::RowStride() const {
  uint32_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->RowStride(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->RowStride(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<
    D>::BytesPerPixel() const {
  uint32_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->BytesPerPixel(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->BytesPerPixel(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Capacity()
    const {
  uint32_t result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Capacity(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(_winrt_abi_type->Capacity(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<
    D>::PixelFormat() const {
  winrt::Microsoft::Windows::PrivateCommon::PixelFormat result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResource>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->PixelFormat(reinterpret_cast<int32_t*>(&result)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResource>**)this;
    check_hresult(
        _winrt_abi_type->PixelFormat(reinterpret_cast<int32_t*>(&result)));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResourceFactory<D>::
    CreateInstance(
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const&
            bufferData) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResourceFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResourceFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(bufferData), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResourceFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(bufferData), &value));
  }
  return winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResourceFactory<D>::
    CreateInstance2(uint32_t height, uint32_t width,
                    winrt::Microsoft::Windows::PrivateCommon::PixelFormat const&
                        pixelFormat,
                    uint32_t rowStride, uint64_t targetProcessHandle,
                    uint64_t sourceProcessHandle) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       IImageBufferResourceFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResourceFactory>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateInstance2(
        height, width, static_cast<int32_t>(pixelFormat), rowStride,
        targetProcessHandle, sourceProcessHandle, &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IImageBufferResourceFactory>**)this;
    check_hresult(_winrt_abi_type->CreateInstance2(
        height, width, static_cast<int32_t>(pixelFormat), rowStride,
        targetProcessHandle, sourceProcessHandle, &value));
  }
  return winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IModelManager<
    D>::EnsureModelInitialized() const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::PrivateCommon::IModelManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IModelManager, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IModelManager>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->EnsureModelInitialized());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager>**)this;
    check_hresult(_winrt_abi_type->EnsureModelInitialized());
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IModelManager<
    D>::GenerateCacheModel(param::hstring const& offlineDriverPath) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::PrivateCommon::IModelManager>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IModelManager, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IModelManager>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->GenerateCacheModel(*(void**)(&offlineDriverPath)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager>**)this;
    check_hresult(
        _winrt_abi_type->GenerateCacheModel(*(void**)(&offlineDriverPath)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IModelManager2<
    D>::SetPackageFamilyName(param::hstring const& packageFamilyName) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::PrivateCommon::IModelManager2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IModelManager2, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IModelManager2>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetPackageFamilyName(*(void**)(&packageFamilyName)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager2>**)this;
    check_hresult(
        _winrt_abi_type->SetPackageFamilyName(*(void**)(&packageFamilyName)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IModelManager3<
    D>::GenerateCacheModel() const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::PrivateCommon::IModelManager3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IModelManager3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IModelManager3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GenerateCacheModel());
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)this;
    check_hresult(_winrt_abi_type->GenerateCacheModel());
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IModelManager3<
    D>::SetCorrelationVector(param::hstring const& correlationVector) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::PrivateCommon::IModelManager3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IModelManager3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IModelManager3>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->SetCorrelationVector(*(void**)(&correlationVector)));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)this;
    check_hresult(
        _winrt_abi_type->SetCorrelationVector(*(void**)(&correlationVector)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_IModelManager3<
    D>::IsModelCacheReady() const {
  bool result{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::PrivateCommon::IModelManager3>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::IModelManager3, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    IModelManager3>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->IsModelCacheReady(&result));
  } else {
    auto const _winrt_abi_type = *(
        abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)this;
    check_hresult(_winrt_abi_type->IsModelCacheReady(&result));
  }
  return result;
}
template <typename D>
auto consume_Microsoft_Windows_PrivateCommon_INotifyExpiredSessionHost<
    D>::NotifyExpiredSessionHost() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::
                                       INotifyExpiredSessionHost>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    INotifyExpiredSessionHost>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->NotifyExpiredSessionHost(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::PrivateCommon::
                    INotifyExpiredSessionHost>**)this;
    check_hresult(_winrt_abi_type->NotifyExpiredSessionHost(&operation));
  }
  return winrt::Windows::Foundation::IAsyncAction{operation,
                                                  take_ownership_from_abi};
}
template <typename D>
struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance>
    : produce_base<D,
                   winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance> {
  int32_t __stdcall AnchorInstance(void* instance) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().AnchorInstance(
        *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(
            &instance));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId>
    : produce_base<
          D,
          winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId> {
  int32_t __stdcall GetSessionHostProcessId(uint32_t* result) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<uint32_t>(this->shim().GetSessionHostProcessId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>
    : produce_base<
          D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate> {
  int32_t __stdcall GetImageBufferView(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView*
          result) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView>(result);
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView>(
            this->shim().GetImageBufferView());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetImageBufferViewData(
      uint32_t targetProcessId,
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData*
          result) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData>(
        result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData>(
        this->shim().GetImageBufferViewData(targetProcessId));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SyncBufferWithOutValue() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SyncBufferWithOutValue();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetImageBufferResource(void* sessionAsInspectable,
                                           void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource>(
        this->shim().GetImageBufferResource(
            *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(
                &sessionAsInspectable)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>
    : produce_base<
          D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource> {
  int32_t __stdcall get_BufferData(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferData*
          value) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::PrivateCommon::ImageBufferData>(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferData>(
            this->shim().BufferData());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_BufferData(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferData
          value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().BufferData(
        *reinterpret_cast<
            winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Buffer(uint64_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<uint64_t>(this->shim().Buffer());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Width(uint32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<uint32_t>(this->shim().Width());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Height(uint32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<uint32_t>(this->shim().Height());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall RowStride(uint32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<uint32_t>(this->shim().RowStride());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall BytesPerPixel(uint32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<uint32_t>(this->shim().BytesPerPixel());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Capacity(uint32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<uint32_t>(this->shim().Capacity());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall PixelFormat(int32_t* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result =
        detach_from<winrt::Microsoft::Windows::PrivateCommon::PixelFormat>(
            this->shim().PixelFormat());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>
    : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::
                          IImageBufferResourceFactory> {
  int32_t __stdcall CreateInstance(
      struct struct_Microsoft_Windows_PrivateCommon_ImageBufferData bufferData,
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource>(
        this->shim().CreateInstance(
            *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::
                                  ImageBufferData const*>(&bufferData)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateInstance2(uint32_t height, uint32_t width,
                                    int32_t pixelFormat, uint32_t rowStride,
                                    uint64_t targetProcessHandle,
                                    uint64_t sourceProcessHandle,
                                    void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource>(
        this->shim().CreateInstance2(
            height, width,
            *reinterpret_cast<
                winrt::Microsoft::Windows::PrivateCommon::PixelFormat const*>(
                &pixelFormat),
            rowStride, targetProcessHandle, sourceProcessHandle));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
template <typename D>
struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager>
    : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager> {
  int32_t __stdcall EnsureModelInitialized() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().EnsureModelInitialized();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GenerateCacheModel(void* offlineDriverPath) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().GenerateCacheModel(
        *reinterpret_cast<hstring const*>(&offlineDriverPath));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager2>
    : produce_base<D,
                   winrt::Microsoft::Windows::PrivateCommon::IModelManager2> {
  int32_t __stdcall SetPackageFamilyName(void* packageFamilyName) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetPackageFamilyName(
        *reinterpret_cast<hstring const*>(&packageFamilyName));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager3>
    : produce_base<D,
                   winrt::Microsoft::Windows::PrivateCommon::IModelManager3> {
  int32_t __stdcall GenerateCacheModel() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().GenerateCacheModel();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall SetCorrelationVector(void* correlationVector) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SetCorrelationVector(
        *reinterpret_cast<hstring const*>(&correlationVector));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall IsModelCacheReady(bool* result) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *result = detach_from<bool>(this->shim().IsModelCacheReady());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost>
    : produce_base<
          D,
          winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost> {
  int32_t __stdcall NotifyExpiredSessionHost(void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(
        this->shim().NotifyExpiredSessionHost());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::PrivateCommon {
  inline ImageBufferResource::ImageBufferResource()
      : ImageBufferResource(
            impl::call_factory_cast<
                ImageBufferResource (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                ImageBufferResource>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<ImageBufferResource>();
                })) {}
  inline ImageBufferResource::ImageBufferResource(
      winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const&
          bufferData)
      : ImageBufferResource(impl::call_factory<ImageBufferResource,
                                               IImageBufferResourceFactory>(
            [&](IImageBufferResourceFactory const& f) {
              return f.CreateInstance(bufferData);
            })) {}
  inline ImageBufferResource::ImageBufferResource(
      uint32_t height, uint32_t width,
      winrt::Microsoft::Windows::PrivateCommon::PixelFormat const& pixelFormat,
      uint32_t rowStride, uint64_t targetProcessHandle,
      uint64_t sourceProcessHandle)
      : ImageBufferResource(impl::call_factory<ImageBufferResource,
                                               IImageBufferResourceFactory>(
            [&](IImageBufferResourceFactory const& f) {
              return f.CreateInstance2(height, width, pixelFormat, rowStride,
                                       targetProcessHandle,
                                       sourceProcessHandle);
            })) {}
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>
    : winrt::impl::hash_base {};
template <>
struct hash<
    winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::IModelManager>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::IModelManager2>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
