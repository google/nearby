// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Windows_Devices_Sensors_H
#define WINRT_Windows_Devices_Sensors_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Windows.Devices.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.Display.2.h"
#include "winrt/impl/Windows.Devices.Sensors.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::AccelerometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::Shaken(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Shaken(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            check_hresult(_winrt_abi_type->add_Shaken(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::Shaken(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Shaken_revoker>(this, Shaken(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer<D>::Shaken(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Shaken(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer>**)this;
            _winrt_abi_type->remove_Shaken(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer2<D>::ReadingTransform(winrt::Windows::Graphics::Display::DisplayOrientations const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer2>**)this;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer2<D>::ReadingTransform() const
    {
        winrt::Windows::Graphics::Display::DisplayOrientations value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer3<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer3>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer3<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer3>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer3<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer3>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer4<D>::ReadingType() const
    {
        winrt::Windows::Devices::Sensors::AccelerometerReadingType type{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingType(reinterpret_cast<int32_t*>(&type)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer4>**)this;
            check_hresult(_winrt_abi_type->get_ReadingType(reinterpret_cast<int32_t*>(&type)));
        }
        return type;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometer5<D>::ReportThreshold() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometer5>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometer5, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer5>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometer5>**)this;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        return winrt::Windows::Devices::Sensors::AccelerometerDataThreshold{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerDataThreshold<D>::XAxisInGForce() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_XAxisInGForce(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_XAxisInGForce(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerDataThreshold<D>::XAxisInGForce(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_XAxisInGForce(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_XAxisInGForce(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerDataThreshold<D>::YAxisInGForce() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YAxisInGForce(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_YAxisInGForce(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerDataThreshold<D>::YAxisInGForce(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_YAxisInGForce(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_YAxisInGForce(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerDataThreshold<D>::ZAxisInGForce() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ZAxisInGForce(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_ZAxisInGForce(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerDataThreshold<D>::ZAxisInGForce(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ZAxisInGForce(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_ZAxisInGForce(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerReading<D>::AccelerationX() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AccelerationX(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)this;
            check_hresult(_winrt_abi_type->get_AccelerationX(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerReading<D>::AccelerationY() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AccelerationY(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)this;
            check_hresult(_winrt_abi_type->get_AccelerationY(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerReading<D>::AccelerationZ() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AccelerationZ(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading>**)this;
            check_hresult(_winrt_abi_type->get_AccelerationZ(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::AccelerometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerShakenEventArgs<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerShakenEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerShakenEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerShakenEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerShakenEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::Accelerometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerStatics2<D>::GetDefault(winrt::Windows::Devices::Sensors::AccelerometerReadingType const& readingType) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultWithAccelerometerReadingType(static_cast<int32_t>(readingType), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDefaultWithAccelerometerReadingType(static_cast<int32_t>(readingType), &result));
        }
        return winrt::Windows::Devices::Sensors::Accelerometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerStatics3<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerStatics3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics3>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Accelerometer>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAccelerometerStatics3<D>::GetDeviceSelector(winrt::Windows::Devices::Sensors::AccelerometerReadingType const& readingType) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAccelerometerStatics3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(static_cast<int32_t>(readingType), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAccelerometerStatics3>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(static_cast<int32_t>(readingType), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::GetCurrentReadingAsync() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReadingAsync(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReadingAsync(&result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::ActivitySensorReading>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::SubscribedActivities() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SubscribedActivities(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            check_hresult(_winrt_abi_type->get_SubscribedActivities(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Devices::Sensors::ActivityType>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::PowerInMilliwatts() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PowerInMilliwatts(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            check_hresult(_winrt_abi_type->get_PowerInMilliwatts(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::SupportedActivities() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SupportedActivities(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            check_hresult(_winrt_abi_type->get_SupportedActivities(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivityType>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ActivitySensor, winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ActivitySensor, winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensor<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensor>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorReading<D>::Activity() const
    {
        winrt::Windows::Devices::Sensors::ActivityType value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Activity(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Activity(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorReading<D>::Confidence() const
    {
        winrt::Windows::Devices::Sensors::ActivitySensorReadingConfidence value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Confidence(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Confidence(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorReadingChangeReport<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorReadingChangeReport>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangeReport, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangeReport>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangeReport>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::ActivitySensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::ActivitySensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorStatics<D>::GetDefaultAsync() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::ActivitySensor>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorStatics<D>::GetDeviceSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorStatics<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::ActivitySensor>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorStatics<D>::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSystemHistoryAsync(impl::bind_in(fromTime), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetSystemHistoryAsync(impl::bind_in(fromTime), &result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivitySensorReading>>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorStatics<D>::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime, winrt::Windows::Foundation::TimeSpan const& duration) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSystemHistoryWithDurationAsync(impl::bind_in(fromTime), impl::bind_in(duration), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetSystemHistoryWithDurationAsync(impl::bind_in(fromTime), impl::bind_in(duration), &result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivitySensorReading>>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IActivitySensorTriggerDetails<D>::ReadReports() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IActivitySensorTriggerDetails>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IActivitySensorTriggerDetails, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorTriggerDetails>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ReadReports(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IActivitySensorTriggerDetails>**)this;
            check_hresult(_winrt_abi_type->ReadReports(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAdaptiveDimmingOptions<D>::AllowWhenExternalDisplayConnected() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowWhenExternalDisplayConnected(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions>**)this;
            check_hresult(_winrt_abi_type->get_AllowWhenExternalDisplayConnected(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAdaptiveDimmingOptions<D>::AllowWhenExternalDisplayConnected(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowWhenExternalDisplayConnected(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions>**)this;
            check_hresult(_winrt_abi_type->put_AllowWhenExternalDisplayConnected(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::AltimeterReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Altimeter, winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Altimeter, winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter2<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter2>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter2<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter2>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeter2<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeter2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeter2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeter2>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeterReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeterReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeterReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeterReading<D>::AltitudeChangeInMeters() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeterReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeterReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AltitudeChangeInMeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading>**)this;
            check_hresult(_winrt_abi_type->get_AltitudeChangeInMeters(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeterReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeterReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeterReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeterReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeterReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeterReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeterReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeterReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeterReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::AltimeterReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IAltimeterStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IAltimeterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IAltimeterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IAltimeterStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::Altimeter{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::BarometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Barometer, winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Barometer, winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer2<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer2>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer2<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer2>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer2<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer2>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometer3<D>::ReportThreshold() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometer3>**)this;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        return winrt::Windows::Devices::Sensors::BarometerDataThreshold{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerDataThreshold<D>::Hectopascals() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Hectopascals(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_Hectopascals(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerDataThreshold<D>::Hectopascals(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Hectopascals(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_Hectopascals(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerReading<D>::StationPressureInHectopascals() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StationPressureInHectopascals(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading>**)this;
            check_hresult(_winrt_abi_type->get_StationPressureInHectopascals(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::BarometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::Barometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerStatics2<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerStatics2>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Barometer>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IBarometerStatics2<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IBarometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IBarometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IBarometerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::CompassReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Compass, winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Compass, winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass2<D>::ReadingTransform(winrt::Windows::Graphics::Display::DisplayOrientations const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass2>**)this;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass2<D>::ReadingTransform() const
    {
        winrt::Windows::Graphics::Display::DisplayOrientations value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass3<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass3>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass3<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass3>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass3<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass3>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompass4<D>::ReportThreshold() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompass4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompass4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompass4>**)this;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        return winrt::Windows::Devices::Sensors::CompassDataThreshold{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassDataThreshold<D>::Degrees() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Degrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_Degrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassDataThreshold<D>::Degrees(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Degrees(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_Degrees(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassReading<D>::HeadingMagneticNorth() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeadingMagneticNorth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading>**)this;
            check_hresult(_winrt_abi_type->get_HeadingMagneticNorth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassReading<D>::HeadingTrueNorth() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeadingTrueNorth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading>**)this;
            check_hresult(_winrt_abi_type->get_HeadingTrueNorth(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::CompassReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassReadingHeadingAccuracy<D>::HeadingAccuracy() const
    {
        winrt::Windows::Devices::Sensors::MagnetometerAccuracy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassReadingHeadingAccuracy>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassReadingHeadingAccuracy, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReadingHeadingAccuracy>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeadingAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassReadingHeadingAccuracy>**)this;
            check_hresult(_winrt_abi_type->get_HeadingAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::Compass{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassStatics2<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ICompassStatics2<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ICompassStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ICompassStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ICompassStatics2>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Compass>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IDetectedPerson<D>::Engagement() const
    {
        winrt::Windows::Devices::Sensors::HumanEngagement value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IDetectedPerson>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IDetectedPerson, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Engagement(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)this;
            check_hresult(_winrt_abi_type->get_Engagement(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IDetectedPerson<D>::DistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IDetectedPerson>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IDetectedPerson, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)this;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IDetectedPerson<D>::HeadOrientation() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IDetectedPerson>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IDetectedPerson, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeadOrientation(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)this;
            check_hresult(_winrt_abi_type->get_HeadOrientation(&value));
        }
        return winrt::Windows::Devices::Sensors::HeadOrientation{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IDetectedPerson<D>::HeadPosition() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IDetectedPerson>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IDetectedPerson, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeadPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)this;
            check_hresult(_winrt_abi_type->get_HeadPosition(&value));
        }
        return winrt::Windows::Devices::Sensors::HeadPosition{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IDetectedPerson<D>::PersonId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IDetectedPerson>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IDetectedPerson, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PersonId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IDetectedPerson>**)this;
            check_hresult(_winrt_abi_type->get_PersonId(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::GyrometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Gyrometer, winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Gyrometer, winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer2<D>::ReadingTransform(winrt::Windows::Graphics::Display::DisplayOrientations const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer2>**)this;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer2<D>::ReadingTransform() const
    {
        winrt::Windows::Graphics::Display::DisplayOrientations value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer3<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer3>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer3<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer3>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer3<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer3>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometer4<D>::ReportThreshold() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometer4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometer4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometer4>**)this;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        return winrt::Windows::Devices::Sensors::GyrometerDataThreshold{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerDataThreshold<D>::XAxisInDegreesPerSecond() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_XAxisInDegreesPerSecond(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_XAxisInDegreesPerSecond(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerDataThreshold<D>::XAxisInDegreesPerSecond(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_XAxisInDegreesPerSecond(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_XAxisInDegreesPerSecond(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerDataThreshold<D>::YAxisInDegreesPerSecond() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YAxisInDegreesPerSecond(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_YAxisInDegreesPerSecond(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerDataThreshold<D>::YAxisInDegreesPerSecond(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_YAxisInDegreesPerSecond(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_YAxisInDegreesPerSecond(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerDataThreshold<D>::ZAxisInDegreesPerSecond() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ZAxisInDegreesPerSecond(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_ZAxisInDegreesPerSecond(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerDataThreshold<D>::ZAxisInDegreesPerSecond(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ZAxisInDegreesPerSecond(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_ZAxisInDegreesPerSecond(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerReading<D>::AngularVelocityX() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AngularVelocityX(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)this;
            check_hresult(_winrt_abi_type->get_AngularVelocityX(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerReading<D>::AngularVelocityY() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AngularVelocityY(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)this;
            check_hresult(_winrt_abi_type->get_AngularVelocityY(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerReading<D>::AngularVelocityZ() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AngularVelocityZ(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading>**)this;
            check_hresult(_winrt_abi_type->get_AngularVelocityZ(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::GyrometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::Gyrometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerStatics2<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IGyrometerStatics2<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IGyrometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IGyrometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IGyrometerStatics2>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Gyrometer>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHeadOrientation<D>::RollInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHeadOrientation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHeadOrientation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadOrientation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RollInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadOrientation>**)this;
            check_hresult(_winrt_abi_type->get_RollInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHeadOrientation<D>::PitchInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHeadOrientation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHeadOrientation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadOrientation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PitchInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadOrientation>**)this;
            check_hresult(_winrt_abi_type->get_PitchInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHeadOrientation<D>::YawInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHeadOrientation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHeadOrientation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadOrientation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YawInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadOrientation>**)this;
            check_hresult(_winrt_abi_type->get_YawInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHeadPosition<D>::AzimuthInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHeadPosition>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHeadPosition, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadPosition>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AzimuthInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadPosition>**)this;
            check_hresult(_winrt_abi_type->get_AzimuthInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHeadPosition<D>::AltitudeInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHeadPosition>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHeadPosition, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadPosition>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AltitudeInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHeadPosition>**)this;
            check_hresult(_winrt_abi_type->get_AltitudeInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleReading<D>::AngleInDegrees() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AngleInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleReading>**)this;
            check_hresult(_winrt_abi_type->get_AngleInDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleReading<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleReading>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::GetCurrentReadingAsync() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReadingAsync(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReadingAsync(&value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleReading>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::MinReportThresholdInDegrees() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinReportThresholdInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)this;
            check_hresult(_winrt_abi_type->get_MinReportThresholdInDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::ReportThresholdInDegrees() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThresholdInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)this;
            check_hresult(_winrt_abi_type->get_ReportThresholdInDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::ReportThresholdInDegrees(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportThresholdInDegrees(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)this;
            check_hresult(_winrt_abi_type->put_ReportThresholdInDegrees(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HingeAngleSensor, winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HingeAngleSensor, winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensor<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensor>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensorReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensorReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::HingeAngleReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensorStatics<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensorStatics<D>::GetDefaultAsync() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleSensor>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensorStatics<D>::GetRelatedToAdjacentPanelsAsync(param::hstring const& firstPanelId, param::hstring const& secondPanelId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetRelatedToAdjacentPanelsAsync(*(void**)(&firstPanelId), *(void**)(&secondPanelId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetRelatedToAdjacentPanelsAsync(*(void**)(&firstPanelId), *(void**)(&secondPanelId), &result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleSensor>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHingeAngleSensorStatics<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleSensor>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceFeatures<D>::SensorId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SensorId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)this;
            check_hresult(_winrt_abi_type->get_SensorId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceFeatures<D>::SupportedWakeOrLockDistancesInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SupportedWakeOrLockDistancesInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)this;
            check_hresult(_winrt_abi_type->get_SupportedWakeOrLockDistancesInMillimeters(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceFeatures<D>::IsWakeOnApproachSupported() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsWakeOnApproachSupported(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)this;
            check_hresult(_winrt_abi_type->get_IsWakeOnApproachSupported(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceFeatures<D>::IsLockOnLeaveSupported() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsLockOnLeaveSupported(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)this;
            check_hresult(_winrt_abi_type->get_IsLockOnLeaveSupported(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceFeatures<D>::IsAttentionAwareDimmingSupported() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAttentionAwareDimmingSupported(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>**)this;
            check_hresult(_winrt_abi_type->get_IsAttentionAwareDimmingSupported(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceFeatures2<D>::IsAdaptiveDimmingSupported() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAdaptiveDimmingSupported(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures2>**)this;
            check_hresult(_winrt_abi_type->get_IsAdaptiveDimmingSupported(&value));
        }
        return value;
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IHumanPresenceFeatures3<
        D>::IsOnlookerDetectionSupported() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IHumanPresenceFeatures3>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IHumanPresenceFeatures3,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceFeatures3>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_IsOnlookerDetectionSupported(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceFeatures3>**)this;
        check_hresult(
            _winrt_abi_type->get_IsOnlookerDetectionSupported(&value));
      }
      return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor<D>::MaxDetectableDistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxDetectableDistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)this;
            check_hresult(_winrt_abi_type->get_MaxDetectableDistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor<D>::MinDetectableDistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinDetectableDistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)this;
            check_hresult(_winrt_abi_type->get_MinDetectableDistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor<D>::GetCurrentReading() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&result));
        }
        return winrt::Windows::Devices::Sensors::HumanPresenceSensorReading{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HumanPresenceSensor, winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HumanPresenceSensor, winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor2<D>::IsPresenceSupported() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPresenceSupported(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor2>**)this;
            check_hresult(_winrt_abi_type->get_IsPresenceSupported(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor2<D>::IsEngagementSupported() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsEngagementSupported(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor2>**)this;
            check_hresult(_winrt_abi_type->get_IsEngagementSupported(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor3<D>::MaxDetectablePersons() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxDetectablePersons(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)this;
            check_hresult(_winrt_abi_type->get_MaxDetectablePersons(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor3<D>::MinDetectableAzimuthInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinDetectableAzimuthInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)this;
            check_hresult(_winrt_abi_type->get_MinDetectableAzimuthInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor3<D>::MaxDetectableAzimuthInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxDetectableAzimuthInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)this;
            check_hresult(_winrt_abi_type->get_MaxDetectableAzimuthInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor3<D>::MinDetectableAltitudeInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinDetectableAltitudeInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)this;
            check_hresult(_winrt_abi_type->get_MinDetectableAltitudeInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensor3<D>::MaxDetectableAltitudeInDegrees() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxDetectableAltitudeInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>**)this;
            check_hresult(_winrt_abi_type->get_MaxDetectableAltitudeInDegrees(&value));
        }
        return winrt::Windows::Foundation::IReference<double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorExtension<D>::Initialize(param::hstring const& deviceInterface) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Initialize(*(void**)(&deviceInterface)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)this;
            check_hresult(_winrt_abi_type->Initialize(*(void**)(&deviceInterface)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorExtension<D>::Start() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Start());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)this;
            check_hresult(_winrt_abi_type->Start());
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorExtension<D>::ProcessReading(winrt::Windows::Devices::Sensors::HumanPresenceSensorReading const& reading) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessReading(*(void**)(&reading), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)this;
            check_hresult(_winrt_abi_type->ProcessReading(*(void**)(&reading), &result));
        }
        return winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorExtension<D>::ProcessReadingTimeoutExpired(winrt::Windows::Devices::Sensors::HumanPresenceSensorReading const& reading) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessReadingTimeoutExpired(*(void**)(&reading)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)this;
            check_hresult(_winrt_abi_type->ProcessReadingTimeoutExpired(*(void**)(&reading)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorExtension<D>::Stop() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Stop());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)this;
            check_hresult(_winrt_abi_type->Stop());
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorExtension<D>::Uninitialize() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Uninitialize());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)this;
            check_hresult(_winrt_abi_type->Uninitialize());
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorExtension<D>::Reset() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Reset());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>**)this;
            check_hresult(_winrt_abi_type->Reset());
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReading<D>::Presence() const
    {
        winrt::Windows::Devices::Sensors::HumanPresence value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Presence(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Presence(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReading<D>::Engagement() const
    {
        winrt::Windows::Devices::Sensors::HumanEngagement value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Engagement(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Engagement(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReading<D>::DistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReading3<D>::OnlookerPresence() const
    {
        winrt::Windows::Devices::Sensors::HumanPresence value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OnlookerPresence(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3>**)this;
            check_hresult(_winrt_abi_type->get_OnlookerPresence(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReading3<D>::DetectedPersons() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DetectedPersons(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3>**)this;
            check_hresult(_winrt_abi_type->get_DetectedPersons(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::DetectedPerson>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::HumanPresenceSensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::Timestamp() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::Timestamp(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Timestamp(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->put_Timestamp(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::Presence() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Presence(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->get_Presence(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanPresence>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::Presence(winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanPresence> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Presence(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->put_Presence(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::Engagement() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Engagement(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->get_Engagement(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanEngagement>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::Engagement(winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanEngagement> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Engagement(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->put_Engagement(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::DistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate<D>::DistanceInMillimeters(winrt::Windows::Foundation::IReference<uint32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DistanceInMillimeters(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>**)this;
            check_hresult(_winrt_abi_type->put_DistanceInMillimeters(*(void**)(&value)));
        }
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate2<
        D>::OnlookerPresence() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Devices::Sensors::
                                        IHumanPresenceSensorReadingUpdate2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Devices::Sensors::
                                         IHumanPresenceSensorReadingUpdate2,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Devices::Sensors::
                    IHumanPresenceSensorReadingUpdate2>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_OnlookerPresence(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSensorReadingUpdate2>**)this;
        check_hresult(_winrt_abi_type->get_OnlookerPresence(&value));
      }
      return winrt::Windows::Foundation::IReference<
          winrt::Windows::Devices::Sensors::HumanPresence>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IHumanPresenceSensorReadingUpdate2<D>::
        OnlookerPresence(winrt::Windows::Foundation::IReference<
                         winrt::Windows::Devices::Sensors::HumanPresence> const&
                             value) const {
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Devices::Sensors::
                                        IHumanPresenceSensorReadingUpdate2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Devices::Sensors::
                                         IHumanPresenceSensorReadingUpdate2,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Devices::Sensors::
                    IHumanPresenceSensorReadingUpdate2>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_OnlookerPresence(*(void**)(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSensorReadingUpdate2>**)this;
        check_hresult(_winrt_abi_type->put_OnlookerPresence(*(void**)(&value)));
      }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorStatics<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorStatics<D>::FromIdAsync(param::hstring const& sensorId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&sensorId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&sensorId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HumanPresenceSensor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorStatics<D>::GetDefaultAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HumanPresenceSensor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorStatics2<D>::FromId(param::hstring const& sensorId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromId(*(void**)(&sensorId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2>**)this;
            check_hresult(_winrt_abi_type->FromId(*(void**)(&sensorId), &result));
        }
        return winrt::Windows::Devices::Sensors::HumanPresenceSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSensorStatics2<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::HumanPresenceSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::SensorId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SensorId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->get_SensorId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::SensorId(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SensorId(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->put_SensorId(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::IsWakeOnApproachEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsWakeOnApproachEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->get_IsWakeOnApproachEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::IsWakeOnApproachEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsWakeOnApproachEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->put_IsWakeOnApproachEnabled(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::WakeOnApproachDistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_WakeOnApproachDistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->get_WakeOnApproachDistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::WakeOnApproachDistanceInMillimeters(winrt::Windows::Foundation::IReference<uint32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_WakeOnApproachDistanceInMillimeters(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->put_WakeOnApproachDistanceInMillimeters(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::IsLockOnLeaveEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsLockOnLeaveEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->get_IsLockOnLeaveEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::IsLockOnLeaveEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsLockOnLeaveEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->put_IsLockOnLeaveEnabled(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::LockOnLeaveDistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LockOnLeaveDistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->get_LockOnLeaveDistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::LockOnLeaveDistanceInMillimeters(winrt::Windows::Foundation::IReference<uint32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LockOnLeaveDistanceInMillimeters(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->put_LockOnLeaveDistanceInMillimeters(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::LockOnLeaveTimeout() const
    {
        winrt::Windows::Foundation::TimeSpan value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LockOnLeaveTimeout(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->get_LockOnLeaveTimeout(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::LockOnLeaveTimeout(winrt::Windows::Foundation::TimeSpan const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LockOnLeaveTimeout(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->put_LockOnLeaveTimeout(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::IsAttentionAwareDimmingEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAttentionAwareDimmingEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->get_IsAttentionAwareDimmingEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings<D>::IsAttentionAwareDimmingEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsAttentionAwareDimmingEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings>**)this;
            check_hresult(_winrt_abi_type->put_IsAttentionAwareDimmingEnabled(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings2<D>::IsAdaptiveDimmingEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAdaptiveDimmingEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)this;
            check_hresult(_winrt_abi_type->get_IsAdaptiveDimmingEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings2<D>::IsAdaptiveDimmingEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsAdaptiveDimmingEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)this;
            check_hresult(_winrt_abi_type->put_IsAdaptiveDimmingEnabled(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings2<D>::WakeOptions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_WakeOptions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)this;
            check_hresult(_winrt_abi_type->get_WakeOptions(&value));
        }
        return winrt::Windows::Devices::Sensors::WakeOnApproachOptions{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings2<D>::DimmingOptions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DimmingOptions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)this;
            check_hresult(_winrt_abi_type->get_DimmingOptions(&value));
        }
        return winrt::Windows::Devices::Sensors::AdaptiveDimmingOptions{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettings2<D>::LockOptions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LockOptions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>**)this;
            check_hresult(_winrt_abi_type->get_LockOptions(&value));
        }
        return winrt::Windows::Devices::Sensors::LockOnLeaveOptions{ value, take_ownership_from_abi };
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IHumanPresenceSettings3<
        D>::IsOnlookerDetectionEnabled() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IHumanPresenceSettings3>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IHumanPresenceSettings3,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSettings3>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_IsOnlookerDetectionEnabled(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSettings3>**)this;
        check_hresult(_winrt_abi_type->get_IsOnlookerDetectionEnabled(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IHumanPresenceSettings3<
        D>::IsOnlookerDetectionEnabled(bool value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IHumanPresenceSettings3>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IHumanPresenceSettings3,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSettings3>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_IsOnlookerDetectionEnabled(value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSettings3>**)this;
        check_hresult(_winrt_abi_type->put_IsOnlookerDetectionEnabled(value));
      }
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IHumanPresenceSettings3<
        D>::OnlookerDetectionOptions() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IHumanPresenceSettings3>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IHumanPresenceSettings3,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSettings3>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_OnlookerDetectionOptions(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IHumanPresenceSettings3>**)this;
        check_hresult(_winrt_abi_type->get_OnlookerDetectionOptions(&value));
      }
      return winrt::Windows::Devices::Sensors::OnlookerDetectionOptions{
          value, take_ownership_from_abi};
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::GetCurrentSettingsAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentSettingsAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->GetCurrentSettingsAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HumanPresenceSettings>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::GetCurrentSettings() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentSettings(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->GetCurrentSettings(&result));
        }
        return winrt::Windows::Devices::Sensors::HumanPresenceSettings{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::UpdateSettingsAsync(winrt::Windows::Devices::Sensors::HumanPresenceSettings const& settings) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->UpdateSettingsAsync(*(void**)(&settings), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->UpdateSettingsAsync(*(void**)(&settings), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::UpdateSettings(winrt::Windows::Devices::Sensors::HumanPresenceSettings const& settings) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->UpdateSettings(*(void**)(&settings)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->UpdateSettings(*(void**)(&settings)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::GetSupportedFeaturesForSensorIdAsync(param::hstring const& sensorId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSupportedFeaturesForSensorIdAsync(*(void**)(&sensorId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->GetSupportedFeaturesForSensorIdAsync(*(void**)(&sensorId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::GetSupportedFeaturesForSensorId(param::hstring const& sensorId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSupportedFeaturesForSensorId(*(void**)(&sensorId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->GetSupportedFeaturesForSensorId(*(void**)(&sensorId), &result));
        }
        return winrt::Windows::Devices::Sensors::HumanPresenceFeatures{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::GetSupportedLockOnLeaveTimeouts() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSupportedLockOnLeaveTimeouts(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->GetSupportedLockOnLeaveTimeouts(&result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::TimeSpan>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::SettingsChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SettingsChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->add_SettingsChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::SettingsChanged(auto_revoke_t, winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, SettingsChanged_revoker>(this, SettingsChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IHumanPresenceSettingsStatics<D>::SettingsChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SettingsChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>**)this;
            _winrt_abi_type->remove_SettingsChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::InclinometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Inclinometer, winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Inclinometer, winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer2<D>::ReadingTransform(winrt::Windows::Graphics::Display::DisplayOrientations const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer2>**)this;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer2<D>::ReadingTransform() const
    {
        winrt::Windows::Graphics::Display::DisplayOrientations value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer2<D>::ReadingType() const
    {
        winrt::Windows::Devices::Sensors::SensorReadingType type{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingType(reinterpret_cast<int32_t*>(&type)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingType(reinterpret_cast<int32_t*>(&type)));
        }
        return type;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer3<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer3>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer3<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer3>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer3<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer3>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometer4<D>::ReportThreshold() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometer4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometer4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometer4>**)this;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        return winrt::Windows::Devices::Sensors::InclinometerDataThreshold{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerDataThreshold<D>::PitchInDegrees() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PitchInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_PitchInDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerDataThreshold<D>::PitchInDegrees(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PitchInDegrees(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_PitchInDegrees(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerDataThreshold<D>::RollInDegrees() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RollInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_RollInDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerDataThreshold<D>::RollInDegrees(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RollInDegrees(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_RollInDegrees(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerDataThreshold<D>::YawInDegrees() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YawInDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_YawInDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerDataThreshold<D>::YawInDegrees(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_YawInDegrees(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_YawInDegrees(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReading<D>::PitchDegrees() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PitchDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)this;
            check_hresult(_winrt_abi_type->get_PitchDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReading<D>::RollDegrees() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RollDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)this;
            check_hresult(_winrt_abi_type->get_RollDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReading<D>::YawDegrees() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YawDegrees(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading>**)this;
            check_hresult(_winrt_abi_type->get_YawDegrees(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::InclinometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerReadingYawAccuracy<D>::YawAccuracy() const
    {
        winrt::Windows::Devices::Sensors::MagnetometerAccuracy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerReadingYawAccuracy>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerReadingYawAccuracy, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReadingYawAccuracy>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YawAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerReadingYawAccuracy>**)this;
            check_hresult(_winrt_abi_type->get_YawAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::Inclinometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerStatics2<D>::GetDefaultForRelativeReadings() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultForRelativeReadings(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDefaultForRelativeReadings(&result));
        }
        return winrt::Windows::Devices::Sensors::Inclinometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerStatics3<D>::GetDefault(winrt::Windows::Devices::Sensors::SensorReadingType const& sensorReadingtype) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerStatics3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerStatics3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultWithSensorReadingType(static_cast<int32_t>(sensorReadingtype), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics3>**)this;
            check_hresult(_winrt_abi_type->GetDefaultWithSensorReadingType(static_cast<int32_t>(sensorReadingtype), &result));
        }
        return winrt::Windows::Devices::Sensors::Inclinometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerStatics4<D>::GetDeviceSelector(winrt::Windows::Devices::Sensors::SensorReadingType const& readingType) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerStatics4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerStatics4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(static_cast<int32_t>(readingType), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics4>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(static_cast<int32_t>(readingType), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IInclinometerStatics4<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IInclinometerStatics4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IInclinometerStatics4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IInclinometerStatics4>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Inclinometer>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::LightSensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::LightSensor, winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::LightSensor, winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor2<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor2>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor2<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor2>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor2<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor2>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensor3<D>::ReportThreshold() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor3>**)this;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        return winrt::Windows::Devices::Sensors::LightSensorDataThreshold{ value, take_ownership_from_abi };
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_ILightSensor4<
        D>::IsChromaticitySupported() const {
      bool supported{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Devices::Sensors::ILightSensor4>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::ILightSensor4, D const*>(
            static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        ILightSensor4>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->IsChromaticitySupported(&supported));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::ILightSensor4>**)this;
        check_hresult(_winrt_abi_type->IsChromaticitySupported(&supported));
      }
      return supported;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorDataThreshold<D>::LuxPercentage() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LuxPercentage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_LuxPercentage(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorDataThreshold<D>::LuxPercentage(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LuxPercentage(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_LuxPercentage(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorDataThreshold<D>::AbsoluteLux() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AbsoluteLux(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_AbsoluteLux(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorDataThreshold<D>::AbsoluteLux(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AbsoluteLux(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_AbsoluteLux(value));
        }
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_ILightSensorDataThreshold2<
        D>::Chromaticity() const {
      winrt::Windows::Devices::Sensors::LightSensorChromaticity value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           ILightSensorDataThreshold2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::ILightSensorDataThreshold2,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        ILightSensorDataThreshold2>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Chromaticity(put_abi(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        ILightSensorDataThreshold2>**)this;
        check_hresult(_winrt_abi_type->get_Chromaticity(put_abi(value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Devices_Sensors_ILightSensorDataThreshold2<D>::Chromaticity(
        winrt::Windows::Devices::Sensors::LightSensorChromaticity const& value)
        const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           ILightSensorDataThreshold2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::ILightSensorDataThreshold2,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        ILightSensorDataThreshold2>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_Chromaticity(impl::bind_in(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        ILightSensorDataThreshold2>**)this;
        check_hresult(_winrt_abi_type->put_Chromaticity(impl::bind_in(value)));
      }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorReading<D>::IlluminanceInLux() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IlluminanceInLux(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_IlluminanceInLux(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_ILightSensorReading3<D>::Chromaticity()
        const {
      winrt::Windows::Devices::Sensors::LightSensorChromaticity value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           ILightSensorReading3>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::ILightSensorReading3, D const*>(
            static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        ILightSensorReading3>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Chromaticity(put_abi(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Devices::Sensors::ILightSensorReading3>**)this;
        check_hresult(_winrt_abi_type->get_Chromaticity(put_abi(value)));
      }
      return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::LightSensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::LightSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorStatics2<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILightSensorStatics2<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILightSensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILightSensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILightSensorStatics2>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::LightSensor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILockOnLeaveOptions<D>::AllowWhenExternalDisplayConnected() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILockOnLeaveOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILockOnLeaveOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILockOnLeaveOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowWhenExternalDisplayConnected(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILockOnLeaveOptions>**)this;
            check_hresult(_winrt_abi_type->get_AllowWhenExternalDisplayConnected(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ILockOnLeaveOptions<D>::AllowWhenExternalDisplayConnected(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ILockOnLeaveOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ILockOnLeaveOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILockOnLeaveOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowWhenExternalDisplayConnected(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ILockOnLeaveOptions>**)this;
            check_hresult(_winrt_abi_type->put_AllowWhenExternalDisplayConnected(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::MagnetometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Magnetometer, winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Magnetometer, winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer2<D>::ReadingTransform(winrt::Windows::Graphics::Display::DisplayOrientations const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer2>**)this;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer2<D>::ReadingTransform() const
    {
        winrt::Windows::Graphics::Display::DisplayOrientations value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer3<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer3>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer3<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer3>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer3<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer3>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometer4<D>::ReportThreshold() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometer4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometer4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometer4>**)this;
            check_hresult(_winrt_abi_type->get_ReportThreshold(&value));
        }
        return winrt::Windows::Devices::Sensors::MagnetometerDataThreshold{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerDataThreshold<D>::XAxisMicroteslas() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_XAxisMicroteslas(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_XAxisMicroteslas(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerDataThreshold<D>::XAxisMicroteslas(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_XAxisMicroteslas(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_XAxisMicroteslas(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerDataThreshold<D>::YAxisMicroteslas() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YAxisMicroteslas(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_YAxisMicroteslas(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerDataThreshold<D>::YAxisMicroteslas(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_YAxisMicroteslas(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_YAxisMicroteslas(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerDataThreshold<D>::ZAxisMicroteslas() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ZAxisMicroteslas(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->get_ZAxisMicroteslas(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerDataThreshold<D>::ZAxisMicroteslas(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ZAxisMicroteslas(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>**)this;
            check_hresult(_winrt_abi_type->put_ZAxisMicroteslas(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReading<D>::MagneticFieldX() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MagneticFieldX(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)this;
            check_hresult(_winrt_abi_type->get_MagneticFieldX(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReading<D>::MagneticFieldY() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MagneticFieldY(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)this;
            check_hresult(_winrt_abi_type->get_MagneticFieldY(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReading<D>::MagneticFieldZ() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MagneticFieldZ(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)this;
            check_hresult(_winrt_abi_type->get_MagneticFieldZ(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReading<D>::DirectionalAccuracy() const
    {
        winrt::Windows::Devices::Sensors::MagnetometerAccuracy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DirectionalAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading>**)this;
            check_hresult(_winrt_abi_type->get_DirectionalAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::MagnetometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::Magnetometer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerStatics2<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IMagnetometerStatics2<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IMagnetometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IMagnetometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IMagnetometerStatics2>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Magnetometer>{ operation, take_ownership_from_abi };
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IOnlookerDetectionOptions<D>::Action()
        const {
      winrt::Windows::Devices::Sensors::OnlookerDetectionAction value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IOnlookerDetectionOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IOnlookerDetectionOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_Action(reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)this;
        check_hresult(
            _winrt_abi_type->get_Action(reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IOnlookerDetectionOptions<D>::Action(
        winrt::Windows::Devices::Sensors::OnlookerDetectionAction const& value)
        const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IOnlookerDetectionOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IOnlookerDetectionOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_Action(static_cast<int32_t>(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)this;
        check_hresult(_winrt_abi_type->put_Action(static_cast<int32_t>(value)));
      }
    }
    template <typename D>
    auto consume_Windows_Devices_Sensors_IOnlookerDetectionOptions<
        D>::BackOnMode() const {
      winrt::Windows::Devices::Sensors::OnlookerDetectionBackOnMode value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IOnlookerDetectionOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IOnlookerDetectionOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_BackOnMode(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)this;
        check_hresult(_winrt_abi_type->get_BackOnMode(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Devices_Sensors_IOnlookerDetectionOptions<D>::BackOnMode(
        winrt::Windows::Devices::Sensors::OnlookerDetectionBackOnMode const&
            value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::
                                           IOnlookerDetectionOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Devices::Sensors::IOnlookerDetectionOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->put_BackOnMode(static_cast<int32_t>(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Devices::Sensors::
                        IOnlookerDetectionOptions>**)this;
        check_hresult(
            _winrt_abi_type->put_BackOnMode(static_cast<int32_t>(value)));
      }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::OrientationSensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::OrientationSensor, winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::OrientationSensor, winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor2<D>::ReadingTransform(winrt::Windows::Graphics::Display::DisplayOrientations const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor2>**)this;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor2<D>::ReadingTransform() const
    {
        winrt::Windows::Graphics::Display::DisplayOrientations value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor2<D>::ReadingType() const
    {
        winrt::Windows::Devices::Sensors::SensorReadingType type{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingType(reinterpret_cast<int32_t*>(&type)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingType(reinterpret_cast<int32_t*>(&type)));
        }
        return type;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor3<D>::ReportLatency(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor3>**)this;
            check_hresult(_winrt_abi_type->put_ReportLatency(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor3<D>::ReportLatency() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor3>**)this;
            check_hresult(_winrt_abi_type->get_ReportLatency(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensor3<D>::MaxBatchSize() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensor3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensor3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensor3>**)this;
            check_hresult(_winrt_abi_type->get_MaxBatchSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorReading<D>::RotationMatrix() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RotationMatrix(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_RotationMatrix(&value));
        }
        return winrt::Windows::Devices::Sensors::SensorRotationMatrix{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorReading<D>::Quaternion() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Quaternion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Quaternion(&value));
        }
        return winrt::Windows::Devices::Sensors::SensorQuaternion{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorReading2<D>::PerformanceCount() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading2>**)this;
            check_hresult(_winrt_abi_type->get_PerformanceCount(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorReading2<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorReading2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReading2>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::OrientationSensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorReadingYawAccuracy<D>::YawAccuracy() const
    {
        winrt::Windows::Devices::Sensors::MagnetometerAccuracy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorReadingYawAccuracy>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorReadingYawAccuracy, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReadingYawAccuracy>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YawAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorReadingYawAccuracy>**)this;
            check_hresult(_winrt_abi_type->get_YawAccuracy(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::OrientationSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorStatics2<D>::GetDefaultForRelativeReadings() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultForRelativeReadings(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDefaultForRelativeReadings(&result));
        }
        return winrt::Windows::Devices::Sensors::OrientationSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorStatics3<D>::GetDefault(winrt::Windows::Devices::Sensors::SensorReadingType const& sensorReadingtype) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorStatics3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultWithSensorReadingType(static_cast<int32_t>(sensorReadingtype), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics3>**)this;
            check_hresult(_winrt_abi_type->GetDefaultWithSensorReadingType(static_cast<int32_t>(sensorReadingtype), &result));
        }
        return winrt::Windows::Devices::Sensors::OrientationSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorStatics3<D>::GetDefault(winrt::Windows::Devices::Sensors::SensorReadingType const& sensorReadingType, winrt::Windows::Devices::Sensors::SensorOptimizationGoal const& optimizationGoal) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorStatics3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal(static_cast<int32_t>(sensorReadingType), static_cast<int32_t>(optimizationGoal), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics3>**)this;
            check_hresult(_winrt_abi_type->GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal(static_cast<int32_t>(sensorReadingType), static_cast<int32_t>(optimizationGoal), &result));
        }
        return winrt::Windows::Devices::Sensors::OrientationSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorStatics4<D>::GetDeviceSelector(winrt::Windows::Devices::Sensors::SensorReadingType const& readingType) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(static_cast<int32_t>(readingType), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(static_cast<int32_t>(readingType), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorStatics4<D>::GetDeviceSelector(winrt::Windows::Devices::Sensors::SensorReadingType const& readingType, winrt::Windows::Devices::Sensors::SensorOptimizationGoal const& optimizationGoal) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelectorWithSensorReadingTypeAndSensorOptimizationGoal(static_cast<int32_t>(readingType), static_cast<int32_t>(optimizationGoal), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelectorWithSensorReadingTypeAndSensorOptimizationGoal(static_cast<int32_t>(readingType), static_cast<int32_t>(optimizationGoal), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IOrientationSensorStatics4<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::OrientationSensor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::PowerInMilliwatts() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PowerInMilliwatts(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)this;
            check_hresult(_winrt_abi_type->get_PowerInMilliwatts(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::MinimumReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)this;
            check_hresult(_winrt_abi_type->get_MinimumReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::ReportInterval(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)this;
            check_hresult(_winrt_abi_type->put_ReportInterval(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::ReportInterval() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)this;
            check_hresult(_winrt_abi_type->get_ReportInterval(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Pedometer, winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Pedometer, winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometer2<D>::GetCurrentReadings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReadings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometer2>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReadings(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<winrt::Windows::Devices::Sensors::PedometerStepKind, winrt::Windows::Devices::Sensors::PedometerReading>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerDataThresholdFactory<D>::Create(winrt::Windows::Devices::Sensors::Pedometer const& sensor, int32_t stepGoal) const
    {
        void* threshold{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerDataThresholdFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerDataThresholdFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerDataThresholdFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&sensor), stepGoal, &threshold));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerDataThresholdFactory>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&sensor), stepGoal, &threshold));
        }
        return winrt::Windows::Devices::Sensors::PedometerDataThreshold{ threshold, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerReading<D>::StepKind() const
    {
        winrt::Windows::Devices::Sensors::PedometerStepKind value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StepKind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)this;
            check_hresult(_winrt_abi_type->get_StepKind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerReading<D>::CumulativeSteps() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CumulativeSteps(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)this;
            check_hresult(_winrt_abi_type->get_CumulativeSteps(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerReading<D>::CumulativeStepsDuration() const
    {
        winrt::Windows::Foundation::TimeSpan value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CumulativeStepsDuration(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReading>**)this;
            check_hresult(_winrt_abi_type->get_CumulativeStepsDuration(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::PedometerReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerStatics<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Pedometer>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerStatics<D>::GetDefaultAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefaultAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Pedometer>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerStatics<D>::GetDeviceSelector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerStatics<D>::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSystemHistoryAsync(impl::bind_in(fromTime), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetSystemHistoryAsync(impl::bind_in(fromTime), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::PedometerReading>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerStatics<D>::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime, winrt::Windows::Foundation::TimeSpan const& duration) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSystemHistoryWithDurationAsync(impl::bind_in(fromTime), impl::bind_in(duration), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics>**)this;
            check_hresult(_winrt_abi_type->GetSystemHistoryWithDurationAsync(impl::bind_in(fromTime), impl::bind_in(duration), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::PedometerReading>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IPedometerStatics2<D>::GetReadingsFromTriggerDetails(winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails const& triggerDetails) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IPedometerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IPedometerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadingsFromTriggerDetails(*(void**)(&triggerDetails), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IPedometerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetReadingsFromTriggerDetails(*(void**)(&triggerDetails), &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::PedometerReading>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::MaxDistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxDistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)this;
            check_hresult(_winrt_abi_type->get_MaxDistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::MinDistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinDistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)this;
            check_hresult(_winrt_abi_type->get_MinDistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::GetCurrentReading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)this;
            check_hresult(_winrt_abi_type->GetCurrentReading(&value));
        }
        return winrt::Windows::Devices::Sensors::ProximitySensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::ReadingChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ProximitySensor, winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)this;
            check_hresult(_winrt_abi_type->add_ReadingChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::ReadingChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ProximitySensor, winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ReadingChanged_revoker>(this, ReadingChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::ReadingChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)this;
            _winrt_abi_type->remove_ReadingChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensor<D>::CreateDisplayOnOffController() const
    {
        void* controller{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateDisplayOnOffController(&controller));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensor>**)this;
            check_hresult(_winrt_abi_type->CreateDisplayOnOffController(&controller));
        }
        return winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController{ controller, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorDataThresholdFactory<D>::Create(winrt::Windows::Devices::Sensors::ProximitySensor const& sensor) const
    {
        void* threshold{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorDataThresholdFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorDataThresholdFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorDataThresholdFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&sensor), &threshold));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorDataThresholdFactory>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&sensor), &threshold));
        }
        return winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold{ threshold, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorReading<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReading>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorReading<D>::IsDetected() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsDetected(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReading>**)this;
            check_hresult(_winrt_abi_type->get_IsDetected(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorReading<D>::DistanceInMillimeters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorReading>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorReading, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReading>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReading>**)this;
            check_hresult(_winrt_abi_type->get_DistanceInMillimeters(&value));
        }
        return winrt::Windows::Foundation::IReference<uint32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorReadingChangedEventArgs<D>::Reading() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorReadingChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorReadingChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReadingChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorReadingChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reading(&value));
        }
        return winrt::Windows::Devices::Sensors::ProximitySensorReading{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorStatics<D>::GetDeviceSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorStatics<D>::FromId(param::hstring const& sensorId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromId(*(void**)(&sensorId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorStatics>**)this;
            check_hresult(_winrt_abi_type->FromId(*(void**)(&sensorId), &result));
        }
        return winrt::Windows::Devices::Sensors::ProximitySensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IProximitySensorStatics2<D>::GetReadingsFromTriggerDetails(winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails const& triggerDetails) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IProximitySensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IProximitySensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadingsFromTriggerDetails(*(void**)(&triggerDetails), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IProximitySensorStatics2>**)this;
            check_hresult(_winrt_abi_type->GetReadingsFromTriggerDetails(*(void**)(&triggerDetails), &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ProximitySensorReading>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorDataThresholdTriggerDetails<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorDataThresholdTriggerDetails<D>::SensorType() const
    {
        winrt::Windows::Devices::Sensors::SensorType value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SensorType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails>**)this;
            check_hresult(_winrt_abi_type->get_SensorType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorQuaternion<D>::W() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorQuaternion>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorQuaternion, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_W(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)this;
            check_hresult(_winrt_abi_type->get_W(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorQuaternion<D>::X() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorQuaternion>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorQuaternion, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_X(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)this;
            check_hresult(_winrt_abi_type->get_X(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorQuaternion<D>::Y() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorQuaternion>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorQuaternion, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Y(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)this;
            check_hresult(_winrt_abi_type->get_Y(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorQuaternion<D>::Z() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorQuaternion>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorQuaternion, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Z(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorQuaternion>**)this;
            check_hresult(_winrt_abi_type->get_Z(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M11() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M11(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M11(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M12() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M12(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M12(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M13() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M13(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M13(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M21() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M21(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M21(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M22() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M22(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M22(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M23() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M23(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M23(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M31() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M31(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M31(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M32() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M32(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M32(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISensorRotationMatrix<D>::M33() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISensorRotationMatrix, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_M33(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISensorRotationMatrix>**)this;
            check_hresult(_winrt_abi_type->get_M33(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensor<D>::GetCurrentOrientation() const
    {
        winrt::Windows::Devices::Sensors::SimpleOrientation value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentOrientation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>**)this;
            check_hresult(_winrt_abi_type->GetCurrentOrientation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensor<D>::OrientationChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::SimpleOrientationSensor, winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_OrientationChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>**)this;
            check_hresult(_winrt_abi_type->add_OrientationChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensor<D>::OrientationChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::SimpleOrientationSensor, winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, OrientationChanged_revoker>(this, OrientationChanged(handler));
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensor<D>::OrientationChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>**)&_winrt_casted_result;
            _winrt_abi_type->remove_OrientationChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>**)this;
            _winrt_abi_type->remove_OrientationChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensor2<D>::ReadingTransform(winrt::Windows::Graphics::Display::DisplayOrientations const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2>**)this;
            check_hresult(_winrt_abi_type->put_ReadingTransform(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensor2<D>::ReadingTransform() const
    {
        winrt::Windows::Graphics::Display::DisplayOrientations value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2>**)this;
            check_hresult(_winrt_abi_type->get_ReadingTransform(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensorDeviceId<D>::DeviceId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorDeviceId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorDeviceId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorDeviceId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorDeviceId>**)this;
            check_hresult(_winrt_abi_type->get_DeviceId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensorOrientationChangedEventArgs<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensorOrientationChangedEventArgs<D>::Orientation() const
    {
        winrt::Windows::Devices::Sensors::SimpleOrientation value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensorStatics<D>::GetDefault() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&result));
        }
        return winrt::Windows::Devices::Sensors::SimpleOrientationSensor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensorStatics2<D>::GetDeviceSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2>**)this;
            check_hresult(_winrt_abi_type->GetDeviceSelector(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_ISimpleOrientationSensorStatics2<D>::FromIdAsync(param::hstring const& deviceId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2>**)this;
            check_hresult(_winrt_abi_type->FromIdAsync(*(void**)(&deviceId), &result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IWakeOnApproachOptions<D>::AllowWhenExternalDisplayConnected() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowWhenExternalDisplayConnected(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)this;
            check_hresult(_winrt_abi_type->get_AllowWhenExternalDisplayConnected(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IWakeOnApproachOptions<D>::AllowWhenExternalDisplayConnected(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowWhenExternalDisplayConnected(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)this;
            check_hresult(_winrt_abi_type->put_AllowWhenExternalDisplayConnected(value));
        }
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IWakeOnApproachOptions<D>::DisableWhenBatterySaverOn() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisableWhenBatterySaverOn(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)this;
            check_hresult(_winrt_abi_type->get_DisableWhenBatterySaverOn(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Devices_Sensors_IWakeOnApproachOptions<D>::DisableWhenBatterySaverOn(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DisableWhenBatterySaverOn(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>**)this;
            check_hresult(_winrt_abi_type->put_DisableWhenBatterySaverOn(value));
        }
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometer> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometer>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::AccelerometerReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Shaken(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Shaken(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Shaken(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Shaken(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometer2> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometer2>
    {
        int32_t __stdcall put_ReadingTransform(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingTransform(*reinterpret_cast<winrt::Windows::Graphics::Display::DisplayOrientations const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingTransform(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Display::DisplayOrientations>(this->shim().ReadingTransform());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometer3> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometer3>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometer4> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometer4>
    {
        int32_t __stdcall get_ReadingType(int32_t* type) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *type = detach_from<winrt::Windows::Devices::Sensors::AccelerometerReadingType>(this->shim().ReadingType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometer5> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometer5>
    {
        int32_t __stdcall get_ReportThreshold(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>(this->shim().ReportThreshold());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold>
    {
        int32_t __stdcall get_XAxisInGForce(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().XAxisInGForce());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_XAxisInGForce(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().XAxisInGForce(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_YAxisInGForce(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().YAxisInGForce());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_YAxisInGForce(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().YAxisInGForce(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ZAxisInGForce(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ZAxisInGForce());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ZAxisInGForce(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ZAxisInGForce(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerDeviceId> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerDeviceId>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerReading> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AccelerationX(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AccelerationX());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AccelerationY(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AccelerationY());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AccelerationZ(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AccelerationZ());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::AccelerometerReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerShakenEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerShakenEventArgs>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Accelerometer>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics2>
    {
        int32_t __stdcall GetDefaultWithAccelerometerReadingType(int32_t readingType, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Accelerometer>(this->shim().GetDefault(*reinterpret_cast<winrt::Windows::Devices::Sensors::AccelerometerReadingType const*>(&readingType)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics3> : produce_base<D, winrt::Windows::Devices::Sensors::IAccelerometerStatics3>
    {
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Accelerometer>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeviceSelector(int32_t readingType, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector(*reinterpret_cast<winrt::Windows::Devices::Sensors::AccelerometerReadingType const*>(&readingType)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IActivitySensor> : produce_base<D, winrt::Windows::Devices::Sensors::IActivitySensor>
    {
        int32_t __stdcall GetCurrentReadingAsync(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::ActivitySensorReading>>(this->shim().GetCurrentReadingAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SubscribedActivities(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Devices::Sensors::ActivityType>>(this->shim().SubscribedActivities());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PowerInMilliwatts(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().PowerInMilliwatts());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SupportedActivities(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivityType>>(this->shim().SupportedActivities());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ActivitySensor, winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IActivitySensorReading> : produce_base<D, winrt::Windows::Devices::Sensors::IActivitySensorReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Activity(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::ActivityType>(this->shim().Activity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Confidence(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::ActivitySensorReadingConfidence>(this->shim().Confidence());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IActivitySensorReadingChangeReport> : produce_base<D, winrt::Windows::Devices::Sensors::IActivitySensorReadingChangeReport>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::ActivitySensorReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IActivitySensorReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IActivitySensorReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::ActivitySensorReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IActivitySensorStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IActivitySensorStatics>
    {
        int32_t __stdcall GetDefaultAsync(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::ActivitySensor>>(this->shim().GetDefaultAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeviceSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::ActivitySensor>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSystemHistoryAsync(int64_t fromTime, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivitySensorReading>>>(this->shim().GetSystemHistoryAsync(*reinterpret_cast<winrt::Windows::Foundation::DateTime const*>(&fromTime)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSystemHistoryWithDurationAsync(int64_t fromTime, int64_t duration, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivitySensorReading>>>(this->shim().GetSystemHistoryAsync(*reinterpret_cast<winrt::Windows::Foundation::DateTime const*>(&fromTime), *reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&duration)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IActivitySensorTriggerDetails> : produce_base<D, winrt::Windows::Devices::Sensors::IActivitySensorTriggerDetails>
    {
        int32_t __stdcall ReadReports(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>>(this->shim().ReadReports());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions> : produce_base<D, winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions>
    {
        int32_t __stdcall get_AllowWhenExternalDisplayConnected(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowWhenExternalDisplayConnected());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowWhenExternalDisplayConnected(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowWhenExternalDisplayConnected(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAltimeter> : produce_base<D, winrt::Windows::Devices::Sensors::IAltimeter>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::AltimeterReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Altimeter, winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAltimeter2> : produce_base<D, winrt::Windows::Devices::Sensors::IAltimeter2>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAltimeterReading> : produce_base<D, winrt::Windows::Devices::Sensors::IAltimeterReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AltitudeChangeInMeters(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AltitudeChangeInMeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAltimeterReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IAltimeterReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAltimeterReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IAltimeterReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::AltimeterReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IAltimeterStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IAltimeterStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Altimeter>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometer> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometer>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::BarometerReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Barometer, winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometer2> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometer2>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometer3> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometer3>
    {
        int32_t __stdcall get_ReportThreshold(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::BarometerDataThreshold>(this->shim().ReportThreshold());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometerDataThreshold> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometerDataThreshold>
    {
        int32_t __stdcall get_Hectopascals(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Hectopascals());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Hectopascals(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Hectopascals(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometerReading> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometerReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StationPressureInHectopascals(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().StationPressureInHectopascals());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometerReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometerReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometerReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometerReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::BarometerReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometerStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Barometer>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IBarometerStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IBarometerStatics2>
    {
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Barometer>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeviceSelector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompass> : produce_base<D, winrt::Windows::Devices::Sensors::ICompass>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::CompassReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Compass, winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompass2> : produce_base<D, winrt::Windows::Devices::Sensors::ICompass2>
    {
        int32_t __stdcall put_ReadingTransform(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingTransform(*reinterpret_cast<winrt::Windows::Graphics::Display::DisplayOrientations const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingTransform(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Display::DisplayOrientations>(this->shim().ReadingTransform());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompass3> : produce_base<D, winrt::Windows::Devices::Sensors::ICompass3>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompass4> : produce_base<D, winrt::Windows::Devices::Sensors::ICompass4>
    {
        int32_t __stdcall get_ReportThreshold(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::CompassDataThreshold>(this->shim().ReportThreshold());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassDataThreshold> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassDataThreshold>
    {
        int32_t __stdcall get_Degrees(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Degrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Degrees(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Degrees(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassDeviceId> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassDeviceId>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassReading> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeadingMagneticNorth(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().HeadingMagneticNorth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeadingTrueNorth(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().HeadingTrueNorth());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassReading2> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::CompassReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassReadingHeadingAccuracy> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassReadingHeadingAccuracy>
    {
        int32_t __stdcall get_HeadingAccuracy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::MagnetometerAccuracy>(this->shim().HeadingAccuracy());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassStatics> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Compass>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ICompassStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::ICompassStatics2>
    {
        int32_t __stdcall GetDeviceSelector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Compass>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IDetectedPerson> : produce_base<D, winrt::Windows::Devices::Sensors::IDetectedPerson>
    {
        int32_t __stdcall get_Engagement(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HumanEngagement>(this->shim().Engagement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().DistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeadOrientation(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HeadOrientation>(this->shim().HeadOrientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeadPosition(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HeadPosition>(this->shim().HeadPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PersonId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().PersonId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometer> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometer>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::GyrometerReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Gyrometer, winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometer2> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometer2>
    {
        int32_t __stdcall put_ReadingTransform(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingTransform(*reinterpret_cast<winrt::Windows::Graphics::Display::DisplayOrientations const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingTransform(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Display::DisplayOrientations>(this->shim().ReadingTransform());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometer3> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometer3>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometer4> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometer4>
    {
        int32_t __stdcall get_ReportThreshold(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>(this->shim().ReportThreshold());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometerDataThreshold>
    {
        int32_t __stdcall get_XAxisInDegreesPerSecond(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().XAxisInDegreesPerSecond());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_XAxisInDegreesPerSecond(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().XAxisInDegreesPerSecond(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_YAxisInDegreesPerSecond(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().YAxisInDegreesPerSecond());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_YAxisInDegreesPerSecond(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().YAxisInDegreesPerSecond(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ZAxisInDegreesPerSecond(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ZAxisInDegreesPerSecond());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ZAxisInDegreesPerSecond(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ZAxisInDegreesPerSecond(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometerDeviceId> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometerDeviceId>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometerReading> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometerReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AngularVelocityX(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AngularVelocityX());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AngularVelocityY(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AngularVelocityY());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AngularVelocityZ(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AngularVelocityZ());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometerReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometerReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometerReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometerReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::GyrometerReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometerStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Gyrometer>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IGyrometerStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IGyrometerStatics2>
    {
        int32_t __stdcall GetDeviceSelector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Gyrometer>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHeadOrientation> : produce_base<D, winrt::Windows::Devices::Sensors::IHeadOrientation>
    {
        int32_t __stdcall get_RollInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().RollInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PitchInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().PitchInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_YawInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().YawInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHeadPosition> : produce_base<D, winrt::Windows::Devices::Sensors::IHeadPosition>
    {
        int32_t __stdcall get_AzimuthInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().AzimuthInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AltitudeInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().AltitudeInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHingeAngleReading> : produce_base<D, winrt::Windows::Devices::Sensors::IHingeAngleReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AngleInDegrees(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().AngleInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor> : produce_base<D, winrt::Windows::Devices::Sensors::IHingeAngleSensor>
    {
        int32_t __stdcall GetCurrentReadingAsync(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleReading>>(this->shim().GetCurrentReadingAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinReportThresholdInDegrees(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MinReportThresholdInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportThresholdInDegrees(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ReportThresholdInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportThresholdInDegrees(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportThresholdInDegrees(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HingeAngleSensor, winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HingeAngleReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics>
    {
        int32_t __stdcall GetDeviceSelector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDefaultAsync(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleSensor>>(this->shim().GetDefaultAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetRelatedToAdjacentPanelsAsync(void* firstPanelId, void* secondPanelId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleSensor>>(this->shim().GetRelatedToAdjacentPanelsAsync(*reinterpret_cast<hstring const*>(&firstPanelId), *reinterpret_cast<hstring const*>(&secondPanelId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleSensor>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures>
    {
        int32_t __stdcall get_SensorId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().SensorId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SupportedWakeOrLockDistancesInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<uint32_t>>(this->shim().SupportedWakeOrLockDistancesInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsWakeOnApproachSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsWakeOnApproachSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsLockOnLeaveSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsLockOnLeaveSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAttentionAwareDimmingSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAttentionAwareDimmingSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures2> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures2>
    {
        int32_t __stdcall get_IsAdaptiveDimmingSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAdaptiveDimmingSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures3>
        : produce_base<
              D, winrt::Windows::Devices::Sensors::IHumanPresenceFeatures3> {
      int32_t __stdcall get_IsOnlookerDetectionSupported(
          bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsOnlookerDetectionSupported());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor>
        : produce_base<D,
                       winrt::Windows::Devices::Sensors::IHumanPresenceSensor> {
      int32_t __stdcall get_DeviceId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().DeviceId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MaxDetectableDistanceInMillimeters(
          void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(
            this->shim().MaxDetectableDistanceInMillimeters());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MinDetectableDistanceInMillimeters(
          void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(
            this->shim().MinDetectableDistanceInMillimeters());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetCurrentReading(void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>(
            this->shim().GetCurrentReading());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall add_ReadingChanged(
          void* handler, winrt::event_token* token) noexcept final try {
        zero_abi<winrt::event_token>(token);
        typename D::abi_guard guard(this->shim());
        *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Windows::Devices::Sensors::HumanPresenceSensor,
                winrt::Windows::Devices::Sensors::
                    HumanPresenceSensorReadingChangedEventArgs> const*>(
                &handler)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall remove_ReadingChanged(
          winrt::event_token token) noexcept final {
        typename D::abi_guard guard(this->shim());
        this->shim().ReadingChanged(
            *reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor2> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor2>
    {
        int32_t __stdcall get_IsPresenceSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPresenceSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsEngagementSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsEngagementSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor3> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensor3>
    {
        int32_t __stdcall get_MaxDetectablePersons(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxDetectablePersons());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinDetectableAzimuthInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().MinDetectableAzimuthInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxDetectableAzimuthInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().MaxDetectableAzimuthInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinDetectableAltitudeInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().MinDetectableAltitudeInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxDetectableAltitudeInDegrees(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<double>>(this->shim().MaxDetectableAltitudeInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>
    {
        int32_t __stdcall Initialize(void* deviceInterface) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Initialize(*reinterpret_cast<hstring const*>(&deviceInterface));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Start() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Start();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessReading(void* reading, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate>(this->shim().ProcessReading(*reinterpret_cast<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading const*>(&reading)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessReadingTimeoutExpired(void* reading) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessReadingTimeoutExpired(*reinterpret_cast<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading const*>(&reading));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Stop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Uninitialize() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Uninitialize();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Reset() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Reset();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Presence(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HumanPresence>(this->shim().Presence());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Engagement(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HumanEngagement>(this->shim().Engagement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().DistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading2>
    {
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3>
    {
        int32_t __stdcall get_OnlookerPresence(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HumanPresence>(this->shim().OnlookerPresence());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DetectedPersons(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::DetectedPerson>>(this->shim().DetectedPersons());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate>
    {
        int32_t __stdcall get_Timestamp(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Timestamp(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Timestamp(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Presence(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanPresence>>(this->shim().Presence());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Presence(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Presence(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanPresence> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Engagement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanEngagement>>(this->shim().Engagement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Engagement(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Engagement(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanEngagement> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().DistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DistanceInMillimeters(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DistanceInMillimeters(*reinterpret_cast<winrt::Windows::Foundation::IReference<uint32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate2>
        : produce_base<D, winrt::Windows::Devices::Sensors::
                              IHumanPresenceSensorReadingUpdate2> {
      int32_t __stdcall get_OnlookerPresence(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::IReference<
            winrt::Windows::Devices::Sensors::HumanPresence>>(
            this->shim().OnlookerPresence());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_OnlookerPresence(void* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().OnlookerPresence(
            *reinterpret_cast<winrt::Windows::Foundation::IReference<
                winrt::Windows::Devices::Sensors::HumanPresence> const*>(
                &value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics>
        : produce_base<
              D,
              winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics> {
      int32_t __stdcall GetDeviceSelector(void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<hstring>(this->shim().GetDeviceSelector());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall FromIdAsync(void* sensorId,
                                    void** operation) noexcept final try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
            winrt::Windows::Devices::Sensors::HumanPresenceSensor>>(
            this->shim().FromIdAsync(
                *reinterpret_cast<hstring const*>(&sensorId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetDefaultAsync(void** operation) noexcept final try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
            winrt::Windows::Devices::Sensors::HumanPresenceSensor>>(
            this->shim().GetDefaultAsync());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2>
    {
        int32_t __stdcall FromId(void* sensorId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::HumanPresenceSensor>(this->shim().FromId(*reinterpret_cast<hstring const*>(&sensorId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::HumanPresenceSensor>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings>
    {
        int32_t __stdcall get_SensorId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().SensorId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SensorId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SensorId(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsWakeOnApproachEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsWakeOnApproachEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsWakeOnApproachEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsWakeOnApproachEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WakeOnApproachDistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().WakeOnApproachDistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_WakeOnApproachDistanceInMillimeters(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WakeOnApproachDistanceInMillimeters(*reinterpret_cast<winrt::Windows::Foundation::IReference<uint32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsLockOnLeaveEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsLockOnLeaveEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsLockOnLeaveEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsLockOnLeaveEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LockOnLeaveDistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().LockOnLeaveDistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LockOnLeaveDistanceInMillimeters(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LockOnLeaveDistanceInMillimeters(*reinterpret_cast<winrt::Windows::Foundation::IReference<uint32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LockOnLeaveTimeout(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::TimeSpan>(this->shim().LockOnLeaveTimeout());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LockOnLeaveTimeout(int64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LockOnLeaveTimeout(*reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAttentionAwareDimmingEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAttentionAwareDimmingEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsAttentionAwareDimmingEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsAttentionAwareDimmingEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings2> : produce_base<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings2>
    {
        int32_t __stdcall get_IsAdaptiveDimmingEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAdaptiveDimmingEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsAdaptiveDimmingEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsAdaptiveDimmingEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WakeOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::WakeOnApproachOptions>(this->shim().WakeOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DimmingOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::AdaptiveDimmingOptions>(this->shim().DimmingOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LockOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::LockOnLeaveOptions>(this->shim().LockOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings3>
        : produce_base<
              D, winrt::Windows::Devices::Sensors::IHumanPresenceSettings3> {
      int32_t __stdcall get_IsOnlookerDetectionEnabled(
          bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsOnlookerDetectionEnabled());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_IsOnlookerDetectionEnabled(
          bool value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().IsOnlookerDetectionEnabled(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_OnlookerDetectionOptions(
          void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Devices::Sensors::OnlookerDetectionOptions>(
            this->shim().OnlookerDetectionOptions());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>
        : produce_base<
              D,
              winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics> {
      int32_t __stdcall GetCurrentSettingsAsync(void** operation) noexcept final
          try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
            winrt::Windows::Devices::Sensors::HumanPresenceSettings>>(
            this->shim().GetCurrentSettingsAsync());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetCurrentSettings(void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Devices::Sensors::HumanPresenceSettings>(
            this->shim().GetCurrentSettings());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall UpdateSettingsAsync(void* settings,
                                            void** operation) noexcept final
          try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(
            this->shim().UpdateSettingsAsync(
                *reinterpret_cast<winrt::Windows::Devices::Sensors::
                                      HumanPresenceSettings const*>(
                    &settings)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall UpdateSettings(void* settings) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().UpdateSettings(
            *reinterpret_cast<
                winrt::Windows::Devices::Sensors::HumanPresenceSettings const*>(
                &settings));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetSupportedFeaturesForSensorIdAsync(
          void* sensorId, void** operation) noexcept final try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
            winrt::Windows::Devices::Sensors::HumanPresenceFeatures>>(
            this->shim().GetSupportedFeaturesForSensorIdAsync(
                *reinterpret_cast<hstring const*>(&sensorId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetSupportedFeaturesForSensorId(
          void* sensorId, void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Devices::Sensors::HumanPresenceFeatures>(
            this->shim().GetSupportedFeaturesForSensorId(
                *reinterpret_cast<hstring const*>(&sensorId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetSupportedLockOnLeaveTimeouts(
          void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result =
            detach_from<winrt::Windows::Foundation::Collections::IVectorView<
                winrt::Windows::Foundation::TimeSpan>>(
                this->shim().GetSupportedLockOnLeaveTimeouts());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall add_SettingsChanged(
          void* handler, winrt::event_token* token) noexcept final try {
        zero_abi<winrt::event_token>(token);
        typename D::abi_guard guard(this->shim());
        *token = detach_from<winrt::event_token>(this->shim().SettingsChanged(
            *reinterpret_cast<winrt::Windows::Foundation::EventHandler<
                winrt::Windows::Foundation::IInspectable> const*>(&handler)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall remove_SettingsChanged(
          winrt::event_token token) noexcept final {
        typename D::abi_guard guard(this->shim());
        this->shim().SettingsChanged(
            *reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometer> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometer>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::InclinometerReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Inclinometer, winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometer2> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometer2>
    {
        int32_t __stdcall put_ReadingTransform(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingTransform(*reinterpret_cast<winrt::Windows::Graphics::Display::DisplayOrientations const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingTransform(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Display::DisplayOrientations>(this->shim().ReadingTransform());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingType(int32_t* type) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *type = detach_from<winrt::Windows::Devices::Sensors::SensorReadingType>(this->shim().ReadingType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometer3> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometer3>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometer4> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometer4>
    {
        int32_t __stdcall get_ReportThreshold(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>(this->shim().ReportThreshold());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerDataThreshold>
    {
        int32_t __stdcall get_PitchInDegrees(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().PitchInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PitchInDegrees(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PitchInDegrees(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RollInDegrees(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().RollInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RollInDegrees(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RollInDegrees(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_YawInDegrees(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().YawInDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_YawInDegrees(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().YawInDegrees(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerDeviceId> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerDeviceId>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerReading> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PitchDegrees(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().PitchDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RollDegrees(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().RollDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_YawDegrees(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().YawDegrees());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::InclinometerReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerReadingYawAccuracy> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerReadingYawAccuracy>
    {
        int32_t __stdcall get_YawAccuracy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::MagnetometerAccuracy>(this->shim().YawAccuracy());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Inclinometer>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerStatics2>
    {
        int32_t __stdcall GetDefaultForRelativeReadings(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Inclinometer>(this->shim().GetDefaultForRelativeReadings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerStatics3> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerStatics3>
    {
        int32_t __stdcall GetDefaultWithSensorReadingType(int32_t sensorReadingtype, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Inclinometer>(this->shim().GetDefault(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorReadingType const*>(&sensorReadingtype)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IInclinometerStatics4> : produce_base<D, winrt::Windows::Devices::Sensors::IInclinometerStatics4>
    {
        int32_t __stdcall GetDeviceSelector(int32_t readingType, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorReadingType const*>(&readingType)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Inclinometer>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensor> : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensor>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::LightSensorReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::LightSensor, winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensor2> : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensor2>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensor3> : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensor3>
    {
        int32_t __stdcall get_ReportThreshold(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>(this->shim().ReportThreshold());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensor4>
        : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensor4> {
      int32_t __stdcall IsChromaticitySupported(bool* supported) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *supported = detach_from<bool>(this->shim().IsChromaticitySupported());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D,
                   winrt::Windows::Devices::Sensors::ILightSensorDataThreshold>
        : produce_base<
              D, winrt::Windows::Devices::Sensors::ILightSensorDataThreshold> {
      int32_t __stdcall get_LuxPercentage(float* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<float>(this->shim().LuxPercentage());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_LuxPercentage(float value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().LuxPercentage(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_AbsoluteLux(float* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<float>(this->shim().AbsoluteLux());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_AbsoluteLux(float value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().AbsoluteLux(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D,
                   winrt::Windows::Devices::Sensors::ILightSensorDataThreshold2>
        : produce_base<
              D, winrt::Windows::Devices::Sensors::ILightSensorDataThreshold2> {
      int32_t __stdcall get_Chromaticity(
          struct struct_Windows_Devices_Sensors_LightSensorChromaticity*
              value) noexcept final try {
        zero_abi<winrt::Windows::Devices::Sensors::LightSensorChromaticity>(
            value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Devices::Sensors::LightSensorChromaticity>(
            this->shim().Chromaticity());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_Chromaticity(
          struct struct_Windows_Devices_Sensors_LightSensorChromaticity
              value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().Chromaticity(
            *reinterpret_cast<winrt::Windows::Devices::Sensors::
                                  LightSensorChromaticity const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensorDeviceId>
        : produce_base<D,
                       winrt::Windows::Devices::Sensors::ILightSensorDeviceId> {
      int32_t __stdcall get_DeviceId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().DeviceId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensorReading> : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensorReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IlluminanceInLux(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().IlluminanceInLux());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensorReading2> : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensorReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensorReading3>
        : produce_base<D,
                       winrt::Windows::Devices::Sensors::ILightSensorReading3> {
      int32_t __stdcall get_Chromaticity(
          struct struct_Windows_Devices_Sensors_LightSensorChromaticity*
              value) noexcept final try {
        zero_abi<winrt::Windows::Devices::Sensors::LightSensorChromaticity>(
            value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Devices::Sensors::LightSensorChromaticity>(
            this->shim().Chromaticity());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Devices::Sensors::ILightSensorReadingChangedEventArgs>
        : produce_base<D, winrt::Windows::Devices::Sensors::
                              ILightSensorReadingChangedEventArgs> {
      int32_t __stdcall get_Reading(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Devices::Sensors::LightSensorReading>(
                this->shim().Reading());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensorStatics> : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensorStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::LightSensor>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILightSensorStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::ILightSensorStatics2>
    {
        int32_t __stdcall GetDeviceSelector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::LightSensor>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ILockOnLeaveOptions> : produce_base<D, winrt::Windows::Devices::Sensors::ILockOnLeaveOptions>
    {
        int32_t __stdcall get_AllowWhenExternalDisplayConnected(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowWhenExternalDisplayConnected());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowWhenExternalDisplayConnected(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowWhenExternalDisplayConnected(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometer> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometer>
    {
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::MagnetometerReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Magnetometer, winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometer2> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometer2>
    {
        int32_t __stdcall put_ReadingTransform(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingTransform(*reinterpret_cast<winrt::Windows::Graphics::Display::DisplayOrientations const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingTransform(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Display::DisplayOrientations>(this->shim().ReadingTransform());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometer3> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometer3>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometer4> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometer4>
    {
        int32_t __stdcall get_ReportThreshold(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>(this->shim().ReportThreshold());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold>
    {
        int32_t __stdcall get_XAxisMicroteslas(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().XAxisMicroteslas());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_XAxisMicroteslas(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().XAxisMicroteslas(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_YAxisMicroteslas(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().YAxisMicroteslas());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_YAxisMicroteslas(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().YAxisMicroteslas(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ZAxisMicroteslas(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().ZAxisMicroteslas());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ZAxisMicroteslas(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ZAxisMicroteslas(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometerDeviceId> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometerDeviceId>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometerReading> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometerReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MagneticFieldX(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().MagneticFieldX());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MagneticFieldY(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().MagneticFieldY());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MagneticFieldZ(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().MagneticFieldZ());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DirectionalAccuracy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::MagnetometerAccuracy>(this->shim().DirectionalAccuracy());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometerReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometerReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometerReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometerReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::MagnetometerReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometerStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::Magnetometer>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IMagnetometerStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IMagnetometerStatics2>
    {
        int32_t __stdcall GetDeviceSelector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Magnetometer>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D,
                   winrt::Windows::Devices::Sensors::IOnlookerDetectionOptions>
        : produce_base<
              D, winrt::Windows::Devices::Sensors::IOnlookerDetectionOptions> {
      int32_t __stdcall get_Action(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Devices::Sensors::OnlookerDetectionAction>(
            this->shim().Action());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_Action(int32_t value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().Action(
            *reinterpret_cast<winrt::Windows::Devices::Sensors::
                                  OnlookerDetectionAction const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_BackOnMode(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Devices::Sensors::OnlookerDetectionBackOnMode>(
            this->shim().BackOnMode());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_BackOnMode(int32_t value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().BackOnMode(
            *reinterpret_cast<winrt::Windows::Devices::Sensors::
                                  OnlookerDetectionBackOnMode const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensor>
        : produce_base<D,
                       winrt::Windows::Devices::Sensors::IOrientationSensor> {
      int32_t __stdcall GetCurrentReading(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Devices::Sensors::OrientationSensorReading>(
            this->shim().GetCurrentReading());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MinimumReportInterval(
          uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().ReportInterval(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().ReportInterval());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall add_ReadingChanged(
          void* handler, winrt::event_token* token) noexcept final try {
        zero_abi<winrt::event_token>(token);
        typename D::abi_guard guard(this->shim());
        *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Windows::Devices::Sensors::OrientationSensor,
                winrt::Windows::Devices::Sensors::
                    OrientationSensorReadingChangedEventArgs> const*>(
                &handler)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall remove_ReadingChanged(
          winrt::event_token token) noexcept final {
        typename D::abi_guard guard(this->shim());
        this->shim().ReadingChanged(
            *reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensor2> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensor2>
    {
        int32_t __stdcall put_ReadingTransform(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingTransform(*reinterpret_cast<winrt::Windows::Graphics::Display::DisplayOrientations const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingTransform(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Display::DisplayOrientations>(this->shim().ReadingTransform());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingType(int32_t* type) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *type = detach_from<winrt::Windows::Devices::Sensors::SensorReadingType>(this->shim().ReadingType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensor3> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensor3>
    {
        int32_t __stdcall put_ReportLatency(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportLatency(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportLatency(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportLatency());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxBatchSize(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MaxBatchSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorDeviceId> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorDeviceId>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RotationMatrix(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::SensorRotationMatrix>(this->shim().RotationMatrix());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Quaternion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::SensorQuaternion>(this->shim().Quaternion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading2> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorReading2>
    {
        int32_t __stdcall get_PerformanceCount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(this->shim().PerformanceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::IInspectable>>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::OrientationSensorReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorReadingYawAccuracy> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorReadingYawAccuracy>
    {
        int32_t __stdcall get_YawAccuracy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::MagnetometerAccuracy>(this->shim().YawAccuracy());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::OrientationSensor>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics2>
    {
        int32_t __stdcall GetDefaultForRelativeReadings(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::OrientationSensor>(this->shim().GetDefaultForRelativeReadings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics3> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics3>
    {
        int32_t __stdcall GetDefaultWithSensorReadingType(int32_t sensorReadingtype, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::OrientationSensor>(this->shim().GetDefault(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorReadingType const*>(&sensorReadingtype)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal(int32_t sensorReadingType, int32_t optimizationGoal, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::OrientationSensor>(this->shim().GetDefault(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorReadingType const*>(&sensorReadingType), *reinterpret_cast<winrt::Windows::Devices::Sensors::SensorOptimizationGoal const*>(&optimizationGoal)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics4> : produce_base<D, winrt::Windows::Devices::Sensors::IOrientationSensorStatics4>
    {
        int32_t __stdcall GetDeviceSelector(int32_t readingType, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorReadingType const*>(&readingType)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeviceSelectorWithSensorReadingTypeAndSensorOptimizationGoal(int32_t readingType, int32_t optimizationGoal, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorReadingType const*>(&readingType), *reinterpret_cast<winrt::Windows::Devices::Sensors::SensorOptimizationGoal const*>(&optimizationGoal)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::OrientationSensor>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IPedometer> : produce_base<D, winrt::Windows::Devices::Sensors::IPedometer>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PowerInMilliwatts(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().PowerInMilliwatts());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().MinimumReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReportInterval(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportInterval(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReportInterval(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ReportInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Pedometer, winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IPedometer2> : produce_base<D, winrt::Windows::Devices::Sensors::IPedometer2>
    {
        int32_t __stdcall GetCurrentReadings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<winrt::Windows::Devices::Sensors::PedometerStepKind, winrt::Windows::Devices::Sensors::PedometerReading>>(this->shim().GetCurrentReadings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IPedometerDataThresholdFactory> : produce_base<D, winrt::Windows::Devices::Sensors::IPedometerDataThresholdFactory>
    {
        int32_t __stdcall Create(void* sensor, int32_t stepGoal, void** threshold) noexcept final try
        {
            clear_abi(threshold);
            typename D::abi_guard guard(this->shim());
            *threshold = detach_from<winrt::Windows::Devices::Sensors::PedometerDataThreshold>(this->shim().Create(*reinterpret_cast<winrt::Windows::Devices::Sensors::Pedometer const*>(&sensor), stepGoal));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IPedometerReading> : produce_base<D, winrt::Windows::Devices::Sensors::IPedometerReading>
    {
        int32_t __stdcall get_StepKind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::PedometerStepKind>(this->shim().StepKind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CumulativeSteps(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().CumulativeSteps());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CumulativeStepsDuration(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::TimeSpan>(this->shim().CumulativeStepsDuration());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IPedometerReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IPedometerReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::PedometerReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IPedometerStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IPedometerStatics>
    {
        int32_t __stdcall FromIdAsync(void* deviceId, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Pedometer>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDefaultAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Pedometer>>(this->shim().GetDefaultAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeviceSelector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSystemHistoryAsync(int64_t fromTime, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::PedometerReading>>>(this->shim().GetSystemHistoryAsync(*reinterpret_cast<winrt::Windows::Foundation::DateTime const*>(&fromTime)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSystemHistoryWithDurationAsync(int64_t fromTime, int64_t duration, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::PedometerReading>>>(this->shim().GetSystemHistoryAsync(*reinterpret_cast<winrt::Windows::Foundation::DateTime const*>(&fromTime), *reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&duration)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IPedometerStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IPedometerStatics2>
    {
        int32_t __stdcall GetReadingsFromTriggerDetails(void* triggerDetails, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::PedometerReading>>(this->shim().GetReadingsFromTriggerDetails(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails const*>(&triggerDetails)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IProximitySensor> : produce_base<D, winrt::Windows::Devices::Sensors::IProximitySensor>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxDistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().MaxDistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinDistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().MinDistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetCurrentReading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::ProximitySensorReading>(this->shim().GetCurrentReading());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ReadingChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ReadingChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ProximitySensor, winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ReadingChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall CreateDisplayOnOffController(void** controller) noexcept final try
        {
            clear_abi(controller);
            typename D::abi_guard guard(this->shim());
            *controller = detach_from<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>(this->shim().CreateDisplayOnOffController());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IProximitySensorDataThresholdFactory> : produce_base<D, winrt::Windows::Devices::Sensors::IProximitySensorDataThresholdFactory>
    {
        int32_t __stdcall Create(void* sensor, void** threshold) noexcept final try
        {
            clear_abi(threshold);
            typename D::abi_guard guard(this->shim());
            *threshold = detach_from<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>(this->shim().Create(*reinterpret_cast<winrt::Windows::Devices::Sensors::ProximitySensor const*>(&sensor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IProximitySensorReading> : produce_base<D, winrt::Windows::Devices::Sensors::IProximitySensorReading>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsDetected(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsDetected());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DistanceInMillimeters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<uint32_t>>(this->shim().DistanceInMillimeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IProximitySensorReadingChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::IProximitySensorReadingChangedEventArgs>
    {
        int32_t __stdcall get_Reading(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::ProximitySensorReading>(this->shim().Reading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IProximitySensorStatics> : produce_base<D, winrt::Windows::Devices::Sensors::IProximitySensorStatics>
    {
        int32_t __stdcall GetDeviceSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromId(void* sensorId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::ProximitySensor>(this->shim().FromId(*reinterpret_cast<hstring const*>(&sensorId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IProximitySensorStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::IProximitySensorStatics2>
    {
        int32_t __stdcall GetReadingsFromTriggerDetails(void* triggerDetails, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sensors::ProximitySensorReading>>(this->shim().GetReadingsFromTriggerDetails(*reinterpret_cast<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails const*>(&triggerDetails)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISensorDataThreshold> : produce_base<D, winrt::Windows::Devices::Sensors::ISensorDataThreshold>
    {
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails> : produce_base<D, winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SensorType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::SensorType>(this->shim().SensorType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISensorQuaternion> : produce_base<D, winrt::Windows::Devices::Sensors::ISensorQuaternion>
    {
        int32_t __stdcall get_W(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().W());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_X(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().X());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Y(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Y());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Z(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Z());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix> : produce_base<D, winrt::Windows::Devices::Sensors::ISensorRotationMatrix>
    {
        int32_t __stdcall get_M11(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M11());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M12(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M12());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M13(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M13());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M21(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M21());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M22(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M22());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M23(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M23());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M31(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M31());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M32(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M32());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_M33(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().M33());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor> : produce_base<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor>
    {
        int32_t __stdcall GetCurrentOrientation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::SimpleOrientation>(this->shim().GetCurrentOrientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_OrientationChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().OrientationChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::SimpleOrientationSensor, winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_OrientationChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OrientationChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2> : produce_base<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2>
    {
        int32_t __stdcall put_ReadingTransform(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReadingTransform(*reinterpret_cast<winrt::Windows::Graphics::Display::DisplayOrientations const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReadingTransform(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Display::DisplayOrientations>(this->shim().ReadingTransform());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorDeviceId> : produce_base<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorDeviceId>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs> : produce_base<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Orientation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Devices::Sensors::SimpleOrientation>(this->shim().Orientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics> : produce_base<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2> : produce_base<D, winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2>
    {
        int32_t __stdcall GetDeviceSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().GetDeviceSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FromIdAsync(void* deviceId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>>(this->shim().FromIdAsync(*reinterpret_cast<hstring const*>(&deviceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Devices::Sensors::IWakeOnApproachOptions> : produce_base<D, winrt::Windows::Devices::Sensors::IWakeOnApproachOptions>
    {
        int32_t __stdcall get_AllowWhenExternalDisplayConnected(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowWhenExternalDisplayConnected());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowWhenExternalDisplayConnected(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowWhenExternalDisplayConnected(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisableWhenBatterySaverOn(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DisableWhenBatterySaverOn());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DisableWhenBatterySaverOn(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisableWhenBatterySaverOn(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Windows::Devices::Sensors
{
    inline auto Accelerometer::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Accelerometer(*)(IAccelerometerStatics const&), Accelerometer, IAccelerometerStatics>([](IAccelerometerStatics const& f) { return f.GetDefault(); });
    }
    inline auto Accelerometer::GetDefault(winrt::Windows::Devices::Sensors::AccelerometerReadingType const& readingType)
    {
        return impl::call_factory<Accelerometer, IAccelerometerStatics2>([&](IAccelerometerStatics2 const& f) { return f.GetDefault(readingType); });
    }
    inline auto Accelerometer::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<Accelerometer, IAccelerometerStatics3>([&](IAccelerometerStatics3 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto Accelerometer::GetDeviceSelector(winrt::Windows::Devices::Sensors::AccelerometerReadingType const& readingType)
    {
        return impl::call_factory<Accelerometer, IAccelerometerStatics3>([&](IAccelerometerStatics3 const& f) { return f.GetDeviceSelector(readingType); });
    }
    inline auto ActivitySensor::GetDefaultAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::ActivitySensor>(*)(IActivitySensorStatics const&), ActivitySensor, IActivitySensorStatics>([](IActivitySensorStatics const& f) { return f.GetDefaultAsync(); });
    }
    inline auto ActivitySensor::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IActivitySensorStatics const&), ActivitySensor, IActivitySensorStatics>([](IActivitySensorStatics const& f) { return f.GetDeviceSelector(); });
    }
    inline auto ActivitySensor::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<ActivitySensor, IActivitySensorStatics>([&](IActivitySensorStatics const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto ActivitySensor::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime)
    {
        return impl::call_factory<ActivitySensor, IActivitySensorStatics>([&](IActivitySensorStatics const& f) { return f.GetSystemHistoryAsync(fromTime); });
    }
    inline auto ActivitySensor::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime, winrt::Windows::Foundation::TimeSpan const& duration)
    {
        return impl::call_factory<ActivitySensor, IActivitySensorStatics>([&](IActivitySensorStatics const& f) { return f.GetSystemHistoryAsync(fromTime, duration); });
    }
    inline auto Altimeter::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Altimeter(*)(IAltimeterStatics const&), Altimeter, IAltimeterStatics>([](IAltimeterStatics const& f) { return f.GetDefault(); });
    }
    inline auto Barometer::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Barometer(*)(IBarometerStatics const&), Barometer, IBarometerStatics>([](IBarometerStatics const& f) { return f.GetDefault(); });
    }
    inline auto Barometer::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<Barometer, IBarometerStatics2>([&](IBarometerStatics2 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto Barometer::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IBarometerStatics2 const&), Barometer, IBarometerStatics2>([](IBarometerStatics2 const& f) { return f.GetDeviceSelector(); });
    }
    inline auto Compass::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Compass(*)(ICompassStatics const&), Compass, ICompassStatics>([](ICompassStatics const& f) { return f.GetDefault(); });
    }
    inline auto Compass::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(ICompassStatics2 const&), Compass, ICompassStatics2>([](ICompassStatics2 const& f) { return f.GetDeviceSelector(); });
    }
    inline auto Compass::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<Compass, ICompassStatics2>([&](ICompassStatics2 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto Gyrometer::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Gyrometer(*)(IGyrometerStatics const&), Gyrometer, IGyrometerStatics>([](IGyrometerStatics const& f) { return f.GetDefault(); });
    }
    inline auto Gyrometer::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IGyrometerStatics2 const&), Gyrometer, IGyrometerStatics2>([](IGyrometerStatics2 const& f) { return f.GetDeviceSelector(); });
    }
    inline auto Gyrometer::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<Gyrometer, IGyrometerStatics2>([&](IGyrometerStatics2 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto HingeAngleSensor::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IHingeAngleSensorStatics const&), HingeAngleSensor, IHingeAngleSensorStatics>([](IHingeAngleSensorStatics const& f) { return f.GetDeviceSelector(); });
    }
    inline auto HingeAngleSensor::GetDefaultAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HingeAngleSensor>(*)(IHingeAngleSensorStatics const&), HingeAngleSensor, IHingeAngleSensorStatics>([](IHingeAngleSensorStatics const& f) { return f.GetDefaultAsync(); });
    }
    inline auto HingeAngleSensor::GetRelatedToAdjacentPanelsAsync(param::hstring const& firstPanelId, param::hstring const& secondPanelId)
    {
        return impl::call_factory<HingeAngleSensor, IHingeAngleSensorStatics>([&](IHingeAngleSensorStatics const& f) { return f.GetRelatedToAdjacentPanelsAsync(firstPanelId, secondPanelId); });
    }
    inline auto HingeAngleSensor::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<HingeAngleSensor, IHingeAngleSensorStatics>([&](IHingeAngleSensorStatics const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto HumanPresenceSensor::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IHumanPresenceSensorStatics const&), HumanPresenceSensor, IHumanPresenceSensorStatics>([](IHumanPresenceSensorStatics const& f) { return f.GetDeviceSelector(); });
    }
    inline auto HumanPresenceSensor::FromIdAsync(param::hstring const& sensorId)
    {
        return impl::call_factory<HumanPresenceSensor, IHumanPresenceSensorStatics>([&](IHumanPresenceSensorStatics const& f) { return f.FromIdAsync(sensorId); });
    }
    inline auto HumanPresenceSensor::GetDefaultAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HumanPresenceSensor>(*)(IHumanPresenceSensorStatics const&), HumanPresenceSensor, IHumanPresenceSensorStatics>([](IHumanPresenceSensorStatics const& f) { return f.GetDefaultAsync(); });
    }
    inline auto HumanPresenceSensor::FromId(param::hstring const& sensorId)
    {
        return impl::call_factory<HumanPresenceSensor, IHumanPresenceSensorStatics2>([&](IHumanPresenceSensorStatics2 const& f) { return f.FromId(sensorId); });
    }
    inline auto HumanPresenceSensor::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::HumanPresenceSensor(*)(IHumanPresenceSensorStatics2 const&), HumanPresenceSensor, IHumanPresenceSensorStatics2>([](IHumanPresenceSensorStatics2 const& f) { return f.GetDefault(); });
    }
    inline HumanPresenceSensorReadingUpdate::HumanPresenceSensorReadingUpdate() :
        HumanPresenceSensorReadingUpdate(impl::call_factory_cast<HumanPresenceSensorReadingUpdate(*)(winrt::Windows::Foundation::IActivationFactory const&), HumanPresenceSensorReadingUpdate>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<HumanPresenceSensorReadingUpdate>(); }))
    {
    }
    inline auto HumanPresenceSettings::GetCurrentSettingsAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::HumanPresenceSettings>(*)(IHumanPresenceSettingsStatics const&), HumanPresenceSettings, IHumanPresenceSettingsStatics>([](IHumanPresenceSettingsStatics const& f) { return f.GetCurrentSettingsAsync(); });
    }
    inline auto HumanPresenceSettings::GetCurrentSettings()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::HumanPresenceSettings(*)(IHumanPresenceSettingsStatics const&), HumanPresenceSettings, IHumanPresenceSettingsStatics>([](IHumanPresenceSettingsStatics const& f) { return f.GetCurrentSettings(); });
    }
    inline auto HumanPresenceSettings::UpdateSettingsAsync(winrt::Windows::Devices::Sensors::HumanPresenceSettings const& settings)
    {
        return impl::call_factory<HumanPresenceSettings, IHumanPresenceSettingsStatics>([&](IHumanPresenceSettingsStatics const& f) { return f.UpdateSettingsAsync(settings); });
    }
    inline auto HumanPresenceSettings::UpdateSettings(winrt::Windows::Devices::Sensors::HumanPresenceSettings const& settings)
    {
        impl::call_factory<HumanPresenceSettings, IHumanPresenceSettingsStatics>([&](IHumanPresenceSettingsStatics const& f) { return f.UpdateSettings(settings); });
    }
    inline auto HumanPresenceSettings::GetSupportedFeaturesForSensorIdAsync(param::hstring const& sensorId)
    {
        return impl::call_factory<HumanPresenceSettings, IHumanPresenceSettingsStatics>([&](IHumanPresenceSettingsStatics const& f) { return f.GetSupportedFeaturesForSensorIdAsync(sensorId); });
    }
    inline auto HumanPresenceSettings::GetSupportedFeaturesForSensorId(param::hstring const& sensorId)
    {
        return impl::call_factory<HumanPresenceSettings, IHumanPresenceSettingsStatics>([&](IHumanPresenceSettingsStatics const& f) { return f.GetSupportedFeaturesForSensorId(sensorId); });
    }
    inline auto HumanPresenceSettings::GetSupportedLockOnLeaveTimeouts()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::TimeSpan>(*)(IHumanPresenceSettingsStatics const&), HumanPresenceSettings, IHumanPresenceSettingsStatics>([](IHumanPresenceSettingsStatics const& f) { return f.GetSupportedLockOnLeaveTimeouts(); });
    }
    inline auto HumanPresenceSettings::SettingsChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler)
    {
        return impl::call_factory<HumanPresenceSettings, IHumanPresenceSettingsStatics>([&](IHumanPresenceSettingsStatics const& f) { return f.SettingsChanged(handler); });
    }
    inline auto HumanPresenceSettings::SettingsChanged(auto_revoke_t, winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler)
    {
        auto f = get_activation_factory<HumanPresenceSettings, winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics>();
        return HumanPresenceSettings::SettingsChanged_revoker{ f, f.SettingsChanged(handler) };
    }
    inline auto HumanPresenceSettings::SettingsChanged(winrt::event_token const& token)
    {
        impl::call_factory<HumanPresenceSettings, IHumanPresenceSettingsStatics>([&](IHumanPresenceSettingsStatics const& f) { return f.SettingsChanged(token); });
    }
    inline auto Inclinometer::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Inclinometer(*)(IInclinometerStatics const&), Inclinometer, IInclinometerStatics>([](IInclinometerStatics const& f) { return f.GetDefault(); });
    }
    inline auto Inclinometer::GetDefaultForRelativeReadings()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Inclinometer(*)(IInclinometerStatics2 const&), Inclinometer, IInclinometerStatics2>([](IInclinometerStatics2 const& f) { return f.GetDefaultForRelativeReadings(); });
    }
    inline auto Inclinometer::GetDefault(winrt::Windows::Devices::Sensors::SensorReadingType const& sensorReadingtype)
    {
        return impl::call_factory<Inclinometer, IInclinometerStatics3>([&](IInclinometerStatics3 const& f) { return f.GetDefault(sensorReadingtype); });
    }
    inline auto Inclinometer::GetDeviceSelector(winrt::Windows::Devices::Sensors::SensorReadingType const& readingType)
    {
        return impl::call_factory<Inclinometer, IInclinometerStatics4>([&](IInclinometerStatics4 const& f) { return f.GetDeviceSelector(readingType); });
    }
    inline auto Inclinometer::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<Inclinometer, IInclinometerStatics4>([&](IInclinometerStatics4 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto LightSensor::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::LightSensor(*)(ILightSensorStatics const&), LightSensor, ILightSensorStatics>([](ILightSensorStatics const& f) { return f.GetDefault(); });
    }
    inline auto LightSensor::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(ILightSensorStatics2 const&), LightSensor, ILightSensorStatics2>([](ILightSensorStatics2 const& f) { return f.GetDeviceSelector(); });
    }
    inline auto LightSensor::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<LightSensor, ILightSensorStatics2>([&](ILightSensorStatics2 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto Magnetometer::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::Magnetometer(*)(IMagnetometerStatics const&), Magnetometer, IMagnetometerStatics>([](IMagnetometerStatics const& f) { return f.GetDefault(); });
    }
    inline auto Magnetometer::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IMagnetometerStatics2 const&), Magnetometer, IMagnetometerStatics2>([](IMagnetometerStatics2 const& f) { return f.GetDeviceSelector(); });
    }
    inline auto Magnetometer::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<Magnetometer, IMagnetometerStatics2>([&](IMagnetometerStatics2 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto OrientationSensor::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::OrientationSensor(*)(IOrientationSensorStatics const&), OrientationSensor, IOrientationSensorStatics>([](IOrientationSensorStatics const& f) { return f.GetDefault(); });
    }
    inline auto OrientationSensor::GetDefaultForRelativeReadings()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::OrientationSensor(*)(IOrientationSensorStatics2 const&), OrientationSensor, IOrientationSensorStatics2>([](IOrientationSensorStatics2 const& f) { return f.GetDefaultForRelativeReadings(); });
    }
    inline auto OrientationSensor::GetDefault(winrt::Windows::Devices::Sensors::SensorReadingType const& sensorReadingtype)
    {
        return impl::call_factory<OrientationSensor, IOrientationSensorStatics3>([&](IOrientationSensorStatics3 const& f) { return f.GetDefault(sensorReadingtype); });
    }
    inline auto OrientationSensor::GetDefault(winrt::Windows::Devices::Sensors::SensorReadingType const& sensorReadingType, winrt::Windows::Devices::Sensors::SensorOptimizationGoal const& optimizationGoal)
    {
        return impl::call_factory<OrientationSensor, IOrientationSensorStatics3>([&](IOrientationSensorStatics3 const& f) { return f.GetDefault(sensorReadingType, optimizationGoal); });
    }
    inline auto OrientationSensor::GetDeviceSelector(winrt::Windows::Devices::Sensors::SensorReadingType const& readingType)
    {
        return impl::call_factory<OrientationSensor, IOrientationSensorStatics4>([&](IOrientationSensorStatics4 const& f) { return f.GetDeviceSelector(readingType); });
    }
    inline auto OrientationSensor::GetDeviceSelector(winrt::Windows::Devices::Sensors::SensorReadingType const& readingType, winrt::Windows::Devices::Sensors::SensorOptimizationGoal const& optimizationGoal)
    {
        return impl::call_factory<OrientationSensor, IOrientationSensorStatics4>([&](IOrientationSensorStatics4 const& f) { return f.GetDeviceSelector(readingType, optimizationGoal); });
    }
    inline auto OrientationSensor::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<OrientationSensor, IOrientationSensorStatics4>([&](IOrientationSensorStatics4 const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto Pedometer::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<Pedometer, IPedometerStatics>([&](IPedometerStatics const& f) { return f.FromIdAsync(deviceId); });
    }
    inline auto Pedometer::GetDefaultAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Sensors::Pedometer>(*)(IPedometerStatics const&), Pedometer, IPedometerStatics>([](IPedometerStatics const& f) { return f.GetDefaultAsync(); });
    }
    inline auto Pedometer::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IPedometerStatics const&), Pedometer, IPedometerStatics>([](IPedometerStatics const& f) { return f.GetDeviceSelector(); });
    }
    inline auto Pedometer::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime)
    {
        return impl::call_factory<Pedometer, IPedometerStatics>([&](IPedometerStatics const& f) { return f.GetSystemHistoryAsync(fromTime); });
    }
    inline auto Pedometer::GetSystemHistoryAsync(winrt::Windows::Foundation::DateTime const& fromTime, winrt::Windows::Foundation::TimeSpan const& duration)
    {
        return impl::call_factory<Pedometer, IPedometerStatics>([&](IPedometerStatics const& f) { return f.GetSystemHistoryAsync(fromTime, duration); });
    }
    inline auto Pedometer::GetReadingsFromTriggerDetails(winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails const& triggerDetails)
    {
        return impl::call_factory<Pedometer, IPedometerStatics2>([&](IPedometerStatics2 const& f) { return f.GetReadingsFromTriggerDetails(triggerDetails); });
    }
    inline PedometerDataThreshold::PedometerDataThreshold(winrt::Windows::Devices::Sensors::Pedometer const& sensor, int32_t stepGoal) :
        PedometerDataThreshold(impl::call_factory<PedometerDataThreshold, IPedometerDataThresholdFactory>([&](IPedometerDataThresholdFactory const& f) { return f.Create(sensor, stepGoal); }))
    {
    }
    inline auto ProximitySensor::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(IProximitySensorStatics const&), ProximitySensor, IProximitySensorStatics>([](IProximitySensorStatics const& f) { return f.GetDeviceSelector(); });
    }
    inline auto ProximitySensor::FromId(param::hstring const& sensorId)
    {
        return impl::call_factory<ProximitySensor, IProximitySensorStatics>([&](IProximitySensorStatics const& f) { return f.FromId(sensorId); });
    }
    inline auto ProximitySensor::GetReadingsFromTriggerDetails(winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails const& triggerDetails)
    {
        return impl::call_factory<ProximitySensor, IProximitySensorStatics2>([&](IProximitySensorStatics2 const& f) { return f.GetReadingsFromTriggerDetails(triggerDetails); });
    }
    inline ProximitySensorDataThreshold::ProximitySensorDataThreshold(winrt::Windows::Devices::Sensors::ProximitySensor const& sensor) :
        ProximitySensorDataThreshold(impl::call_factory<ProximitySensorDataThreshold, IProximitySensorDataThresholdFactory>([&](IProximitySensorDataThresholdFactory const& f) { return f.Create(sensor); }))
    {
    }
    inline auto SimpleOrientationSensor::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Devices::Sensors::SimpleOrientationSensor(*)(ISimpleOrientationSensorStatics const&), SimpleOrientationSensor, ISimpleOrientationSensorStatics>([](ISimpleOrientationSensorStatics const& f) { return f.GetDefault(); });
    }
    inline auto SimpleOrientationSensor::GetDeviceSelector()
    {
        return impl::call_factory_cast<hstring(*)(ISimpleOrientationSensorStatics2 const&), SimpleOrientationSensor, ISimpleOrientationSensorStatics2>([](ISimpleOrientationSensorStatics2 const& f) { return f.GetDeviceSelector(); });
    }
    inline auto SimpleOrientationSensor::FromIdAsync(param::hstring const& deviceId)
    {
        return impl::call_factory<SimpleOrientationSensor, ISimpleOrientationSensorStatics2>([&](ISimpleOrientationSensorStatics2 const& f) { return f.FromIdAsync(deviceId); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometer3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometer4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometer5> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerShakenEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAccelerometerStatics3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IActivitySensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IActivitySensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangeReport> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IActivitySensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IActivitySensorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IActivitySensorTriggerDetails> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAdaptiveDimmingOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAltimeter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAltimeter2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAltimeterReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAltimeterReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAltimeterReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IAltimeterStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometer3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometerReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IBarometerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompass> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompass2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompass3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompass4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassReadingHeadingAccuracy> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ICompassStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IDetectedPerson> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometer3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometer4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometerDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometerReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IGyrometerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHeadOrientation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHeadPosition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHingeAngleReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHingeAngleSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHingeAngleSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHingeAngleSensorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures2> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceFeatures3>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensor2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensor3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReading3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Devices::Sensors::IHumanPresenceSensorReadingUpdate2>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSensorStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSettings2> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSettings3>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IHumanPresenceSettingsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometer3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometer4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerReadingYawAccuracy> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerStatics3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IInclinometerStatics4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensor2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensor3> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Devices::Sensors::ILightSensor4>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Devices::Sensors::ILightSensorDataThreshold2>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensorDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensorReading2> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Devices::Sensors::ILightSensorReading3>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILightSensorStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ILockOnLeaveOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometer3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometer4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometerDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometerReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IMagnetometerStatics2> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Devices::Sensors::IOnlookerDetectionOptions>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensor2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensor3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorReading2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorReadingYawAccuracy> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorStatics3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IOrientationSensorStatics4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IPedometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IPedometer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IPedometerDataThresholdFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IPedometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IPedometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IPedometerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IPedometerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IProximitySensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IProximitySensorDataThresholdFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IProximitySensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IProximitySensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IProximitySensorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IProximitySensorStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISensorDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISensorDataThresholdTriggerDetails> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISensorQuaternion> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISensorRotationMatrix> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISimpleOrientationSensor2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorDeviceId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorOrientationChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ISimpleOrientationSensorStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::IWakeOnApproachOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Accelerometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::AccelerometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ActivitySensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ActivitySensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::AdaptiveDimmingOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Altimeter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::AltimeterReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Barometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::BarometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::BarometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Compass> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::CompassDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::CompassReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::DetectedPerson> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Gyrometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::GyrometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::GyrometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HeadOrientation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HeadPosition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HingeAngleReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HingeAngleSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HumanPresenceFeatures> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HumanPresenceSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::HumanPresenceSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Inclinometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::InclinometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::InclinometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::LightSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::LightSensorDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::LightSensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::LockOnLeaveOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Magnetometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::MagnetometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Devices::Sensors::OnlookerDetectionOptions>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::OrientationSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::OrientationSensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::Pedometer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::PedometerDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::PedometerReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ProximitySensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ProximitySensorReading> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::SensorQuaternion> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::SensorRotationMatrix> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::SimpleOrientationSensor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Devices::Sensors::WakeOnApproachOptions> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
