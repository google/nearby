// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Windows_Storage_Provider_H
#define WINRT_Windows_Storage_Provider_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Windows.Storage.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Storage.2.h"
#include "winrt/impl/Windows.Storage.Provider.2.h"
#include "winrt/impl/Windows.Storage.Search.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/Windows.UI.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterStatics<D>::SetUpdateInformation(winrt::Windows::Storage::IStorageFile const& file, param::hstring const& contentId, winrt::Windows::Storage::Provider::ReadActivationMode const& readMode, winrt::Windows::Storage::Provider::WriteActivationMode const& writeMode, winrt::Windows::Storage::Provider::CachedFileOptions const& options) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetUpdateInformation(*(void**)(&file), *(void**)(&contentId), static_cast<int32_t>(readMode), static_cast<int32_t>(writeMode), static_cast<uint32_t>(options)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterStatics>**)this;
            check_hresult(_winrt_abi_type->SetUpdateInformation(*(void**)(&file), *(void**)(&contentId), static_cast<int32_t>(readMode), static_cast<int32_t>(writeMode), static_cast<uint32_t>(options)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::Title(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::UpdateTarget() const
    {
        winrt::Windows::Storage::Provider::CachedFileTarget value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UpdateTarget(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            check_hresult(_winrt_abi_type->get_UpdateTarget(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::FileUpdateRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_FileUpdateRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            check_hresult(_winrt_abi_type->add_FileUpdateRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::FileUpdateRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, FileUpdateRequested_revoker>(this, FileUpdateRequested(handler));
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::FileUpdateRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            _winrt_abi_type->remove_FileUpdateRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            _winrt_abi_type->remove_FileUpdateRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::UIRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_UIRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            check_hresult(_winrt_abi_type->add_UIRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::UIRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, UIRequested_revoker>(this, UIRequested(handler));
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::UIRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            _winrt_abi_type->remove_UIRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            _winrt_abi_type->remove_UIRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI<D>::UIStatus() const
    {
        winrt::Windows::Storage::Provider::UIStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UIStatus(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>**)this;
            check_hresult(_winrt_abi_type->get_UIStatus(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI2<D>::UpdateRequest() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UpdateRequest(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2>**)this;
            check_hresult(_winrt_abi_type->get_UpdateRequest(&value));
        }
        return winrt::Windows::Storage::Provider::FileUpdateRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_ICachedFileUpdaterUI2<D>::GetDeferral() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeferral(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2>**)this;
            check_hresult(_winrt_abi_type->GetDeferral(&value));
        }
        return winrt::Windows::Storage::Provider::FileUpdateRequestDeferral{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest<D>::ContentId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)this;
            check_hresult(_winrt_abi_type->get_ContentId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest<D>::File() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_File(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)this;
            check_hresult(_winrt_abi_type->get_File(&value));
        }
        return winrt::Windows::Storage::StorageFile{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest<D>::Status() const
    {
        winrt::Windows::Storage::Provider::FileUpdateStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest<D>::Status(winrt::Windows::Storage::Provider::FileUpdateStatus const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)this;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest<D>::GetDeferral() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeferral(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)this;
            check_hresult(_winrt_abi_type->GetDeferral(&value));
        }
        return winrt::Windows::Storage::Provider::FileUpdateRequestDeferral{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest<D>::UpdateLocalFile(winrt::Windows::Storage::IStorageFile const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->UpdateLocalFile(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest>**)this;
            check_hresult(_winrt_abi_type->UpdateLocalFile(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest2<D>::UserInputNeededMessage() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UserInputNeededMessage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest2>**)this;
            check_hresult(_winrt_abi_type->get_UserInputNeededMessage(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequest2<D>::UserInputNeededMessage(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequest2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequest2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_UserInputNeededMessage(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequest2>**)this;
            check_hresult(_winrt_abi_type->put_UserInputNeededMessage(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequestDeferral<D>::Complete() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequestDeferral>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequestDeferral, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequestDeferral>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Complete());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequestDeferral>**)this;
            check_hresult(_winrt_abi_type->Complete());
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IFileUpdateRequestedEventArgs<D>::Request() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IFileUpdateRequestedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IFileUpdateRequestedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequestedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IFileUpdateRequestedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        return winrt::Windows::Storage::Provider::FileUpdateRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderFileTypeInfo<D>::FileExtension() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FileExtension(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo>**)this;
            check_hresult(_winrt_abi_type->get_FileExtension(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderFileTypeInfo<D>::IconResource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconResource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo>**)this;
            check_hresult(_winrt_abi_type->get_IconResource(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderFileTypeInfoFactory<D>::CreateInstance(param::hstring const& fileExtension, param::hstring const& iconResource) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfoFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfoFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfoFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&fileExtension), *(void**)(&iconResource), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfoFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&fileExtension), *(void**)(&iconResource), &value));
        }
        return winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetContentInfoForPathResult<D>::Status() const
    {
        winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetContentInfoForPathResult<D>::Status(winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)this;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetContentInfoForPathResult<D>::ContentUri() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentUri(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)this;
            check_hresult(_winrt_abi_type->get_ContentUri(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetContentInfoForPathResult<D>::ContentUri(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ContentUri(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)this;
            check_hresult(_winrt_abi_type->put_ContentUri(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetContentInfoForPathResult<D>::ContentId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)this;
            check_hresult(_winrt_abi_type->get_ContentId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetContentInfoForPathResult<D>::ContentId(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ContentId(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>**)this;
            check_hresult(_winrt_abi_type->put_ContentId(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetPathForContentUriResult<D>::Status() const
    {
        winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetPathForContentUriResult<D>::Status(winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)this;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetPathForContentUriResult<D>::Path() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Path(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)this;
            check_hresult(_winrt_abi_type->get_Path(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderGetPathForContentUriResult<D>::Path(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Path(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>**)this;
            check_hresult(_winrt_abi_type->put_Path(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemPropertiesStatics<D>::SetAsync(winrt::Windows::Storage::IStorageItem const& item, param::async_iterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty> const& itemProperties) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertiesStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemPropertiesStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertiesStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetAsync(*(void**)(&item), *(void**)(&itemProperties), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertiesStatics>**)this;
            check_hresult(_winrt_abi_type->SetAsync(*(void**)(&item), *(void**)(&itemProperties), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemProperty<D>::Id(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Id(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)this;
            check_hresult(_winrt_abi_type->put_Id(value));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemProperty<D>::Id() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)this;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemProperty<D>::Value(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Value(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)this;
            check_hresult(_winrt_abi_type->put_Value(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemProperty<D>::Value() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemProperty<D>::IconResource(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconResource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)this;
            check_hresult(_winrt_abi_type->put_IconResource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemProperty<D>::IconResource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconResource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemProperty>**)this;
            check_hresult(_winrt_abi_type->get_IconResource(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemPropertyDefinition<D>::Id() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)this;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemPropertyDefinition<D>::Id(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Id(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)this;
            check_hresult(_winrt_abi_type->put_Id(value));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemPropertyDefinition<D>::DisplayNameResource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayNameResource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)this;
            check_hresult(_winrt_abi_type->get_DisplayNameResource(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemPropertyDefinition<D>::DisplayNameResource(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DisplayNameResource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>**)this;
            check_hresult(_winrt_abi_type->put_DisplayNameResource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderItemPropertySource<D>::GetItemProperties(param::hstring const& itemPath) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetItemProperties(*(void**)(&itemPath), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>**)this;
            check_hresult(_winrt_abi_type->GetItemProperties(*(void**)(&itemPath), &result));
        }
        return winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderEntry<D>::KnownFolderId() const
    {
        winrt::guid value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_KnownFolderId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)this;
            check_hresult(_winrt_abi_type->get_KnownFolderId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderEntry<D>::KnownFolderId(winrt::guid const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_KnownFolderId(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)this;
            check_hresult(_winrt_abi_type->put_KnownFolderId(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderEntry<D>::Status() const
    {
        winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderEntry<D>::Status(winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncStatus const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>**)this;
            check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfo<D>::ProviderDisplayName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderDisplayName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)this;
            check_hresult(_winrt_abi_type->get_ProviderDisplayName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfo<D>::ProviderDisplayName(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProviderDisplayName(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)this;
            check_hresult(_winrt_abi_type->put_ProviderDisplayName(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfo<D>::KnownFolderEntries() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_KnownFolderEntries(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)this;
            check_hresult(_winrt_abi_type->get_KnownFolderEntries(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfo<D>::SyncRequested() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SyncRequested(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)this;
            check_hresult(_winrt_abi_type->get_SyncRequested(&value));
        }
        return winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfo<D>::SyncRequested(winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SyncRequested(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>**)this;
            check_hresult(_winrt_abi_type->put_SyncRequested(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfoSource<D>::GetKnownFolderSyncInfo() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetKnownFolderSyncInfo(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>**)this;
            check_hresult(_winrt_abi_type->GetKnownFolderSyncInfo(&result));
        }
        return winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfoSource<D>::KnownFolderSyncInfoChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_KnownFolderSyncInfoChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>**)this;
            check_hresult(_winrt_abi_type->add_KnownFolderSyncInfoChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfoSource<D>::KnownFolderSyncInfoChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, KnownFolderSyncInfoChanged_revoker>(this, KnownFolderSyncInfoChanged(handler));
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfoSource<D>::KnownFolderSyncInfoChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_KnownFolderSyncInfoChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>**)this;
            _winrt_abi_type->remove_KnownFolderSyncInfoChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncInfoSourceFactory<D>::GetKnownFolderSyncInfoSource() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetKnownFolderSyncInfoSource(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>**)this;
            check_hresult(_winrt_abi_type->GetKnownFolderSyncInfoSource(&result));
        }
        return winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncRequestArgs<D>::KnownFolders() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_KnownFolders(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs>**)this;
            check_hresult(_winrt_abi_type->get_KnownFolders(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::guid>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderKnownFolderSyncRequestArgs<D>::Source() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs>**)this;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        return winrt::Windows::Storage::StorageFolder{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderMoreInfoUI<D>::Message() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Message(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)this;
            check_hresult(_winrt_abi_type->get_Message(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderMoreInfoUI<D>::Message(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Message(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)this;
            check_hresult(_winrt_abi_type->put_Message(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderMoreInfoUI<D>::Command() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Command(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)this;
            check_hresult(_winrt_abi_type->get_Command(&value));
        }
        return winrt::Windows::Storage::Provider::IStorageProviderUICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderMoreInfoUI<D>::Command(winrt::Windows::Storage::Provider::IStorageProviderUICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Command(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>**)this;
            check_hresult(_winrt_abi_type->put_Command(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderPropertyCapabilities<D>::IsPropertySupported(param::hstring const& propertyCanonicalName) const
    {
        bool isSupported{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsPropertySupported(*(void**)(&propertyCanonicalName), &isSupported));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>**)this;
            check_hresult(_winrt_abi_type->IsPropertySupported(*(void**)(&propertyCanonicalName), &isSupported));
        }
        return isSupported;
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResult<D>::Kind()
        const {
      winrt::Windows::Storage::Provider::StorageProviderResultKind value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(
            _winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResult<D>::Kind(
        winrt::Windows::Storage::Provider::StorageProviderResultKind const&
            value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_Kind(static_cast<int32_t>(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->put_Kind(static_cast<int32_t>(value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResult<
        D>::ResultId() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ResultId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->get_ResultId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderQueryResult<D>::ResultId(
        param::hstring const& value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_ResultId(*(void**)(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->put_ResultId(*(void**)(&value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResult<
        D>::RemoteFileId() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RemoteFileId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->get_RemoteFileId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResult<
        D>::RemoteFileId(param::hstring const& value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_RemoteFileId(*(void**)(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->put_RemoteFileId(*(void**)(&value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResult<
        D>::FilePath() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_FilePath(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->get_FilePath(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderQueryResult<D>::FilePath(
        param::hstring const& value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_FilePath(*(void**)(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->put_FilePath(*(void**)(&value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResult<
        D>::RequestedProperties() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RequestedProperties(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResult>**)this;
        check_hresult(_winrt_abi_type->get_RequestedProperties(&value));
      }
      return winrt::Windows::Foundation::Collections::PropertySet{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResultSet<
        D>::GetResults() const {
      uint32_t result_impl_size{};
      void** result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResultSet>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResultSet,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->GetResults(&result_impl_size, &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)this;
        check_hresult(_winrt_abi_type->GetResults(&result_impl_size, &result));
      }
      return com_array<
          winrt::Windows::Storage::Provider::IStorageProviderQueryResult>{
          result, result_impl_size, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResultSet<
        D>::QueryResultId() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResultSet>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResultSet,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_QueryResultId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)this;
        check_hresult(_winrt_abi_type->get_QueryResultId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResultSet<
        D>::QueryResultId(param::hstring const& value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResultSet>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResultSet,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_QueryResultId(*(void**)(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)this;
        check_hresult(_winrt_abi_type->put_QueryResultId(*(void**)(&value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResultSet<
        D>::Status() const {
      winrt::Windows::Storage::Provider::StorageProviderSearchQueryStatus
          value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResultSet>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResultSet,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)this;
        check_hresult(
            _winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderQueryResultSet<D>::Status(
        winrt::Windows::Storage::Provider::
            StorageProviderSearchQueryStatus const& value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderQueryResultSet>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderQueryResultSet,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSet>**)this;
        check_hresult(_winrt_abi_type->put_Status(static_cast<int32_t>(value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderQueryResultSetFactory<
        D>::CreateInstance(array_view<winrt::Windows::Storage::Provider::
                                          IStorageProviderQueryResult const>
                               results) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Storage::Provider::
                               IStorageProviderQueryResultSetFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderQueryResultSetFactory,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderQueryResultSetFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            results.size(), get_abi(results), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderQueryResultSetFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            results.size(), get_abi(results), &value));
      }
      return winrt::Windows::Storage::Provider::StorageProviderQueryResultSet{
          value, take_ownership_from_abi};
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaTotalInBytes() const
    {
        uint64_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_QuotaTotalInBytes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->get_QuotaTotalInBytes(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaTotalInBytes(uint64_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_QuotaTotalInBytes(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->put_QuotaTotalInBytes(value));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaUsedInBytes() const
    {
        uint64_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_QuotaUsedInBytes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->get_QuotaUsedInBytes(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaUsedInBytes(uint64_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_QuotaUsedInBytes(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->put_QuotaUsedInBytes(value));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaUsedLabel() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_QuotaUsedLabel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->get_QuotaUsedLabel(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaUsedLabel(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_QuotaUsedLabel(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->put_QuotaUsedLabel(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaUsedColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_QuotaUsedColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->get_QuotaUsedColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderQuotaUI<D>::QuotaUsedColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_QuotaUsedColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>**)this;
            check_hresult(_winrt_abi_type->put_QuotaUsedColor(*(void**)(&value)));
        }
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSearchHandler<D>::Find(
        winrt::Windows::Storage::Provider::
            StorageProviderSearchQueryOptions const& options) const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchHandler>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchHandler,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchHandler>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->Find(*(void**)(&options), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchHandler>**)this;
        check_hresult(_winrt_abi_type->Find(*(void**)(&options), &result));
      }
      return winrt::Windows::Storage::Provider::StorageProviderQueryResultSet{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchHandler<D>::
        ReportUsage(winrt::Windows::Storage::Provider::
                        StorageProviderResultUsageKind const& resultUsageKind,
                    param::hstring const& remoteFileId,
                    param::hstring const& resultId,
                    winrt::Windows::Foundation::TimeSpan const& latency) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchHandler>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchHandler,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchHandler>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->ReportUsage(
            static_cast<int32_t>(resultUsageKind), *(void**)(&remoteFileId),
            *(void**)(&resultId), impl::bind_in(latency)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchHandler>**)this;
        check_hresult(_winrt_abi_type->ReportUsage(
            static_cast<int32_t>(resultUsageKind), *(void**)(&remoteFileId),
            *(void**)(&resultId), impl::bind_in(latency)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchHandlerFactory<
        D>::CreateSearchHandler(param::hstring const& cloudProviderId) const {
      void* result{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchHandlerFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchHandlerFactory,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchHandlerFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateSearchHandler(
            *(void**)(&cloudProviderId), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchHandlerFactory>**)this;
        check_hresult(_winrt_abi_type->CreateSearchHandler(
            *(void**)(&cloudProviderId), &result));
      }
      return winrt::Windows::Storage::Provider::IStorageProviderSearchHandler{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::UserQuery() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_UserQuery(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_UserQuery(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::Language() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Language(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_Language(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::SortOrder() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_SortOrder(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_SortOrder(&value));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Windows::Storage::Search::SortEntry>{value,
                                                      take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::ProgrammaticQuery() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ProgrammaticQuery(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_ProgrammaticQuery(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::MaxResults() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_MaxResults(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_MaxResults(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::FolderScope() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_FolderScope(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_FolderScope(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::QueryId() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_QueryId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_QueryId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchQueryOptions<
        D>::PropertiesToFetch() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSearchQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSearchQueryOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSearchQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_PropertiesToFetch(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_PropertiesToFetch(&value));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<hstring>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchResult<
        D>::MatchScore() const {
      double value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_MatchScore(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)this;
        check_hresult(_winrt_abi_type->get_MatchScore(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchResult<
        D>::MatchScore(double value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_MatchScore(value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)this;
        check_hresult(_winrt_abi_type->put_MatchScore(value));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchResult<
        D>::MatchKind() const {
      winrt::Windows::Storage::Provider::StorageProviderSearchMatchKind value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_MatchKind(reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)this;
        check_hresult(
            _winrt_abi_type->get_MatchKind(reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSearchResult<D>::MatchKind(
        winrt::Windows::Storage::Provider::StorageProviderSearchMatchKind const&
            value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->put_MatchKind(static_cast<int32_t>(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)this;
        check_hresult(
            _winrt_abi_type->put_MatchKind(static_cast<int32_t>(value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchResult<
        D>::MatchedPropertyName() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_MatchedPropertyName(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)this;
        check_hresult(_winrt_abi_type->get_MatchedPropertyName(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSearchResult<
        D>::MatchedPropertyName(param::hstring const& value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderSearchResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderSearchResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->put_MatchedPropertyName(*(void**)(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSearchResult>**)this;
        check_hresult(
            _winrt_abi_type->put_MatchedPropertyName(*(void**)(&value)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderShareLinkSource<D>::
        CreateLinkAsync(param::async_vector_view<
                        winrt::Windows::Storage::IStorageItem> const&
                            storageItemList) const {
      void* operation{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderShareLinkSource>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Storage::Provider::
                      IStorageProviderShareLinkSource>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateLinkAsync(
            *(void**)(&storageItemList), &operation));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderShareLinkSource>**)this;
        check_hresult(_winrt_abi_type->CreateLinkAsync(
            *(void**)(&storageItemList), &operation));
      }
      return winrt::Windows::Foundation::IAsyncOperation<
          winrt::Windows::Foundation::Uri>{operation, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderShareLinkSource<D>::
        GetDefaultAccessControlStringAsync(
            param::async_vector_view<
                winrt::Windows::Storage::IStorageItem> const& storageItemList)
            const {
      void* operation{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderShareLinkSource>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Storage::Provider::
                      IStorageProviderShareLinkSource>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->GetDefaultAccessControlStringAsync(
            *(void**)(&storageItemList), &operation));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderShareLinkSource>**)this;
        check_hresult(_winrt_abi_type->GetDefaultAccessControlStringAsync(
            *(void**)(&storageItemList), &operation));
      }
      return winrt::Windows::Foundation::IAsyncOperation<hstring>{
          operation, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderShareLinkSource<D>::
        GetState(param::async_vector_view<
                 winrt::Windows::Storage::IStorageItem> const& storageItemList)
            const {
      void* operation{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::
                                           IStorageProviderShareLinkSource>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Storage::Provider::
                      IStorageProviderShareLinkSource>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->GetState(*(void**)(&storageItemList), &operation));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderShareLinkSource>**)this;
        check_hresult(
            _winrt_abi_type->GetState(*(void**)(&storageItemList), &operation));
      }
      return winrt::Windows::Foundation::IAsyncOperation<
          winrt::Windows::Storage::Provider::StorageProviderShareLinkState>{
          operation, take_ownership_from_abi};
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderState() const
    {
        winrt::Windows::Storage::Provider::StorageProviderState value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderState(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_ProviderState(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderState(winrt::Windows::Storage::Provider::StorageProviderState const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProviderState(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_ProviderState(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderStateLabel() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderStateLabel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_ProviderStateLabel(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderStateLabel(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProviderStateLabel(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_ProviderStateLabel(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderStateIcon() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderStateIcon(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_ProviderStateIcon(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderStateIcon(winrt::Windows::Foundation::Uri const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProviderStateIcon(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_ProviderStateIcon(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::SyncStatusCommand() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SyncStatusCommand(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_SyncStatusCommand(&value));
        }
        return winrt::Windows::Storage::Provider::IStorageProviderUICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::SyncStatusCommand(winrt::Windows::Storage::Provider::IStorageProviderUICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SyncStatusCommand(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_SyncStatusCommand(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::QuotaUI() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_QuotaUI(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_QuotaUI(&value));
        }
        return winrt::Windows::Storage::Provider::StorageProviderQuotaUI{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::QuotaUI(winrt::Windows::Storage::Provider::StorageProviderQuotaUI const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_QuotaUI(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_QuotaUI(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::MoreInfoUI() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoreInfoUI(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_MoreInfoUI(&value));
        }
        return winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::MoreInfoUI(winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MoreInfoUI(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_MoreInfoUI(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderPrimaryCommand() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderPrimaryCommand(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_ProviderPrimaryCommand(&value));
        }
        return winrt::Windows::Storage::Provider::IStorageProviderUICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderPrimaryCommand(winrt::Windows::Storage::Provider::IStorageProviderUICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProviderPrimaryCommand(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_ProviderPrimaryCommand(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderSecondaryCommands() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderSecondaryCommands(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->get_ProviderSecondaryCommands(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::IStorageProviderUICommand>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUI<D>::ProviderSecondaryCommands(param::vector<winrt::Windows::Storage::Provider::IStorageProviderUICommand> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUI, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProviderSecondaryCommands(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUI>**)this;
            check_hresult(_winrt_abi_type->put_ProviderSecondaryCommands(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUISource<D>::GetStatusUI() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetStatusUI(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>**)this;
            check_hresult(_winrt_abi_type->GetStatusUI(&result));
        }
        return winrt::Windows::Storage::Provider::StorageProviderStatusUI{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUISource<D>::StatusUIChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_StatusUIChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>**)this;
            check_hresult(_winrt_abi_type->add_StatusUIChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUISource<D>::StatusUIChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, StatusUIChanged_revoker>(this, StatusUIChanged(handler));
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUISource<D>::StatusUIChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_StatusUIChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>**)this;
            _winrt_abi_type->remove_StatusUIChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderStatusUISourceFactory<D>::GetStatusUISource(param::hstring const& syncRootId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetStatusUISource(*(void**)(&syncRootId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>**)this;
            check_hresult(_winrt_abi_type->GetStatusUISource(*(void**)(&syncRootId), &result));
        }
        return winrt::Windows::Storage::Provider::IStorageProviderStatusUISource{ result, take_ownership_from_abi };
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSuggestionsHandler<
        D>::GetSuggestions(winrt::Windows::Storage::Provider::
                               StorageProviderSuggestionsQueryOptions const&
                                   options) const {
      void* result{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSuggestionsHandler>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSuggestionsHandler,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsHandler>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->GetSuggestions(*(void**)(&options), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsHandler>**)this;
        check_hresult(
            _winrt_abi_type->GetSuggestions(*(void**)(&options), &result));
      }
      return winrt::Windows::Storage::Provider::StorageProviderQueryResultSet{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsHandler<D>::Add(
        winrt::Windows::Storage::Provider::StorageProviderResultKind const&
            kind,
        param::hstring const& remoteFileId) const {
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSuggestionsHandler>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSuggestionsHandler,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsHandler>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->Add(static_cast<int32_t>(kind),
                                           *(void**)(&remoteFileId)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsHandler>**)this;
        check_hresult(_winrt_abi_type->Add(static_cast<int32_t>(kind),
                                           *(void**)(&remoteFileId)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSuggestionsHandler<
        D>::Remove(winrt::Windows::Storage::Provider::
                       StorageProviderResultKind const& kind,
                   param::hstring const& remoteFileId) const {
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSuggestionsHandler>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSuggestionsHandler,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsHandler>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->Remove(static_cast<int32_t>(kind),
                                              *(void**)(&remoteFileId)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsHandler>**)this;
        check_hresult(_winrt_abi_type->Remove(static_cast<int32_t>(kind),
                                              *(void**)(&remoteFileId)));
      }
    }
    template <typename D>
    auto consume_Windows_Storage_Provider_IStorageProviderSuggestionsHandler<
        D>::GetDetails(param::hstring const& remoteFileId,
                       array_view<hstring const> propertiesToFetch,
                       param::hstring const& queryId) const {
      void* result{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSuggestionsHandler>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSuggestionsHandler,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsHandler>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->GetDetails(
            *(void**)(&remoteFileId), propertiesToFetch.size(),
            get_abi(propertiesToFetch), *(void**)(&queryId), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsHandler>**)this;
        check_hresult(_winrt_abi_type->GetDetails(
            *(void**)(&remoteFileId), propertiesToFetch.size(),
            get_abi(propertiesToFetch), *(void**)(&queryId), &result));
      }
      return winrt::Windows::Storage::Provider::StorageProviderSuggestionResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsHandler<D>::
        ReportUsage(winrt::Windows::Storage::Provider::
                        StorageProviderResultUsageKind const& resultUsageKind,
                    param::hstring const& remoteFileId,
                    param::hstring const& resultId,
                    winrt::Windows::Foundation::TimeSpan const& latency) const {
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Storage::Provider::
                                        IStorageProviderSuggestionsHandler>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Storage::Provider::
                                         IStorageProviderSuggestionsHandler,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsHandler>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->ReportUsage(
            static_cast<int32_t>(resultUsageKind), *(void**)(&remoteFileId),
            *(void**)(&resultId), impl::bind_in(latency)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsHandler>**)this;
        check_hresult(_winrt_abi_type->ReportUsage(
            static_cast<int32_t>(resultUsageKind), *(void**)(&remoteFileId),
            *(void**)(&resultId), impl::bind_in(latency)));
      }
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsHandlerFactory<
        D>::CreateSuggestionsHandler(param::hstring const& cloudProviderId)
        const {
      void* result{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Storage::Provider::
                               IStorageProviderSuggestionsHandlerFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::
                IStorageProviderSuggestionsHandlerFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsHandlerFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateSuggestionsHandler(
            *(void**)(&cloudProviderId), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsHandlerFactory>**)this;
        check_hresult(_winrt_abi_type->CreateSuggestionsHandler(
            *(void**)(&cloudProviderId), &result));
      }
      return winrt::Windows::Storage::Provider::
          IStorageProviderSuggestionsHandler{result, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsQueryOptions<
        D>::SuggestionsKind() const {
      winrt::Windows::Storage::Provider::StorageProviderResultKind value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Storage::Provider::
                               IStorageProviderSuggestionsQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::
                IStorageProviderSuggestionsQueryOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_SuggestionsKind(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_SuggestionsKind(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsQueryOptions<
        D>::RemoteFileId() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Storage::Provider::
                               IStorageProviderSuggestionsQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::
                IStorageProviderSuggestionsQueryOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RemoteFileId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_RemoteFileId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsQueryOptions<
        D>::MaxResults() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Storage::Provider::
                               IStorageProviderSuggestionsQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::
                IStorageProviderSuggestionsQueryOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_MaxResults(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_MaxResults(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsQueryOptions<
        D>::QueryId() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Storage::Provider::
                               IStorageProviderSuggestionsQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::
                IStorageProviderSuggestionsQueryOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_QueryId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_QueryId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Storage_Provider_IStorageProviderSuggestionsQueryOptions<
        D>::PropertiesToFetch() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Storage::Provider::
                               IStorageProviderSuggestionsQueryOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Storage::Provider::
                IStorageProviderSuggestionsQueryOptions,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsQueryOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_PropertiesToFetch(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Storage::Provider::
                        IStorageProviderSuggestionsQueryOptions>**)this;
        check_hresult(_winrt_abi_type->get_PropertiesToFetch(&value));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<hstring>{
          value, take_ownership_from_abi};
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Id() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Id(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Id(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_Id(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Context() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Context(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_Context(&value));
        }
        return winrt::Windows::Storage::Streams::IBuffer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Context(winrt::Windows::Storage::Streams::IBuffer const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Context(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_Context(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Path() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Path(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_Path(&value));
        }
        return winrt::Windows::Storage::IStorageFolder{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Path(winrt::Windows::Storage::IStorageFolder const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Path(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_Path(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::DisplayNameResource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayNameResource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_DisplayNameResource(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::DisplayNameResource(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DisplayNameResource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_DisplayNameResource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::IconResource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconResource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_IconResource(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::IconResource(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconResource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_IconResource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::HydrationPolicy() const
    {
        winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HydrationPolicy(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_HydrationPolicy(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::HydrationPolicy(winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HydrationPolicy(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_HydrationPolicy(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::HydrationPolicyModifier() const
    {
        winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HydrationPolicyModifier(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_HydrationPolicyModifier(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::HydrationPolicyModifier(winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HydrationPolicyModifier(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_HydrationPolicyModifier(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::PopulationPolicy() const
    {
        winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PopulationPolicy(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_PopulationPolicy(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::PopulationPolicy(winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PopulationPolicy(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_PopulationPolicy(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::InSyncPolicy() const
    {
        winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InSyncPolicy(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_InSyncPolicy(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::InSyncPolicy(winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InSyncPolicy(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_InSyncPolicy(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::HardlinkPolicy() const
    {
        winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HardlinkPolicy(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_HardlinkPolicy(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::HardlinkPolicy(winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HardlinkPolicy(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_HardlinkPolicy(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::ShowSiblingsAsGroup() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowSiblingsAsGroup(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_ShowSiblingsAsGroup(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::ShowSiblingsAsGroup(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShowSiblingsAsGroup(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_ShowSiblingsAsGroup(value));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Version() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Version(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_Version(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::Version(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Version(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_Version(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::ProtectionMode() const
    {
        winrt::Windows::Storage::Provider::StorageProviderProtectionMode value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProtectionMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_ProtectionMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::ProtectionMode(winrt::Windows::Storage::Provider::StorageProviderProtectionMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProtectionMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_ProtectionMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::AllowPinning() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowPinning(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_AllowPinning(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::AllowPinning(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowPinning(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_AllowPinning(value));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::StorageProviderItemPropertyDefinitions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StorageProviderItemPropertyDefinitions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_StorageProviderItemPropertyDefinitions(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::RecycleBinUri() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RecycleBinUri(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->get_RecycleBinUri(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo<D>::RecycleBinUri(winrt::Windows::Foundation::Uri const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RecycleBinUri(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>**)this;
            check_hresult(_winrt_abi_type->put_RecycleBinUri(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo2<D>::ProviderId() const
    {
        winrt::guid value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2>**)this;
            check_hresult(_winrt_abi_type->get_ProviderId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo2<D>::ProviderId(winrt::guid const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProviderId(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2>**)this;
            check_hresult(_winrt_abi_type->put_ProviderId(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootInfo3<D>::FallbackFileTypeInfo() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FallbackFileTypeInfo(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo3>**)this;
            check_hresult(_winrt_abi_type->get_FallbackFileTypeInfo(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootManagerStatics<D>::Register(winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo const& syncRootInformation) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Register(*(void**)(&syncRootInformation)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)this;
            check_hresult(_winrt_abi_type->Register(*(void**)(&syncRootInformation)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootManagerStatics<D>::Unregister(param::hstring const& id) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Unregister(*(void**)(&id)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)this;
            check_hresult(_winrt_abi_type->Unregister(*(void**)(&id)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootManagerStatics<D>::GetSyncRootInformationForFolder(winrt::Windows::Storage::IStorageFolder const& folder) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSyncRootInformationForFolder(*(void**)(&folder), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)this;
            check_hresult(_winrt_abi_type->GetSyncRootInformationForFolder(*(void**)(&folder), &result));
        }
        return winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootManagerStatics<D>::GetSyncRootInformationForId(param::hstring const& id) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSyncRootInformationForId(*(void**)(&id), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)this;
            check_hresult(_winrt_abi_type->GetSyncRootInformationForId(*(void**)(&id), &result));
        }
        return winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootManagerStatics<D>::GetCurrentSyncRoots() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentSyncRoots(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>**)this;
            check_hresult(_winrt_abi_type->GetCurrentSyncRoots(&result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderSyncRootManagerStatics2<D>::IsSupported() const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsSupported(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics2>**)this;
            check_hresult(_winrt_abi_type->IsSupported(&result));
        }
        return result;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderUICommand<D>::Label() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderUICommand>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderUICommand, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Label(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)this;
            check_hresult(_winrt_abi_type->get_Label(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderUICommand<D>::Description() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderUICommand>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderUICommand, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)this;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderUICommand<D>::Icon() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderUICommand>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderUICommand, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Icon(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)this;
            check_hresult(_winrt_abi_type->get_Icon(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderUICommand<D>::State() const
    {
        winrt::Windows::Storage::Provider::StorageProviderUICommandState value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderUICommand>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderUICommand, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)this;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderUICommand<D>::Invoke() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderUICommand>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderUICommand, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Invoke());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUICommand>**)this;
            check_hresult(_winrt_abi_type->Invoke());
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderUriSource<D>::GetPathForContentUri(param::hstring const& contentUri, winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult const& result) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderUriSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderUriSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUriSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPathForContentUri(*(void**)(&contentUri), *(void**)(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUriSource>**)this;
            check_hresult(_winrt_abi_type->GetPathForContentUri(*(void**)(&contentUri), *(void**)(&result)));
        }
    }
    template <typename D> auto consume_Windows_Storage_Provider_IStorageProviderUriSource<D>::GetContentInfoForPath(param::hstring const& path, winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult const& result) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Storage::Provider::IStorageProviderUriSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Storage::Provider::IStorageProviderUriSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUriSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetContentInfoForPath(*(void**)(&path), *(void**)(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Storage::Provider::IStorageProviderUriSource>**)this;
            check_hresult(_winrt_abi_type->GetContentInfoForPath(*(void**)(&path), *(void**)(&result)));
        }
    }
    template <typename H> struct delegate<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler, H> final : implements_delegate<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterStatics> : produce_base<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterStatics>
    {
        int32_t __stdcall SetUpdateInformation(void* file, void* contentId, int32_t readMode, int32_t writeMode, uint32_t options) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetUpdateInformation(*reinterpret_cast<winrt::Windows::Storage::IStorageFile const*>(&file), *reinterpret_cast<hstring const*>(&contentId), *reinterpret_cast<winrt::Windows::Storage::Provider::ReadActivationMode const*>(&readMode), *reinterpret_cast<winrt::Windows::Storage::Provider::WriteActivationMode const*>(&writeMode), *reinterpret_cast<winrt::Windows::Storage::Provider::CachedFileOptions const*>(&options));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI> : produce_base<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI>
    {
        int32_t __stdcall get_Title(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Title());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Title(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Title(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UpdateTarget(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::CachedFileTarget>(this->shim().UpdateTarget());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_FileUpdateRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().FileUpdateRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_FileUpdateRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FileUpdateRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_UIRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().UIRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_UIRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UIRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_UIStatus(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::UIStatus>(this->shim().UIStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2> : produce_base<D, winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2>
    {
        int32_t __stdcall get_UpdateRequest(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::FileUpdateRequest>(this->shim().UpdateRequest());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeferral(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>(this->shim().GetDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IFileUpdateRequest> : produce_base<D, winrt::Windows::Storage::Provider::IFileUpdateRequest>
    {
        int32_t __stdcall get_ContentId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ContentId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_File(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::StorageFile>(this->shim().File());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::FileUpdateStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Status(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Status(*reinterpret_cast<winrt::Windows::Storage::Provider::FileUpdateStatus const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeferral(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>(this->shim().GetDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall UpdateLocalFile(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UpdateLocalFile(*reinterpret_cast<winrt::Windows::Storage::IStorageFile const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IFileUpdateRequest2> : produce_base<D, winrt::Windows::Storage::Provider::IFileUpdateRequest2>
    {
        int32_t __stdcall get_UserInputNeededMessage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().UserInputNeededMessage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_UserInputNeededMessage(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UserInputNeededMessage(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IFileUpdateRequestDeferral> : produce_base<D, winrt::Windows::Storage::Provider::IFileUpdateRequestDeferral>
    {
        int32_t __stdcall Complete() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Complete();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IFileUpdateRequestedEventArgs> : produce_base<D, winrt::Windows::Storage::Provider::IFileUpdateRequestedEventArgs>
    {
        int32_t __stdcall get_Request(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::FileUpdateRequest>(this->shim().Request());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo>
    {
        int32_t __stdcall get_FileExtension(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().FileExtension());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconResource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().IconResource());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfoFactory> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfoFactory>
    {
        int32_t __stdcall CreateInstance(void* fileExtension, void* iconResource, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&fileExtension), *reinterpret_cast<hstring const*>(&iconResource)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Status(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Status(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ContentUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ContentUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContentUri(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ContentId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ContentId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContentId(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Status(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Status(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Path(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Path());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Path(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Path(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertiesStatics> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertiesStatics>
    {
        int32_t __stdcall SetAsync(void* item, void* itemProperties, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SetAsync(*reinterpret_cast<winrt::Windows::Storage::IStorageItem const*>(&item), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty> const*>(&itemProperties)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderItemProperty>
    {
        int32_t __stdcall put_Id(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Id(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Id(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Value(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Value(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Value(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconResource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconResource(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconResource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().IconResource());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition>
    {
        int32_t __stdcall get_Id(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Id(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Id(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayNameResource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DisplayNameResource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DisplayNameResource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisplayNameResource(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>
    {
        int32_t __stdcall GetItemProperties(void* itemPath, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>(this->shim().GetItemProperties(*reinterpret_cast<hstring const*>(&itemPath)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry>
    {
        int32_t __stdcall get_KnownFolderId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().KnownFolderId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_KnownFolderId(winrt::guid value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().KnownFolderId(*reinterpret_cast<winrt::guid const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Status(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Status(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncStatus const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo>
    {
        int32_t __stdcall get_ProviderDisplayName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ProviderDisplayName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProviderDisplayName(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProviderDisplayName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KnownFolderEntries(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry>>(this->shim().KnownFolderEntries());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SyncRequested(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler>(this->shim().SyncRequested());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SyncRequested(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SyncRequested(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>
    {
        int32_t __stdcall GetKnownFolderSyncInfo(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo>(this->shim().GetKnownFolderSyncInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_KnownFolderSyncInfoChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().KnownFolderSyncInfoChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_KnownFolderSyncInfoChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().KnownFolderSyncInfoChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>
    {
        int32_t __stdcall GetKnownFolderSyncInfoSource(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>(this->shim().GetKnownFolderSyncInfoSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs>
    {
        int32_t __stdcall get_KnownFolders(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::guid>>(this->shim().KnownFolders());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Source(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::StorageFolder>(this->shim().Source());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI>
    {
        int32_t __stdcall get_Message(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Message());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Message(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Message(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Command(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(this->shim().Command());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Command(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Command(*reinterpret_cast<winrt::Windows::Storage::Provider::IStorageProviderUICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>
    {
        int32_t __stdcall IsPropertySupported(void* propertyCanonicalName, bool* isSupported) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *isSupported = detach_from<bool>(this->shim().IsPropertySupported(*reinterpret_cast<hstring const*>(&propertyCanonicalName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<
        D, winrt::Windows::Storage::Provider::IStorageProviderQueryResult>
        : produce_base<
              D,
              winrt::Windows::Storage::Provider::IStorageProviderQueryResult> {
      int32_t __stdcall get_Kind(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Storage::Provider::StorageProviderResultKind>(
            this->shim().Kind());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_Kind(int32_t value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().Kind(
            *reinterpret_cast<winrt::Windows::Storage::Provider::
                                  StorageProviderResultKind const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ResultId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().ResultId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_ResultId(void* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().ResultId(*reinterpret_cast<hstring const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RemoteFileId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().RemoteFileId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_RemoteFileId(void* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().RemoteFileId(*reinterpret_cast<hstring const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_FilePath(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().FilePath());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_FilePath(void* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().FilePath(*reinterpret_cast<hstring const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RequestedProperties(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::Collections::PropertySet>(
                this->shim().RequestedProperties());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Storage::Provider::IStorageProviderQueryResultSet>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderQueryResultSet> {
      int32_t __stdcall GetResults(uint32_t* __resultSize,
                                   void*** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        std::tie(*__resultSize, *result) =
            detach_abi(this->shim().GetResults());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_QueryResultId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().QueryResultId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_QueryResultId(void* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().QueryResultId(*reinterpret_cast<hstring const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Status(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Storage::Provider::
                                 StorageProviderSearchQueryStatus>(
            this->shim().Status());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_Status(int32_t value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().Status(
            *reinterpret_cast<winrt::Windows::Storage::Provider::
                                  StorageProviderSearchQueryStatus const*>(
                &value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::
                          IStorageProviderQueryResultSetFactory>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderQueryResultSetFactory> {
      int32_t __stdcall CreateInstance(uint32_t __resultsSize, void** results,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Storage::Provider::StorageProviderQueryResultSet>(
            this->shim().CreateInstance(
                array_view<winrt::Windows::Storage::Provider::
                               IStorageProviderQueryResult const>(
                    reinterpret_cast<winrt::Windows::Storage::Provider::
                                         IStorageProviderQueryResult const*>(
                        results),
                    reinterpret_cast<winrt::Windows::Storage::Provider::
                                         IStorageProviderQueryResult const*>(
                        results) +
                        __resultsSize)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderQuotaUI>
    {
        int32_t __stdcall get_QuotaTotalInBytes(uint64_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint64_t>(this->shim().QuotaTotalInBytes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_QuotaTotalInBytes(uint64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().QuotaTotalInBytes(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_QuotaUsedInBytes(uint64_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint64_t>(this->shim().QuotaUsedInBytes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_QuotaUsedInBytes(uint64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().QuotaUsedInBytes(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_QuotaUsedLabel(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().QuotaUsedLabel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_QuotaUsedLabel(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().QuotaUsedLabel(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_QuotaUsedColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().QuotaUsedColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_QuotaUsedColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().QuotaUsedColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<
        D, winrt::Windows::Storage::Provider::IStorageProviderSearchHandler>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderSearchHandler> {
      int32_t __stdcall Find(void* options, void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Storage::Provider::StorageProviderQueryResultSet>(
            this->shim().Find(
                *reinterpret_cast<winrt::Windows::Storage::Provider::
                                      StorageProviderSearchQueryOptions const*>(
                    &options)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall ReportUsage(int32_t resultUsageKind, void* remoteFileId,
                                    void* resultId,
                                    int64_t latency) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().ReportUsage(
            *reinterpret_cast<winrt::Windows::Storage::Provider::
                                  StorageProviderResultUsageKind const*>(
                &resultUsageKind),
            *reinterpret_cast<hstring const*>(&remoteFileId),
            *reinterpret_cast<hstring const*>(&resultId),
            *reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(
                &latency));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Storage::Provider::IStorageProviderSearchHandlerFactory>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderSearchHandlerFactory> {
      int32_t __stdcall CreateSearchHandler(void* cloudProviderId,
                                            void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Storage::Provider::IStorageProviderSearchHandler>(
            this->shim().CreateSearchHandler(
                *reinterpret_cast<hstring const*>(&cloudProviderId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Storage::Provider::IStorageProviderSearchQueryOptions>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderSearchQueryOptions> {
      int32_t __stdcall get_UserQuery(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().UserQuery());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Language(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Language());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_SortOrder(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::Collections::IVectorView<
                winrt::Windows::Storage::Search::SortEntry>>(
                this->shim().SortOrder());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ProgrammaticQuery(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().ProgrammaticQuery());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MaxResults(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().MaxResults());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_FolderScope(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().FolderScope());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_QueryId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().QueryId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_PropertiesToFetch(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Foundation::Collections::IVectorView<hstring>>(
            this->shim().PropertiesToFetch());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Storage::Provider::IStorageProviderSearchResult>
        : produce_base<
              D,
              winrt::Windows::Storage::Provider::IStorageProviderSearchResult> {
      int32_t __stdcall get_MatchScore(double* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<double>(this->shim().MatchScore());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_MatchScore(double value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().MatchScore(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MatchKind(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Storage::Provider::StorageProviderSearchMatchKind>(
            this->shim().MatchKind());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_MatchKind(int32_t value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().MatchKind(
            *reinterpret_cast<winrt::Windows::Storage::Provider::
                                  StorageProviderSearchMatchKind const*>(
                &value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MatchedPropertyName(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().MatchedPropertyName());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_MatchedPropertyName(void* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        this->shim().MatchedPropertyName(
            *reinterpret_cast<hstring const*>(&value));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
    template <typename D>
    struct produce<
        D, winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderShareLinkSource> {
      int32_t __stdcall CreateLinkAsync(void* storageItemList,
                                        void** operation) noexcept final try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
            winrt::Windows::Foundation::Uri>>(
            this->shim().CreateLinkAsync(
                *reinterpret_cast<
                    winrt::Windows::Foundation::Collections::IVectorView<
                        winrt::Windows::Storage::IStorageItem> const*>(
                    &storageItemList)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetDefaultAccessControlStringAsync(
          void* storageItemList, void** operation) noexcept final try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation =
            detach_from<winrt::Windows::Foundation::IAsyncOperation<hstring>>(
                this->shim().GetDefaultAccessControlStringAsync(
                    *reinterpret_cast<
                        winrt::Windows::Foundation::Collections::IVectorView<
                            winrt::Windows::Storage::IStorageItem> const*>(
                        &storageItemList)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetState(void* storageItemList,
                                 void** operation) noexcept final try {
        clear_abi(operation);
        typename D::abi_guard guard(this->shim());
        *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
            winrt::Windows::Storage::Provider::StorageProviderShareLinkState>>(
            this->shim().GetState(
                *reinterpret_cast<
                    winrt::Windows::Foundation::Collections::IVectorView<
                        winrt::Windows::Storage::IStorageItem> const*>(
                    &storageItemList)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUI>
    {
        int32_t __stdcall get_ProviderState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderState>(this->shim().ProviderState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProviderState(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProviderState(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderState const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProviderStateLabel(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ProviderStateLabel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProviderStateLabel(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProviderStateLabel(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProviderStateIcon(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().ProviderStateIcon());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProviderStateIcon(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProviderStateIcon(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SyncStatusCommand(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(this->shim().SyncStatusCommand());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SyncStatusCommand(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SyncStatusCommand(*reinterpret_cast<winrt::Windows::Storage::Provider::IStorageProviderUICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_QuotaUI(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>(this->shim().QuotaUI());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_QuotaUI(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().QuotaUI(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderQuotaUI const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoreInfoUI(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>(this->shim().MoreInfoUI());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MoreInfoUI(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoreInfoUI(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProviderPrimaryCommand(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(this->shim().ProviderPrimaryCommand());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProviderPrimaryCommand(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProviderPrimaryCommand(*reinterpret_cast<winrt::Windows::Storage::Provider::IStorageProviderUICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProviderSecondaryCommands(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::IStorageProviderUICommand>>(this->shim().ProviderSecondaryCommands());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProviderSecondaryCommands(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProviderSecondaryCommands(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::IStorageProviderUICommand> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISource> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>
    {
        int32_t __stdcall GetStatusUI(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Provider::StorageProviderStatusUI>(this->shim().GetStatusUI());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_StatusUIChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().StatusUIChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_StatusUIChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StatusUIChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>
    {
        int32_t __stdcall GetStatusUISource(void* syncRootId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>(this->shim().GetStatusUISource(*reinterpret_cast<hstring const*>(&syncRootId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Storage::Provider::IStorageProviderSuggestionsHandler>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderSuggestionsHandler> {
      int32_t __stdcall GetSuggestions(void* options,
                                       void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Storage::Provider::StorageProviderQueryResultSet>(
            this->shim().GetSuggestions(
                *reinterpret_cast<
                    winrt::Windows::Storage::Provider::
                        StorageProviderSuggestionsQueryOptions const*>(
                    &options)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall Add(int32_t kind, void* remoteFileId) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        this->shim().Add(
            *reinterpret_cast<winrt::Windows::Storage::Provider::
                                  StorageProviderResultKind const*>(&kind),
            *reinterpret_cast<hstring const*>(&remoteFileId));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall Remove(int32_t kind, void* remoteFileId) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        this->shim().Remove(
            *reinterpret_cast<winrt::Windows::Storage::Provider::
                                  StorageProviderResultKind const*>(&kind),
            *reinterpret_cast<hstring const*>(&remoteFileId));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetDetails(void* remoteFileId,
                                   uint32_t __propertiesToFetchSize,
                                   void** propertiesToFetch, void* queryId,
                                   void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Storage::Provider::StorageProviderSuggestionResult>(
            this->shim().GetDetails(
                *reinterpret_cast<hstring const*>(&remoteFileId),
                array_view<hstring const>(
                    reinterpret_cast<hstring const*>(propertiesToFetch),
                    reinterpret_cast<hstring const*>(propertiesToFetch) +
                        __propertiesToFetchSize),
                *reinterpret_cast<hstring const*>(&queryId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall ReportUsage(int32_t resultUsageKind, void* remoteFileId,
                                    void* resultId,
                                    int64_t latency) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().ReportUsage(
            *reinterpret_cast<winrt::Windows::Storage::Provider::
                                  StorageProviderResultUsageKind const*>(
                &resultUsageKind),
            *reinterpret_cast<hstring const*>(&remoteFileId),
            *reinterpret_cast<hstring const*>(&resultId),
            *reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(
                &latency));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::
                          IStorageProviderSuggestionsHandlerFactory>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderSuggestionsHandlerFactory> {
      int32_t __stdcall CreateSuggestionsHandler(void* cloudProviderId,
                                                 void** result) noexcept final
          try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<winrt::Windows::Storage::Provider::
                                  IStorageProviderSuggestionsHandler>(
            this->shim().CreateSuggestionsHandler(
                *reinterpret_cast<hstring const*>(&cloudProviderId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::
                          IStorageProviderSuggestionsQueryOptions>
        : produce_base<D, winrt::Windows::Storage::Provider::
                              IStorageProviderSuggestionsQueryOptions> {
      int32_t __stdcall get_SuggestionsKind(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Storage::Provider::StorageProviderResultKind>(
            this->shim().SuggestionsKind());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RemoteFileId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().RemoteFileId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MaxResults(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().MaxResults());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_QueryId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().QueryId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_PropertiesToFetch(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Foundation::Collections::IVectorView<hstring>>(
            this->shim().PropertiesToFetch());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Id(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Id(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Context(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Streams::IBuffer>(this->shim().Context());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Context(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Context(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Path(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::IStorageFolder>(this->shim().Path());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Path(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Path(*reinterpret_cast<winrt::Windows::Storage::IStorageFolder const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayNameResource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DisplayNameResource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DisplayNameResource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisplayNameResource(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconResource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().IconResource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconResource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconResource(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HydrationPolicy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy>(this->shim().HydrationPolicy());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HydrationPolicy(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HydrationPolicy(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HydrationPolicyModifier(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier>(this->shim().HydrationPolicyModifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HydrationPolicyModifier(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HydrationPolicyModifier(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PopulationPolicy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy>(this->shim().PopulationPolicy());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PopulationPolicy(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PopulationPolicy(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InSyncPolicy(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy>(this->shim().InSyncPolicy());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InSyncPolicy(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InSyncPolicy(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HardlinkPolicy(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy>(this->shim().HardlinkPolicy());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HardlinkPolicy(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HardlinkPolicy(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowSiblingsAsGroup(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShowSiblingsAsGroup());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShowSiblingsAsGroup(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShowSiblingsAsGroup(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Version(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Version());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Version(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Version(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProtectionMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderProtectionMode>(this->shim().ProtectionMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProtectionMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProtectionMode(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderProtectionMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowPinning(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowPinning());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowPinning(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowPinning(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StorageProviderItemPropertyDefinitions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>>(this->shim().StorageProviderItemPropertyDefinitions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RecycleBinUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().RecycleBinUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RecycleBinUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RecycleBinUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2>
    {
        int32_t __stdcall get_ProviderId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().ProviderId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProviderId(winrt::guid value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProviderId(*reinterpret_cast<winrt::guid const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo3> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo3>
    {
        int32_t __stdcall get_FallbackFileTypeInfo(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>>(this->shim().FallbackFileTypeInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics>
    {
        int32_t __stdcall Register(void* syncRootInformation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Register(*reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo const*>(&syncRootInformation));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Unregister(void* id) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Unregister(*reinterpret_cast<hstring const*>(&id));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSyncRootInformationForFolder(void* folder, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(this->shim().GetSyncRootInformationForFolder(*reinterpret_cast<winrt::Windows::Storage::IStorageFolder const*>(&folder)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSyncRootInformationForId(void* id, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(this->shim().GetSyncRootInformationForId(*reinterpret_cast<hstring const*>(&id)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetCurrentSyncRoots(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>>(this->shim().GetCurrentSyncRoots());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics2> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics2>
    {
        int32_t __stdcall IsSupported(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderUICommand> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderUICommand>
    {
        int32_t __stdcall get_Label(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Label());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Description(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Description());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Icon(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().Icon());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_State(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Provider::StorageProviderUICommandState>(this->shim().State());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Invoke() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Invoke();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Windows::Storage::Provider::IStorageProviderUriSource> : produce_base<D, winrt::Windows::Storage::Provider::IStorageProviderUriSource>
    {
        int32_t __stdcall GetPathForContentUri(void* contentUri, void* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GetPathForContentUri(*reinterpret_cast<hstring const*>(&contentUri), *reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult const*>(&result));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetContentInfoForPath(void* path, void* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GetContentInfoForPath(*reinterpret_cast<hstring const*>(&path), *reinterpret_cast<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult const*>(&result));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::Windows::Storage::Provider
{
    constexpr auto operator|(CachedFileOptions const left, CachedFileOptions const right) noexcept
    {
        return static_cast<CachedFileOptions>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(CachedFileOptions& left, CachedFileOptions const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(CachedFileOptions const left, CachedFileOptions const right) noexcept
    {
        return static_cast<CachedFileOptions>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(CachedFileOptions& left, CachedFileOptions const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(CachedFileOptions const value) noexcept
    {
        return static_cast<CachedFileOptions>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(CachedFileOptions const left, CachedFileOptions const right) noexcept
    {
        return static_cast<CachedFileOptions>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(CachedFileOptions& left, CachedFileOptions const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(StorageProviderHardlinkPolicy const left, StorageProviderHardlinkPolicy const right) noexcept
    {
        return static_cast<StorageProviderHardlinkPolicy>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(StorageProviderHardlinkPolicy& left, StorageProviderHardlinkPolicy const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(StorageProviderHardlinkPolicy const left, StorageProviderHardlinkPolicy const right) noexcept
    {
        return static_cast<StorageProviderHardlinkPolicy>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(StorageProviderHardlinkPolicy& left, StorageProviderHardlinkPolicy const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(StorageProviderHardlinkPolicy const value) noexcept
    {
        return static_cast<StorageProviderHardlinkPolicy>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(StorageProviderHardlinkPolicy const left, StorageProviderHardlinkPolicy const right) noexcept
    {
        return static_cast<StorageProviderHardlinkPolicy>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(StorageProviderHardlinkPolicy& left, StorageProviderHardlinkPolicy const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(StorageProviderHydrationPolicyModifier const left, StorageProviderHydrationPolicyModifier const right) noexcept
    {
        return static_cast<StorageProviderHydrationPolicyModifier>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(StorageProviderHydrationPolicyModifier& left, StorageProviderHydrationPolicyModifier const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(StorageProviderHydrationPolicyModifier const left, StorageProviderHydrationPolicyModifier const right) noexcept
    {
        return static_cast<StorageProviderHydrationPolicyModifier>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(StorageProviderHydrationPolicyModifier& left, StorageProviderHydrationPolicyModifier const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(StorageProviderHydrationPolicyModifier const value) noexcept
    {
        return static_cast<StorageProviderHydrationPolicyModifier>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(StorageProviderHydrationPolicyModifier const left, StorageProviderHydrationPolicyModifier const right) noexcept
    {
        return static_cast<StorageProviderHydrationPolicyModifier>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(StorageProviderHydrationPolicyModifier& left, StorageProviderHydrationPolicyModifier const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(StorageProviderInSyncPolicy const left, StorageProviderInSyncPolicy const right) noexcept
    {
        return static_cast<StorageProviderInSyncPolicy>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(StorageProviderInSyncPolicy& left, StorageProviderInSyncPolicy const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(StorageProviderInSyncPolicy const left, StorageProviderInSyncPolicy const right) noexcept
    {
        return static_cast<StorageProviderInSyncPolicy>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(StorageProviderInSyncPolicy& left, StorageProviderInSyncPolicy const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(StorageProviderInSyncPolicy const value) noexcept
    {
        return static_cast<StorageProviderInSyncPolicy>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(StorageProviderInSyncPolicy const left, StorageProviderInSyncPolicy const right) noexcept
    {
        return static_cast<StorageProviderInSyncPolicy>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(StorageProviderInSyncPolicy& left, StorageProviderInSyncPolicy const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline auto CachedFileUpdater::SetUpdateInformation(winrt::Windows::Storage::IStorageFile const& file, param::hstring const& contentId, winrt::Windows::Storage::Provider::ReadActivationMode const& readMode, winrt::Windows::Storage::Provider::WriteActivationMode const& writeMode, winrt::Windows::Storage::Provider::CachedFileOptions const& options)
    {
        impl::call_factory<CachedFileUpdater, ICachedFileUpdaterStatics>([&](ICachedFileUpdaterStatics const& f) { return f.SetUpdateInformation(file, contentId, readMode, writeMode, options); });
    }
    inline StorageProviderFileTypeInfo::StorageProviderFileTypeInfo(param::hstring const& fileExtension, param::hstring const& iconResource) :
        StorageProviderFileTypeInfo(impl::call_factory<StorageProviderFileTypeInfo, IStorageProviderFileTypeInfoFactory>([&](IStorageProviderFileTypeInfoFactory const& f) { return f.CreateInstance(fileExtension, iconResource); }))
    {
    }
    inline StorageProviderGetContentInfoForPathResult::StorageProviderGetContentInfoForPathResult() :
        StorageProviderGetContentInfoForPathResult(impl::call_factory_cast<StorageProviderGetContentInfoForPathResult(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderGetContentInfoForPathResult>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderGetContentInfoForPathResult>(); }))
    {
    }
    inline StorageProviderGetPathForContentUriResult::StorageProviderGetPathForContentUriResult() :
        StorageProviderGetPathForContentUriResult(impl::call_factory_cast<StorageProviderGetPathForContentUriResult(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderGetPathForContentUriResult>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderGetPathForContentUriResult>(); }))
    {
    }
    inline auto StorageProviderItemProperties::SetAsync(winrt::Windows::Storage::IStorageItem const& item, param::async_iterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty> const& itemProperties)
    {
        return impl::call_factory<StorageProviderItemProperties, IStorageProviderItemPropertiesStatics>([&](IStorageProviderItemPropertiesStatics const& f) { return f.SetAsync(item, itemProperties); });
    }
    inline StorageProviderItemProperty::StorageProviderItemProperty() :
        StorageProviderItemProperty(impl::call_factory_cast<StorageProviderItemProperty(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderItemProperty>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderItemProperty>(); }))
    {
    }
    inline StorageProviderItemPropertyDefinition::StorageProviderItemPropertyDefinition() :
        StorageProviderItemPropertyDefinition(impl::call_factory_cast<StorageProviderItemPropertyDefinition(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderItemPropertyDefinition>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderItemPropertyDefinition>(); }))
    {
    }
    inline StorageProviderKnownFolderEntry::StorageProviderKnownFolderEntry() :
        StorageProviderKnownFolderEntry(impl::call_factory_cast<StorageProviderKnownFolderEntry(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderKnownFolderEntry>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderKnownFolderEntry>(); }))
    {
    }
    inline StorageProviderKnownFolderSyncInfo::StorageProviderKnownFolderSyncInfo() :
        StorageProviderKnownFolderSyncInfo(impl::call_factory_cast<StorageProviderKnownFolderSyncInfo(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderKnownFolderSyncInfo>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderKnownFolderSyncInfo>(); }))
    {
    }
    inline StorageProviderMoreInfoUI::StorageProviderMoreInfoUI() :
        StorageProviderMoreInfoUI(impl::call_factory_cast<StorageProviderMoreInfoUI(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderMoreInfoUI>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderMoreInfoUI>(); }))
    {
    }
    inline StorageProviderQueryResultSet::StorageProviderQueryResultSet(
        array_view<winrt::Windows::Storage::Provider::
                       IStorageProviderQueryResult const>
            results)
        : StorageProviderQueryResultSet(
              impl::call_factory<StorageProviderQueryResultSet,
                                 IStorageProviderQueryResultSetFactory>(
                  [&](IStorageProviderQueryResultSetFactory const& f) {
                    return f.CreateInstance(results);
                  })) {}
    inline StorageProviderQuotaUI::StorageProviderQuotaUI() :
        StorageProviderQuotaUI(impl::call_factory_cast<StorageProviderQuotaUI(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderQuotaUI>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderQuotaUI>(); }))
    {
    }
    inline StorageProviderSearchResult::StorageProviderSearchResult()
        : StorageProviderSearchResult(
              impl::call_factory_cast<
                  StorageProviderSearchResult (*)(
                      winrt::Windows::Foundation::IActivationFactory const&),
                  StorageProviderSearchResult>(
                  [](winrt::Windows::Foundation::IActivationFactory const& f) {
                    return f.template ActivateInstance<
                        StorageProviderSearchResult>();
                  })) {}
    inline StorageProviderStatusUI::StorageProviderStatusUI() :
        StorageProviderStatusUI(impl::call_factory_cast<StorageProviderStatusUI(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderStatusUI>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderStatusUI>(); }))
    {
    }
    inline StorageProviderSuggestionResult::StorageProviderSuggestionResult()
        : StorageProviderSuggestionResult(
              impl::call_factory_cast<
                  StorageProviderSuggestionResult (*)(
                      winrt::Windows::Foundation::IActivationFactory const&),
                  StorageProviderSuggestionResult>(
                  [](winrt::Windows::Foundation::IActivationFactory const& f) {
                    return f.template ActivateInstance<
                        StorageProviderSuggestionResult>();
                  })) {}
    inline StorageProviderSyncRootInfo::StorageProviderSyncRootInfo() :
        StorageProviderSyncRootInfo(impl::call_factory_cast<StorageProviderSyncRootInfo(*)(winrt::Windows::Foundation::IActivationFactory const&), StorageProviderSyncRootInfo>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StorageProviderSyncRootInfo>(); }))
    {
    }
    inline auto StorageProviderSyncRootManager::Register(winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo const& syncRootInformation)
    {
        impl::call_factory<StorageProviderSyncRootManager, IStorageProviderSyncRootManagerStatics>([&](IStorageProviderSyncRootManagerStatics const& f) { return f.Register(syncRootInformation); });
    }
    inline auto StorageProviderSyncRootManager::Unregister(param::hstring const& id)
    {
        impl::call_factory<StorageProviderSyncRootManager, IStorageProviderSyncRootManagerStatics>([&](IStorageProviderSyncRootManagerStatics const& f) { return f.Unregister(id); });
    }
    inline auto StorageProviderSyncRootManager::GetSyncRootInformationForFolder(winrt::Windows::Storage::IStorageFolder const& folder)
    {
        return impl::call_factory<StorageProviderSyncRootManager, IStorageProviderSyncRootManagerStatics>([&](IStorageProviderSyncRootManagerStatics const& f) { return f.GetSyncRootInformationForFolder(folder); });
    }
    inline auto StorageProviderSyncRootManager::GetSyncRootInformationForId(param::hstring const& id)
    {
        return impl::call_factory<StorageProviderSyncRootManager, IStorageProviderSyncRootManagerStatics>([&](IStorageProviderSyncRootManagerStatics const& f) { return f.GetSyncRootInformationForId(id); });
    }
    inline auto StorageProviderSyncRootManager::GetCurrentSyncRoots()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(*)(IStorageProviderSyncRootManagerStatics const&), StorageProviderSyncRootManager, IStorageProviderSyncRootManagerStatics>([](IStorageProviderSyncRootManagerStatics const& f) { return f.GetCurrentSyncRoots(); });
    }
    inline auto StorageProviderSyncRootManager::IsSupported()
    {
        return impl::call_factory_cast<bool(*)(IStorageProviderSyncRootManagerStatics2 const&), StorageProviderSyncRootManager, IStorageProviderSyncRootManagerStatics2>([](IStorageProviderSyncRootManagerStatics2 const& f) { return f.IsSupported(); });
    }
    template <typename L> StorageProviderKnownFolderSyncRequestedHandler::StorageProviderKnownFolderSyncRequestedHandler(L handler) :
        StorageProviderKnownFolderSyncRequestedHandler(impl::make_delegate<StorageProviderKnownFolderSyncRequestedHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> StorageProviderKnownFolderSyncRequestedHandler::StorageProviderKnownFolderSyncRequestedHandler(F* handler) :
        StorageProviderKnownFolderSyncRequestedHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> StorageProviderKnownFolderSyncRequestedHandler::StorageProviderKnownFolderSyncRequestedHandler(O* object, M method) :
        StorageProviderKnownFolderSyncRequestedHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> StorageProviderKnownFolderSyncRequestedHandler::StorageProviderKnownFolderSyncRequestedHandler(com_ptr<O>&& object, M method) :
        StorageProviderKnownFolderSyncRequestedHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> StorageProviderKnownFolderSyncRequestedHandler::StorageProviderKnownFolderSyncRequestedHandler(weak_ref<O>&& object, LM&& lambda_or_method) :
        StorageProviderKnownFolderSyncRequestedHandler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> StorageProviderKnownFolderSyncRequestedHandler::StorageProviderKnownFolderSyncRequestedHandler(std::shared_ptr<O>&& object, M method) :
        StorageProviderKnownFolderSyncRequestedHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> StorageProviderKnownFolderSyncRequestedHandler::StorageProviderKnownFolderSyncRequestedHandler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        StorageProviderKnownFolderSyncRequestedHandler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto StorageProviderKnownFolderSyncRequestedHandler::operator()(winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs const& args) const
    {
        check_hresult((*(impl::abi_t<StorageProviderKnownFolderSyncRequestedHandler>**)this)->Invoke(*(void**)(&args)));
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Windows::Storage::Provider::ICachedFileUpdaterStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::ICachedFileUpdaterUI2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IFileUpdateRequest> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IFileUpdateRequest2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IFileUpdateRequestDeferral> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IFileUpdateRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderFileTypeInfoFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderGetContentInfoForPathResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderGetPathForContentUriResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderItemPropertiesStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderItemProperty> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderItemPropertyDefinition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderEntry> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncRequestArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderMoreInfoUI> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Storage::Provider::IStorageProviderQueryResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::IStorageProviderQueryResultSet>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Storage::Provider::
                    IStorageProviderQueryResultSetFactory>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderQuotaUI> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::IStorageProviderSearchHandler>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::IStorageProviderSearchHandlerFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::IStorageProviderSearchQueryOptions>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Storage::Provider::IStorageProviderSearchResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderStatusUI> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::IStorageProviderSuggestionsHandler>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsHandlerFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Storage::Provider::
                    IStorageProviderSuggestionsQueryOptions>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderSyncRootInfo3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderSyncRootManagerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderUICommand> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::IStorageProviderUriSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::CachedFileUpdater> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::CachedFileUpdaterUI> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::FileUpdateRequest> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderItemProperties> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderItemProperty> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::StorageProviderQueryResultSet>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderQuotaUI> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::StorageProviderSearchQueryOptions>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Storage::Provider::StorageProviderSearchResult>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderStatusUI> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Storage::Provider::StorageProviderSuggestionResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Storage::Provider::
                    StorageProviderSuggestionsQueryOptions>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
