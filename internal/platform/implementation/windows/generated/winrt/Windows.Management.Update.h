// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Windows_Management_Update_H
#define WINRT_Windows_Management_Update_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Windows.Management.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Management.Update.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Windows_Management_Update_IPreviewBuildsManager<D>::ArePreviewBuildsAllowed() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IPreviewBuildsManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IPreviewBuildsManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ArePreviewBuildsAllowed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)this;
            check_hresult(_winrt_abi_type->get_ArePreviewBuildsAllowed(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IPreviewBuildsManager<D>::ArePreviewBuildsAllowed(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IPreviewBuildsManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IPreviewBuildsManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ArePreviewBuildsAllowed(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)this;
            check_hresult(_winrt_abi_type->put_ArePreviewBuildsAllowed(value));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IPreviewBuildsManager<D>::GetCurrentState() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IPreviewBuildsManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IPreviewBuildsManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentState(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)this;
            check_hresult(_winrt_abi_type->GetCurrentState(&result));
        }
        return winrt::Windows::Management::Update::PreviewBuildsState{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IPreviewBuildsManager<D>::SyncAsync() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IPreviewBuildsManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IPreviewBuildsManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SyncAsync(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManager>**)this;
            check_hresult(_winrt_abi_type->SyncAsync(&result));
        }
        return winrt::Windows::Foundation::IAsyncOperation<bool>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IPreviewBuildsManagerStatics<D>::GetDefault() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IPreviewBuildsManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IPreviewBuildsManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDefault(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManagerStatics>**)this;
            check_hresult(_winrt_abi_type->GetDefault(&value));
        }
        return winrt::Windows::Management::Update::PreviewBuildsManager{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IPreviewBuildsManagerStatics<D>::IsSupported() const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IPreviewBuildsManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IPreviewBuildsManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsSupported(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsManagerStatics>**)this;
            check_hresult(_winrt_abi_type->IsSupported(&result));
        }
        return result;
    }
    template <typename D> auto consume_Windows_Management_Update_IPreviewBuildsState<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IPreviewBuildsState>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IPreviewBuildsState, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsState>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IPreviewBuildsState>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Windows::Foundation::Collections::ValueSet{ value, take_ownership_from_abi };
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::InstallationType() const {
      winrt::Windows::Management::Update::WindowsSoftwareUpdateInstallationType
          value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_InstallationType(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_InstallationType(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ProviderId() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ProviderId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_ProviderId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<D>::UpdateId()
        const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_UpdateId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_UpdateId(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<D>::Title()
        const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Title(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_Title(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::Description() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Description(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_Description(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::MoreInfoUrl() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
      }
      return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::DownloadSizeInBytes() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_DownloadSizeInBytes(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_DownloadSizeInBytes(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::InstallSizeInBytes() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_InstallSizeInBytes(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_InstallSizeInBytes(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::SourceVersion() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_SourceVersion(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_SourceVersion(&value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::TargetVersion() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_TargetVersion(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_TargetVersion(&value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ProductCode() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ProductCode(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_ProductCode(&value));
      }
      return winrt::Windows::Foundation::IReference<winrt::guid>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::PackageFamilyName() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_PackageFamilyName(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_PackageFamilyName(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<D>::Approve(
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateApprovalInfo const& approvalInfo) const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->Approve(*(void**)(&approvalInfo), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(
            _winrt_abi_type->Approve(*(void**)(&approvalInfo), &result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ApproveCurrentAction(bool approve) const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->ApproveCurrentAction(approve, &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->ApproveCurrentAction(approve, &result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::CurrentAction() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CurrentAction(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_CurrentAction(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ActionResultInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ActionResultInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_ActionResultInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionResultInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ApprovalInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ApprovalInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_ApprovalInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateApprovalInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ApprovedActions() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ApprovedActions(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_ApprovedActions(&value));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Windows::Management::Update::WindowsSoftwareUpdateActionType>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::AttentionRequiredInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_AttentionRequiredInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_AttentionRequiredInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsUpdateAttentionRequiredInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ActionProgress() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ActionProgress(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_ActionProgress(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionProgress{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::RestartReason() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RestartReason(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_RestartReason(&value));
      }
      return winrt::Windows::Foundation::IReference<
          winrt::Windows::Management::Update::
              WindowsSoftwareUpdateRestartReason>{value,
                                                  take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::AppPackageInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_AppPackageInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_AppPackageInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateAppPackageInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::ExecutionInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ExecutionInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_ExecutionInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateExecutionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdate<
        D>::OptionalInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdate>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdate,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_OptionalInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdate>**)this;
        check_hresult(_winrt_abi_type->get_OptionalInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateOptionalInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateActionInfo<
        D>::FileName() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateActionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateActionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_FileName(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionInfo>**)this;
        check_hresult(_winrt_abi_type->get_FileName(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateActionInfo<
        D>::FileArguments() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateActionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateActionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_FileArguments(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionInfo>**)this;
        check_hresult(_winrt_abi_type->get_FileArguments(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateActionInfo<
        D>::ActionType() const {
      winrt::Windows::Management::Update::WindowsSoftwareUpdateActionType
          value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateActionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateActionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ActionType(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionInfo>**)this;
        check_hresult(_winrt_abi_type->get_ActionType(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateActionInfoFactory<
        D>::CreateInstance(param::hstring const& fileName,
                           param::hstring const& fileArguments,
                           winrt::Windows::Management::Update::
                               WindowsSoftwareUpdateActionType const&
                                   actionType) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateActionInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateActionInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&fileName), *(void**)(&fileArguments),
            static_cast<int32_t>(actionType), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&fileName), *(void**)(&fileArguments),
            static_cast<int32_t>(actionType), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateActionProgress<
        D>::Action() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateActionProgress>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionProgress,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionProgress>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Action(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionProgress>**)this;
        check_hresult(_winrt_abi_type->get_Action(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateActionProgress<
        D>::CurrentProgress() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateActionProgress>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionProgress,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionProgress>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CurrentProgress(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionProgress>**)this;
        check_hresult(_winrt_abi_type->get_CurrentProgress(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateActionProgress<
        D>::TotalProgress() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateActionProgress>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionProgress,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionProgress>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_TotalProgress(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionProgress>**)this;
        check_hresult(_winrt_abi_type->get_TotalProgress(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateActionResultInfo<
        D>::Timestamp() const {
      winrt::Windows::Foundation::DateTime value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateActionResultInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionResultInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionResultInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionResultInfo>**)this;
        check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateActionResultInfo<
        D>::Succeeded() const {
      bool value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateActionResultInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionResultInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionResultInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Succeeded(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionResultInfo>**)this;
        check_hresult(_winrt_abi_type->get_Succeeded(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateActionResultInfo<
        D>::ResultCode() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateActionResultInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionResultInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionResultInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionResultInfo>**)this;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateActionResultInfo<
        D>::ExtendedError() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateActionResultInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionResultInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionResultInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionResultInfo>**)this;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateActionResultInfo<
        D>::Action() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateActionResultInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateActionResultInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionResultInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Action(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateActionResultInfo>**)this;
        check_hresult(_winrt_abi_type->get_Action(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateAppPackageInfo<
        D>::PackageFamilyName() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateAppPackageInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateAppPackageInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateAppPackageInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_PackageFamilyName(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateAppPackageInfo>**)this;
        check_hresult(_winrt_abi_type->get_PackageFamilyName(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateAppPackageInfo<
        D>::PackageArchitecture() const {
      winrt::Windows::Management::Update::WindowsSoftwareUpdateArchitecture
          value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateAppPackageInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateAppPackageInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateAppPackageInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_PackageArchitecture(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateAppPackageInfo>**)this;
        check_hresult(_winrt_abi_type->get_PackageArchitecture(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateAppPackageInfo<
        D>::InstallUri() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateAppPackageInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateAppPackageInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateAppPackageInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_InstallUri(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateAppPackageInfo>**)this;
        check_hresult(_winrt_abi_type->get_InstallUri(&value));
      }
      return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateAppPackageInfoFactory<
        D>::CreateInstance(param::hstring const& packageFamilyName,
                           winrt::Windows::Management::Update::
                               WindowsSoftwareUpdateArchitecture const&
                                   packageArchitecture,
                           winrt::Windows::Foundation::Uri const& installUri)
        const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateAppPackageInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateAppPackageInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateAppPackageInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&packageFamilyName),
            static_cast<int32_t>(packageArchitecture), *(void**)(&installUri),
            &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateAppPackageInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&packageFamilyName),
            static_cast<int32_t>(packageArchitecture), *(void**)(&installUri),
            &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateAppPackageInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateApprovalInfo<
        D>::UserInitiated() const {
      bool value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateApprovalInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateApprovalInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateApprovalInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_UserInitiated(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateApprovalInfo>**)this;
        check_hresult(_winrt_abi_type->get_UserInitiated(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateApprovalInfo<
        D>::AppClosure() const {
      bool value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateApprovalInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateApprovalInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateApprovalInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_AppClosure(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateApprovalInfo>**)this;
        check_hresult(_winrt_abi_type->get_AppClosure(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateApprovalInfo<
        D>::MeteredNetwork() const {
      bool value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateApprovalInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateApprovalInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateApprovalInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_MeteredNetwork(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateApprovalInfo>**)this;
        check_hresult(_winrt_abi_type->get_MeteredNetwork(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateApprovalInfo<
        D>::Seeker() const {
      bool value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateApprovalInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateApprovalInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateApprovalInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Seeker(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateApprovalInfo>**)this;
        check_hresult(_winrt_abi_type->get_Seeker(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateApprovalInfoFactory<
        D>::CreateInstance(bool userInitiated, bool appClosure,
                           bool meteredNetwork, bool seeker) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateApprovalInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateApprovalInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateApprovalInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            userInitiated, appClosure, meteredNetwork, seeker, &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateApprovalInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            userInitiated, appClosure, meteredNetwork, seeker, &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateApprovalInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateExecutionInfo<
        D>::DownloadInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateExecutionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateExecutionInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateExecutionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_DownloadInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateExecutionInfo>**)this;
        check_hresult(_winrt_abi_type->get_DownloadInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateExecutionInfo<
        D>::InstallInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateExecutionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateExecutionInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateExecutionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_InstallInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateExecutionInfo>**)this;
        check_hresult(_winrt_abi_type->get_InstallInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateExecutionInfo<
        D>::DeployInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateExecutionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateExecutionInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateExecutionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_DeployInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateExecutionInfo>**)this;
        check_hresult(_winrt_abi_type->get_DeployInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateExecutionInfo<
        D>::OptionalActionInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateExecutionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateExecutionInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateExecutionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_OptionalActionInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateExecutionInfo>**)this;
        check_hresult(_winrt_abi_type->get_OptionalActionInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateOptionalActionInfo{value,
                                                  take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateExecutionInfoFactory<
        D>::
        CreateInstance(
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& downloadInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& installInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateOptionalActionInfo const& actions) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateExecutionInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateExecutionInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateExecutionInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&downloadInfo), *(void**)(&installInfo),
            *(void**)(&actions), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateExecutionInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&downloadInfo), *(void**)(&installInfo),
            *(void**)(&actions), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateExecutionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateExecutionInfoFactory<
        D>::CreateInstance2(winrt::Windows::Management::Update::
                                WindowsSoftwareUpdateActionInfo const&
                                    deployInfo,
                            winrt::Windows::Management::Update::
                                WindowsSoftwareUpdateOptionalActionInfo const&
                                    actions) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateExecutionInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateExecutionInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateExecutionInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance2(
            *(void**)(&deployInfo), *(void**)(&actions), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateExecutionInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance2(
            *(void**)(&deployInfo), *(void**)(&actions), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateExecutionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateFactory<D>::
        CreateInstance(
            param::hstring const& providerId,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateInstallationType const& installationType,
            param::hstring const& updateId, param::hstring const& title,
            param::hstring const& description,
            winrt::Windows::Foundation::Uri const& moreInfoUrl,
            uint64_t downloadSizeInBytes, uint64_t installSizeInBytes,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateVersion const& sourceVersion,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateVersion const& targetVersion,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateAppPackageInfo const& appPackageInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateExecutionInfo const& executionInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateOptionalInfo const& optionalInfo) const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&providerId), static_cast<int32_t>(installationType),
            *(void**)(&updateId), *(void**)(&title), *(void**)(&description),
            *(void**)(&moreInfoUrl), downloadSizeInBytes, installSizeInBytes,
            *(void**)(&sourceVersion), *(void**)(&targetVersion),
            *(void**)(&appPackageInfo), *(void**)(&executionInfo),
            *(void**)(&optionalInfo), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&providerId), static_cast<int32_t>(installationType),
            *(void**)(&updateId), *(void**)(&title), *(void**)(&description),
            *(void**)(&moreInfoUrl), downloadSizeInBytes, installSizeInBytes,
            *(void**)(&sourceVersion), *(void**)(&targetVersion),
            *(void**)(&appPackageInfo), *(void**)(&executionInfo),
            *(void**)(&optionalInfo), &value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdate{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateFactory<D>::
        CreateInstance2(
            param::hstring const& providerId,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateInstallationType const& installationType,
            param::hstring const& updateId, param::hstring const& title,
            param::hstring const& description,
            winrt::Windows::Foundation::Uri const& moreInfoUrl,
            uint64_t downloadSizeInBytes, uint64_t installSizeInBytes,
            winrt::Windows::Foundation::IReference<winrt::guid> const&
                productCode,
            param::hstring const& packageFamilyName,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateVersion const& sourceVersion,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateVersion const& targetVersion,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateAppPackageInfo const& appPackageInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateExecutionInfo const& executionInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateOptionalInfo const& optionalInfo) const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance2(
            *(void**)(&providerId), static_cast<int32_t>(installationType),
            *(void**)(&updateId), *(void**)(&title), *(void**)(&description),
            *(void**)(&moreInfoUrl), downloadSizeInBytes, installSizeInBytes,
            *(void**)(&productCode), *(void**)(&packageFamilyName),
            *(void**)(&sourceVersion), *(void**)(&targetVersion),
            *(void**)(&appPackageInfo), *(void**)(&executionInfo),
            *(void**)(&optionalInfo), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance2(
            *(void**)(&providerId), static_cast<int32_t>(installationType),
            *(void**)(&updateId), *(void**)(&title), *(void**)(&description),
            *(void**)(&moreInfoUrl), downloadSizeInBytes, installSizeInBytes,
            *(void**)(&productCode), *(void**)(&packageFamilyName),
            *(void**)(&sourceVersion), *(void**)(&targetVersion),
            *(void**)(&appPackageInfo), *(void**)(&executionInfo),
            *(void**)(&optionalInfo), &value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdate{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateLocalizationInfo<
        D>::LanguageId() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateLocalizationInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateLocalizationInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateLocalizationInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_LanguageId(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateLocalizationInfo>**)this;
        check_hresult(_winrt_abi_type->get_LanguageId(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateLocalizationInfo<
        D>::Title() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateLocalizationInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateLocalizationInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateLocalizationInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Title(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateLocalizationInfo>**)this;
        check_hresult(_winrt_abi_type->get_Title(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateLocalizationInfo<
        D>::Description() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateLocalizationInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateLocalizationInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateLocalizationInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Description(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateLocalizationInfo>**)this;
        check_hresult(_winrt_abi_type->get_Description(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateLocalizationInfo<
        D>::MoreInfoUrl() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateLocalizationInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateLocalizationInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateLocalizationInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateLocalizationInfo>**)this;
        check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
      }
      return winrt::Windows::Foundation::Uri{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateLocalizationInfoFactory<
        D>::CreateInstance(uint32_t languageId, param::hstring const& title,
                           param::hstring const& description,
                           winrt::Windows::Foundation::Uri const& moreInfoUrl)
        const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateLocalizationInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateLocalizationInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateLocalizationInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            languageId, *(void**)(&title), *(void**)(&description),
            *(void**)(&moreInfoUrl), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateLocalizationInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            languageId, *(void**)(&title), *(void**)(&description),
            *(void**)(&moreInfoUrl), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateLocalizationInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalActionInfo<
        D>::CloseAndDeployInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateOptionalActionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateOptionalActionInfo,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalActionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CloseAndDeployInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalActionInfo>**)this;
        check_hresult(_winrt_abi_type->get_CloseAndDeployInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalActionInfo<
        D>::CloseAndInstallInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateOptionalActionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateOptionalActionInfo,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalActionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CloseAndInstallInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalActionInfo>**)this;
        check_hresult(_winrt_abi_type->get_CloseAndInstallInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalActionInfo<
        D>::CloseAndRestartInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateOptionalActionInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateOptionalActionInfo,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalActionInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CloseAndRestartInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalActionInfo>**)this;
        check_hresult(_winrt_abi_type->get_CloseAndRestartInfo(&value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateActionInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalActionInfoFactory<
        D>::CreateInstance(winrt::Windows::Management::Update::
                               WindowsSoftwareUpdateActionInfo const&
                                   closeAndDeployInfo,
                           winrt::Windows::Management::Update::
                               WindowsSoftwareUpdateActionInfo const&
                                   closeAndInstallInfo,
                           winrt::Windows::Management::Update::
                               WindowsSoftwareUpdateActionInfo const&
                                   closeAndRestartInfo) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D,
                        winrt::Windows::Management::Update::
                            IWindowsSoftwareUpdateOptionalActionInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateOptionalActionInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalActionInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&closeAndDeployInfo), *(void**)(&closeAndInstallInfo),
            *(void**)(&closeAndRestartInfo), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalActionInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&closeAndDeployInfo), *(void**)(&closeAndInstallInfo),
            *(void**)(&closeAndRestartInfo), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateOptionalActionInfo{value,
                                                  take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalInfo<
        D>::LocalizationInfo() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateOptionalInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateOptionalInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_LocalizationInfo(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalInfo>**)this;
        check_hresult(_winrt_abi_type->get_LocalizationInfo(&value));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Windows::Management::Update::
              WindowsSoftwareUpdateLocalizationInfo>{value,
                                                     take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalInfo<
        D>::ComplianceDeadlineInDays() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateOptionalInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateOptionalInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ComplianceDeadlineInDays(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalInfo>**)this;
        check_hresult(_winrt_abi_type->get_ComplianceDeadlineInDays(&value));
      }
      return winrt::Windows::Foundation::IReference<int32_t>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalInfo<
        D>::ComplianceGracePeriodInDays() const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateOptionalInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateOptionalInfo,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ComplianceGracePeriodInDays(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalInfo>**)this;
        check_hresult(_winrt_abi_type->get_ComplianceGracePeriodInDays(&value));
      }
      return winrt::Windows::Foundation::IReference<int32_t>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalInfoFactory<
        D>::
        CreateInstance(winrt::Windows::Foundation::IReference<int32_t> const&
                           complianceDeadlineInDays,
                       winrt::Windows::Foundation::IReference<int32_t> const&
                           complianceGracePeriodInDays) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateOptionalInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateOptionalInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&complianceDeadlineInDays),
            *(void**)(&complianceGracePeriodInDays), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&complianceDeadlineInDays),
            *(void**)(&complianceGracePeriodInDays), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateOptionalInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateOptionalInfoFactory<
        D>::
        CreateInstance2(
            param::iterable<winrt::Windows::Management::Update::
                                WindowsSoftwareUpdateLocalizationInfo> const&
                localizationInfo,
            winrt::Windows::Foundation::IReference<int32_t> const&
                complianceDeadlineInDays,
            winrt::Windows::Foundation::IReference<int32_t> const&
                complianceGracePeriodInDays) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateOptionalInfoFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateOptionalInfoFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalInfoFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance2(
            *(void**)(&localizationInfo), *(void**)(&complianceDeadlineInDays),
            *(void**)(&complianceGracePeriodInDays), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateOptionalInfoFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance2(
            *(void**)(&localizationInfo), *(void**)(&complianceDeadlineInDays),
            *(void**)(&complianceGracePeriodInDays), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateOptionalInfo{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::Register() const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->Register(&result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->Register(&result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::Unregister() const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->Unregister(&result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->Unregister(&result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::Validate() const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->Validate(&result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->Validate(&result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::Id() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Id(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_Id(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::Version() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Version(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_Version(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::FolderPath() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_FolderPath(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_FolderPath(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::CatalogFile() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CatalogFile(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_CatalogFile(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::ScanFileName() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ScanFileName(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_ScanFileName(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::ScanFileArguments() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ScanFileArguments(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_ScanFileArguments(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::Type() const {
      winrt::Windows::Management::Update::WindowsSoftwareUpdateProviderType
          value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_Type(reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(
            _winrt_abi_type->get_Type(reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::PayloadFiles() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_PayloadFiles(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_PayloadFiles(&value));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Windows::Management::Update::
              WindowsSoftwareUpdateProviderPayloadFileInfo>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::TrustState() const {
      winrt::Windows::Management::Update::
          WindowsSoftwareUpdateProviderTrustState value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_TrustState(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_TrustState(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::RegistrationType() const {
      winrt::Windows::Management::Update::
          WindowsSoftwareUpdateProviderRegistrationType value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RegistrationType(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_RegistrationType(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::Properties() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Properties(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(_winrt_abi_type->get_Properties(&value));
      }
      return winrt::Windows::Foundation::Collections::PropertySet{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProvider<
        D>::GetPropertyValue(param::hstring const& name) const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateProvider>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->GetPropertyValue(*(void**)(&name), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProvider>**)this;
        check_hresult(
            _winrt_abi_type->GetPropertyValue(*(void**)(&name), &result));
      }
      return winrt::Windows::Foundation::IInspectable{result,
                                                      take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderActionResult<
        D>::Result() const {
      winrt::Windows::Management::Update::WindowsSoftwareUpdateActionResult
          value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderActionResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderActionResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderActionResult>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_Result(reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderActionResult>**)this;
        check_hresult(
            _winrt_abi_type->get_Result(reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderActionResult<
        D>::RestartReason() const {
      winrt::Windows::Management::Update::WindowsSoftwareUpdateRestartReason
          value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderActionResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderActionResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderActionResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RestartReason(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderActionResult>**)this;
        check_hresult(_winrt_abi_type->get_RestartReason(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderActionResult<
        D>::ResultCode() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderActionResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderActionResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderActionResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderActionResult>**)this;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderActionResult<
        D>::ExtendedError() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderActionResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderActionResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderActionResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderActionResult>**)this;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderActionResultFactory<
        D>::CreateInstance(winrt::Windows::Management::Update::
                               WindowsSoftwareUpdateActionResult const&
                                   actionResult,
                           winrt::Windows::Management::Update::
                               WindowsSoftwareUpdateRestartReason const&
                                   restartReason,
                           uint32_t resultCode, uint64_t extendedError) const {
      void* value{};
      if constexpr (
          !std::is_same_v<
              D, winrt::Windows::Management::Update::
                     IWindowsSoftwareUpdateProviderActionResultFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderActionResultFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderActionResultFactory>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->CreateInstance(static_cast<int32_t>(actionResult),
                                            static_cast<int32_t>(restartReason),
                                            resultCode, extendedError, &value));
      } else {
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateProviderActionResultFactory>**)this;
        check_hresult(
            _winrt_abi_type->CreateInstance(static_cast<int32_t>(actionResult),
                                            static_cast<int32_t>(restartReason),
                                            resultCode, extendedError, &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateProviderActionResult{value,
                                                    take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderFactory<
        D>::CreateInstance(param::hstring const& folderPath) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateProviderFactory,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderFactory>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->CreateInstance(*(void**)(&folderPath), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderFactory>**)this;
        check_hresult(
            _winrt_abi_type->CreateInstance(*(void**)(&folderPath), &value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateProvider{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderPayloadFileInfo<
        D>::Filename() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderPayloadFileInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderPayloadFileInfo,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderPayloadFileInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Filename(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderPayloadFileInfo>**)this;
        check_hresult(_winrt_abi_type->get_Filename(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderPayloadFileInfo<
        D>::FileHash() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderPayloadFileInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderPayloadFileInfo,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderPayloadFileInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_FileHash(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderPayloadFileInfo>**)this;
        check_hresult(_winrt_abi_type->get_FileHash(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderPayloadFileInfo<
        D>::CatalogFile() const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderPayloadFileInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderPayloadFileInfo,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderPayloadFileInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CatalogFile(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderPayloadFileInfo>**)this;
        check_hresult(_winrt_abi_type->get_CatalogFile(&value));
      }
      return hstring{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderPayloadFileInfo<
        D>::TrustState() const {
      winrt::Windows::Management::Update::
          WindowsSoftwareUpdateProviderTrustState value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderPayloadFileInfo>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderPayloadFileInfo,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderPayloadFileInfo>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_TrustState(
            reinterpret_cast<int32_t*>(&value)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderPayloadFileInfo>**)this;
        check_hresult(_winrt_abi_type->get_TrustState(
            reinterpret_cast<int32_t*>(&value)));
      }
      return value;
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderStatus<D>::
        CancelRequested(winrt::Windows::Foundation::TypedEventHandler<
                        winrt::Windows::Management::Update::
                            WindowsSoftwareUpdateProviderStatus,
                        winrt::Windows::Foundation::IInspectable> const&
                            handler) const {
      winrt::event_token token{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateProviderStatus>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateProviderStatus,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatus>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->add_CancelRequested(*(void**)(&handler),
                                                           put_abi(token)));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderStatus>**)this;
        check_hresult(_winrt_abi_type->add_CancelRequested(*(void**)(&handler),
                                                           put_abi(token)));
      }
      return token;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderStatus<
        D>::CancelRequested(auto_revoke_t,
                            winrt::Windows::Foundation::TypedEventHandler<
                                winrt::Windows::Management::Update::
                                    WindowsSoftwareUpdateProviderStatus,
                                winrt::Windows::Foundation::IInspectable> const&
                                handler) const {
      return impl::make_event_revoker<D, CancelRequested_revoker>(
          this, CancelRequested(handler));
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderStatus<
        D>::CancelRequested(winrt::event_token const& token) const noexcept {
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateProviderStatus>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateProviderStatus,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatus>**)&_winrt_casted_result;
        _winrt_abi_type->remove_CancelRequested(impl::bind_in(token));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderStatus>**)this;
        _winrt_abi_type->remove_CancelRequested(impl::bind_in(token));
      }
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderStatus<
        D>::SetScanResult(bool succeeded, uint32_t resultCode,
                          uint64_t extendedError,
                          param::iterable<winrt::Windows::Management::Update::
                                              WindowsSoftwareUpdate> const&
                              updates) const {
      void* result{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateProviderStatus>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateProviderStatus,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatus>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->SetScanResult(succeeded, resultCode, extendedError,
                                           *(void**)(&updates), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderStatus>**)this;
        check_hresult(
            _winrt_abi_type->SetScanResult(succeeded, resultCode, extendedError,
                                           *(void**)(&updates), &result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderStatus<
        D>::SetActionProgress(uint64_t current, uint64_t total) const {
      void* result{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateProviderStatus>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateProviderStatus,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatus>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->SetActionProgress(current, total, &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderStatus>**)this;
        check_hresult(
            _winrt_abi_type->SetActionProgress(current, total, &result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderStatus<
        D>::SetActionResult(winrt::Windows::Management::Update::
                                WindowsSoftwareUpdateProviderActionResult const&
                                    actionResult) const {
      void* result{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateProviderStatus>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateProviderStatus,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatus>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->SetActionResult(*(void**)(&actionResult),
                                                       &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderStatus>**)this;
        check_hresult(_winrt_abi_type->SetActionResult(*(void**)(&actionResult),
                                                       &result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateProviderStatusFactory<
        D>::CreateInstance(param::hstring const& providerId) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateProviderStatusFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateProviderStatusFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatusFactory>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->CreateInstance(*(void**)(&providerId), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateProviderStatusFactory>**)this;
        check_hresult(
            _winrt_abi_type->CreateInstance(*(void**)(&providerId), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateProviderStatus{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateResult<
        D>::Succeeded() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Succeeded(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)this;
        check_hresult(_winrt_abi_type->get_Succeeded(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateResult<
        D>::CancelRequested() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_CancelRequested(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)this;
        check_hresult(_winrt_abi_type->get_CancelRequested(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateResult<
        D>::ResultCode() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)this;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateResult<
        D>::ExtendedError() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateResult,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResult>**)this;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateResultFactory<
        D>::CreateInstance(bool succeeded, uint32_t resultCode) const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateResultFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateResultFactory,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateResultFactory>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->CreateInstance(succeeded, resultCode, &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResultFactory>**)this;
        check_hresult(
            _winrt_abi_type->CreateInstance(succeeded, resultCode, &value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateResultFactory<
        D>::CreateInstance2(bool succeeded, uint32_t resultCode,
                            uint64_t extendedError) const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateResultFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateResultFactory,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateResultFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance2(succeeded, resultCode,
                                                       extendedError, &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResultFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance2(succeeded, resultCode,
                                                       extendedError, &value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateResultFactory<
        D>::CreateInstance3(bool succeeded, bool cancelRequested,
                            uint32_t resultCode, uint64_t extendedError) const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateResultFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateResultFactory,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateResultFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance3(
            succeeded, cancelRequested, resultCode, extendedError, &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateResultFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance3(
            succeeded, cancelRequested, resultCode, extendedError, &value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateResult{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateScanResult<
        D>::Succeeded() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateScanResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateScanResult,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateScanResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Succeeded(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateScanResult>**)this;
        check_hresult(_winrt_abi_type->get_Succeeded(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateScanResult<
        D>::ResultCode() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateScanResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateScanResult,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateScanResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateScanResult>**)this;
        check_hresult(_winrt_abi_type->get_ResultCode(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateScanResult<
        D>::ExtendedError() const {
      uint64_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateScanResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateScanResult,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateScanResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateScanResult>**)this;
        check_hresult(_winrt_abi_type->get_ExtendedError(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateScanResult<
        D>::Updates() const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateScanResult>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateScanResult,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsSoftwareUpdateScanResult>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Updates(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateScanResult>**)this;
        check_hresult(_winrt_abi_type->get_Updates(&value));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Windows::Management::Update::WindowsSoftwareUpdate>{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateScanResultFactory<
        D>::CreateInstance(bool succeeded, uint32_t resultCode,
                           param::iterable<winrt::Windows::Management::Update::
                                               WindowsSoftwareUpdate> const&
                               updates) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateScanResultFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateScanResultFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateScanResultFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            succeeded, resultCode, *(void**)(&updates), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateScanResultFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            succeeded, resultCode, *(void**)(&updates), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateScanResult{value, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsSoftwareUpdateScanResultFactory<
        D>::CreateInstance2(bool succeeded, uint32_t resultCode,
                            uint64_t extendedError,
                            param::iterable<winrt::Windows::Management::Update::
                                                WindowsSoftwareUpdate> const&
                                updates) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsSoftwareUpdateScanResultFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsSoftwareUpdateScanResultFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateScanResultFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance2(
            succeeded, resultCode, extendedError, *(void**)(&updates), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateScanResultFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance2(
            succeeded, resultCode, extendedError, *(void**)(&updates), &value));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateScanResult{value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateVersion<
        D>::Major() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateVersion>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateVersion,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Major(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)this;
        check_hresult(_winrt_abi_type->get_Major(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateVersion<
        D>::Minor() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateVersion>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateVersion,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_Minor(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)this;
        check_hresult(_winrt_abi_type->get_Minor(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateVersion<
        D>::RevisionMajor() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateVersion>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateVersion,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RevisionMajor(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)this;
        check_hresult(_winrt_abi_type->get_RevisionMajor(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateVersion<
        D>::RevisionMinor() const {
      uint32_t value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsSoftwareUpdateVersion>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsSoftwareUpdateVersion,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_RevisionMinor(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersion>**)this;
        check_hresult(_winrt_abi_type->get_RevisionMinor(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsSoftwareUpdateVersionFactory<
        D>::CreateInstance(uint32_t major, uint32_t minor,
                           uint32_t revisionMajor,
                           uint32_t revisionMinor) const {
      void* value{};
      if constexpr (!std::is_same_v<D,
                                    winrt::Windows::Management::Update::
                                        IWindowsSoftwareUpdateVersionFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsSoftwareUpdateVersionFactory,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateVersionFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            major, minor, revisionMajor, revisionMinor, &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsSoftwareUpdateVersionFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            major, minor, revisionMajor, revisionMinor, &value));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion{
          value, take_ownership_from_abi};
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::ProviderId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_ProviderId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::UpdateId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UpdateId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_UpdateId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::Description() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsFeatureUpdate() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsFeatureUpdate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsFeatureUpdate(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsMinorImpact() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsMinorImpact(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsMinorImpact(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsSecurity() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSecurity(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsSecurity(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsCritical() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsCritical(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsCritical(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsForOS() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsForOS(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsForOS(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsDriver() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsDriver(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsDriver(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsMandatory() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsMandatory(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsMandatory(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsUrgent() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsUrgent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsUrgent(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsSeeker() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSeeker(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsSeeker(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::MoreInfoUrl() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::SupportUrl() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SupportUrl(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_SupportUrl(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::IsEulaAccepted() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsEulaAccepted(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_IsEulaAccepted(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::EulaText() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EulaText(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_EulaText(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::Deadline() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Deadline(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_Deadline(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::AttentionRequiredInfo() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AttentionRequiredInfo(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_AttentionRequiredInfo(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::ActionResult() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionResult(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_ActionResult(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdateActionResult{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::CurrentAction() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CurrentAction(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_CurrentAction(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::ActionProgress() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionProgress(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->get_ActionProgress(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdateActionProgress{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::GetPropertyValue(param::hstring const& propertyName) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPropertyValue(*(void**)(&propertyName), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->GetPropertyValue(*(void**)(&propertyName), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdate<D>::AcceptEula() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->AcceptEula());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdate>**)this;
            check_hresult(_winrt_abi_type->AcceptEula());
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionCompletedEventArgs<D>::Update() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Update(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Update(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionCompletedEventArgs<D>::Action() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Action(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Action(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionCompletedEventArgs<D>::Succeeded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Succeeded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Succeeded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionCompletedEventArgs<D>::ExtendedError() const
    {
        winrt::hresult value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionProgress<D>::Action() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionProgress>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionProgress, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionProgress>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Action(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionProgress>**)this;
            check_hresult(_winrt_abi_type->get_Action(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionProgress<D>::Progress() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionProgress>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionProgress, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionProgress>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Progress(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionProgress>**)this;
            check_hresult(_winrt_abi_type->get_Progress(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionResult<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionResult<D>::Succeeded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Succeeded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)this;
            check_hresult(_winrt_abi_type->get_Succeeded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionResult<D>::ExtendedError() const
    {
        winrt::hresult value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)this;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateActionResult<D>::Action() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateActionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateActionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Action(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateActionResult>**)this;
            check_hresult(_winrt_abi_type->get_Action(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministrator<D>::StartAdministratorScan() const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministrator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->StartAdministratorScan());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)this;
            check_hresult(_winrt_abi_type->StartAdministratorScan());
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministrator<D>::ApproveWindowsUpdateAction(param::hstring const& updateId, param::hstring const& action) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministrator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ApproveWindowsUpdateAction(*(void**)(&updateId), *(void**)(&action)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)this;
            check_hresult(_winrt_abi_type->ApproveWindowsUpdateAction(*(void**)(&updateId), *(void**)(&action)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministrator<D>::RevokeWindowsUpdateActionApproval(param::hstring const& updateId, param::hstring const& action) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministrator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RevokeWindowsUpdateActionApproval(*(void**)(&updateId), *(void**)(&action)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)this;
            check_hresult(_winrt_abi_type->RevokeWindowsUpdateActionApproval(*(void**)(&updateId), *(void**)(&action)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministrator<D>::ApproveWindowsUpdate(param::hstring const& updateId, winrt::Windows::Management::Update::WindowsUpdateApprovalData const& approvalData) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministrator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ApproveWindowsUpdate(*(void**)(&updateId), *(void**)(&approvalData)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)this;
            check_hresult(_winrt_abi_type->ApproveWindowsUpdate(*(void**)(&updateId), *(void**)(&approvalData)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministrator<D>::RevokeWindowsUpdateApproval(param::hstring const& updateId) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministrator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RevokeWindowsUpdateApproval(*(void**)(&updateId)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)this;
            check_hresult(_winrt_abi_type->RevokeWindowsUpdateApproval(*(void**)(&updateId)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministrator<D>::GetUpdates() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministrator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetUpdates(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministrator>**)this;
            check_hresult(_winrt_abi_type->GetUpdates(&result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdate>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministratorStatics<D>::GetRegisteredAdministrator(param::hstring const& organizationName) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetRegisteredAdministrator(*(void**)(&organizationName), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)this;
            check_hresult(_winrt_abi_type->GetRegisteredAdministrator(*(void**)(&organizationName), &result));
        }
        return winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministratorStatics<D>::RegisterForAdministration(param::hstring const& organizationName, winrt::Windows::Management::Update::WindowsUpdateAdministratorOptions const& options) const
    {
        winrt::Windows::Management::Update::WindowsUpdateAdministratorStatus result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RegisterForAdministration(*(void**)(&organizationName), static_cast<uint32_t>(options), reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)this;
            check_hresult(_winrt_abi_type->RegisterForAdministration(*(void**)(&organizationName), static_cast<uint32_t>(options), reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministratorStatics<D>::UnregisterForAdministration(param::hstring const& organizationName) const
    {
        winrt::Windows::Management::Update::WindowsUpdateAdministratorStatus result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->UnregisterForAdministration(*(void**)(&organizationName), reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)this;
            check_hresult(_winrt_abi_type->UnregisterForAdministration(*(void**)(&organizationName), reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministratorStatics<D>::GetRegisteredAdministratorName() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetRegisteredAdministratorName(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)this;
            check_hresult(_winrt_abi_type->GetRegisteredAdministratorName(&result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministratorStatics<D>::RequestRestart(winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions const& restartOptions) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RequestRestart(*(void**)(&restartOptions), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)this;
            check_hresult(_winrt_abi_type->RequestRestart(*(void**)(&restartOptions), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAdministratorStatics<D>::CancelRestartRequest(param::hstring const& requestRestartToken) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CancelRestartRequest(*(void**)(&requestRestartToken)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>**)this;
            check_hresult(_winrt_abi_type->CancelRestartRequest(*(void**)(&requestRestartToken)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::Seeker() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Seeker(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->get_Seeker(&value));
        }
        return winrt::Windows::Foundation::IReference<bool>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::Seeker(winrt::Windows::Foundation::IReference<bool> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Seeker(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->put_Seeker(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::AllowDownloadOnMetered() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowDownloadOnMetered(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->get_AllowDownloadOnMetered(&value));
        }
        return winrt::Windows::Foundation::IReference<bool>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::AllowDownloadOnMetered(winrt::Windows::Foundation::IReference<bool> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowDownloadOnMetered(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->put_AllowDownloadOnMetered(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::ComplianceDeadlineInDays() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ComplianceDeadlineInDays(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->get_ComplianceDeadlineInDays(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::ComplianceDeadlineInDays(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ComplianceDeadlineInDays(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->put_ComplianceDeadlineInDays(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::ComplianceGracePeriodInDays() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ComplianceGracePeriodInDays(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->get_ComplianceGracePeriodInDays(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::ComplianceGracePeriodInDays(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ComplianceGracePeriodInDays(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->put_ComplianceGracePeriodInDays(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::OptOutOfAutoReboot() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OptOutOfAutoReboot(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->get_OptOutOfAutoReboot(&value));
        }
        return winrt::Windows::Foundation::IReference<bool>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateApprovalData<D>::OptOutOfAutoReboot(winrt::Windows::Foundation::IReference<bool> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateApprovalData, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OptOutOfAutoReboot(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateApprovalData>**)this;
            check_hresult(_winrt_abi_type->put_OptOutOfAutoReboot(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAttentionRequiredInfo<D>::Reason() const
    {
        winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReason value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAttentionRequiredInfo<D>::Timestamp() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAttentionRequiredReasonChangedEventArgs<D>::Update() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Update(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Update(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateAttentionRequiredReasonChangedEventArgs<D>::Reason() const
    {
        winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReason value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateGetAdministratorResult<D>::Administrator() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Administrator(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult>**)this;
            check_hresult(_winrt_abi_type->get_Administrator(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdateAdministrator{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateGetAdministratorResult<D>::Status() const
    {
        winrt::Windows::Management::Update::WindowsUpdateAdministratorStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::ProviderId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_ProviderId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::UpdateId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UpdateId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_UpdateId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::Timestamp() const
    {
        winrt::Windows::Foundation::DateTime value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::Description() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::MoreInfoUrl() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::Category() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Category(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_Category(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateItem<D>::Operation() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Operation(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateItem>**)this;
            check_hresult(_winrt_abi_type->get_Operation(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ScanningStateChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ScanningStateChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->add_ScanningStateChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ScanningStateChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, ScanningStateChanged_revoker>(this, ScanningStateChanged(handler));
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ScanningStateChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ScanningStateChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            _winrt_abi_type->remove_ScanningStateChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::WorkingStateChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_WorkingStateChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->add_WorkingStateChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::WorkingStateChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, WorkingStateChanged_revoker>(this, WorkingStateChanged(handler));
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::WorkingStateChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_WorkingStateChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            _winrt_abi_type->remove_WorkingStateChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ProgressChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ProgressChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->add_ProgressChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ProgressChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ProgressChanged_revoker>(this, ProgressChanged(handler));
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ProgressChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ProgressChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            _winrt_abi_type->remove_ProgressChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::AttentionRequiredReasonChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_AttentionRequiredReasonChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->add_AttentionRequiredReasonChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::AttentionRequiredReasonChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, AttentionRequiredReasonChanged_revoker>(this, AttentionRequiredReasonChanged(handler));
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::AttentionRequiredReasonChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_AttentionRequiredReasonChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            _winrt_abi_type->remove_AttentionRequiredReasonChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ActionCompleted(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ActionCompleted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->add_ActionCompleted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ActionCompleted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ActionCompleted_revoker>(this, ActionCompleted(handler));
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ActionCompleted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ActionCompleted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            _winrt_abi_type->remove_ActionCompleted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ScanCompleted(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ScanCompleted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->add_ScanCompleted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ScanCompleted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ScanCompleted_revoker>(this, ScanCompleted(handler));
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::ScanCompleted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ScanCompleted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            _winrt_abi_type->remove_ScanCompleted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::IsScanning() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsScanning(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->get_IsScanning(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::IsWorking() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsWorking(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->get_IsWorking(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::LastSuccessfulScanTimestamp() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LastSuccessfulScanTimestamp(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->get_LastSuccessfulScanTimestamp(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::GetApplicableUpdates() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetApplicableUpdates(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->GetApplicableUpdates(&result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdate>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::GetMostRecentCompletedUpdates(int32_t count) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetMostRecentCompletedUpdates(count, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->GetMostRecentCompletedUpdates(count, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdateItem>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::GetMostRecentCompletedUpdatesAsync(int32_t count) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetMostRecentCompletedUpdatesAsync(count, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->GetMostRecentCompletedUpdatesAsync(count, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdateItem>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManager<D>::StartScan(bool userInitiated) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->StartScan(userInitiated));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManager>**)this;
            check_hresult(_winrt_abi_type->StartScan(userInitiated));
        }
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsUpdateManager2<D>::GetProvider(
        param::hstring const& id) const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManager2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsUpdateManager2,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->GetProvider(*(void**)(&id), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)this;
        check_hresult(_winrt_abi_type->GetProvider(*(void**)(&id), &result));
      }
      return winrt::Windows::Management::Update::WindowsSoftwareUpdateProvider{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManager2<
        D>::ProviderIds() const {
      uint32_t value_impl_size{};
      void** value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManager2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsUpdateManager2,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->get_ProviderIds(&value_impl_size, &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)this;
        check_hresult(
            _winrt_abi_type->get_ProviderIds(&value_impl_size, &value));
      }
      return com_array<hstring>{value, value_impl_size,
                                take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManager2<
        D>::GetApplicableSoftwareUpdates() const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManager2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsUpdateManager2,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->GetApplicableSoftwareUpdates(&result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)this;
        check_hresult(_winrt_abi_type->GetApplicableSoftwareUpdates(&result));
      }
      return winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Windows::Management::Update::WindowsSoftwareUpdate>{
          result, take_ownership_from_abi};
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsUpdateManager2<D>::PerformScan(
        winrt::Windows::Management::Update::
            WindowsUpdateManagerScanOptions const& options) const {
      void* result{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManager2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsUpdateManager2,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)&_winrt_casted_result;
        check_hresult(
            _winrt_abi_type->PerformScan(*(void**)(&options), &result));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManager2>**)this;
        check_hresult(
            _winrt_abi_type->PerformScan(*(void**)(&options), &result));
      }
      return winrt::Windows::Management::Update::
          WindowsSoftwareUpdateScanResult{result, take_ownership_from_abi};
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateManagerFactory<D>::CreateInstance(param::hstring const& clientId) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateManagerFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateManagerFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManagerFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&clientId), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateManagerFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&clientId), &value));
        }
        return winrt::Windows::Management::Update::WindowsUpdateManager{ value, take_ownership_from_abi };
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManagerFactory2<
        D>::CreateInstance(param::hstring const& clientId,
                           array_view<hstring const> providerIdFilter) const {
      void* value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManagerFactory2>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::IWindowsUpdateManagerFactory2,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerFactory2>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&clientId), providerIdFilter.size(),
            get_abi(providerIdFilter), &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerFactory2>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(
            *(void**)(&clientId), providerIdFilter.size(),
            get_abi(providerIdFilter), &value));
      }
      return winrt::Windows::Management::Update::WindowsUpdateManager{
          value, take_ownership_from_abi};
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManagerScanOptions<
        D>::IsUserInitiated() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManagerScanOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsUpdateManagerScanOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsUpdateManagerScanOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_IsUserInitiated(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerScanOptions>**)this;
        check_hresult(_winrt_abi_type->get_IsUserInitiated(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManagerScanOptions<
        D>::IsUserInitiated(bool value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManagerScanOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsUpdateManagerScanOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsUpdateManagerScanOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_IsUserInitiated(value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerScanOptions>**)this;
        check_hresult(_winrt_abi_type->put_IsUserInitiated(value));
      }
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManagerScanOptions<
        D>::AllowBypassThrottling() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManagerScanOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsUpdateManagerScanOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsUpdateManagerScanOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_AllowBypassThrottling(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerScanOptions>**)this;
        check_hresult(_winrt_abi_type->get_AllowBypassThrottling(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManagerScanOptions<
        D>::AllowBypassThrottling(bool value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManagerScanOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsUpdateManagerScanOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsUpdateManagerScanOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_AllowBypassThrottling(value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerScanOptions>**)this;
        check_hresult(_winrt_abi_type->put_AllowBypassThrottling(value));
      }
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManagerScanOptions<
        D>::PerformUpdateActions() const {
      bool value{};
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManagerScanOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsUpdateManagerScanOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsUpdateManagerScanOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->get_PerformUpdateActions(&value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerScanOptions>**)this;
        check_hresult(_winrt_abi_type->get_PerformUpdateActions(&value));
      }
      return value;
    }
    template <typename D>
    auto consume_Windows_Management_Update_IWindowsUpdateManagerScanOptions<
        D>::PerformUpdateActions(bool value) const {
      if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::
                                           IWindowsUpdateManagerScanOptions>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result =
            impl::try_as_with_reason<winrt::Windows::Management::Update::
                                         IWindowsUpdateManagerScanOptions,
                                     D const*>(static_cast<D const*>(this),
                                               _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type = *(
            abi_t<winrt::Windows::Management::Update::
                      IWindowsUpdateManagerScanOptions>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->put_PerformUpdateActions(value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerScanOptions>**)this;
        check_hresult(_winrt_abi_type->put_PerformUpdateActions(value));
      }
    }
    template <typename D>
    auto
    consume_Windows_Management_Update_IWindowsUpdateManagerScanOptionsFactory<
        D>::CreateInstance(bool isUserInitiated) const {
      void* value{};
      if constexpr (!std::is_same_v<
                        D, winrt::Windows::Management::Update::
                               IWindowsUpdateManagerScanOptionsFactory>) {
        winrt::hresult _winrt_cast_result_code;
        auto const _winrt_casted_result = impl::try_as_with_reason<
            winrt::Windows::Management::Update::
                IWindowsUpdateManagerScanOptionsFactory,
            D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
        check_hresult(_winrt_cast_result_code);
        auto const _winrt_abi_type =
            *(abi_t<
                winrt::Windows::Management::Update::
                    IWindowsUpdateManagerScanOptionsFactory>**)&_winrt_casted_result;
        check_hresult(_winrt_abi_type->CreateInstance(isUserInitiated, &value));
      } else {
        auto const _winrt_abi_type =
            *(abi_t<winrt::Windows::Management::Update::
                        IWindowsUpdateManagerScanOptionsFactory>**)this;
        check_hresult(_winrt_abi_type->CreateInstance(isUserInitiated, &value));
      }
      return winrt::Windows::Management::Update::
          WindowsUpdateManagerScanOptions{value, take_ownership_from_abi};
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateProgressChangedEventArgs<D>::Update() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Update(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Update(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateProgressChangedEventArgs<D>::ActionProgress() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionProgress(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ActionProgress(&value));
        }
        return winrt::Windows::Management::Update::WindowsUpdateActionProgress{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::Title(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::Description() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::Description(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Description(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->put_Description(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::MoreInfoUrl() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->get_MoreInfoUrl(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::MoreInfoUrl(winrt::Windows::Foundation::Uri const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MoreInfoUrl(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->put_MoreInfoUrl(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::ComplianceDeadlineInDays() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ComplianceDeadlineInDays(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->get_ComplianceDeadlineInDays(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::ComplianceDeadlineInDays(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ComplianceDeadlineInDays(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->put_ComplianceDeadlineInDays(value));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::ComplianceGracePeriodInDays() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ComplianceGracePeriodInDays(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->get_ComplianceGracePeriodInDays(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::ComplianceGracePeriodInDays(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ComplianceGracePeriodInDays(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->put_ComplianceGracePeriodInDays(value));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::OrganizationName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OrganizationName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->get_OrganizationName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::OrganizationName(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OrganizationName(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->put_OrganizationName(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::OptOutOfAutoReboot() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OptOutOfAutoReboot(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->get_OptOutOfAutoReboot(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptions<D>::OptOutOfAutoReboot(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OptOutOfAutoReboot(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>**)this;
            check_hresult(_winrt_abi_type->put_OptOutOfAutoReboot(value));
        }
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateRestartRequestOptionsFactory<D>::CreateInstance(param::hstring const& title, param::hstring const& description, winrt::Windows::Foundation::Uri const& moreInfoUrl, int32_t complianceDeadlineInDays, int32_t complianceGracePeriodInDays) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptionsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptionsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptionsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&title), *(void**)(&description), *(void**)(&moreInfoUrl), complianceDeadlineInDays, complianceGracePeriodInDays, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptionsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&title), *(void**)(&description), *(void**)(&moreInfoUrl), complianceDeadlineInDays, complianceGracePeriodInDays, &value));
        }
        return winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateScanCompletedEventArgs<D>::ProviderId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProviderId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ProviderId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateScanCompletedEventArgs<D>::Succeeded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Succeeded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Succeeded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateScanCompletedEventArgs<D>::ExtendedError() const
    {
        winrt::hresult value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Windows_Management_Update_IWindowsUpdateScanCompletedEventArgs<D>::Updates() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Updates(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Updates(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdate>{ value, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IPreviewBuildsManager> : produce_base<D, winrt::Windows::Management::Update::IPreviewBuildsManager>
    {
        int32_t __stdcall get_ArePreviewBuildsAllowed(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ArePreviewBuildsAllowed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ArePreviewBuildsAllowed(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ArePreviewBuildsAllowed(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetCurrentState(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Management::Update::PreviewBuildsState>(this->shim().GetCurrentState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SyncAsync(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IAsyncOperation<bool>>(this->shim().SyncAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IPreviewBuildsManagerStatics> : produce_base<D, winrt::Windows::Management::Update::IPreviewBuildsManagerStatics>
    {
        int32_t __stdcall GetDefault(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::PreviewBuildsManager>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsSupported(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IPreviewBuildsState> : produce_base<D, winrt::Windows::Management::Update::IPreviewBuildsState>
    {
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::ValueSet>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D,
                   winrt::Windows::Management::Update::IWindowsSoftwareUpdate>
        : produce_base<
              D, winrt::Windows::Management::Update::IWindowsSoftwareUpdate> {
      int32_t __stdcall get_InstallationType(int32_t* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateInstallationType>(
            this->shim().InstallationType());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ProviderId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().ProviderId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_UpdateId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().UpdateId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Title(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Title());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Description(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Description());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MoreInfoUrl(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::Uri>(
            this->shim().MoreInfoUrl());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_DownloadSizeInBytes(uint64_t* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().DownloadSizeInBytes());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_InstallSizeInBytes(uint64_t* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().InstallSizeInBytes());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_SourceVersion(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion>(
            this->shim().SourceVersion());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_TargetVersion(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion>(
            this->shim().TargetVersion());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ProductCode(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::IReference<winrt::guid>>(
                this->shim().ProductCode());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_PackageFamilyName(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().PackageFamilyName());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall Approve(void* approvalInfo,
                                void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().Approve(
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateApprovalInfo const*>(
                    &approvalInfo)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall ApproveCurrentAction(bool approve,
                                             void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().ApproveCurrentAction(approve));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CurrentAction(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().CurrentAction());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ActionResultInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionResultInfo>(
            this->shim().ActionResultInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ApprovalInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateApprovalInfo>(
            this->shim().ApprovalInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ApprovedActions(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::Collections::IVectorView<
                winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateActionType>>(
                this->shim().ApprovedActions());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_AttentionRequiredInfo(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsUpdateAttentionRequiredInfo>(
            this->shim().AttentionRequiredInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ActionProgress(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionProgress>(
            this->shim().ActionProgress());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RestartReason(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::IReference<
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateRestartReason>>(
            this->shim().RestartReason());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_AppPackageInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateAppPackageInfo>(
            this->shim().AppPackageInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ExecutionInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateExecutionInfo>(
            this->shim().ExecutionInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_OptionalInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateOptionalInfo>(
            this->shim().OptionalInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsSoftwareUpdateActionInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateActionInfo> {
      int32_t __stdcall get_FileName(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().FileName());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_FileArguments(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().FileArguments());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ActionType(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionType>(
            this->shim().ActionType());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateActionInfoFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateActionInfoFactory> {
      int32_t __stdcall CreateInstance(void* fileName, void* fileArguments,
                                       int32_t actionType,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionInfo>(
            this->shim().CreateInstance(
                *reinterpret_cast<hstring const*>(&fileName),
                *reinterpret_cast<hstring const*>(&fileArguments),
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionType const*>(
                    &actionType)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateActionProgress>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateActionProgress> {
      int32_t __stdcall get_Action(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Action());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CurrentProgress(uint64_t* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().CurrentProgress());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_TotalProgress(uint64_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().TotalProgress());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateActionResultInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateActionResultInfo> {
      int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try {
        zero_abi<winrt::Windows::Foundation::DateTime>(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::DateTime>(
            this->shim().Timestamp());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Succeeded(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().Succeeded());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ResultCode(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().ResultCode());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ExtendedError(uint64_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().ExtendedError());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Action(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Action());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateAppPackageInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateAppPackageInfo> {
      int32_t __stdcall get_PackageFamilyName(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().PackageFamilyName());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_PackageArchitecture(int32_t* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateArchitecture>(
            this->shim().PackageArchitecture());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_InstallUri(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::Uri>(
            this->shim().InstallUri());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateAppPackageInfoFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateAppPackageInfoFactory> {
      int32_t __stdcall CreateInstance(void* packageFamilyName,
                                       int32_t packageArchitecture,
                                       void* installUri,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateAppPackageInfo>(
            this->shim().CreateInstance(
                *reinterpret_cast<hstring const*>(&packageFamilyName),
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateArchitecture const*>(
                    &packageArchitecture),
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &installUri)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateApprovalInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateApprovalInfo> {
      int32_t __stdcall get_UserInitiated(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().UserInitiated());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_AppClosure(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().AppClosure());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MeteredNetwork(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().MeteredNetwork());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Seeker(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().Seeker());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateApprovalInfoFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateApprovalInfoFactory> {
      int32_t __stdcall CreateInstance(bool userInitiated, bool appClosure,
                                       bool meteredNetwork, bool seeker,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateApprovalInfo>(
            this->shim().CreateInstance(userInitiated, appClosure,
                                        meteredNetwork, seeker));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateExecutionInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateExecutionInfo> {
      int32_t __stdcall get_DownloadInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionInfo>(
            this->shim().DownloadInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_InstallInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionInfo>(
            this->shim().InstallInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_DeployInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionInfo>(
            this->shim().DeployInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_OptionalActionInfo(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateOptionalActionInfo>(
            this->shim().OptionalActionInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateExecutionInfoFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateExecutionInfoFactory> {
      int32_t __stdcall CreateInstance(void* downloadInfo, void* installInfo,
                                       void* actions,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateExecutionInfo>(
            this->shim().CreateInstance(
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionInfo const*>(
                    &downloadInfo),
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionInfo const*>(
                    &installInfo),
                *reinterpret_cast<
                    winrt::Windows::Management::Update::
                        WindowsSoftwareUpdateOptionalActionInfo const*>(
                    &actions)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall CreateInstance2(void* deployInfo, void* actions,
                                        void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateExecutionInfo>(
            this->shim().CreateInstance2(
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionInfo const*>(
                    &deployInfo),
                *reinterpret_cast<
                    winrt::Windows::Management::Update::
                        WindowsSoftwareUpdateOptionalActionInfo const*>(
                    &actions)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsSoftwareUpdateFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateFactory> {
      int32_t __stdcall CreateInstance(
          void* providerId, int32_t installationType, void* updateId,
          void* title, void* description, void* moreInfoUrl,
          uint64_t downloadSizeInBytes, uint64_t installSizeInBytes,
          void* sourceVersion, void* targetVersion, void* appPackageInfo,
          void* executionInfo, void* optionalInfo, void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdate>(this->shim().CreateInstance(
            *reinterpret_cast<hstring const*>(&providerId),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateInstallationType const*>(
                &installationType),
            *reinterpret_cast<hstring const*>(&updateId),
            *reinterpret_cast<hstring const*>(&title),
            *reinterpret_cast<hstring const*>(&description),
            *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                &moreInfoUrl),
            downloadSizeInBytes, installSizeInBytes,
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateVersion const*>(
                &sourceVersion),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateVersion const*>(
                &targetVersion),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateAppPackageInfo const*>(
                &appPackageInfo),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateExecutionInfo const*>(
                &executionInfo),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateOptionalInfo const*>(
                &optionalInfo)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall CreateInstance2(
          void* providerId, int32_t installationType, void* updateId,
          void* title, void* description, void* moreInfoUrl,
          uint64_t downloadSizeInBytes, uint64_t installSizeInBytes,
          void* productCode, void* packageFamilyName, void* sourceVersion,
          void* targetVersion, void* appPackageInfo, void* executionInfo,
          void* optionalInfo, void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdate>(this->shim().CreateInstance2(
            *reinterpret_cast<hstring const*>(&providerId),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateInstallationType const*>(
                &installationType),
            *reinterpret_cast<hstring const*>(&updateId),
            *reinterpret_cast<hstring const*>(&title),
            *reinterpret_cast<hstring const*>(&description),
            *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                &moreInfoUrl),
            downloadSizeInBytes, installSizeInBytes,
            *reinterpret_cast<
                winrt::Windows::Foundation::IReference<winrt::guid> const*>(
                &productCode),
            *reinterpret_cast<hstring const*>(&packageFamilyName),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateVersion const*>(
                &sourceVersion),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateVersion const*>(
                &targetVersion),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateAppPackageInfo const*>(
                &appPackageInfo),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateExecutionInfo const*>(
                &executionInfo),
            *reinterpret_cast<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateOptionalInfo const*>(
                &optionalInfo)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateLocalizationInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateLocalizationInfo> {
      int32_t __stdcall get_LanguageId(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().LanguageId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Title(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Title());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Description(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Description());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MoreInfoUrl(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::Uri>(
            this->shim().MoreInfoUrl());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateLocalizationInfoFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateLocalizationInfoFactory> {
      int32_t __stdcall CreateInstance(uint32_t languageId, void* title,
                                       void* description, void* moreInfoUrl,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateLocalizationInfo>(
            this->shim().CreateInstance(
                languageId, *reinterpret_cast<hstring const*>(&title),
                *reinterpret_cast<hstring const*>(&description),
                *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(
                    &moreInfoUrl)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateOptionalActionInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateOptionalActionInfo> {
      int32_t __stdcall get_CloseAndDeployInfo(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionInfo>(
            this->shim().CloseAndDeployInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CloseAndInstallInfo(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionInfo>(
            this->shim().CloseAndInstallInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CloseAndRestartInfo(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionInfo>(
            this->shim().CloseAndRestartInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateOptionalActionInfoFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateOptionalActionInfoFactory> {
      int32_t __stdcall CreateInstance(void* closeAndDeployInfo,
                                       void* closeAndInstallInfo,
                                       void* closeAndRestartInfo,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateOptionalActionInfo>(
            this->shim().CreateInstance(
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionInfo const*>(
                    &closeAndDeployInfo),
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionInfo const*>(
                    &closeAndInstallInfo),
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionInfo const*>(
                    &closeAndRestartInfo)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateOptionalInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateOptionalInfo> {
      int32_t __stdcall get_LocalizationInfo(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::Collections::IVectorView<
                winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateLocalizationInfo>>(
                this->shim().LocalizationInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ComplianceDeadlineInDays(
          void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(
            this->shim().ComplianceDeadlineInDays());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ComplianceGracePeriodInDays(
          void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(
            this->shim().ComplianceGracePeriodInDays());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateOptionalInfoFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateOptionalInfoFactory> {
      int32_t __stdcall CreateInstance(void* complianceDeadlineInDays,
                                       void* complianceGracePeriodInDays,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateOptionalInfo>(
            this->shim().CreateInstance(
                *reinterpret_cast<
                    winrt::Windows::Foundation::IReference<int32_t> const*>(
                    &complianceDeadlineInDays),
                *reinterpret_cast<
                    winrt::Windows::Foundation::IReference<int32_t> const*>(
                    &complianceGracePeriodInDays)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall CreateInstance2(void* localizationInfo,
                                        void* complianceDeadlineInDays,
                                        void* complianceGracePeriodInDays,
                                        void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateOptionalInfo>(
            this->shim().CreateInstance2(
                *reinterpret_cast<
                    winrt::Windows::Foundation::Collections::IIterable<
                        winrt::Windows::Management::Update::
                            WindowsSoftwareUpdateLocalizationInfo> const*>(
                    &localizationInfo),
                *reinterpret_cast<
                    winrt::Windows::Foundation::IReference<int32_t> const*>(
                    &complianceDeadlineInDays),
                *reinterpret_cast<
                    winrt::Windows::Foundation::IReference<int32_t> const*>(
                    &complianceGracePeriodInDays)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateProvider> {
      int32_t __stdcall Register(void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().Register());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall Unregister(void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().Unregister());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall Validate(void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().Validate());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Id(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Id());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Version(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Version());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_FolderPath(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().FolderPath());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CatalogFile(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().CatalogFile());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ScanFileName(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().ScanFileName());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ScanFileArguments(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().ScanFileArguments());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Type(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateProviderType>(
            this->shim().Type());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_PayloadFiles(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::Collections::IVectorView<
                winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateProviderPayloadFileInfo>>(
                this->shim().PayloadFiles());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_TrustState(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateProviderTrustState>(
            this->shim().TrustState());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RegistrationType(int32_t* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateProviderRegistrationType>(
            this->shim().RegistrationType());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Properties(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::Collections::PropertySet>(
                this->shim().Properties());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetPropertyValue(void* name,
                                         void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<winrt::Windows::Foundation::IInspectable>(
            this->shim().GetPropertyValue(
                *reinterpret_cast<hstring const*>(&name)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateProviderActionResult>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateProviderActionResult> {
      int32_t __stdcall get_Result(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateActionResult>(
            this->shim().Result());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RestartReason(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateRestartReason>(
            this->shim().RestartReason());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ResultCode(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().ResultCode());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ExtendedError(uint64_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().ExtendedError());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateProviderActionResultFactory>
        : produce_base<D,
                       winrt::Windows::Management::Update::
                           IWindowsSoftwareUpdateProviderActionResultFactory> {
      int32_t __stdcall CreateInstance(int32_t actionResult,
                                       int32_t restartReason,
                                       uint32_t resultCode,
                                       uint64_t extendedError,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateProviderActionResult>(
            this->shim().CreateInstance(
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsSoftwareUpdateActionResult const*>(
                    &actionResult),
                *reinterpret_cast<
                    winrt::Windows::Management::Update::
                        WindowsSoftwareUpdateRestartReason const*>(
                    &restartReason),
                resultCode, extendedError));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateProviderFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateProviderFactory> {
      int32_t __stdcall CreateInstance(void* folderPath,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateProvider>(
            this->shim().CreateInstance(
                *reinterpret_cast<hstring const*>(&folderPath)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateProviderPayloadFileInfo>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateProviderPayloadFileInfo> {
      int32_t __stdcall get_Filename(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Filename());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_FileHash(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().FileHash());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CatalogFile(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().CatalogFile());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_TrustState(int32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateProviderTrustState>(
            this->shim().TrustState());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateProviderStatus>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateProviderStatus> {
      int32_t __stdcall add_CancelRequested(
          void* handler, winrt::event_token* token) noexcept final try {
        zero_abi<winrt::event_token>(token);
        typename D::abi_guard guard(this->shim());
        *token = detach_from<winrt::event_token>(this->shim().CancelRequested(
            *reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<
                winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateProviderStatus,
                winrt::Windows::Foundation::IInspectable> const*>(&handler)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall remove_CancelRequested(
          winrt::event_token token) noexcept final {
        typename D::abi_guard guard(this->shim());
        this->shim().CancelRequested(
            *reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
      }
      int32_t __stdcall SetScanResult(bool succeeded, uint32_t resultCode,
                                      uint64_t extendedError, void* updates,
                                      void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().SetScanResult(
                succeeded, resultCode, extendedError,
                *reinterpret_cast<
                    winrt::Windows::Foundation::Collections::IIterable<
                        winrt::Windows::Management::Update::
                            WindowsSoftwareUpdate> const*>(&updates)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall SetActionProgress(uint64_t current, uint64_t total,
                                          void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().SetActionProgress(current, total));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall SetActionResult(void* actionResult,
                                        void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().SetActionResult(
                *reinterpret_cast<
                    winrt::Windows::Management::Update::
                        WindowsSoftwareUpdateProviderActionResult const*>(
                    &actionResult)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateProviderStatusFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateProviderStatusFactory> {
      int32_t __stdcall CreateInstance(void* providerId,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateProviderStatus>(
            this->shim().CreateInstance(
                *reinterpret_cast<hstring const*>(&providerId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsSoftwareUpdateResult>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateResult> {
      int32_t __stdcall get_Succeeded(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().Succeeded());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CancelRequested(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().CancelRequested());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ResultCode(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().ResultCode());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ExtendedError(uint64_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().ExtendedError());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D,
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateResultFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateResultFactory> {
      int32_t __stdcall CreateInstance(bool succeeded, uint32_t resultCode,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().CreateInstance(succeeded, resultCode));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall CreateInstance2(bool succeeded, uint32_t resultCode,
                                        uint64_t extendedError,
                                        void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().CreateInstance2(succeeded, resultCode, extendedError));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall CreateInstance3(bool succeeded, bool cancelRequested,
                                        uint32_t resultCode,
                                        uint64_t extendedError,
                                        void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>(
            this->shim().CreateInstance3(succeeded, cancelRequested, resultCode,
                                         extendedError));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsSoftwareUpdateScanResult>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateScanResult> {
      int32_t __stdcall get_Succeeded(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().Succeeded());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ResultCode(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().ResultCode());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ExtendedError(uint64_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint64_t>(this->shim().ExtendedError());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Updates(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value =
            detach_from<winrt::Windows::Foundation::Collections::IVectorView<
                winrt::Windows::Management::Update::WindowsSoftwareUpdate>>(
                this->shim().Updates());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateScanResultFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateScanResultFactory> {
      int32_t __stdcall CreateInstance(bool succeeded, uint32_t resultCode,
                                       void* updates,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateScanResult>(
            this->shim().CreateInstance(
                succeeded, resultCode,
                *reinterpret_cast<
                    winrt::Windows::Foundation::Collections::IIterable<
                        winrt::Windows::Management::Update::
                            WindowsSoftwareUpdate> const*>(&updates)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall CreateInstance2(bool succeeded, uint32_t resultCode,
                                        uint64_t extendedError, void* updates,
                                        void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsSoftwareUpdateScanResult>(
            this->shim().CreateInstance2(
                succeeded, resultCode, extendedError,
                *reinterpret_cast<
                    winrt::Windows::Foundation::Collections::IIterable<
                        winrt::Windows::Management::Update::
                            WindowsSoftwareUpdate> const*>(&updates)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsSoftwareUpdateVersion>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateVersion> {
      int32_t __stdcall get_Major(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().Major());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Minor(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().Minor());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RevisionMajor(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().RevisionMajor());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_RevisionMinor(uint32_t* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<uint32_t>(this->shim().RevisionMinor());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsSoftwareUpdateVersionFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsSoftwareUpdateVersionFactory> {
      int32_t __stdcall CreateInstance(uint32_t major, uint32_t minor,
                                       uint32_t revisionMajor,
                                       uint32_t revisionMinor,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion>(
            this->shim().CreateInstance(major, minor, revisionMajor,
                                        revisionMinor));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdate>
        : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdate> {
      int32_t __stdcall get_ProviderId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().ProviderId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_UpdateId(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().UpdateId());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Title(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Title());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Description(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().Description());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsFeatureUpdate(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsFeatureUpdate());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsMinorImpact(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsMinorImpact());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsSecurity(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsSecurity());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsCritical(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsCritical());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsForOS(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsForOS());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsDriver(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsDriver());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsMandatory(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsMandatory());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsUrgent(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsUrgent());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsSeeker(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsSeeker());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_MoreInfoUrl(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::Uri>(
            this->shim().MoreInfoUrl());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_SupportUrl(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::Uri>(
            this->shim().SupportUrl());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_IsEulaAccepted(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsEulaAccepted());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_EulaText(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().EulaText());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_Deadline(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Foundation::IReference<
            winrt::Windows::Foundation::DateTime>>(this->shim().Deadline());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_AttentionRequiredInfo(void** value) noexcept final
          try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsUpdateAttentionRequiredInfo>(
            this->shim().AttentionRequiredInfo());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ActionResult(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsUpdateActionResult>(
            this->shim().ActionResult());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_CurrentAction(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<hstring>(this->shim().CurrentAction());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ActionProgress(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsUpdateActionProgress>(
            this->shim().ActionProgress());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetPropertyValue(void* propertyName,
                                         void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<winrt::Windows::Foundation::IInspectable>(
            this->shim().GetPropertyValue(
                *reinterpret_cast<hstring const*>(&propertyName)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall AcceptEula() noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().AcceptEula();
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs>
    {
        int32_t __stdcall get_Update(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::WindowsUpdate>(this->shim().Update());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Action(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Action());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Succeeded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Succeeded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateActionProgress> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateActionProgress>
    {
        int32_t __stdcall get_Action(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Action());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Progress(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Progress());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateActionResult> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateActionResult>
    {
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Succeeded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Succeeded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Action(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Action());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateAdministrator>
    {
        int32_t __stdcall StartAdministratorScan() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartAdministratorScan();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ApproveWindowsUpdateAction(void* updateId, void* action) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ApproveWindowsUpdateAction(*reinterpret_cast<hstring const*>(&updateId), *reinterpret_cast<hstring const*>(&action));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RevokeWindowsUpdateActionApproval(void* updateId, void* action) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RevokeWindowsUpdateActionApproval(*reinterpret_cast<hstring const*>(&updateId), *reinterpret_cast<hstring const*>(&action));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ApproveWindowsUpdate(void* updateId, void* approvalData) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ApproveWindowsUpdate(*reinterpret_cast<hstring const*>(&updateId), *reinterpret_cast<winrt::Windows::Management::Update::WindowsUpdateApprovalData const*>(&approvalData));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RevokeWindowsUpdateApproval(void* updateId) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RevokeWindowsUpdateApproval(*reinterpret_cast<hstring const*>(&updateId));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetUpdates(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdate>>(this->shim().GetUpdates());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics>
    {
        int32_t __stdcall GetRegisteredAdministrator(void* organizationName, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>(this->shim().GetRegisteredAdministrator(*reinterpret_cast<hstring const*>(&organizationName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RegisterForAdministration(void* organizationName, uint32_t options, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Management::Update::WindowsUpdateAdministratorStatus>(this->shim().RegisterForAdministration(*reinterpret_cast<hstring const*>(&organizationName), *reinterpret_cast<winrt::Windows::Management::Update::WindowsUpdateAdministratorOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall UnregisterForAdministration(void* organizationName, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Management::Update::WindowsUpdateAdministratorStatus>(this->shim().UnregisterForAdministration(*reinterpret_cast<hstring const*>(&organizationName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetRegisteredAdministratorName(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetRegisteredAdministratorName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RequestRestart(void* restartOptions, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().RequestRestart(*reinterpret_cast<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions const*>(&restartOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CancelRestartRequest(void* requestRestartToken) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CancelRestartRequest(*reinterpret_cast<hstring const*>(&requestRestartToken));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateApprovalData>
    {
        int32_t __stdcall get_Seeker(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<bool>>(this->shim().Seeker());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Seeker(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Seeker(*reinterpret_cast<winrt::Windows::Foundation::IReference<bool> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowDownloadOnMetered(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<bool>>(this->shim().AllowDownloadOnMetered());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowDownloadOnMetered(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowDownloadOnMetered(*reinterpret_cast<winrt::Windows::Foundation::IReference<bool> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ComplianceDeadlineInDays(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().ComplianceDeadlineInDays());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ComplianceDeadlineInDays(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ComplianceDeadlineInDays(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ComplianceGracePeriodInDays(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().ComplianceGracePeriodInDays());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ComplianceGracePeriodInDays(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ComplianceGracePeriodInDays(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptOutOfAutoReboot(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<bool>>(this->shim().OptOutOfAutoReboot());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OptOutOfAutoReboot(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OptOutOfAutoReboot(*reinterpret_cast<winrt::Windows::Foundation::IReference<bool> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Timestamp(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs>
    {
        int32_t __stdcall get_Update(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::WindowsUpdate>(this->shim().Update());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult>
    {
        int32_t __stdcall get_Administrator(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::WindowsUpdateAdministrator>(this->shim().Administrator());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::WindowsUpdateAdministratorStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateItem> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateItem>
    {
        int32_t __stdcall get_ProviderId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ProviderId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UpdateId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().UpdateId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Timestamp(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Title(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Title());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Description(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Description());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoreInfoUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().MoreInfoUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Category(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Category());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Operation(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Operation());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateManager> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateManager>
    {
        int32_t __stdcall add_ScanningStateChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ScanningStateChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ScanningStateChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ScanningStateChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_WorkingStateChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().WorkingStateChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_WorkingStateChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WorkingStateChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ProgressChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ProgressChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ProgressChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProgressChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_AttentionRequiredReasonChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().AttentionRequiredReasonChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_AttentionRequiredReasonChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AttentionRequiredReasonChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ActionCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ActionCompleted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ActionCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ActionCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ScanCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ScanCompleted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ScanCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ScanCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_IsScanning(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsScanning());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsWorking(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsWorking());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LastSuccessfulScanTimestamp(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(this->shim().LastSuccessfulScanTimestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetApplicableUpdates(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdate>>(this->shim().GetApplicableUpdates());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetMostRecentCompletedUpdates(int32_t count, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdateItem>>(this->shim().GetMostRecentCompletedUpdates(count));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetMostRecentCompletedUpdatesAsync(int32_t count, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdateItem>>>(this->shim().GetMostRecentCompletedUpdatesAsync(count));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StartScan(bool userInitiated) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartScan(userInitiated);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D,
                   winrt::Windows::Management::Update::IWindowsUpdateManager2>
        : produce_base<
              D, winrt::Windows::Management::Update::IWindowsUpdateManager2> {
      int32_t __stdcall GetProvider(void* id, void** result) noexcept final
          try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<
            winrt::Windows::Management::Update::WindowsSoftwareUpdateProvider>(
            this->shim().GetProvider(*reinterpret_cast<hstring const*>(&id)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ProviderIds(uint32_t* __valueSize,
                                        void*** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        std::tie(*__valueSize, *value) = detach_abi(this->shim().ProviderIds());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall GetApplicableSoftwareUpdates(
          void** result) noexcept final try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result =
            detach_from<winrt::Windows::Foundation::Collections::IVectorView<
                winrt::Windows::Management::Update::WindowsSoftwareUpdate>>(
                this->shim().GetApplicableSoftwareUpdates());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall PerformScan(void* options, void** result) noexcept final
          try {
        clear_abi(result);
        typename D::abi_guard guard(this->shim());
        *result = detach_from<winrt::Windows::Management::Update::
                                  WindowsSoftwareUpdateScanResult>(
            this->shim().PerformScan(
                *reinterpret_cast<winrt::Windows::Management::Update::
                                      WindowsUpdateManagerScanOptions const*>(
                    &options)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsUpdateManagerFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsUpdateManagerFactory> {
      int32_t __stdcall CreateInstance(void* clientId,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsUpdateManager>(
            this->shim().CreateInstance(
                *reinterpret_cast<hstring const*>(&clientId)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsUpdateManagerFactory2>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsUpdateManagerFactory2> {
      int32_t __stdcall CreateInstance(void* clientId,
                                       uint32_t __providerIdFilterSize,
                                       void** providerIdFilter,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsUpdateManager>(
            this->shim().CreateInstance(
                *reinterpret_cast<hstring const*>(&clientId),
                array_view<hstring const>(
                    reinterpret_cast<hstring const*>(providerIdFilter),
                    reinterpret_cast<hstring const*>(providerIdFilter) +
                        __providerIdFilterSize)));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<
        D, winrt::Windows::Management::Update::IWindowsUpdateManagerScanOptions>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsUpdateManagerScanOptions> {
      int32_t __stdcall get_IsUserInitiated(bool* value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().IsUserInitiated());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_IsUserInitiated(bool value) noexcept final try {
        typename D::abi_guard guard(this->shim());
        this->shim().IsUserInitiated(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_AllowBypassThrottling(bool* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().AllowBypassThrottling());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_AllowBypassThrottling(bool value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        this->shim().AllowBypassThrottling(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_PerformUpdateActions(bool* value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        *value = detach_from<bool>(this->shim().PerformUpdateActions());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall put_PerformUpdateActions(bool value) noexcept final
          try {
        typename D::abi_guard guard(this->shim());
        this->shim().PerformUpdateActions(value);
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsUpdateManagerScanOptionsFactory>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsUpdateManagerScanOptionsFactory> {
      int32_t __stdcall CreateInstance(bool isUserInitiated,
                                       void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::
                                 WindowsUpdateManagerScanOptions>(
            this->shim().CreateInstance(isUserInitiated));
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::
                          IWindowsUpdateProgressChangedEventArgs>
        : produce_base<D, winrt::Windows::Management::Update::
                              IWindowsUpdateProgressChangedEventArgs> {
      int32_t __stdcall get_Update(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<winrt::Windows::Management::Update::WindowsUpdate>(
            this->shim().Update());
        return 0;
      } catch (...) {
        return to_hresult();
      }
      int32_t __stdcall get_ActionProgress(void** value) noexcept final try {
        clear_abi(value);
        typename D::abi_guard guard(this->shim());
        *value = detach_from<
            winrt::Windows::Management::Update::WindowsUpdateActionProgress>(
            this->shim().ActionProgress());
        return 0;
      } catch (...) {
        return to_hresult();
      }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions>
    {
        int32_t __stdcall get_Title(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Title());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Title(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Title(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Description(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Description());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Description(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Description(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoreInfoUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().MoreInfoUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MoreInfoUrl(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoreInfoUrl(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ComplianceDeadlineInDays(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().ComplianceDeadlineInDays());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ComplianceDeadlineInDays(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ComplianceDeadlineInDays(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ComplianceGracePeriodInDays(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().ComplianceGracePeriodInDays());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ComplianceGracePeriodInDays(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ComplianceGracePeriodInDays(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OrganizationName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().OrganizationName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OrganizationName(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OrganizationName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptOutOfAutoReboot(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().OptOutOfAutoReboot());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OptOutOfAutoReboot(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OptOutOfAutoReboot(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptionsFactory> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptionsFactory>
    {
        int32_t __stdcall CreateInstance(void* title, void* description, void* moreInfoUrl, int32_t complianceDeadlineInDays, int32_t complianceGracePeriodInDays, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&title), *reinterpret_cast<hstring const*>(&description), *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&moreInfoUrl), complianceDeadlineInDays, complianceGracePeriodInDays));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs> : produce_base<D, winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs>
    {
        int32_t __stdcall get_ProviderId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ProviderId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Succeeded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Succeeded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Updates(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Management::Update::WindowsUpdate>>(this->shim().Updates());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Windows::Management::Update
{
    constexpr auto operator|(WindowsUpdateAdministratorOptions const left, WindowsUpdateAdministratorOptions const right) noexcept
    {
        return static_cast<WindowsUpdateAdministratorOptions>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(WindowsUpdateAdministratorOptions& left, WindowsUpdateAdministratorOptions const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(WindowsUpdateAdministratorOptions const left, WindowsUpdateAdministratorOptions const right) noexcept
    {
        return static_cast<WindowsUpdateAdministratorOptions>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(WindowsUpdateAdministratorOptions& left, WindowsUpdateAdministratorOptions const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(WindowsUpdateAdministratorOptions const value) noexcept
    {
        return static_cast<WindowsUpdateAdministratorOptions>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(WindowsUpdateAdministratorOptions const left, WindowsUpdateAdministratorOptions const right) noexcept
    {
        return static_cast<WindowsUpdateAdministratorOptions>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(WindowsUpdateAdministratorOptions& left, WindowsUpdateAdministratorOptions const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline auto PreviewBuildsManager::GetDefault()
    {
        return impl::call_factory_cast<winrt::Windows::Management::Update::PreviewBuildsManager(*)(IPreviewBuildsManagerStatics const&), PreviewBuildsManager, IPreviewBuildsManagerStatics>([](IPreviewBuildsManagerStatics const& f) { return f.GetDefault(); });
    }
    inline auto PreviewBuildsManager::IsSupported()
    {
        return impl::call_factory_cast<bool(*)(IPreviewBuildsManagerStatics const&), PreviewBuildsManager, IPreviewBuildsManagerStatics>([](IPreviewBuildsManagerStatics const& f) { return f.IsSupported(); });
    }
    inline WindowsSoftwareUpdate::WindowsSoftwareUpdate(
        param::hstring const& providerId,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateInstallationType const& installationType,
        param::hstring const& updateId, param::hstring const& title,
        param::hstring const& description,
        winrt::Windows::Foundation::Uri const& moreInfoUrl,
        uint64_t downloadSizeInBytes, uint64_t installSizeInBytes,
        winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion const&
            sourceVersion,
        winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion const&
            targetVersion,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateAppPackageInfo const& appPackageInfo,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateExecutionInfo const& executionInfo,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateOptionalInfo const& optionalInfo)
        : WindowsSoftwareUpdate(
              impl::call_factory<WindowsSoftwareUpdate,
                                 IWindowsSoftwareUpdateFactory>(
                  [&](IWindowsSoftwareUpdateFactory const& f) {
                    return f.CreateInstance(
                        providerId, installationType, updateId, title,
                        description, moreInfoUrl, downloadSizeInBytes,
                        installSizeInBytes, sourceVersion, targetVersion,
                        appPackageInfo, executionInfo, optionalInfo);
                  })) {}
    inline WindowsSoftwareUpdate::WindowsSoftwareUpdate(
        param::hstring const& providerId,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateInstallationType const& installationType,
        param::hstring const& updateId, param::hstring const& title,
        param::hstring const& description,
        winrt::Windows::Foundation::Uri const& moreInfoUrl,
        uint64_t downloadSizeInBytes, uint64_t installSizeInBytes,
        winrt::Windows::Foundation::IReference<winrt::guid> const& productCode,
        param::hstring const& packageFamilyName,
        winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion const&
            sourceVersion,
        winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion const&
            targetVersion,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateAppPackageInfo const& appPackageInfo,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateExecutionInfo const& executionInfo,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateOptionalInfo const& optionalInfo)
        : WindowsSoftwareUpdate(
              impl::call_factory<WindowsSoftwareUpdate,
                                 IWindowsSoftwareUpdateFactory>(
                  [&](IWindowsSoftwareUpdateFactory const& f) {
                    return f.CreateInstance2(
                        providerId, installationType, updateId, title,
                        description, moreInfoUrl, downloadSizeInBytes,
                        installSizeInBytes, productCode, packageFamilyName,
                        sourceVersion, targetVersion, appPackageInfo,
                        executionInfo, optionalInfo);
                  })) {}
    inline WindowsSoftwareUpdateActionInfo::WindowsSoftwareUpdateActionInfo(
        param::hstring const& fileName, param::hstring const& fileArguments,
        winrt::Windows::Management::Update::
            WindowsSoftwareUpdateActionType const& actionType)
        : WindowsSoftwareUpdateActionInfo(
              impl::call_factory<WindowsSoftwareUpdateActionInfo,
                                 IWindowsSoftwareUpdateActionInfoFactory>(
                  [&](IWindowsSoftwareUpdateActionInfoFactory const& f) {
                    return f.CreateInstance(fileName, fileArguments,
                                            actionType);
                  })) {}
    inline WindowsSoftwareUpdateAppPackageInfo::
        WindowsSoftwareUpdateAppPackageInfo(
            param::hstring const& packageFamilyName,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateArchitecture const& packageArchitecture,
            winrt::Windows::Foundation::Uri const& installUri)
        : WindowsSoftwareUpdateAppPackageInfo(
              impl::call_factory<WindowsSoftwareUpdateAppPackageInfo,
                                 IWindowsSoftwareUpdateAppPackageInfoFactory>(
                  [&](IWindowsSoftwareUpdateAppPackageInfoFactory const& f) {
                    return f.CreateInstance(packageFamilyName,
                                            packageArchitecture, installUri);
                  })) {}
    inline WindowsSoftwareUpdateApprovalInfo::WindowsSoftwareUpdateApprovalInfo(
        bool userInitiated, bool appClosure, bool meteredNetwork, bool seeker)
        : WindowsSoftwareUpdateApprovalInfo(
              impl::call_factory<WindowsSoftwareUpdateApprovalInfo,
                                 IWindowsSoftwareUpdateApprovalInfoFactory>(
                  [&](IWindowsSoftwareUpdateApprovalInfoFactory const& f) {
                    return f.CreateInstance(userInitiated, appClosure,
                                            meteredNetwork, seeker);
                  })) {}
    inline WindowsSoftwareUpdateExecutionInfo::
        WindowsSoftwareUpdateExecutionInfo(
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& downloadInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& installInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateOptionalActionInfo const& actions)
        : WindowsSoftwareUpdateExecutionInfo(
              impl::call_factory<WindowsSoftwareUpdateExecutionInfo,
                                 IWindowsSoftwareUpdateExecutionInfoFactory>(
                  [&](IWindowsSoftwareUpdateExecutionInfoFactory const& f) {
                    return f.CreateInstance(downloadInfo, installInfo, actions);
                  })) {}
    inline WindowsSoftwareUpdateExecutionInfo::
        WindowsSoftwareUpdateExecutionInfo(
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& deployInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateOptionalActionInfo const& actions)
        : WindowsSoftwareUpdateExecutionInfo(
              impl::call_factory<WindowsSoftwareUpdateExecutionInfo,
                                 IWindowsSoftwareUpdateExecutionInfoFactory>(
                  [&](IWindowsSoftwareUpdateExecutionInfoFactory const& f) {
                    return f.CreateInstance2(deployInfo, actions);
                  })) {}
    inline WindowsSoftwareUpdateLocalizationInfo::
        WindowsSoftwareUpdateLocalizationInfo(
            uint32_t languageId, param::hstring const& title,
            param::hstring const& description,
            winrt::Windows::Foundation::Uri const& moreInfoUrl)
        : WindowsSoftwareUpdateLocalizationInfo(
              impl::call_factory<WindowsSoftwareUpdateLocalizationInfo,
                                 IWindowsSoftwareUpdateLocalizationInfoFactory>(
                  [&](IWindowsSoftwareUpdateLocalizationInfoFactory const& f) {
                    return f.CreateInstance(languageId, title, description,
                                            moreInfoUrl);
                  })) {}
    inline WindowsSoftwareUpdateOptionalActionInfo::
        WindowsSoftwareUpdateOptionalActionInfo(
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& closeAndDeployInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& closeAndInstallInfo,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionInfo const& closeAndRestartInfo)
        : WindowsSoftwareUpdateOptionalActionInfo(
              impl::call_factory<
                  WindowsSoftwareUpdateOptionalActionInfo,
                  IWindowsSoftwareUpdateOptionalActionInfoFactory>(
                  [&](IWindowsSoftwareUpdateOptionalActionInfoFactory const&
                          f) {
                    return f.CreateInstance(closeAndDeployInfo,
                                            closeAndInstallInfo,
                                            closeAndRestartInfo);
                  })) {}
    inline WindowsSoftwareUpdateOptionalInfo::WindowsSoftwareUpdateOptionalInfo(
        winrt::Windows::Foundation::IReference<int32_t> const&
            complianceDeadlineInDays,
        winrt::Windows::Foundation::IReference<int32_t> const&
            complianceGracePeriodInDays)
        : WindowsSoftwareUpdateOptionalInfo(
              impl::call_factory<WindowsSoftwareUpdateOptionalInfo,
                                 IWindowsSoftwareUpdateOptionalInfoFactory>(
                  [&](IWindowsSoftwareUpdateOptionalInfoFactory const& f) {
                    return f.CreateInstance(complianceDeadlineInDays,
                                            complianceGracePeriodInDays);
                  })) {}
    inline WindowsSoftwareUpdateOptionalInfo::WindowsSoftwareUpdateOptionalInfo(
        param::iterable<winrt::Windows::Management::Update::
                            WindowsSoftwareUpdateLocalizationInfo> const&
            localizationInfo,
        winrt::Windows::Foundation::IReference<int32_t> const&
            complianceDeadlineInDays,
        winrt::Windows::Foundation::IReference<int32_t> const&
            complianceGracePeriodInDays)
        : WindowsSoftwareUpdateOptionalInfo(
              impl::call_factory<WindowsSoftwareUpdateOptionalInfo,
                                 IWindowsSoftwareUpdateOptionalInfoFactory>(
                  [&](IWindowsSoftwareUpdateOptionalInfoFactory const& f) {
                    return f.CreateInstance2(localizationInfo,
                                             complianceDeadlineInDays,
                                             complianceGracePeriodInDays);
                  })) {}
    inline WindowsSoftwareUpdateProvider::WindowsSoftwareUpdateProvider(
        param::hstring const& folderPath)
        : WindowsSoftwareUpdateProvider(
              impl::call_factory<WindowsSoftwareUpdateProvider,
                                 IWindowsSoftwareUpdateProviderFactory>(
                  [&](IWindowsSoftwareUpdateProviderFactory const& f) {
                    return f.CreateInstance(folderPath);
                  })) {}
    inline WindowsSoftwareUpdateProviderActionResult::
        WindowsSoftwareUpdateProviderActionResult(
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateActionResult const& actionResult,
            winrt::Windows::Management::Update::
                WindowsSoftwareUpdateRestartReason const& restartReason,
            uint32_t resultCode, uint64_t extendedError)
        : WindowsSoftwareUpdateProviderActionResult(
              impl::call_factory<
                  WindowsSoftwareUpdateProviderActionResult,
                  IWindowsSoftwareUpdateProviderActionResultFactory>(
                  [&](IWindowsSoftwareUpdateProviderActionResultFactory const&
                          f) {
                    return f.CreateInstance(actionResult, restartReason,
                                            resultCode, extendedError);
                  })) {}
    inline WindowsSoftwareUpdateProviderStatus::
        WindowsSoftwareUpdateProviderStatus(param::hstring const& providerId)
        : WindowsSoftwareUpdateProviderStatus(
              impl::call_factory<WindowsSoftwareUpdateProviderStatus,
                                 IWindowsSoftwareUpdateProviderStatusFactory>(
                  [&](IWindowsSoftwareUpdateProviderStatusFactory const& f) {
                    return f.CreateInstance(providerId);
                  })) {}
    inline WindowsSoftwareUpdateResult::WindowsSoftwareUpdateResult(
        bool succeeded, uint32_t resultCode)
        : WindowsSoftwareUpdateResult(
              impl::call_factory<WindowsSoftwareUpdateResult,
                                 IWindowsSoftwareUpdateResultFactory>(
                  [&](IWindowsSoftwareUpdateResultFactory const& f) {
                    return f.CreateInstance(succeeded, resultCode);
                  })) {}
    inline WindowsSoftwareUpdateResult::WindowsSoftwareUpdateResult(
        bool succeeded, uint32_t resultCode, uint64_t extendedError)
        : WindowsSoftwareUpdateResult(
              impl::call_factory<WindowsSoftwareUpdateResult,
                                 IWindowsSoftwareUpdateResultFactory>(
                  [&](IWindowsSoftwareUpdateResultFactory const& f) {
                    return f.CreateInstance2(succeeded, resultCode,
                                             extendedError);
                  })) {}
    inline WindowsSoftwareUpdateResult::WindowsSoftwareUpdateResult(
        bool succeeded, bool cancelRequested, uint32_t resultCode,
        uint64_t extendedError)
        : WindowsSoftwareUpdateResult(
              impl::call_factory<WindowsSoftwareUpdateResult,
                                 IWindowsSoftwareUpdateResultFactory>(
                  [&](IWindowsSoftwareUpdateResultFactory const& f) {
                    return f.CreateInstance3(succeeded, cancelRequested,
                                             resultCode, extendedError);
                  })) {}
    inline WindowsSoftwareUpdateScanResult::WindowsSoftwareUpdateScanResult(
        bool succeeded, uint32_t resultCode,
        param::iterable<
            winrt::Windows::Management::Update::WindowsSoftwareUpdate> const&
            updates)
        : WindowsSoftwareUpdateScanResult(
              impl::call_factory<WindowsSoftwareUpdateScanResult,
                                 IWindowsSoftwareUpdateScanResultFactory>(
                  [&](IWindowsSoftwareUpdateScanResultFactory const& f) {
                    return f.CreateInstance(succeeded, resultCode, updates);
                  })) {}
    inline WindowsSoftwareUpdateScanResult::WindowsSoftwareUpdateScanResult(
        bool succeeded, uint32_t resultCode, uint64_t extendedError,
        param::iterable<
            winrt::Windows::Management::Update::WindowsSoftwareUpdate> const&
            updates)
        : WindowsSoftwareUpdateScanResult(
              impl::call_factory<WindowsSoftwareUpdateScanResult,
                                 IWindowsSoftwareUpdateScanResultFactory>(
                  [&](IWindowsSoftwareUpdateScanResultFactory const& f) {
                    return f.CreateInstance2(succeeded, resultCode,
                                             extendedError, updates);
                  })) {}
    inline WindowsSoftwareUpdateVersion::WindowsSoftwareUpdateVersion(
        uint32_t major, uint32_t minor, uint32_t revisionMajor,
        uint32_t revisionMinor)
        : WindowsSoftwareUpdateVersion(
              impl::call_factory<WindowsSoftwareUpdateVersion,
                                 IWindowsSoftwareUpdateVersionFactory>(
                  [&](IWindowsSoftwareUpdateVersionFactory const& f) {
                    return f.CreateInstance(major, minor, revisionMajor,
                                            revisionMinor);
                  })) {}
    inline auto WindowsUpdateAdministrator::GetRegisteredAdministrator(param::hstring const& organizationName)
    {
        return impl::call_factory<WindowsUpdateAdministrator, IWindowsUpdateAdministratorStatics>([&](IWindowsUpdateAdministratorStatics const& f) { return f.GetRegisteredAdministrator(organizationName); });
    }
    inline auto WindowsUpdateAdministrator::RegisterForAdministration(param::hstring const& organizationName, winrt::Windows::Management::Update::WindowsUpdateAdministratorOptions const& options)
    {
        return impl::call_factory<WindowsUpdateAdministrator, IWindowsUpdateAdministratorStatics>([&](IWindowsUpdateAdministratorStatics const& f) { return f.RegisterForAdministration(organizationName, options); });
    }
    inline auto WindowsUpdateAdministrator::UnregisterForAdministration(param::hstring const& organizationName)
    {
        return impl::call_factory<WindowsUpdateAdministrator, IWindowsUpdateAdministratorStatics>([&](IWindowsUpdateAdministratorStatics const& f) { return f.UnregisterForAdministration(organizationName); });
    }
    inline auto WindowsUpdateAdministrator::GetRegisteredAdministratorName()
    {
        return impl::call_factory_cast<hstring(*)(IWindowsUpdateAdministratorStatics const&), WindowsUpdateAdministrator, IWindowsUpdateAdministratorStatics>([](IWindowsUpdateAdministratorStatics const& f) { return f.GetRegisteredAdministratorName(); });
    }
    inline auto WindowsUpdateAdministrator::RequestRestart(winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions const& restartOptions)
    {
        return impl::call_factory<WindowsUpdateAdministrator, IWindowsUpdateAdministratorStatics>([&](IWindowsUpdateAdministratorStatics const& f) { return f.RequestRestart(restartOptions); });
    }
    inline auto WindowsUpdateAdministrator::CancelRestartRequest(param::hstring const& requestRestartToken)
    {
        impl::call_factory<WindowsUpdateAdministrator, IWindowsUpdateAdministratorStatics>([&](IWindowsUpdateAdministratorStatics const& f) { return f.CancelRestartRequest(requestRestartToken); });
    }
    inline WindowsUpdateApprovalData::WindowsUpdateApprovalData() :
        WindowsUpdateApprovalData(impl::call_factory_cast<WindowsUpdateApprovalData(*)(winrt::Windows::Foundation::IActivationFactory const&), WindowsUpdateApprovalData>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<WindowsUpdateApprovalData>(); }))
    {
    }
    inline WindowsUpdateManager::WindowsUpdateManager(param::hstring const& clientId) :
        WindowsUpdateManager(impl::call_factory<WindowsUpdateManager, IWindowsUpdateManagerFactory>([&](IWindowsUpdateManagerFactory const& f) { return f.CreateInstance(clientId); }))
    {
    }
    inline WindowsUpdateManager::WindowsUpdateManager(
        param::hstring const& clientId,
        array_view<hstring const> providerIdFilter)
        : WindowsUpdateManager(
              impl::call_factory<WindowsUpdateManager,
                                 IWindowsUpdateManagerFactory2>(
                  [&](IWindowsUpdateManagerFactory2 const& f) {
                    return f.CreateInstance(clientId, providerIdFilter);
                  })) {}
    inline WindowsUpdateManagerScanOptions::WindowsUpdateManagerScanOptions()
        : WindowsUpdateManagerScanOptions(
              impl::call_factory_cast<
                  WindowsUpdateManagerScanOptions (*)(
                      winrt::Windows::Foundation::IActivationFactory const&),
                  WindowsUpdateManagerScanOptions>(
                  [](winrt::Windows::Foundation::IActivationFactory const& f) {
                    return f.template ActivateInstance<
                        WindowsUpdateManagerScanOptions>();
                  })) {}
    inline WindowsUpdateManagerScanOptions::WindowsUpdateManagerScanOptions(
        bool isUserInitiated)
        : WindowsUpdateManagerScanOptions(
              impl::call_factory<WindowsUpdateManagerScanOptions,
                                 IWindowsUpdateManagerScanOptionsFactory>(
                  [&](IWindowsUpdateManagerScanOptionsFactory const& f) {
                    return f.CreateInstance(isUserInitiated);
                  })) {}
    inline WindowsUpdateRestartRequestOptions::WindowsUpdateRestartRequestOptions() :
        WindowsUpdateRestartRequestOptions(impl::call_factory_cast<WindowsUpdateRestartRequestOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), WindowsUpdateRestartRequestOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<WindowsUpdateRestartRequestOptions>(); }))
    {
    }
    inline WindowsUpdateRestartRequestOptions::WindowsUpdateRestartRequestOptions(param::hstring const& title, param::hstring const& description, winrt::Windows::Foundation::Uri const& moreInfoUrl, int32_t complianceDeadlineInDays, int32_t complianceGracePeriodInDays) :
        WindowsUpdateRestartRequestOptions(impl::call_factory<WindowsUpdateRestartRequestOptions, IWindowsUpdateRestartRequestOptionsFactory>([&](IWindowsUpdateRestartRequestOptionsFactory const& f) { return f.CreateInstance(title, description, moreInfoUrl, complianceDeadlineInDays, complianceGracePeriodInDays); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Windows::Management::Update::IPreviewBuildsManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IPreviewBuildsManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IPreviewBuildsState> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::IWindowsSoftwareUpdate>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateActionInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionInfoFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionProgress>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateActionResultInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateAppPackageInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateAppPackageInfoFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateApprovalInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateApprovalInfoFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateExecutionInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateExecutionInfoFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateLocalizationInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateLocalizationInfoFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalActionInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalActionInfoFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateOptionalInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateOptionalInfoFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateProvider>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderActionResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderActionResultFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderPayloadFileInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatus>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateProviderStatusFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateResultFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateScanResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateScanResultFactory>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsSoftwareUpdateVersion>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsSoftwareUpdateVersionFactory>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdate> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateActionCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateActionProgress> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateActionResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateAdministrator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateAdministratorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateApprovalData> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateAttentionRequiredReasonChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateGetAdministratorResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateManager> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::IWindowsUpdateManager2>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateManagerFactory> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsUpdateManagerFactory2>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::IWindowsUpdateManagerScanOptions>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    IWindowsUpdateManagerScanOptionsFactory>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateProgressChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateRestartRequestOptionsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::IWindowsUpdateScanCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::PreviewBuildsManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::PreviewBuildsState> : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::WindowsSoftwareUpdate>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateActionInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateActionProgress>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateActionResultInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateAppPackageInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateApprovalInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateExecutionInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateLocalizationInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateOptionalActionInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateOptionalInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateProvider>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateProviderActionResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::
                    WindowsSoftwareUpdateProviderPayloadFileInfo>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateProviderStatus>
        : winrt::impl::hash_base {};
    template <>
    struct hash<winrt::Windows::Management::Update::WindowsSoftwareUpdateResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateScanResult>
        : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsSoftwareUpdateVersion>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdate> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateActionProgress> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateActionResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateAdministrator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateApprovalData> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateManager> : winrt::impl::hash_base {};
    template <>
    struct hash<
        winrt::Windows::Management::Update::WindowsUpdateManagerScanOptions>
        : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
