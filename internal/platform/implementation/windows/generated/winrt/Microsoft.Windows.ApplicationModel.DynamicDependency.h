// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_ApplicationModel_DynamicDependency_H
#define WINRT_Microsoft_Windows_ApplicationModel_DynamicDependency_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.ApplicationModel.DynamicDependency.2.h"
#include "winrt/impl/Windows.ApplicationModel.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<
    D>::Rank() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IAddPackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IAddPackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Rank(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->get_Rank(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<
    D>::Rank(int32_t value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IAddPackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IAddPackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_Rank(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->put_Rank(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<
    D>::PrependIfRankCollision() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IAddPackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IAddPackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PrependIfRankCollision(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->get_PrependIfRankCollision(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<
    D>::PrependIfRankCollision(bool value) const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IAddPackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IAddPackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_PrependIfRankCollision(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IAddPackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->put_PrependIfRankCollision(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::Architectures() const {
  winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyProcessorArchitectures value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Architectures(
        reinterpret_cast<uint32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->get_Architectures(
        reinterpret_cast<uint32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::
    Architectures(
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            PackageDependencyProcessorArchitectures const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_Architectures(static_cast<uint32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(
        _winrt_abi_type->put_Architectures(static_cast<uint32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::VerifyDependencyResolution() const {
  bool value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_VerifyDependencyResolution(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->get_VerifyDependencyResolution(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::VerifyDependencyResolution(bool value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_VerifyDependencyResolution(value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->put_VerifyDependencyResolution(value));
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::LifetimeArtifactKind() const {
  winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyLifetimeArtifactKind value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LifetimeArtifactKind(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->get_LifetimeArtifactKind(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::
    LifetimeArtifactKind(
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            PackageDependencyLifetimeArtifactKind const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->put_LifetimeArtifactKind(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(
        _winrt_abi_type->put_LifetimeArtifactKind(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::LifetimeArtifact() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_LifetimeArtifact(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->get_LifetimeArtifact(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<
    D>::LifetimeArtifact(param::hstring const& value) const {
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::ICreatePackageDependencyOptions>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            ICreatePackageDependencyOptions,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_LifetimeArtifact(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    ICreatePackageDependencyOptions>**)this;
    check_hresult(_winrt_abi_type->put_LifetimeArtifact(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<
    D>::Id() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       DynamicDependency::IPackageDependency>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     DynamicDependency::IPackageDependency,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Id(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)this;
    check_hresult(_winrt_abi_type->get_Id(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<
    D>::Delete() const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       DynamicDependency::IPackageDependency>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     DynamicDependency::IPackageDependency,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Delete());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)this;
    check_hresult(_winrt_abi_type->Delete());
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<
    D>::Add() const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       DynamicDependency::IPackageDependency>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     DynamicDependency::IPackageDependency,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Add(&result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)this;
    check_hresult(_winrt_abi_type->Add(&result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyContext{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<
    D>::Add(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                AddPackageDependencyOptions const& options) const {
  void* result{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::
                                       DynamicDependency::IPackageDependency>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result =
        impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::
                                     DynamicDependency::IPackageDependency,
                                 D const*>(static_cast<D const*>(this),
                                           _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Add2(*(void**)(&options), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependency>**)this;
    check_hresult(_winrt_abi_type->Add2(*(void**)(&options), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyContext{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<
    D>::ContextId() const {
  winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyContextId value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyContext>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyContext,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_ContextId(put_abi(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)this;
    check_hresult(_winrt_abi_type->get_ContextId(put_abi(value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<
    D>::PackageDependencyId() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyContext>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyContext,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageDependencyId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)this;
    check_hresult(_winrt_abi_type->get_PackageDependencyId(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<
    D>::PackageFullName() const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyContext>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyContext,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageFullName(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)this;
    check_hresult(_winrt_abi_type->get_PackageFullName(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<
    D>::Remove() const {
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyContext>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyContext,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Remove());
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContext>**)this;
    check_hresult(_winrt_abi_type->Remove());
  }
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContextFactory<
    D>::CreateInstance(winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::PackageDependencyContextId const&
                               contextId) const {
  void* value{};
  if constexpr (!std::is_same_v<
                    D,
                    winrt::Microsoft::Windows::ApplicationModel::
                        DynamicDependency::IPackageDependencyContextFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyContextFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContextFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(contextId), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyContextFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(contextId), &value));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependencyContext{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyRankStatics<
    D>::Default() const {
  int32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyRankStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyRankStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyRankStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Default(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyRankStatics>**)this;
    check_hresult(_winrt_abi_type->get_Default(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<
    D>::GetFromId(param::hstring const& id) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetFromId(*(void**)(&id), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)this;
    check_hresult(_winrt_abi_type->GetFromId(*(void**)(&id), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependency{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<
    D>::GetFromIdForSystem(param::hstring const& id) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->GetFromIdForSystem(*(void**)(&id), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)this;
    check_hresult(_winrt_abi_type->GetFromIdForSystem(*(void**)(&id), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependency{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<
    D>::Create(param::hstring const& packageFamilyName,
               winrt::Windows::ApplicationModel::PackageVersion const&
                   minVersion) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create(*(void**)(&packageFamilyName),
                                          impl::bind_in(minVersion), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)this;
    check_hresult(_winrt_abi_type->Create(*(void**)(&packageFamilyName),
                                          impl::bind_in(minVersion), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependency{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<
    D>::Create(param::hstring const& packageFamilyName,
               winrt::Windows::ApplicationModel::PackageVersion const&
                   minVersion,
               winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                   CreatePackageDependencyOptions const& options) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->Create2(*(void**)(&packageFamilyName),
                                           impl::bind_in(minVersion),
                                           *(void**)(&options), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)this;
    check_hresult(_winrt_abi_type->Create2(*(void**)(&packageFamilyName),
                                           impl::bind_in(minVersion),
                                           *(void**)(&options), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependency{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<
    D>::
    CreateForSystem(
        param::hstring const& packageFamilyName,
        winrt::Windows::ApplicationModel::PackageVersion const& minVersion,
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            CreatePackageDependencyOptions const& options) const {
  void* result{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->CreateForSystem(
        *(void**)(&packageFamilyName), impl::bind_in(minVersion),
        *(void**)(&options), &result));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)this;
    check_hresult(_winrt_abi_type->CreateForSystem(
        *(void**)(&packageFamilyName), impl::bind_in(minVersion),
        *(void**)(&options), &result));
  }
  return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
      PackageDependency{result, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<
    D>::GenerationId() const {
  uint32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyStatics>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyStatics,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_GenerationId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics>**)this;
    check_hresult(_winrt_abi_type->get_GenerationId(&value));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics2<
    D>::PackageGraphRevisionId() const {
  uint32_t value{};
  if constexpr (!std::is_same_v<
                    D, winrt::Microsoft::Windows::ApplicationModel::
                           DynamicDependency::IPackageDependencyStatics2>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            IPackageDependencyStatics2,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics2>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_PackageGraphRevisionId(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    IPackageDependencyStatics2>**)this;
    check_hresult(_winrt_abi_type->get_PackageGraphRevisionId(&value));
  }
  return value;
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::IAddPackageDependencyOptions>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::IAddPackageDependencyOptions> {
  int32_t __stdcall get_Rank(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().Rank());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Rank(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Rank(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PrependIfRankCollision(bool* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().PrependIfRankCollision());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_PrependIfRankCollision(bool value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().PrependIfRankCollision(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::ICreatePackageDependencyOptions>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::ICreatePackageDependencyOptions> {
  int32_t __stdcall get_Architectures(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            PackageDependencyProcessorArchitectures>(
        this->shim().Architectures());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_Architectures(uint32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Architectures(
        *reinterpret_cast<
            winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                PackageDependencyProcessorArchitectures const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_VerifyDependencyResolution(bool* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<bool>(this->shim().VerifyDependencyResolution());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_VerifyDependencyResolution(bool value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().VerifyDependencyResolution(value);
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LifetimeArtifactKind(int32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
            PackageDependencyLifetimeArtifactKind>(
        this->shim().LifetimeArtifactKind());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_LifetimeArtifactKind(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().LifetimeArtifactKind(
        *reinterpret_cast<
            winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                PackageDependencyLifetimeArtifactKind const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_LifetimeArtifact(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().LifetimeArtifact());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_LifetimeArtifact(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().LifetimeArtifact(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::IPackageDependency>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::IPackageDependency> {
  int32_t __stdcall get_Id(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Id());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Delete() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Delete();
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Add(void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              DynamicDependency::PackageDependencyContext>(
        this->shim().Add());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Add2(void* options, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              DynamicDependency::PackageDependencyContext>(
        this->shim().Add(
            *reinterpret_cast<
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    AddPackageDependencyOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::IPackageDependencyContext>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::IPackageDependencyContext> {
  int32_t __stdcall get_ContextId(
      struct
      struct_Microsoft_Windows_ApplicationModel_DynamicDependency_PackageDependencyContextId*
          value) noexcept final try {
    zero_abi<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                 PackageDependencyContextId>(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                             DynamicDependency::PackageDependencyContextId>(
        this->shim().ContextId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageDependencyId(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageDependencyId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_PackageFullName(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().PackageFullName());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Remove() noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().Remove();
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::IPackageDependencyContextFactory>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::IPackageDependencyContextFactory> {
  int32_t __stdcall CreateInstance(
      struct
      struct_Microsoft_Windows_ApplicationModel_DynamicDependency_PackageDependencyContextId
          contextId,
      void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                             DynamicDependency::PackageDependencyContext>(
        this->shim().CreateInstance(
            *reinterpret_cast<
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    PackageDependencyContextId const*>(&contextId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::IPackageDependencyRankStatics>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::IPackageDependencyRankStatics> {
  int32_t __stdcall get_Default(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<int32_t>(this->shim().Default());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::IPackageDependencyStatics>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::IPackageDependencyStatics> {
  int32_t __stdcall GetFromId(void* id, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              DynamicDependency::PackageDependency>(
        this->shim().GetFromId(*reinterpret_cast<hstring const*>(&id)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall GetFromIdForSystem(void* id, void** result) noexcept final
      try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              DynamicDependency::PackageDependency>(
        this->shim().GetFromIdForSystem(
            *reinterpret_cast<hstring const*>(&id)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Create(
      void* packageFamilyName,
      struct struct_Windows_ApplicationModel_PackageVersion minVersion,
      void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              DynamicDependency::PackageDependency>(
        this->shim().Create(
            *reinterpret_cast<hstring const*>(&packageFamilyName),
            *reinterpret_cast<
                winrt::Windows::ApplicationModel::PackageVersion const*>(
                &minVersion)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall Create2(
      void* packageFamilyName,
      struct struct_Windows_ApplicationModel_PackageVersion minVersion,
      void* options, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              DynamicDependency::PackageDependency>(
        this->shim().Create(
            *reinterpret_cast<hstring const*>(&packageFamilyName),
            *reinterpret_cast<
                winrt::Windows::ApplicationModel::PackageVersion const*>(
                &minVersion),
            *reinterpret_cast<
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    CreatePackageDependencyOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall CreateForSystem(
      void* packageFamilyName,
      struct struct_Windows_ApplicationModel_PackageVersion minVersion,
      void* options, void** result) noexcept final try {
    clear_abi(result);
    typename D::abi_guard guard(this->shim());
    *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::
                              DynamicDependency::PackageDependency>(
        this->shim().CreateForSystem(
            *reinterpret_cast<hstring const*>(&packageFamilyName),
            *reinterpret_cast<
                winrt::Windows::ApplicationModel::PackageVersion const*>(
                &minVersion),
            *reinterpret_cast<
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                    CreatePackageDependencyOptions const*>(&options)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_GenerationId(uint32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().GenerationId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::ApplicationModel::
                      DynamicDependency::IPackageDependencyStatics2>
    : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::
                          DynamicDependency::IPackageDependencyStatics2> {
  int32_t __stdcall get_PackageGraphRevisionId(uint32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<uint32_t>(this->shim().PackageGraphRevisionId());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::ApplicationModel::
    DynamicDependency {
  constexpr auto operator|(
      PackageDependencyProcessorArchitectures const left,
      PackageDependencyProcessorArchitectures const right) noexcept {
    return static_cast<PackageDependencyProcessorArchitectures>(
        impl::to_underlying_type(left) | impl::to_underlying_type(right));
  }
  constexpr auto operator|=(
      PackageDependencyProcessorArchitectures& left,
      PackageDependencyProcessorArchitectures const right) noexcept {
    left = left | right;
    return left;
  }
  constexpr auto operator&(
      PackageDependencyProcessorArchitectures const left,
      PackageDependencyProcessorArchitectures const right) noexcept {
    return static_cast<PackageDependencyProcessorArchitectures>(
        impl::to_underlying_type(left) & impl::to_underlying_type(right));
  }
  constexpr auto operator&=(
      PackageDependencyProcessorArchitectures& left,
      PackageDependencyProcessorArchitectures const right) noexcept {
    left = left & right;
    return left;
  }
  constexpr auto operator~(
      PackageDependencyProcessorArchitectures const value) noexcept {
    return static_cast<PackageDependencyProcessorArchitectures>(
        ~impl::to_underlying_type(value));
  }
  constexpr auto operator^(
      PackageDependencyProcessorArchitectures const left,
      PackageDependencyProcessorArchitectures const right) noexcept {
    return static_cast<PackageDependencyProcessorArchitectures>(
        impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
  }
  constexpr auto operator^=(
      PackageDependencyProcessorArchitectures& left,
      PackageDependencyProcessorArchitectures const right) noexcept {
    left = left ^ right;
    return left;
  }
  inline AddPackageDependencyOptions::AddPackageDependencyOptions()
      : AddPackageDependencyOptions(
            impl::call_factory_cast<
                AddPackageDependencyOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                AddPackageDependencyOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f
                      .template ActivateInstance<AddPackageDependencyOptions>();
                })) {}
  inline CreatePackageDependencyOptions::CreatePackageDependencyOptions()
      : CreatePackageDependencyOptions(
            impl::call_factory_cast<
                CreatePackageDependencyOptions (*)(
                    winrt::Windows::Foundation::IActivationFactory const&),
                CreatePackageDependencyOptions>(
                [](winrt::Windows::Foundation::IActivationFactory const& f) {
                  return f.template ActivateInstance<
                      CreatePackageDependencyOptions>();
                })) {}
  inline auto PackageDependency::GetFromId(param::hstring const& id) {
    return impl::call_factory<PackageDependency, IPackageDependencyStatics>(
        [&](IPackageDependencyStatics const& f) { return f.GetFromId(id); });
  }
  inline auto PackageDependency::GetFromIdForSystem(param::hstring const& id) {
    return impl::call_factory<PackageDependency, IPackageDependencyStatics>(
        [&](IPackageDependencyStatics const& f) {
          return f.GetFromIdForSystem(id);
        });
  }
  inline auto PackageDependency::Create(
      param::hstring const& packageFamilyName,
      winrt::Windows::ApplicationModel::PackageVersion const& minVersion) {
    return impl::call_factory<PackageDependency, IPackageDependencyStatics>(
        [&](IPackageDependencyStatics const& f) {
          return f.Create(packageFamilyName, minVersion);
        });
  }
  inline auto PackageDependency::Create(
      param::hstring const& packageFamilyName,
      winrt::Windows::ApplicationModel::PackageVersion const& minVersion,
      winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
          CreatePackageDependencyOptions const& options) {
    return impl::call_factory<PackageDependency, IPackageDependencyStatics>(
        [&](IPackageDependencyStatics const& f) {
          return f.Create(packageFamilyName, minVersion, options);
        });
  }
  inline auto PackageDependency::CreateForSystem(
      param::hstring const& packageFamilyName,
      winrt::Windows::ApplicationModel::PackageVersion const& minVersion,
      winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
          CreatePackageDependencyOptions const& options) {
    return impl::call_factory<PackageDependency, IPackageDependencyStatics>(
        [&](IPackageDependencyStatics const& f) {
          return f.CreateForSystem(packageFamilyName, minVersion, options);
        });
  }
  inline auto PackageDependency::GenerationId() {
    return impl::call_factory_cast<
        uint32_t (*)(IPackageDependencyStatics const&), PackageDependency,
        IPackageDependencyStatics>(
        [](IPackageDependencyStatics const& f) { return f.GenerationId(); });
  }
  inline auto PackageDependency::PackageGraphRevisionId() {
    return impl::call_factory_cast<
        uint32_t (*)(IPackageDependencyStatics2 const&), PackageDependency,
        IPackageDependencyStatics2>([](IPackageDependencyStatics2 const& f) {
      return f.PackageGraphRevisionId();
    });
  }
  inline PackageDependencyContext::PackageDependencyContext(
      winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
          PackageDependencyContextId const& contextId)
      : PackageDependencyContext(
            impl::call_factory<PackageDependencyContext,
                               IPackageDependencyContextFactory>(
                [&](IPackageDependencyContextFactory const& f) {
                  return f.CreateInstance(contextId);
                })) {}
  inline auto PackageDependencyRank::Default() {
    return impl::call_factory_cast<
        int32_t (*)(IPackageDependencyRankStatics const&),
        PackageDependencyRank, IPackageDependencyRankStatics>(
        [](IPackageDependencyRankStatics const& f) { return f.Default(); });
  }
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                IAddPackageDependencyOptions> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                ICreatePackageDependencyOptions> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                IPackageDependency> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                IPackageDependencyContext> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                IPackageDependencyContextFactory> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                IPackageDependencyRankStatics> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                IPackageDependencyStatics> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                IPackageDependencyStatics2> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                AddPackageDependencyOptions> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                CreatePackageDependencyOptions> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                PackageDependency> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                PackageDependencyContext> : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::
                PackageDependencyRank> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
