// WARNING: Please don't edit this file. It was generated by C++/WinRT
// v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_Storage_Pickers_H
#define WINRT_Microsoft_Windows_Storage_Pickers_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"),
              "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.Storage.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Microsoft.Windows.Storage.Pickers.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
namespace winrt::impl {
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<D>::ViewMode()
    const {
  winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_ViewMode(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(
        _winrt_abi_type->get_ViewMode(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<D>::ViewMode(
    winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode const& value)
    const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ViewMode(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->put_ViewMode(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<
    D>::SuggestedStartLocation() const {
  winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SuggestedStartLocation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->get_SuggestedStartLocation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<D>::
    SuggestedStartLocation(
        winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId const&
            value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_SuggestedStartLocation(
        static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->put_SuggestedStartLocation(
        static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<
    D>::CommitButtonText() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CommitButtonText(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->get_CommitButtonText(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<
    D>::CommitButtonText(param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_CommitButtonText(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->put_CommitButtonText(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<
    D>::FileTypeFilter() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_FileTypeFilter(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->get_FileTypeFilter(&value));
  }
  return winrt::Windows::Foundation::Collections::IVector<hstring>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<
    D>::PickSingleFileAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->PickSingleFileAsync(&operation));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->PickSingleFileAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::Storage::Pickers::PickFileResult>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPicker<
    D>::PickMultipleFilesAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->PickMultipleFilesAsync(&operation));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileOpenPicker>**)this;
    check_hresult(_winrt_abi_type->PickMultipleFilesAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Windows::Foundation::Collections::IVectorView<
          winrt::Microsoft::Windows::Storage::Pickers::PickFileResult>>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileOpenPickerFactory<
    D>::CreateInstance(winrt::Microsoft::UI::WindowId const& windowId) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileOpenPickerFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPickerFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPickerFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(windowId), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileOpenPickerFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(windowId), &value));
  }
  return winrt::Microsoft::Windows::Storage::Pickers::FileOpenPicker{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::SuggestedStartLocation() const {
  winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SuggestedStartLocation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->get_SuggestedStartLocation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<D>::
    SuggestedStartLocation(
        winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId const&
            value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_SuggestedStartLocation(
        static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->put_SuggestedStartLocation(
        static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::CommitButtonText() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CommitButtonText(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->get_CommitButtonText(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::CommitButtonText(param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_CommitButtonText(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->put_CommitButtonText(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::FileTypeChoices() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_FileTypeChoices(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->get_FileTypeChoices(&value));
  }
  return winrt::Windows::Foundation::Collections::IMap<
      hstring, winrt::Windows::Foundation::Collections::IVector<hstring>>{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::DefaultFileExtension() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_DefaultFileExtension(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->get_DefaultFileExtension(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::DefaultFileExtension(param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_DefaultFileExtension(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->put_DefaultFileExtension(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::SuggestedFileName() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SuggestedFileName(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->get_SuggestedFileName(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::SuggestedFileName(param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_SuggestedFileName(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->put_SuggestedFileName(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::SuggestedFolder() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SuggestedFolder(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->get_SuggestedFolder(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::SuggestedFolder(param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_SuggestedFolder(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->put_SuggestedFolder(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePicker<
    D>::PickSaveFileAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->PickSaveFileAsync(&operation));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IFileSavePicker>**)this;
    check_hresult(_winrt_abi_type->PickSaveFileAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::Storage::Pickers::PickFileResult>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFileSavePickerFactory<
    D>::CreateInstance(winrt::Microsoft::UI::WindowId const& windowId) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFileSavePickerFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFileSavePickerFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePickerFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(windowId), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFileSavePickerFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(windowId), &value));
  }
  return winrt::Microsoft::Windows::Storage::Pickers::FileSavePicker{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPicker<D>::ViewMode()
    const {
  winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPicker>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->get_ViewMode(reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>**)this;
    check_hresult(
        _winrt_abi_type->get_ViewMode(reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPicker<D>::ViewMode(
    winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode const& value)
    const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_ViewMode(static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>**)this;
    check_hresult(_winrt_abi_type->put_ViewMode(static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPicker<
    D>::SuggestedStartLocation() const {
  winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_SuggestedStartLocation(
        reinterpret_cast<int32_t*>(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>**)this;
    check_hresult(_winrt_abi_type->get_SuggestedStartLocation(
        reinterpret_cast<int32_t*>(&value)));
  }
  return value;
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPicker<D>::
    SuggestedStartLocation(
        winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId const&
            value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_SuggestedStartLocation(
        static_cast<int32_t>(value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>**)this;
    check_hresult(_winrt_abi_type->put_SuggestedStartLocation(
        static_cast<int32_t>(value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPicker<
    D>::CommitButtonText() const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_CommitButtonText(&value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>**)this;
    check_hresult(_winrt_abi_type->get_CommitButtonText(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPicker<
    D>::CommitButtonText(param::hstring const& value) const {
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->put_CommitButtonText(*(void**)(&value)));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>**)this;
    check_hresult(_winrt_abi_type->put_CommitButtonText(*(void**)(&value)));
  }
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPicker<
    D>::PickSingleFolderAsync() const {
  void* operation{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPicker>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPicker>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->PickSingleFolderAsync(&operation));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<
            winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>**)this;
    check_hresult(_winrt_abi_type->PickSingleFolderAsync(&operation));
  }
  return winrt::Windows::Foundation::IAsyncOperation<
      winrt::Microsoft::Windows::Storage::Pickers::PickFolderResult>{
      operation, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IFolderPickerFactory<
    D>::CreateInstance(winrt::Microsoft::UI::WindowId const& windowId) const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IFolderPickerFactory>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IFolderPickerFactory,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPickerFactory>**)&_winrt_casted_result;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(windowId), &value));
  } else {
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IFolderPickerFactory>**)this;
    check_hresult(
        _winrt_abi_type->CreateInstance(impl::bind_in(windowId), &value));
  }
  return winrt::Microsoft::Windows::Storage::Pickers::FolderPicker{
      value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IPickFileResult<D>::Path()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IPickFileResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IPickFileResult, D const*>(
        static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IPickFileResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Path(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IPickFileResult>**)this;
    check_hresult(_winrt_abi_type->get_Path(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
template <typename D>
auto consume_Microsoft_Windows_Storage_Pickers_IPickFolderResult<D>::Path()
    const {
  void* value{};
  if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::Storage::Pickers::
                                       IPickFolderResult>) {
    winrt::hresult _winrt_cast_result_code;
    auto const _winrt_casted_result = impl::try_as_with_reason<
        winrt::Microsoft::Windows::Storage::Pickers::IPickFolderResult,
        D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
    check_hresult(_winrt_cast_result_code);
    auto const _winrt_abi_type =
        *(abi_t<winrt::Microsoft::Windows::Storage::Pickers::
                    IPickFolderResult>**)&_winrt_casted_result;
    check_hresult(_winrt_abi_type->get_Path(&value));
  } else {
    auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::Storage::
                                             Pickers::IPickFolderResult>**)this;
    check_hresult(_winrt_abi_type->get_Path(&value));
  }
  return hstring{value, take_ownership_from_abi};
}
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker>
    : produce_base<
          D, winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker> {
  int32_t __stdcall get_ViewMode(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode>(
        this->shim().ViewMode());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ViewMode(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ViewMode(
        *reinterpret_cast<
            winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SuggestedStartLocation(int32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId>(
        this->shim().SuggestedStartLocation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_SuggestedStartLocation(int32_t value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SuggestedStartLocation(
        *reinterpret_cast<winrt::Microsoft::Windows::Storage::Pickers::
                              PickerLocationId const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_CommitButtonText(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().CommitButtonText());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_CommitButtonText(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CommitButtonText(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_FileTypeFilter(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(
            this->shim().FileTypeFilter());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall PickSingleFileAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::Storage::Pickers::PickFileResult>>(
        this->shim().PickSingleFileAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall PickMultipleFilesAsync(void** operation) noexcept final
      try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Windows::Foundation::Collections::IVectorView<
            winrt::Microsoft::Windows::Storage::Pickers::PickFileResult>>>(
        this->shim().PickMultipleFilesAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPickerFactory>
    : produce_base<
          D,
          winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPickerFactory> {
  int32_t __stdcall CreateInstance(struct struct_Microsoft_UI_WindowId windowId,
                                   void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::Pickers::FileOpenPicker>(
        this->shim().CreateInstance(
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                &windowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker>
    : produce_base<
          D, winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker> {
  int32_t __stdcall get_SuggestedStartLocation(int32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId>(
        this->shim().SuggestedStartLocation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_SuggestedStartLocation(int32_t value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SuggestedStartLocation(
        *reinterpret_cast<winrt::Microsoft::Windows::Storage::Pickers::
                              PickerLocationId const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_CommitButtonText(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().CommitButtonText());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_CommitButtonText(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CommitButtonText(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_FileTypeChoices(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<winrt::Windows::Foundation::Collections::IMap<
        hstring, winrt::Windows::Foundation::Collections::IVector<hstring>>>(
        this->shim().FileTypeChoices());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_DefaultFileExtension(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().DefaultFileExtension());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_DefaultFileExtension(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().DefaultFileExtension(
        *reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SuggestedFileName(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().SuggestedFileName());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_SuggestedFileName(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SuggestedFileName(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SuggestedFolder(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().SuggestedFolder());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_SuggestedFolder(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().SuggestedFolder(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall PickSaveFileAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::Storage::Pickers::PickFileResult>>(
        this->shim().PickSaveFileAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Storage::Pickers::IFileSavePickerFactory>
    : produce_base<
          D,
          winrt::Microsoft::Windows::Storage::Pickers::IFileSavePickerFactory> {
  int32_t __stdcall CreateInstance(struct struct_Microsoft_UI_WindowId windowId,
                                   void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::Pickers::FileSavePicker>(
        this->shim().CreateInstance(
            *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                &windowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>
    : produce_base<D,
                   winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker> {
  int32_t __stdcall get_ViewMode(int32_t* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode>(
        this->shim().ViewMode());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_ViewMode(int32_t value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().ViewMode(
        *reinterpret_cast<
            winrt::Microsoft::Windows::Storage::Pickers::PickerViewMode const*>(
            &value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_SuggestedStartLocation(int32_t* value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    *value = detach_from<
        winrt::Microsoft::Windows::Storage::Pickers::PickerLocationId>(
        this->shim().SuggestedStartLocation());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_SuggestedStartLocation(int32_t value) noexcept final
      try {
    typename D::abi_guard guard(this->shim());
    this->shim().SuggestedStartLocation(
        *reinterpret_cast<winrt::Microsoft::Windows::Storage::Pickers::
                              PickerLocationId const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall get_CommitButtonText(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().CommitButtonText());
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall put_CommitButtonText(void* value) noexcept final try {
    typename D::abi_guard guard(this->shim());
    this->shim().CommitButtonText(*reinterpret_cast<hstring const*>(&value));
    return 0;
  } catch (...) {
    return to_hresult();
  }
  int32_t __stdcall PickSingleFolderAsync(void** operation) noexcept final try {
    clear_abi(operation);
    typename D::abi_guard guard(this->shim());
    *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<
        winrt::Microsoft::Windows::Storage::Pickers::PickFolderResult>>(
        this->shim().PickSingleFolderAsync());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<
    D, winrt::Microsoft::Windows::Storage::Pickers::IFolderPickerFactory>
    : produce_base<
          D,
          winrt::Microsoft::Windows::Storage::Pickers::IFolderPickerFactory> {
  int32_t __stdcall CreateInstance(struct struct_Microsoft_UI_WindowId windowId,
                                   void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value =
        detach_from<winrt::Microsoft::Windows::Storage::Pickers::FolderPicker>(
            this->shim().CreateInstance(
                *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(
                    &windowId)));
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D, winrt::Microsoft::Windows::Storage::Pickers::IPickFileResult>
    : produce_base<
          D, winrt::Microsoft::Windows::Storage::Pickers::IPickFileResult> {
  int32_t __stdcall get_Path(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Path());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
#ifndef WINRT_LEAN_AND_MEAN
template <typename D>
struct produce<D,
               winrt::Microsoft::Windows::Storage::Pickers::IPickFolderResult>
    : produce_base<
          D, winrt::Microsoft::Windows::Storage::Pickers::IPickFolderResult> {
  int32_t __stdcall get_Path(void** value) noexcept final try {
    clear_abi(value);
    typename D::abi_guard guard(this->shim());
    *value = detach_from<hstring>(this->shim().Path());
    return 0;
  } catch (...) {
    return to_hresult();
  }
};
#endif
}  // namespace winrt::impl
WINRT_EXPORT namespace winrt::Microsoft::Windows::Storage::Pickers {
  inline FileOpenPicker::FileOpenPicker(
      winrt::Microsoft::UI::WindowId const& windowId)
      : FileOpenPicker(
            impl::call_factory<FileOpenPicker, IFileOpenPickerFactory>(
                [&](IFileOpenPickerFactory const& f) {
                  return f.CreateInstance(windowId);
                })) {}
  inline FileSavePicker::FileSavePicker(
      winrt::Microsoft::UI::WindowId const& windowId)
      : FileSavePicker(
            impl::call_factory<FileSavePicker, IFileSavePickerFactory>(
                [&](IFileSavePickerFactory const& f) {
                  return f.CreateInstance(windowId);
                })) {}
  inline FolderPicker::FolderPicker(
      winrt::Microsoft::UI::WindowId const& windowId)
      : FolderPicker(impl::call_factory<FolderPicker, IFolderPickerFactory>(
            [&](IFolderPickerFactory const& f) {
              return f.CreateInstance(windowId);
            })) {}
}
namespace std {
#ifndef WINRT_LEAN_AND_MEAN
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPicker>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IFileOpenPickerFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IFileSavePicker>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IFileSavePickerFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IFolderPicker>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IFolderPickerFactory>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IPickFileResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::IPickFolderResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::FileOpenPicker>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::FileSavePicker>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::FolderPicker>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::PickFileResult>
    : winrt::impl::hash_base {};
template <>
struct hash<winrt::Microsoft::Windows::Storage::Pickers::PickFolderResult>
    : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}  // namespace std
#endif
