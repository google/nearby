
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__avahi_entrygroup_client_glue_h__proxy__H__
#define __sdbuscpp__avahi_entrygroup_client_glue_h__proxy__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace freedesktop {
namespace Avahi {

class EntryGroup_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.Avahi.EntryGroup";

protected:
    EntryGroup_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
        proxy_.uponSignal("StateChanged").onInterface(INTERFACE_NAME).call([this](const int32_t& state, const std::string& error){ this->onStateChanged(state, error); });
    }

    ~EntryGroup_proxy() = default;

    virtual void onStateChanged(const int32_t& state, const std::string& error) = 0;

public:
    void Free()
    {
        proxy_.callMethod("Free").onInterface(INTERFACE_NAME);
    }

    void Commit()
    {
        proxy_.callMethod("Commit").onInterface(INTERFACE_NAME);
    }

    void Reset()
    {
        proxy_.callMethod("Reset").onInterface(INTERFACE_NAME);
    }

    int32_t GetState()
    {
        int32_t result;
        proxy_.callMethod("GetState").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    bool IsEmpty()
    {
        bool result;
        proxy_.callMethod("IsEmpty").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void AddService(const int32_t& interface, const int32_t& protocol, const uint32_t& flags, const std::string& name, const std::string& type, const std::string& domain, const std::string& host, const uint16_t& port, const std::vector<std::vector<uint8_t>>& txt)
    {
        proxy_.callMethod("AddService").onInterface(INTERFACE_NAME).withArguments(interface, protocol, flags, name, type, domain, host, port, txt);
    }

    void AddServiceSubtype(const int32_t& interface, const int32_t& protocol, const uint32_t& flags, const std::string& name, const std::string& type, const std::string& domain, const std::string& subtype)
    {
        proxy_.callMethod("AddServiceSubtype").onInterface(INTERFACE_NAME).withArguments(interface, protocol, flags, name, type, domain, subtype);
    }

    void UpdateServiceTxt(const int32_t& interface, const int32_t& protocol, const uint32_t& flags, const std::string& name, const std::string& type, const std::string& domain, const std::vector<std::vector<uint8_t>>& txt)
    {
        proxy_.callMethod("UpdateServiceTxt").onInterface(INTERFACE_NAME).withArguments(interface, protocol, flags, name, type, domain, txt);
    }

    void AddAddress(const int32_t& interface, const int32_t& protocol, const uint32_t& flags, const std::string& name, const std::string& address)
    {
        proxy_.callMethod("AddAddress").onInterface(INTERFACE_NAME).withArguments(interface, protocol, flags, name, address);
    }

    void AddRecord(const int32_t& interface, const int32_t& protocol, const uint32_t& flags, const std::string& name, const uint16_t& clazz, const uint16_t& type, const uint32_t& ttl, const std::vector<uint8_t>& rdata)
    {
        proxy_.callMethod("AddRecord").onInterface(INTERFACE_NAME).withArguments(interface, protocol, flags, name, clazz, type, ttl, rdata);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

#endif
