// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: proto/securegcm.proto
// Protobuf C++ Version: 6.33.3

#include "proto/securegcm.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace securegcm {

inline constexpr Tickle::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        expiry_time_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR Tickle::Tickle(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(Tickle_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TickleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TickleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TickleDefaultTypeInternal() {}
  union {
    Tickle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TickleDefaultTypeInternal _Tickle_default_instance_;

inline constexpr LoginNotificationInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        email_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        host_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        source_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        event_type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        creation_time_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR LoginNotificationInfo::LoginNotificationInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(LoginNotificationInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LoginNotificationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginNotificationInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginNotificationInfoDefaultTypeInternal() {}
  union {
    LoginNotificationInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginNotificationInfoDefaultTypeInternal _LoginNotificationInfo_default_instance_;

inline constexpr GcmMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        type_{static_cast< ::securegcm::Type >(0)},
        version_{0} {}

template <typename>
PROTOBUF_CONSTEXPR GcmMetadata::GcmMetadata(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(GcmMetadata_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GcmMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GcmMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GcmMetadataDefaultTypeInternal() {}
  union {
    GcmMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GcmMetadataDefaultTypeInternal _GcmMetadata_default_instance_;

inline constexpr GcmDeviceInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        enabled_software_features_{},
        user_public_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_model_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        locale_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        key_handle_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_os_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_os_release_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_os_codename_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_software_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_software_package_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        long_device_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_manufacturer_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_master_key_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        apn_registration_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        bluetooth_mac_address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        android_device_id_{::uint64_t{0u}},
        counter_{::int64_t{0}},
        device_os_version_code_{::int64_t{0}},
        device_software_version_code_{::int64_t{0}},
        device_display_diagonal_mils_{0},
        device_authzen_version_{0},
        bluetooth_radio_enabled_{false},
        mobile_data_supported_{false},
        arc_plus_plus_{false},
        notification_enabled_{true},
        supported_software_features_{},
        gcm_registration_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        enrollment_session_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        oauth_token_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        using_secure_screenlock_{false},
        auto_unlock_screenlock_supported_{false},
        auto_unlock_screenlock_enabled_{false},
        bluetooth_radio_supported_{false},
        tethering_supported_{false},
        ble_radio_supported_{false},
        pixel_experience_{false},
        is_screenlock_state_flaky_{false},
        device_type_{static_cast< ::securegcm::DeviceType >(1)} {}

template <typename>
PROTOBUF_CONSTEXPR GcmDeviceInfo::GcmDeviceInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(GcmDeviceInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GcmDeviceInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GcmDeviceInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GcmDeviceInfoDefaultTypeInternal() {}
  union {
    GcmDeviceInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GcmDeviceInfoDefaultTypeInternal _GcmDeviceInfo_default_instance_;
}  // namespace securegcm
namespace securegcm {
PROTOBUF_CONSTINIT const uint32_t AppleDeviceDiagonalMils_internal_data_[] = {
    69536u, 65536u, 7900u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    AppleDeviceDiagonalMils_strings[2] = {};

static const char AppleDeviceDiagonalMils_names[] = {
    "APPLE_PAD"
    "APPLE_PHONE"
};

static const ::google::protobuf::internal::EnumEntry AppleDeviceDiagonalMils_entries[] = {
    {{&AppleDeviceDiagonalMils_names[0], 9}, 7900},
    {{&AppleDeviceDiagonalMils_names[9], 11}, 4000},
};

static const int AppleDeviceDiagonalMils_entries_by_number[] = {
    1,  // 4000 -> APPLE_PHONE
    0,  // 7900 -> APPLE_PAD
};

const ::std::string& AppleDeviceDiagonalMils_Name(AppleDeviceDiagonalMils value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      AppleDeviceDiagonalMils_entries, AppleDeviceDiagonalMils_entries_by_number, 2,
      AppleDeviceDiagonalMils_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(AppleDeviceDiagonalMils_entries,
                                  AppleDeviceDiagonalMils_entries_by_number,
                                  2, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : AppleDeviceDiagonalMils_strings[idx].get();
}

bool AppleDeviceDiagonalMils_Parse(::absl::string_view name, AppleDeviceDiagonalMils* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      AppleDeviceDiagonalMils_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<AppleDeviceDiagonalMils>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t DeviceType_internal_data_[] = {
    393216u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    DeviceType_strings[6] = {};

static const char DeviceType_names[] = {
    "ANDROID"
    "BROWSER"
    "CHROME"
    "IOS"
    "OSX"
    "UNKNOWN"
};

static const ::google::protobuf::internal::EnumEntry DeviceType_entries[] = {
    {{&DeviceType_names[0], 7}, 1},
    {{&DeviceType_names[7], 7}, 4},
    {{&DeviceType_names[14], 6}, 2},
    {{&DeviceType_names[20], 3}, 3},
    {{&DeviceType_names[23], 3}, 5},
    {{&DeviceType_names[26], 7}, 0},
};

static const int DeviceType_entries_by_number[] = {
    5,  // 0 -> UNKNOWN
    0,  // 1 -> ANDROID
    2,  // 2 -> CHROME
    3,  // 3 -> IOS
    1,  // 4 -> BROWSER
    4,  // 5 -> OSX
};

const ::std::string& DeviceType_Name(DeviceType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      DeviceType_entries, DeviceType_entries_by_number, 6,
      DeviceType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(DeviceType_entries,
                                  DeviceType_entries_by_number,
                                  6, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : DeviceType_strings[idx].get();
}

bool DeviceType_Parse(::absl::string_view name, DeviceType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      DeviceType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DeviceType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t SoftwareFeature_internal_data_[] = {
    589824u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    SoftwareFeature_strings[9] = {};

static const char SoftwareFeature_names[] = {
    "BETTER_TOGETHER_CLIENT"
    "BETTER_TOGETHER_HOST"
    "EASY_UNLOCK_CLIENT"
    "EASY_UNLOCK_HOST"
    "MAGIC_TETHER_CLIENT"
    "MAGIC_TETHER_HOST"
    "SMS_CONNECT_CLIENT"
    "SMS_CONNECT_HOST"
    "UNKNOWN_FEATURE"
};

static const ::google::protobuf::internal::EnumEntry SoftwareFeature_entries[] = {
    {{&SoftwareFeature_names[0], 22}, 2},
    {{&SoftwareFeature_names[22], 20}, 1},
    {{&SoftwareFeature_names[42], 18}, 4},
    {{&SoftwareFeature_names[60], 16}, 3},
    {{&SoftwareFeature_names[76], 19}, 6},
    {{&SoftwareFeature_names[95], 17}, 5},
    {{&SoftwareFeature_names[112], 18}, 8},
    {{&SoftwareFeature_names[130], 16}, 7},
    {{&SoftwareFeature_names[146], 15}, 0},
};

static const int SoftwareFeature_entries_by_number[] = {
    8,  // 0 -> UNKNOWN_FEATURE
    1,  // 1 -> BETTER_TOGETHER_HOST
    0,  // 2 -> BETTER_TOGETHER_CLIENT
    3,  // 3 -> EASY_UNLOCK_HOST
    2,  // 4 -> EASY_UNLOCK_CLIENT
    5,  // 5 -> MAGIC_TETHER_HOST
    4,  // 6 -> MAGIC_TETHER_CLIENT
    7,  // 7 -> SMS_CONNECT_HOST
    6,  // 8 -> SMS_CONNECT_CLIENT
};

const ::std::string& SoftwareFeature_Name(SoftwareFeature value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      SoftwareFeature_entries, SoftwareFeature_entries_by_number, 9,
      SoftwareFeature_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(SoftwareFeature_entries,
                                  SoftwareFeature_entries_by_number,
                                  9, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : SoftwareFeature_strings[idx].get();
}

bool SoftwareFeature_Parse(::absl::string_view name, SoftwareFeature* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      SoftwareFeature_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<SoftwareFeature>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t InvocationReason_internal_data_[] = {
    1048576u, 0u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    InvocationReason_strings[16] = {};

static const char InvocationReason_names[] = {
    "REASON_ADDRESS_CHANGE"
    "REASON_CHANGED_ACCOUNT"
    "REASON_CUSTOM_KEY_INVALIDATION"
    "REASON_EXPIRATION"
    "REASON_FAILURE_RECOVERY"
    "REASON_FAST_PERIODIC"
    "REASON_FEATURE_TOGGLED"
    "REASON_INITIALIZATION"
    "REASON_MANUAL"
    "REASON_NEW_ACCOUNT"
    "REASON_PERIODIC"
    "REASON_PROXIMITY_PERIODIC"
    "REASON_SERVER_INITIATED"
    "REASON_SLOW_PERIODIC"
    "REASON_SOFTWARE_UPDATE"
    "REASON_UNKNOWN"
};

static const ::google::protobuf::internal::EnumEntry InvocationReason_entries[] = {
    {{&InvocationReason_names[0], 21}, 11},
    {{&InvocationReason_names[21], 22}, 8},
    {{&InvocationReason_names[43], 30}, 14},
    {{&InvocationReason_names[73], 17}, 5},
    {{&InvocationReason_names[90], 23}, 6},
    {{&InvocationReason_names[113], 20}, 4},
    {{&InvocationReason_names[133], 22}, 9},
    {{&InvocationReason_names[155], 21}, 1},
    {{&InvocationReason_names[176], 13}, 13},
    {{&InvocationReason_names[189], 18}, 7},
    {{&InvocationReason_names[207], 15}, 2},
    {{&InvocationReason_names[222], 25}, 15},
    {{&InvocationReason_names[247], 23}, 10},
    {{&InvocationReason_names[270], 20}, 3},
    {{&InvocationReason_names[290], 22}, 12},
    {{&InvocationReason_names[312], 14}, 0},
};

static const int InvocationReason_entries_by_number[] = {
    15,  // 0 -> REASON_UNKNOWN
    7,  // 1 -> REASON_INITIALIZATION
    10,  // 2 -> REASON_PERIODIC
    13,  // 3 -> REASON_SLOW_PERIODIC
    5,  // 4 -> REASON_FAST_PERIODIC
    3,  // 5 -> REASON_EXPIRATION
    4,  // 6 -> REASON_FAILURE_RECOVERY
    9,  // 7 -> REASON_NEW_ACCOUNT
    1,  // 8 -> REASON_CHANGED_ACCOUNT
    6,  // 9 -> REASON_FEATURE_TOGGLED
    12,  // 10 -> REASON_SERVER_INITIATED
    0,  // 11 -> REASON_ADDRESS_CHANGE
    14,  // 12 -> REASON_SOFTWARE_UPDATE
    8,  // 13 -> REASON_MANUAL
    2,  // 14 -> REASON_CUSTOM_KEY_INVALIDATION
    11,  // 15 -> REASON_PROXIMITY_PERIODIC
};

const ::std::string& InvocationReason_Name(InvocationReason value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      InvocationReason_entries, InvocationReason_entries_by_number, 16,
      InvocationReason_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(InvocationReason_entries,
                                  InvocationReason_entries_by_number,
                                  16, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : InvocationReason_strings[idx].get();
}

bool InvocationReason_Parse(::absl::string_view name, InvocationReason* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      InvocationReason_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<InvocationReason>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t Type_internal_data_[] = {
    589824u, 65568u, 126u, 101u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    Type_strings[16] = {};

static const char Type_names[] = {
    "DEVICE_INFO_UPDATE"
    "DEVICE_PROXIMITY_CALLBACK"
    "DEVICE_TO_DEVICE_MESSAGE"
    "DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD"
    "ENROLLMENT"
    "GCMV1_IDENTITY_ASSERTION"
    "LOGIN_NOTIFICATION"
    "PROXIMITYAUTH_PAIRING"
    "TICKLE"
    "TX_CANCEL_REQUEST"
    "TX_PING"
    "TX_REPLY"
    "TX_REQUEST"
    "TX_SYNC_REQUEST"
    "TX_SYNC_RESPONSE"
    "UNLOCK_KEY_SIGNED_CHALLENGE"
};

static const ::google::protobuf::internal::EnumEntry Type_entries[] = {
    {{&Type_names[0], 18}, 7},
    {{&Type_names[18], 25}, 14},
    {{&Type_names[43], 24}, 13},
    {{&Type_names[67], 40}, 12},
    {{&Type_names[107], 10}, 0},
    {{&Type_names[117], 24}, 11},
    {{&Type_names[141], 18}, 101},
    {{&Type_names[159], 21}, 10},
    {{&Type_names[180], 6}, 1},
    {{&Type_names[186], 17}, 8},
    {{&Type_names[203], 7}, 6},
    {{&Type_names[210], 8}, 3},
    {{&Type_names[218], 10}, 2},
    {{&Type_names[228], 15}, 4},
    {{&Type_names[243], 16}, 5},
    {{&Type_names[259], 27}, 15},
};

static const int Type_entries_by_number[] = {
    4,  // 0 -> ENROLLMENT
    8,  // 1 -> TICKLE
    12,  // 2 -> TX_REQUEST
    11,  // 3 -> TX_REPLY
    13,  // 4 -> TX_SYNC_REQUEST
    14,  // 5 -> TX_SYNC_RESPONSE
    10,  // 6 -> TX_PING
    0,  // 7 -> DEVICE_INFO_UPDATE
    9,  // 8 -> TX_CANCEL_REQUEST
    7,  // 10 -> PROXIMITYAUTH_PAIRING
    5,  // 11 -> GCMV1_IDENTITY_ASSERTION
    3,  // 12 -> DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD
    2,  // 13 -> DEVICE_TO_DEVICE_MESSAGE
    1,  // 14 -> DEVICE_PROXIMITY_CALLBACK
    15,  // 15 -> UNLOCK_KEY_SIGNED_CHALLENGE
    6,  // 101 -> LOGIN_NOTIFICATION
};

const ::std::string& Type_Name(Type value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      Type_entries, Type_entries_by_number, 16,
      Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(Type_entries,
                                  Type_entries_by_number,
                                  16, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : Type_strings[idx].get();
}

bool Type_Parse(::absl::string_view name, Type* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Type_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<Type>(int_value);
  }
  return success;
}
// ===================================================================

class GcmDeviceInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GcmDeviceInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

GcmDeviceInfo::GcmDeviceInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, GcmDeviceInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:securegcm.GcmDeviceInfo)
}
PROTOBUF_NDEBUG_INLINE GcmDeviceInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::securegcm::GcmDeviceInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        enabled_software_features_{visibility, arena, from.enabled_software_features_},
        user_public_key_(arena, from.user_public_key_),
        device_model_(arena, from.device_model_),
        locale_(arena, from.locale_),
        key_handle_(arena, from.key_handle_),
        device_os_version_(arena, from.device_os_version_),
        device_os_release_(arena, from.device_os_release_),
        device_os_codename_(arena, from.device_os_codename_),
        device_software_version_(arena, from.device_software_version_),
        device_software_package_(arena, from.device_software_package_),
        long_device_id_(arena, from.long_device_id_),
        device_manufacturer_(arena, from.device_manufacturer_),
        device_master_key_hash_(arena, from.device_master_key_hash_),
        apn_registration_id_(arena, from.apn_registration_id_),
        bluetooth_mac_address_(arena, from.bluetooth_mac_address_),
        supported_software_features_{visibility, arena, from.supported_software_features_},
        gcm_registration_id_(arena, from.gcm_registration_id_),
        enrollment_session_id_(arena, from.enrollment_session_id_),
        oauth_token_(arena, from.oauth_token_) {}

GcmDeviceInfo::GcmDeviceInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GcmDeviceInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, GcmDeviceInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GcmDeviceInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, android_device_id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, android_device_id_),
           offsetof(Impl_, notification_enabled_) -
               offsetof(Impl_, android_device_id_) +
               sizeof(Impl_::notification_enabled_));
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, using_secure_screenlock_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, using_secure_screenlock_),
           offsetof(Impl_, device_type_) -
               offsetof(Impl_, using_secure_screenlock_) +
               sizeof(Impl_::device_type_));

  // @@protoc_insertion_point(copy_constructor:securegcm.GcmDeviceInfo)
}
PROTOBUF_NDEBUG_INLINE GcmDeviceInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        enabled_software_features_{visibility, arena},
        user_public_key_(arena),
        device_model_(arena),
        locale_(arena),
        key_handle_(arena),
        device_os_version_(arena),
        device_os_release_(arena),
        device_os_codename_(arena),
        device_software_version_(arena),
        device_software_package_(arena),
        long_device_id_(arena),
        device_manufacturer_(arena),
        device_master_key_hash_(arena),
        apn_registration_id_(arena),
        bluetooth_mac_address_(arena),
        notification_enabled_{true},
        supported_software_features_{visibility, arena},
        gcm_registration_id_(arena),
        enrollment_session_id_(arena),
        oauth_token_(arena),
        device_type_{static_cast< ::securegcm::DeviceType >(1)} {}

inline void GcmDeviceInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, android_device_id_),
           0,
           offsetof(Impl_, arc_plus_plus_) -
               offsetof(Impl_, android_device_id_) +
               sizeof(Impl_::arc_plus_plus_));
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, using_secure_screenlock_),
           0,
           offsetof(Impl_, is_screenlock_state_flaky_) -
               offsetof(Impl_, using_secure_screenlock_) +
               sizeof(Impl_::is_screenlock_state_flaky_));
}
GcmDeviceInfo::~GcmDeviceInfo() {
  // @@protoc_insertion_point(destructor:securegcm.GcmDeviceInfo)
  SharedDtor(*this);
}
inline void GcmDeviceInfo::SharedDtor(MessageLite& self) {
  GcmDeviceInfo& this_ = static_cast<GcmDeviceInfo&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.user_public_key_.Destroy();
  this_._impl_.device_model_.Destroy();
  this_._impl_.locale_.Destroy();
  this_._impl_.key_handle_.Destroy();
  this_._impl_.device_os_version_.Destroy();
  this_._impl_.device_os_release_.Destroy();
  this_._impl_.device_os_codename_.Destroy();
  this_._impl_.device_software_version_.Destroy();
  this_._impl_.device_software_package_.Destroy();
  this_._impl_.long_device_id_.Destroy();
  this_._impl_.device_manufacturer_.Destroy();
  this_._impl_.device_master_key_hash_.Destroy();
  this_._impl_.apn_registration_id_.Destroy();
  this_._impl_.bluetooth_mac_address_.Destroy();
  this_._impl_.gcm_registration_id_.Destroy();
  this_._impl_.enrollment_session_id_.Destroy();
  this_._impl_.oauth_token_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GcmDeviceInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GcmDeviceInfo(arena);
}
constexpr auto GcmDeviceInfo::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.supported_software_features_) +
          decltype(GcmDeviceInfo::_impl_.supported_software_features_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.enabled_software_features_) +
          decltype(GcmDeviceInfo::_impl_.enabled_software_features_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(GcmDeviceInfo), alignof(GcmDeviceInfo), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&GcmDeviceInfo::PlacementNew_,
                                 sizeof(GcmDeviceInfo),
                                 alignof(GcmDeviceInfo));
  }
}
constexpr auto GcmDeviceInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<24>{
      {
          &_GcmDeviceInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          GcmDeviceInfo::IsInitializedImpl,
          &GcmDeviceInfo::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<GcmDeviceInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GcmDeviceInfo::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<GcmDeviceInfo>(), &GcmDeviceInfo::ByteSizeLong,
              &GcmDeviceInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_._cached_size_),
          true,
      },
      "securegcm.GcmDeviceInfo",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<24> GcmDeviceInfo_class_data_ =
    GcmDeviceInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GcmDeviceInfo::GetClassData() const {
  return GcmDeviceInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 38, 3, 0, 27>
GcmDeviceInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_._has_bits_),
    0, // no _extensions_
    1001, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    794297910,  // skipmap
    offsetof(decltype(_table_), field_entries),
    38,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    GcmDeviceInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::securegcm::GcmDeviceInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional fixed64 android_device_id = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 15, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.android_device_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // required bytes user_public_key = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.user_public_key_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional string device_model = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 2, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_model_)}},
    // optional string locale = 8;
    {::_pbi::TcParser::FastBS1,
     {66, 3, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.locale_)}},
    // optional bytes key_handle = 9;
    {::_pbi::TcParser::FastBS1,
     {74, 4, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.key_handle_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 counter = 12 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {96, 16, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.counter_)}},
    // optional string device_os_version = 13;
    {::_pbi::TcParser::FastBS1,
     {106, 5, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_version_)}},
    // optional int64 device_os_version_code = 14;
    {::_pbi::TcParser::FastV64S1,
     {112, 17, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_version_code_)}},
    // optional string device_os_release = 15;
    {::_pbi::TcParser::FastBS1,
     {122, 6, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_release_)}},
    // optional string device_os_codename = 16;
    {::_pbi::TcParser::FastBS2,
     {386, 7, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_codename_)}},
    // optional string device_software_version = 17;
    {::_pbi::TcParser::FastBS2,
     {394, 8, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_software_version_)}},
    // optional int64 device_software_version_code = 18;
    {::_pbi::TcParser::FastV64S2,
     {400, 18, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_software_version_code_)}},
    // optional string device_software_package = 19;
    {::_pbi::TcParser::FastBS2,
     {410, 9, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_software_package_)}},
    // optional bool bluetooth_radio_enabled = 404 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {6560, 21, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.bluetooth_radio_enabled_)}},
    // optional bool mobile_data_supported = 405 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {6568, 22, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.mobile_data_supported_)}},
    // optional int32 device_display_diagonal_mils = 22;
    {::_pbi::TcParser::FastV32S2,
     {432, 19, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_display_diagonal_mils_)}},
    // optional bytes device_master_key_hash = 103;
    {::_pbi::TcParser::FastBS2,
     {1722, 12, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_master_key_hash_)}},
    // optional int32 device_authzen_version = 24;
    {::_pbi::TcParser::FastV32S2,
     {448, 20, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_authzen_version_)}},
    // optional bool arc_plus_plus = 409 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {6600, 23, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.arc_plus_plus_)}},
    // optional bytes apn_registration_id = 202;
    {::_pbi::TcParser::FastBS2,
     {3282, 13, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.apn_registration_id_)}},
    // optional bool notification_enabled = 203 [default = true];
    {::_pbi::TcParser::FastV8S2,
     {3288, 24, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.notification_enabled_)}},
    // repeated .securegcm.SoftwareFeature enabled_software_features = 412;
    {::_pbi::TcParser::FastEr0R2,
     {6624, 0, 8,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.enabled_software_features_)}},
    // optional bytes long_device_id = 29;
    {::_pbi::TcParser::FastBS2,
     {490, 10, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.long_device_id_)}},
    // optional string bluetooth_mac_address = 302;
    {::_pbi::TcParser::FastBS2,
     {4850, 14, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.bluetooth_mac_address_)}},
    // optional string device_manufacturer = 31;
    {::_pbi::TcParser::FastBS2,
     {506, 11, 0,
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_manufacturer_)}},
  }}, {{
    102, 0, 1,
    65532, 18,
    202, 0, 1,
    65532, 20,
    302, 0, 1,
    65534, 22,
    400, 0, 1,
    57344, 23,
    1000, 0, 1,
    65532, 36,
    65535, 65535
  }}, {{
    // optional fixed64 android_device_id = 1;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.android_device_id_), _Internal::kHasBitsOffset + 15, 0, (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // required bytes user_public_key = 4;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.user_public_key_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string device_model = 7;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_model_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string locale = 8;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.locale_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes key_handle = 9;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.key_handle_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 counter = 12 [default = 0];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.counter_), _Internal::kHasBitsOffset + 16, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional string device_os_version = 13;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_version_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 device_os_version_code = 14;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_version_code_), _Internal::kHasBitsOffset + 17, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional string device_os_release = 15;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_release_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string device_os_codename = 16;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_os_codename_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string device_software_version = 17;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_software_version_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 device_software_version_code = 18;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_software_version_code_), _Internal::kHasBitsOffset + 18, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional string device_software_package = 19;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_software_package_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 device_display_diagonal_mils = 22;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_display_diagonal_mils_), _Internal::kHasBitsOffset + 19, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 device_authzen_version = 24;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_authzen_version_), _Internal::kHasBitsOffset + 20, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bytes long_device_id = 29;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.long_device_id_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string device_manufacturer = 31;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_manufacturer_), _Internal::kHasBitsOffset + 11, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .securegcm.DeviceType device_type = 32 [default = ANDROID];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_type_), _Internal::kHasBitsOffset + 37, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bytes gcm_registration_id = 102;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.gcm_registration_id_), _Internal::kHasBitsOffset + 26, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes device_master_key_hash = 103;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_master_key_hash_), _Internal::kHasBitsOffset + 12, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes apn_registration_id = 202;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.apn_registration_id_), _Internal::kHasBitsOffset + 13, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool notification_enabled = 203 [default = true];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.notification_enabled_), _Internal::kHasBitsOffset + 24, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string bluetooth_mac_address = 302;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.bluetooth_mac_address_), _Internal::kHasBitsOffset + 14, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool using_secure_screenlock = 400 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.using_secure_screenlock_), _Internal::kHasBitsOffset + 29, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool auto_unlock_screenlock_supported = 401 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.auto_unlock_screenlock_supported_), _Internal::kHasBitsOffset + 30, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool auto_unlock_screenlock_enabled = 402 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.auto_unlock_screenlock_enabled_), _Internal::kHasBitsOffset + 31, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool bluetooth_radio_supported = 403 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.bluetooth_radio_supported_), _Internal::kHasBitsOffset + 32, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool bluetooth_radio_enabled = 404 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.bluetooth_radio_enabled_), _Internal::kHasBitsOffset + 21, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool mobile_data_supported = 405 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.mobile_data_supported_), _Internal::kHasBitsOffset + 22, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool tethering_supported = 406 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.tethering_supported_), _Internal::kHasBitsOffset + 33, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool ble_radio_supported = 407 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.ble_radio_supported_), _Internal::kHasBitsOffset + 34, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool pixel_experience = 408 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.pixel_experience_), _Internal::kHasBitsOffset + 35, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool arc_plus_plus = 409 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.arc_plus_plus_), _Internal::kHasBitsOffset + 23, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_screenlock_state_flaky = 410 [default = false];
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.is_screenlock_state_flaky_), _Internal::kHasBitsOffset + 36, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .securegcm.SoftwareFeature supported_software_features = 411;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.supported_software_features_), _Internal::kHasBitsOffset + 25, 1, (0 | ::_fl::kFcRepeated | ::_fl::kEnumRange)},
    // repeated .securegcm.SoftwareFeature enabled_software_features = 412;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.enabled_software_features_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kEnumRange)},
    // optional bytes enrollment_session_id = 1000;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.enrollment_session_id_), _Internal::kHasBitsOffset + 27, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string oauth_token = 1001;
    {PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.oauth_token_), _Internal::kHasBitsOffset + 28, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  {{
      {0, 5},
      {0, 8},
      {0, 8},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void GcmDeviceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:securegcm.GcmDeviceInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.enabled_software_features_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.user_public_key_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.device_model_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.locale_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.key_handle_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.device_os_version_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _impl_.device_os_release_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _impl_.device_os_codename_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00007f00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _impl_.device_software_version_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _impl_.device_software_package_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _impl_.long_device_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _impl_.device_manufacturer_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _impl_.device_master_key_hash_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      _impl_.apn_registration_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      _impl_.bluetooth_mac_address_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.android_device_id_ = ::uint64_t{0u};
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    ::memset(&_impl_.counter_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.arc_plus_plus_) -
        reinterpret_cast<char*>(&_impl_.counter_)) + sizeof(_impl_.arc_plus_plus_));
  }
  if (BatchCheckHasBit(cached_has_bits, 0x1f000000U)) {
    _impl_.notification_enabled_ = true;
    if (CheckHasBitForRepeated(cached_has_bits, 0x02000000U)) {
      _impl_.supported_software_features_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x04000000U)) {
      _impl_.gcm_registration_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x08000000U)) {
      _impl_.enrollment_session_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x10000000U)) {
      _impl_.oauth_token_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0xe0000000U)) {
    ::memset(&_impl_.using_secure_screenlock_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.auto_unlock_screenlock_enabled_) -
        reinterpret_cast<char*>(&_impl_.using_secure_screenlock_)) + sizeof(_impl_.auto_unlock_screenlock_enabled_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    ::memset(&_impl_.bluetooth_radio_supported_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_screenlock_state_flaky_) -
        reinterpret_cast<char*>(&_impl_.bluetooth_radio_supported_)) + sizeof(_impl_.is_screenlock_state_flaky_));
    _impl_.device_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GcmDeviceInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GcmDeviceInfo& this_ = static_cast<const GcmDeviceInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GcmDeviceInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GcmDeviceInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:securegcm.GcmDeviceInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional fixed64 android_device_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00008000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        1, this_._internal_android_device_id(), target);
  }

  // required bytes user_public_key = 4;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_user_public_key();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  // optional string device_model = 7;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_device_model();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional string locale = 8;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_locale();
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // optional bytes key_handle = 9;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    const ::std::string& _s = this_._internal_key_handle();
    target = stream->WriteBytesMaybeAliased(9, _s, target);
  }

  // optional int64 counter = 12 [default = 0];
  if (CheckHasBit(cached_has_bits, 0x00010000U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<12>(
            stream, this_._internal_counter(), target);
  }

  // optional string device_os_version = 13;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    const ::std::string& _s = this_._internal_device_os_version();
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // optional int64 device_os_version_code = 14;
  if (CheckHasBit(cached_has_bits, 0x00020000U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<14>(
            stream, this_._internal_device_os_version_code(), target);
  }

  // optional string device_os_release = 15;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    const ::std::string& _s = this_._internal_device_os_release();
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  // optional string device_os_codename = 16;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    const ::std::string& _s = this_._internal_device_os_codename();
    target = stream->WriteStringMaybeAliased(16, _s, target);
  }

  // optional string device_software_version = 17;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    const ::std::string& _s = this_._internal_device_software_version();
    target = stream->WriteStringMaybeAliased(17, _s, target);
  }

  // optional int64 device_software_version_code = 18;
  if (CheckHasBit(cached_has_bits, 0x00040000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        18, this_._internal_device_software_version_code(), target);
  }

  // optional string device_software_package = 19;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    const ::std::string& _s = this_._internal_device_software_package();
    target = stream->WriteStringMaybeAliased(19, _s, target);
  }

  // optional int32 device_display_diagonal_mils = 22;
  if (CheckHasBit(cached_has_bits, 0x00080000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this_._internal_device_display_diagonal_mils(), target);
  }

  // optional int32 device_authzen_version = 24;
  if (CheckHasBit(cached_has_bits, 0x00100000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this_._internal_device_authzen_version(), target);
  }

  // optional bytes long_device_id = 29;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    const ::std::string& _s = this_._internal_long_device_id();
    target = stream->WriteBytesMaybeAliased(29, _s, target);
  }

  // optional string device_manufacturer = 31;
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    const ::std::string& _s = this_._internal_device_manufacturer();
    target = stream->WriteStringMaybeAliased(31, _s, target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional .securegcm.DeviceType device_type = 32 [default = ANDROID];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        32, this_._internal_device_type(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes gcm_registration_id = 102;
  if (CheckHasBit(cached_has_bits, 0x04000000U)) {
    const ::std::string& _s = this_._internal_gcm_registration_id();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes device_master_key_hash = 103;
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    const ::std::string& _s = this_._internal_device_master_key_hash();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  // optional bytes apn_registration_id = 202;
  if (CheckHasBit(cached_has_bits, 0x00002000U)) {
    const ::std::string& _s = this_._internal_apn_registration_id();
    target = stream->WriteBytesMaybeAliased(202, _s, target);
  }

  // optional bool notification_enabled = 203 [default = true];
  if (CheckHasBit(cached_has_bits, 0x01000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        203, this_._internal_notification_enabled(), target);
  }

  // optional string bluetooth_mac_address = 302;
  if (CheckHasBit(cached_has_bits, 0x00004000U)) {
    const ::std::string& _s = this_._internal_bluetooth_mac_address();
    target = stream->WriteStringMaybeAliased(302, _s, target);
  }

  // optional bool using_secure_screenlock = 400 [default = false];
  if (CheckHasBit(cached_has_bits, 0x20000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        400, this_._internal_using_secure_screenlock(), target);
  }

  // optional bool auto_unlock_screenlock_supported = 401 [default = false];
  if (CheckHasBit(cached_has_bits, 0x40000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        401, this_._internal_auto_unlock_screenlock_supported(), target);
  }

  // optional bool auto_unlock_screenlock_enabled = 402 [default = false];
  if (CheckHasBit(cached_has_bits, 0x80000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        402, this_._internal_auto_unlock_screenlock_enabled(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional bool bluetooth_radio_supported = 403 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        403, this_._internal_bluetooth_radio_supported(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool bluetooth_radio_enabled = 404 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00200000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        404, this_._internal_bluetooth_radio_enabled(), target);
  }

  // optional bool mobile_data_supported = 405 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00400000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        405, this_._internal_mobile_data_supported(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional bool tethering_supported = 406 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        406, this_._internal_tethering_supported(), target);
  }

  // optional bool ble_radio_supported = 407 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        407, this_._internal_ble_radio_supported(), target);
  }

  // optional bool pixel_experience = 408 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        408, this_._internal_pixel_experience(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool arc_plus_plus = 409 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00800000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        409, this_._internal_arc_plus_plus(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional bool is_screenlock_state_flaky = 410 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        410, this_._internal_is_screenlock_state_flaky(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .securegcm.SoftwareFeature supported_software_features = 411;
  if (CheckHasBitForRepeated(cached_has_bits, 0x02000000U)) {
    for (int i = 0, n = this_._internal_supported_software_features_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          411, static_cast<::securegcm::SoftwareFeature>(this_._internal_supported_software_features().Get(i)),
          target);
    }
  }

  // repeated .securegcm.SoftwareFeature enabled_software_features = 412;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_enabled_software_features_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          412, static_cast<::securegcm::SoftwareFeature>(this_._internal_enabled_software_features().Get(i)),
          target);
    }
  }

  // optional bytes enrollment_session_id = 1000;
  if (CheckHasBit(cached_has_bits, 0x08000000U)) {
    const ::std::string& _s = this_._internal_enrollment_session_id();
    target = stream->WriteBytesMaybeAliased(1000, _s, target);
  }

  // optional string oauth_token = 1001;
  if (CheckHasBit(cached_has_bits, 0x10000000U)) {
    const ::std::string& _s = this_._internal_oauth_token();
    target = stream->WriteStringMaybeAliased(1001, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:securegcm.GcmDeviceInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GcmDeviceInfo::ByteSizeLong(const MessageLite& base) {
  const GcmDeviceInfo& this_ = static_cast<const GcmDeviceInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GcmDeviceInfo::ByteSizeLong() const {
  const GcmDeviceInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:securegcm.GcmDeviceInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00008000U & cached_has_bits) * 9;
  total_size += ::absl::popcount(0xe1e00000U & cached_has_bits) * 3;
   {
    // repeated .securegcm.SoftwareFeature enabled_software_features = 412;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size =
          ::_pbi::WireFormatLite::EnumSize(this_._internal_enabled_software_features());
      ::size_t tag_size = ::size_t{2} *
          ::_pbi::FromIntSize(this_._internal_enabled_software_features_size());
      total_size += data_size + tag_size;
    }
  }
   {
    // required bytes user_public_key = 4;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_user_public_key());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000fcU)) {
    // optional string device_model = 7;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_model());
    }
    // optional string locale = 8;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_locale());
    }
    // optional bytes key_handle = 9;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_key_handle());
    }
    // optional string device_os_version = 13;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_os_version());
    }
    // optional string device_os_release = 15;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_os_release());
    }
    // optional string device_os_codename = 16;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_os_codename());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00007f00U)) {
    // optional string device_software_version = 17;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_software_version());
    }
    // optional string device_software_package = 19;
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_software_package());
    }
    // optional bytes long_device_id = 29;
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_long_device_id());
    }
    // optional string device_manufacturer = 31;
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_device_manufacturer());
    }
    // optional bytes device_master_key_hash = 103;
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_device_master_key_hash());
    }
    // optional bytes apn_registration_id = 202;
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_apn_registration_id());
    }
    // optional string bluetooth_mac_address = 302;
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_bluetooth_mac_address());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x001f0000U)) {
    // optional int64 counter = 12 [default = 0];
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_counter());
    }
    // optional int64 device_os_version_code = 14;
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_device_os_version_code());
    }
    // optional int64 device_software_version_code = 18;
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                      this_._internal_device_software_version_code());
    }
    // optional int32 device_display_diagonal_mils = 22;
    if (CheckHasBit(cached_has_bits, 0x00080000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this_._internal_device_display_diagonal_mils());
    }
    // optional int32 device_authzen_version = 24;
    if (CheckHasBit(cached_has_bits, 0x00100000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this_._internal_device_authzen_version());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x1e000000U)) {
    // repeated .securegcm.SoftwareFeature supported_software_features = 411;
    if (CheckHasBitForRepeated(cached_has_bits, 0x02000000U)) {
      ::size_t data_size =
          ::_pbi::WireFormatLite::EnumSize(this_._internal_supported_software_features());
      ::size_t tag_size = ::size_t{2} *
          ::_pbi::FromIntSize(this_._internal_supported_software_features_size());
      total_size += data_size + tag_size;
    }
    // optional bytes gcm_registration_id = 102;
    if (CheckHasBit(cached_has_bits, 0x04000000U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_gcm_registration_id());
    }
    // optional bytes enrollment_session_id = 1000;
    if (CheckHasBit(cached_has_bits, 0x08000000U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_enrollment_session_id());
    }
    // optional string oauth_token = 1001;
    if (CheckHasBit(cached_has_bits, 0x10000000U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_oauth_token());
    }
  }
  cached_has_bits = this_._impl_._has_bits_[1];
  total_size += ::absl::popcount(0x0000001fU & cached_has_bits) * 3;
   {
    // optional .securegcm.DeviceType device_type = 32 [default = ANDROID];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_device_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void GcmDeviceInfo::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GcmDeviceInfo*>(&to_msg);
  auto& from = static_cast<const GcmDeviceInfo&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:securegcm.GcmDeviceInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_enabled_software_features()->MergeFrom(from._internal_enabled_software_features());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_user_public_key(from._internal_user_public_key());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_device_model(from._internal_device_model());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_locale(from._internal_locale());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_internal_set_key_handle(from._internal_key_handle());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_internal_set_device_os_version(from._internal_device_os_version());
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_internal_set_device_os_release(from._internal_device_os_release());
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_internal_set_device_os_codename(from._internal_device_os_codename());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_internal_set_device_software_version(from._internal_device_software_version());
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_internal_set_device_software_package(from._internal_device_software_package());
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_internal_set_long_device_id(from._internal_long_device_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _this->_internal_set_device_manufacturer(from._internal_device_manufacturer());
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_internal_set_device_master_key_hash(from._internal_device_master_key_hash());
    }
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      _this->_internal_set_apn_registration_id(from._internal_apn_registration_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      _this->_internal_set_bluetooth_mac_address(from._internal_bluetooth_mac_address());
    }
    if (CheckHasBit(cached_has_bits, 0x00008000U)) {
      _this->_impl_.android_device_id_ = from._impl_.android_device_id_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      _this->_impl_.counter_ = from._impl_.counter_;
    }
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      _this->_impl_.device_os_version_code_ = from._impl_.device_os_version_code_;
    }
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      _this->_impl_.device_software_version_code_ = from._impl_.device_software_version_code_;
    }
    if (CheckHasBit(cached_has_bits, 0x00080000U)) {
      _this->_impl_.device_display_diagonal_mils_ = from._impl_.device_display_diagonal_mils_;
    }
    if (CheckHasBit(cached_has_bits, 0x00100000U)) {
      _this->_impl_.device_authzen_version_ = from._impl_.device_authzen_version_;
    }
    if (CheckHasBit(cached_has_bits, 0x00200000U)) {
      _this->_impl_.bluetooth_radio_enabled_ = from._impl_.bluetooth_radio_enabled_;
    }
    if (CheckHasBit(cached_has_bits, 0x00400000U)) {
      _this->_impl_.mobile_data_supported_ = from._impl_.mobile_data_supported_;
    }
    if (CheckHasBit(cached_has_bits, 0x00800000U)) {
      _this->_impl_.arc_plus_plus_ = from._impl_.arc_plus_plus_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0xff000000U)) {
    if (CheckHasBit(cached_has_bits, 0x01000000U)) {
      _this->_impl_.notification_enabled_ = from._impl_.notification_enabled_;
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x02000000U)) {
      _this->_internal_mutable_supported_software_features()->MergeFrom(from._internal_supported_software_features());
    }
    if (CheckHasBit(cached_has_bits, 0x04000000U)) {
      _this->_internal_set_gcm_registration_id(from._internal_gcm_registration_id());
    }
    if (CheckHasBit(cached_has_bits, 0x08000000U)) {
      _this->_internal_set_enrollment_session_id(from._internal_enrollment_session_id());
    }
    if (CheckHasBit(cached_has_bits, 0x10000000U)) {
      _this->_internal_set_oauth_token(from._internal_oauth_token());
    }
    if (CheckHasBit(cached_has_bits, 0x20000000U)) {
      _this->_impl_.using_secure_screenlock_ = from._impl_.using_secure_screenlock_;
    }
    if (CheckHasBit(cached_has_bits, 0x40000000U)) {
      _this->_impl_.auto_unlock_screenlock_supported_ = from._impl_.auto_unlock_screenlock_supported_;
    }
    if (CheckHasBit(cached_has_bits, 0x80000000U)) {
      _this->_impl_.auto_unlock_screenlock_enabled_ = from._impl_.auto_unlock_screenlock_enabled_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.bluetooth_radio_supported_ = from._impl_.bluetooth_radio_supported_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.tethering_supported_ = from._impl_.tethering_supported_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.ble_radio_supported_ = from._impl_.ble_radio_supported_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.pixel_experience_ = from._impl_.pixel_experience_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.is_screenlock_state_flaky_ = from._impl_.is_screenlock_state_flaky_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.device_type_ = from._impl_.device_type_;
    }
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void GcmDeviceInfo::CopyFrom(const GcmDeviceInfo& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:securegcm.GcmDeviceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool GcmDeviceInfo::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const GcmDeviceInfo&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void GcmDeviceInfo::InternalSwap(GcmDeviceInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.enabled_software_features_.InternalSwap(&other->_impl_.enabled_software_features_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.user_public_key_, &other->_impl_.user_public_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_model_, &other->_impl_.device_model_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.locale_, &other->_impl_.locale_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_handle_, &other->_impl_.key_handle_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_os_version_, &other->_impl_.device_os_version_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_os_release_, &other->_impl_.device_os_release_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_os_codename_, &other->_impl_.device_os_codename_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_software_version_, &other->_impl_.device_software_version_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_software_package_, &other->_impl_.device_software_package_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.long_device_id_, &other->_impl_.long_device_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_manufacturer_, &other->_impl_.device_manufacturer_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_master_key_hash_, &other->_impl_.device_master_key_hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.apn_registration_id_, &other->_impl_.apn_registration_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.bluetooth_mac_address_, &other->_impl_.bluetooth_mac_address_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.notification_enabled_)
      + sizeof(GcmDeviceInfo::_impl_.notification_enabled_)
      - PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.android_device_id_)>(
          reinterpret_cast<char*>(&_impl_.android_device_id_),
          reinterpret_cast<char*>(&other->_impl_.android_device_id_));
  _impl_.supported_software_features_.InternalSwap(&other->_impl_.supported_software_features_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.gcm_registration_id_, &other->_impl_.gcm_registration_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.enrollment_session_id_, &other->_impl_.enrollment_session_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.oauth_token_, &other->_impl_.oauth_token_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.device_type_)
      + sizeof(GcmDeviceInfo::_impl_.device_type_)
      - PROTOBUF_FIELD_OFFSET(GcmDeviceInfo, _impl_.using_secure_screenlock_)>(
          reinterpret_cast<char*>(&_impl_.using_secure_screenlock_),
          reinterpret_cast<char*>(&other->_impl_.using_secure_screenlock_));
}

// ===================================================================

class GcmMetadata::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GcmMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GcmMetadata::GcmMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, GcmMetadata_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:securegcm.GcmMetadata)
}
GcmMetadata::GcmMetadata(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GcmMetadata& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, GcmMetadata_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE GcmMetadata::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void GcmMetadata::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, type_),
           0,
           offsetof(Impl_, version_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::version_));
}
GcmMetadata::~GcmMetadata() {
  // @@protoc_insertion_point(destructor:securegcm.GcmMetadata)
  SharedDtor(*this);
}
inline void GcmMetadata::SharedDtor(MessageLite& self) {
  GcmMetadata& this_ = static_cast<GcmMetadata&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GcmMetadata::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GcmMetadata(arena);
}
constexpr auto GcmMetadata::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(GcmMetadata),
                                            alignof(GcmMetadata));
}
constexpr auto GcmMetadata::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<22>{
      {
          &_GcmMetadata_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          GcmMetadata::IsInitializedImpl,
          &GcmMetadata::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<GcmMetadata>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GcmMetadata::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<GcmMetadata>(), &GcmMetadata::ByteSizeLong,
              &GcmMetadata::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_._cached_size_),
          true,
      },
      "securegcm.GcmMetadata",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<22> GcmMetadata_class_data_ =
    GcmMetadata::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GcmMetadata::GetClassData() const {
  return GcmMetadata_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
GcmMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    GcmMetadata_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::securegcm::GcmMetadata>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 version = 2 [default = 0];
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_.version_)}},
    // required .securegcm.Type type = 1;
    {::_pbi::TcParser::FastEvS1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required .securegcm.Type type = 1;
    {PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_.type_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnum)},
    // optional int32 version = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_.version_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  {{
      {::_pbi::FieldAuxEnumData{}, ::securegcm::Type_internal_data_},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void GcmMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:securegcm.GcmMetadata)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    ::memset(&_impl_.type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.version_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GcmMetadata::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GcmMetadata& this_ = static_cast<const GcmMetadata&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GcmMetadata::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GcmMetadata& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:securegcm.GcmMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required .securegcm.Type type = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_type(), target);
  }

  // optional int32 version = 2 [default = 0];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_version(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:securegcm.GcmMetadata)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GcmMetadata::ByteSizeLong(const MessageLite& base) {
  const GcmMetadata& this_ = static_cast<const GcmMetadata&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GcmMetadata::ByteSizeLong() const {
  const GcmMetadata& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:securegcm.GcmMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // required .securegcm.Type type = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
  }
   {
    // optional int32 version = 2 [default = 0];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_version());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void GcmMetadata::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GcmMetadata*>(&to_msg);
  auto& from = static_cast<const GcmMetadata&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:securegcm.GcmMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.version_ = from._impl_.version_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void GcmMetadata::CopyFrom(const GcmMetadata& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:securegcm.GcmMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool GcmMetadata::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const GcmMetadata&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void GcmMetadata::InternalSwap(GcmMetadata* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_.version_)
      + sizeof(GcmMetadata::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(GcmMetadata, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

// ===================================================================

class Tickle::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Tickle>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Tickle, _impl_._has_bits_);
};

Tickle::Tickle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, Tickle_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:securegcm.Tickle)
}
Tickle::Tickle(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Tickle& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, Tickle_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE Tickle::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void Tickle::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.expiry_time_ = {};
}
Tickle::~Tickle() {
  // @@protoc_insertion_point(destructor:securegcm.Tickle)
  SharedDtor(*this);
}
inline void Tickle::SharedDtor(MessageLite& self) {
  Tickle& this_ = static_cast<Tickle&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Tickle::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Tickle(arena);
}
constexpr auto Tickle::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Tickle),
                                            alignof(Tickle));
}
constexpr auto Tickle::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<17>{
      {
          &_Tickle_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Tickle::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<Tickle>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Tickle::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<Tickle>(), &Tickle::ByteSizeLong,
              &Tickle::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Tickle, _impl_._cached_size_),
          true,
      },
      "securegcm.Tickle",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<17> Tickle_class_data_ =
    Tickle::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Tickle::GetClassData() const {
  return Tickle_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
Tickle::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Tickle, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Tickle_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::securegcm::Tickle>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional fixed64 expiry_time = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0,
      PROTOBUF_FIELD_OFFSET(Tickle, _impl_.expiry_time_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed64 expiry_time = 1;
    {PROTOBUF_FIELD_OFFSET(Tickle, _impl_.expiry_time_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Tickle::Clear() {
// @@protoc_insertion_point(message_clear_start:securegcm.Tickle)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.expiry_time_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Tickle::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Tickle& this_ = static_cast<const Tickle&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Tickle::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Tickle& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:securegcm.Tickle)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional fixed64 expiry_time = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        1, this_._internal_expiry_time(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:securegcm.Tickle)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Tickle::ByteSizeLong(const MessageLite& base) {
  const Tickle& this_ = static_cast<const Tickle&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Tickle::ByteSizeLong() const {
  const Tickle& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:securegcm.Tickle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000001U & cached_has_bits) * 9;
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void Tickle::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<Tickle*>(&to_msg);
  auto& from = static_cast<const Tickle&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:securegcm.Tickle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_impl_.expiry_time_ = from._impl_.expiry_time_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void Tickle::CopyFrom(const Tickle& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:securegcm.Tickle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Tickle::InternalSwap(Tickle* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.expiry_time_, other->_impl_.expiry_time_);
}

// ===================================================================

class LoginNotificationInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LoginNotificationInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_._has_bits_);
};

LoginNotificationInfo::LoginNotificationInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, LoginNotificationInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:securegcm.LoginNotificationInfo)
}
PROTOBUF_NDEBUG_INLINE LoginNotificationInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::securegcm::LoginNotificationInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        email_(arena, from.email_),
        host_(arena, from.host_),
        source_(arena, from.source_),
        event_type_(arena, from.event_type_) {}

LoginNotificationInfo::LoginNotificationInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LoginNotificationInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, LoginNotificationInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LoginNotificationInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.creation_time_ = from._impl_.creation_time_;

  // @@protoc_insertion_point(copy_constructor:securegcm.LoginNotificationInfo)
}
PROTOBUF_NDEBUG_INLINE LoginNotificationInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        email_(arena),
        host_(arena),
        source_(arena),
        event_type_(arena) {}

inline void LoginNotificationInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.creation_time_ = {};
}
LoginNotificationInfo::~LoginNotificationInfo() {
  // @@protoc_insertion_point(destructor:securegcm.LoginNotificationInfo)
  SharedDtor(*this);
}
inline void LoginNotificationInfo::SharedDtor(MessageLite& self) {
  LoginNotificationInfo& this_ = static_cast<LoginNotificationInfo&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.email_.Destroy();
  this_._impl_.host_.Destroy();
  this_._impl_.source_.Destroy();
  this_._impl_.event_type_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LoginNotificationInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LoginNotificationInfo(arena);
}
constexpr auto LoginNotificationInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(LoginNotificationInfo),
                                            alignof(LoginNotificationInfo));
}
constexpr auto LoginNotificationInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<32>{
      {
          &_LoginNotificationInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LoginNotificationInfo::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<LoginNotificationInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LoginNotificationInfo::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<LoginNotificationInfo>(), &LoginNotificationInfo::ByteSizeLong,
              &LoginNotificationInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_._cached_size_),
          true,
      },
      "securegcm.LoginNotificationInfo",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<32> LoginNotificationInfo_class_data_ =
    LoginNotificationInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LoginNotificationInfo::GetClassData() const {
  return LoginNotificationInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2>
LoginNotificationInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967233,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LoginNotificationInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::securegcm::LoginNotificationInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional fixed64 creation_time = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 4, 0,
      PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.creation_time_)}},
    // optional string email = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.email_)}},
    // optional string host = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0,
      PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.host_)}},
    // optional string source = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.source_)}},
    // optional string event_type = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 3, 0,
      PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.event_type_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed64 creation_time = 2;
    {PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.creation_time_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional string email = 3;
    {PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.email_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string host = 4;
    {PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.host_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string source = 5;
    {PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.source_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string event_type = 6;
    {PROTOBUF_FIELD_OFFSET(LoginNotificationInfo, _impl_.event_type_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void LoginNotificationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:securegcm.LoginNotificationInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.email_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.host_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.source_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.event_type_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.creation_time_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LoginNotificationInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LoginNotificationInfo& this_ = static_cast<const LoginNotificationInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LoginNotificationInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LoginNotificationInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:securegcm.LoginNotificationInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional fixed64 creation_time = 2;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        2, this_._internal_creation_time(), target);
  }

  // optional string email = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_email();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string host = 4;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_host();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string source = 5;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_source();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string event_type = 6;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_event_type();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:securegcm.LoginNotificationInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LoginNotificationInfo::ByteSizeLong(const MessageLite& base) {
  const LoginNotificationInfo& this_ = static_cast<const LoginNotificationInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LoginNotificationInfo::ByteSizeLong() const {
  const LoginNotificationInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:securegcm.LoginNotificationInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000010U & cached_has_bits) * 9;
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional string email = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_email());
    }
    // optional string host = 4;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_host());
    }
    // optional string source = 5;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_source());
    }
    // optional string event_type = 6;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_event_type());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void LoginNotificationInfo::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LoginNotificationInfo*>(&to_msg);
  auto& from = static_cast<const LoginNotificationInfo&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:securegcm.LoginNotificationInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_email(from._internal_email());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_host(from._internal_host());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_source(from._internal_source());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_event_type(from._internal_event_type());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.creation_time_ = from._impl_.creation_time_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void LoginNotificationInfo::CopyFrom(const LoginNotificationInfo& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:securegcm.LoginNotificationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LoginNotificationInfo::InternalSwap(LoginNotificationInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.email_, &other->_impl_.email_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.host_, &other->_impl_.host_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.source_, &other->_impl_.source_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.event_type_, &other->_impl_.event_type_, arena);
  swap(_impl_.creation_time_, other->_impl_.creation_time_);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace securegcm
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
